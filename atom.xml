<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xmweijh.github.io/</id>
    <title>小虾米的记录</title>
    <updated>2021-02-06T03:13:17.347Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xmweijh.github.io/"/>
    <link rel="self" href="https://xmweijh.github.io/atom.xml"/>
    <subtitle>努力成就自我</subtitle>
    <logo>https://xmweijh.github.io/images/avatar.png</logo>
    <icon>https://xmweijh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小虾米的记录</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://xmweijh.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://xmweijh.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-08-23T03:09:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<p>计算机网络:是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p>
<p>计算机网络是<strong>互连的、自治</strong>的计算机集合。<br>
互连-互联互通通信链路<br>
自治-无主从关系</p>
<p>计算机网络的功能<br>
★1. 数据通信(连通性)<br>
2.资源共享    	硬件	软件	数据<br>
3.分布式处理		多台计算机各自承担同一工作任务的不同部分 Hadoop 平台<br>
4.提高可靠性		替代机<br>
5.负载均衡		各计算机之间更亲密</p>
<p>计算机网络的组成<br>
1.组成部分硬件、软件、协议(一系列规则和约定的集合)</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594777907079.png" alt="1594777907079" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594778204294.png" alt="1594778204294" loading="lazy"></figure>
<p>标准的分类-</p>
<p>法定标准		由权威机构制定的正式的、 合法的标准	OSI</p>
<p>事实标准		某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准<br>
TCP/IP</p>
<p>RFC (Request For Comments )一因特网标准的形式<br>
RFC要上升为因特网正式标准的四个阶段:<br>
1)因特网草案(Internet Draft)这个阶段还不是RFC文档。<br>
2)建议标准(Proposed Standard)从这个阶段开始成为RFC文档。<br>
3)草案标准( Draft Standard)<br>
IETF、IAB<br>
4)因特网标准( internet Standard)</p>
<p>国际标准化组织ISO	OSI参考模型、HDLC协议<br>
国际电信联盟ITU	制定通信规则<br>
国际电气电子工程师协会IEEE	学术机构、IEEE802 系列标准、5G<br>
Internet工程任务组IETF	负责因特网相关标准的制定RFC XXXX</p>
<p>速率即数据率或称数据传输率或比特率。<br>
比特1/0 位<br>
连接在计算机网络上的主机在数字信道上传送数据位数的速率。<br>
单位是b/s，kb/s, Mb/s, Gb/s， Tb/s</p>
<p>(1) “带宽&quot;原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz)。<br>
(2)计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中<br>
的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s, kb/s, Mb/s, Gb/s。<br>
网络设备所支持的最高速度</p>
<p>吞吐量	表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s，kb/s， Mb/s等。<br>
吞吐量受网络的带宽或网络的额定速率的限制。</p>
<p>时延<br>
指数据(报文/分组/比特流)从网络( 或链路)的-端传送到另一端所需的时间。也叫延迟或迟延。单位s。<br>
时延	发送时延(传输时延)	传播时延	排队时延	处理时延</p>
<p>时延带宽积=传播时延X带宽  	时延带宽积又称为以比特为单位的链路长度。即“某段链路现在有多少比特”	容量</p>
<p>往返时延RTT	从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多。<br>
RTT包括	往返传播时延=传播时延*2	末端处理时间</p>
<p>利用率			信道利用率		网络利用率</p>
<p>分层的基本原则<br>
1.各层之间相互独立，每层只实现一种相对独立的功能。<br>
2.每层之间界面自然清晰，易于理解，相互交流尽可能少。<br>
3.结构上可分割开。每层都采用最合适的技术来实现。<br>
4.保持下层对上层的独立性，上层单向使用下层提供的服务。<br>
5.整个分层结构应该能促进标准化工作。</p>
<p>1.实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。<br>
2.协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。【水平】<br>
语法:规定传输数据的格式<br>
语义:规定所要完成的功能<br>
同步:规定各种操作的顺序<br>
3.接口（访问服务点SAP）:上层使用下层服务的入口。<br>
4.服务:下层为相邻上层提供的功能调用。【垂直】</p>
<p>SDU服务数据单元:为完成用户所要求的功能而应传送的数据。<br>
PCI协议控制信息:控制协议操作的信息。<br>
PDU协议数据单元:对等层次之间传送的数据单位。</p>
<p>网络体系结构是从功能上描述计算机网络结构。<br>
计算机网络体系结构简称网络体系结构是分层结构。<br>
每层遵循某个/些网络协议以完成本层功能。<br>
计算机网络体系结构是计算机网络的各层及其协议的集合。<br>
体系结构是抽象的，而实现是指能运行的一些软件和硬件。<br>
第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。<br>
仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595040529479.png" alt="1595040529479" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121141004.png" alt="1595121141004" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121523494.png" alt="1595121523494" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595215799893.png" alt="1595215799893" loading="lazy"></figure>
<h2 id="物理层">物理层</h2>
<p>物理层接口特性<br>
物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。<br>
物理层主要任务:确定与传输媒体<strong>接口</strong>有关的一些特性	定义标准<br>
1<strong>机械特性</strong> 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目、引脚数量</strong>和排列情况。<br>
2<strong>电气特性 <strong>规定传输二进制位时，线路上信号的</strong>电压范围</strong>、阻抗匹配、传<strong>输速率和距离</strong>限制等。<br>
3<strong>功能特性</strong>  指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途。<br>
4<strong>规程待性</strong>	(过程特性）定义各条物理线路的工作规程和时序关系。</p>
<p>数据通信相关术语<br>
通信的目的是传送消息（消息:语音、文字、图像、视频等）。<br>
数据data:传送信息的实体，通常是有意义的符号序列。<br>
信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。<br>
数字信号/离散信号:代表消息的参数的取值是离散的。<br>
模拟信号/连续信号:代表消息的参数的取值是连续的。信源:产生和发送数据的源头。<br>
信宿:接收数据的终点。<br>
条发送信道和一条接收信道。<br>
信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>
<p>三种通信方式<br>
从通信双方信息的交互方式看，可以有三种基本方式:<br>
1.单工通信<br>
只有一个方向的通信而没有反方向的交互，仅需要一条信道。<br>
2.半双工通信/双向交替通信<br>
通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。<br>
3.全双工通信/双向同时通信<br>
通信双方可以同时发送和接受信息，也需要两条信道。</p>
<p>串行传输&amp;并行传输<br>
串行传输将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。速度慢，费用低，适合远距离<br>
并行传输将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离</p>
<p>同步传输&amp;异步传输</p>
<p>同步传输:在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p>
<p>。<br>
异步传输:异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位</p>
<p>码元<br>
码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。<br>
1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>
<p>数字通信系统数据传输速率的两种表示方法<br>
速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示<br>
1）码元传输速率:别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数)，单位是波特（Baud)。1波特表示数字通信系统每秒传输一个码元。</p>
<p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。</p>
<p>2）信息传输速率:别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)，单位是比特/秒(b/s)。<br>
带宽（Bandwidth）</p>
<p>1.模拟信号系统中:当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</p>
<p>2数字设备中:表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps)。</p>
<p>失真</p>
<p>影响失真程度的因素:1.码元传输速率﹐⒉信号传输距离  3.噪声干扰  4.传输媒体质量</p>
<p>码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。</p>
<p>奈氏准则（奈奎斯特定理）</p>
<p>奈氏准则:在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰,极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>
<p>理想低通信道下的极限数据传输率=2Wlog2v (b/s)  v：几种码元/码元的离散电平数目</p>
<p>1.在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。<br>
2.信道的频带越宽（即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p>
<p>3.奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限<br>
4.由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多信息量，这就需要采用多元制的调制方法。</p>
<p>香农定理</p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即:</p>
<p>信噪比（dB） =10log10(S/N)	数值等价</p>
<p>香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<br>
信道的极限数据传输速率=Wlog2(1+S/N)	 (b/s)</p>
<p>1.信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p>
<p>2对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p>
<p>3.只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。<br>
4.香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p>
<p>基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。<strong>来自信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</p>
<p>宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)<br>
在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出基带型号）</p>
<p>数据   ------  数字信号   编码<br>
数据  ------   模拟信号   调制</p>
<p>数字数据编码为数字信号<br>
(1）非归零编码【NRZ】</p>
<p>(2）曼彻斯特编码</p>
<p>(3）差分曼彻斯特编码</p>
<p>(4）归零编码【RZ】</p>
<p>(5）反向不归零编码【NRZl】</p>
<p>(6）4B/5B编码</p>
<p>数字数据调制为模拟信号</p>
<p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<p>模拟数据编码为数字信号<br>
计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）。</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中,能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。</p>
<p>1.抽样:对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:f采样频率&gt;=2f信号最高频率<br>
⒉量化:把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p>
<p>3.编码:把量化的结果转换为与之对应的二进制编码。</p>
<p>模拟数据调制为模拟信号<br>
为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式，模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<p>数据交换方式<br>
电路交换<br>
报文交换<br>
存储转发</p>
<p>电路交换的原理:<br>
在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。</p>
<p>电路交换的阶段:<br>
建立连接（呼叫/电路建立）<br>
通信(数据传输）<br>
释放连接(拆除电路）</p>
<p>特点:独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p>
<p>电路交换优点<br>
传输时延小<br>
数据顺序传送，无失序问题<br>
实时性强，双方一旦建立物理通路，便可以实时通信，适用于交互式会话类通信。<br>
全双工通信，没有冲突，通信双方有不同的信道，不会争用物理信道<br>
适用于模拟信号和数字信号<br>
控制简单，电路的交换设备及控制较简单</p>
<p>电路交换缺点<br>
建立连接时间长<br>
线路独占，即使通信线路空闲，也不能供其他用户使用，信道使用效率低。<br>
灵活性差，双方连接通路中的任何一点除了故障，必须重新拨号建立新连接，不适应突发性通信。<br>
无数据存储能力，难以平滑通信量。<br>
电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信<br>
无法发现与纠正传输差错，难以在通信过程中进行差错控制。</p>
<p>报文:报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p>
<p>报文交换的原理:<br>
无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p>
<p>报文交换优点<br>
无需建立连接，无建立连接时延，用户可随时发送报文。<br>
动态分配线路，动态选择报文通过的最佳路径，可以平滑通信量。<br>
提高线路可靠性，某条传输路径发生故障，可重新选择另一条路径传输。<br>
提高线路利用率，通信双方在不同的时间一段一段地部分占有这条物理通道，多个报文可共享信道。<br>
提供多目标服务:一个报文可同时发往多个目的地址。<br>
在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度预同的计算机之间通行通信。</p>
<p>报文交换缺点<br>
实时性差，不适合传送实时或交互式业务的数据。数据进入交换结点后要经历存储转发过程，从而引起转发时延。<br>
只适用于数字信号。<br>
由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p>
<p>分组:大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet） 。</p>
<p>分组交换的原理:<br>
分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p>
<p>分组交换优点<br>
无建立时延，无需为通信双方预先建立一条专用通信线路，用户对随时发送分组。<br>
线路利用率高，通信双方在不同的时间一段一段地部分占有这条物理通道，多个分组可共享信道。<br>
简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>
加速传输，后一个分组的存储可以和前一个分组的转发并行操作;传输一个分组比一份报文所需缓冲区小，减少等待发送时间。<br>
减少出错几率和重发数据量，提高可靠性，减少传输时延。<br>
分组短小，适用于计算机之问突发式数据通信。</p>
<p>分组交换缺点<br>
尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>
每个分组都要加控制信息，一定程度上降低了通信效率，增加了处理的时间。<br>
当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p>1.传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。<br>
2.当端揣到揣的通路有很多段的链路组成时，采用分组交换传送数据较为合适。<br>
3.从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交<br>
换的时延小，尤其适合于计算机之间的突发式的数据通信。</p>
<p>数据报方式的特点<br>
1.数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p>
<p>无连接服务∶不事光为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<p>2.同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p>
<p>3.每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p>
<p>4.分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较太或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p>
<p>5.网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通</p>
<p>虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</p>
<p>虚电路方式的特点<br>
1.虚电路方式为网络层提供连接服务。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。</p>
<p>连接服务︰首光为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p>
<p>2.一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。</p>
<p>3.分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。<br>
4.每个节点可能与多个节点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务。</p>
<p>5.致命弱点:当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将会遭到破坏</p>
<p>传输介质及分类<br>
传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。<br>
<strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。<br>
但物理层规定了电气特性，因此能够识别所传送的比特流。<br>
导向性传输介质——1.双绞线<br>
双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP），无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。</p>
<p>同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类:5OQ同轴电缆和7sQ同轴电缆。其中，50Q同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用;75Q同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。</p>
<p>光纤主要由纤芯(实心的! )和包层构成，光波通过纤芯进行传导，包尾较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<p>光纤的特点:<br>
1.传输损耗小，中继距离长，对远距离传输特别经济。<br>
2.抗雷电和电磁干扰性能好。<br>
3.无串音干扰，保密性好，也不易被窃听或截取数据。<br>
4.体积小，重量轻。</p>
<p>非导向性传输介质<br>
无线电波:较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）。<br>
信号向所有方向传播</p>
<p>微波</p>
<p>红外线、激光</p>
<p>中继器的功能:对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（再生数字信号）</p>
<p>中继器的两端:两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。<br>
5-4-3规则:网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p>
<p>集线器（多口中继器）<br>
集线器的功能:对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。(再生，放大信号)</p>
<h2 id="数据链路层">数据链路层</h2>
<p>数据链路层功能概述</p>
<p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<p>功能一:为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p>
<p>功能二:链路管理，即连接的建立、维持、释放（用于面向连接的服务）</p>
<p>功能三:组帧。<br>
功能四:流量控制。<br>
功能五:差错控制（帧错/位错）。</p>
<p>封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。<br>
帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。<br>
组帧的四种方法:1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。</p>
<p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<p>决定局域网的主要要素为:网络拓扑，传输介质与介质访问控制方法。</p>
<p>局域网介质访问控制方法<br>
1.CSMA/CD常用于总线型局域网，也用于树型网络<br>
2令牌总线常用于总线型局域网，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。3.令牌环用于环形局域网，如令牌环网</p>
<p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD(载波监听多路访问及冲突检测）技术。</p>
<p>以太网两个标准<br>
DIX Ethernet V2:第一个局域网产品（以太网）规约。<br>
IEEE 802.3: IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动）</p>
<p>以太网提供无连接、不可靠的服务</p>
<p>以太网只实现无差错接收，不实现可靠传输</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。<br>
以太网拓扑:逻辑上总线型，物理上星型。</p>
<p>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。</p>
<p>物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。</p>
<p>采用曼彻斯特编码。</p>
<p>采用CSMA/CD介质访问控制。</p>
<p>计算机与外界有局域网的连接是通过通信适配器的。</p>
<p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符</p>
<p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准。</p>
<p>点对点协议PPP ( Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。<br>
只支持全双工链路。</p>
<p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪-一个接口，或者是把它丢弃(即过滤)。</p>
<h2 id="网络层">网络层</h2>
<p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层传输单位是数据报。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML基础]]></title>
        <id>https://xmweijh.github.io/post/html-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/html-ji-chu/">
        </link>
        <updated>2020-04-30T00:53:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html">HTML</h2>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)  是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>常见状态码</strong></p>
<ul>
<li>200 ：成功。</li>
<li>400 ：客户端请求有语法错误，服务器端不能理解。</li>
<li>401 ：该请求可能未经过授权。</li>
<li>403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。</li>
<li>404 ：该资源没找到。</li>
<li>500 ：服务器端发生了一个不可预知的错误。</li>
<li>503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。</li>
</ul>
<p>HTML（超文本标记语言）是一种用于创建网页的标准标记语言。 HTML 不需要编译，可以直接由浏览器执行，它的解析依赖于浏览器的内核。 它不是一种编程语言，而是一种标记语言。</p>
<p>一个网页的基本结构：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>&lt;!DOCTYPE html&gt;是我们的文档声明头。他告诉了浏览器，本文档处理的是 HTML 文档。<code>html</code> 标签即根元素，此处表示文档的开始。<code>head</code> 标签是网页的头部，设置网页的相关信息。<code>title</code> 标签设置网页标题。<code>body</code> 标签定义文档的主体，也就是我们的主要内容。</p>
<p>在 HTML 中满足以下格式的内容即为注释，被注释的内容将不会被渲染和显示。</p>
<pre><code>&lt;!-- 在此处写注释 --&gt;
</code></pre>
<p>**注：**在开始标签中有一个惊叹号，但是结束标签中没有。浏览器不会显示注释，但是能够帮助记录。</p>
<p>HTML 标签的大小写无关的，例如 <code>和</code> 表示的意思是一样的，都代表“主体”，推荐使用小写。</p>
<p><strong>双标签（双标记）</strong></p>
<p>双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名&gt;&lt;/标记名&gt;
</code></pre>
<p>常见的双标签有：</p>
<pre><code class="language-html">&lt;html&gt;&lt;/html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;body&gt;&lt;/body&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;span&gt;&lt;/span&gt;
&lt;a&gt;&lt;/a&gt;
&lt;ul&gt;&lt;/ul&gt;
</code></pre>
<p><strong>单标签（单标记）</strong></p>
<p>单标记也称空标记，是指用一个标记符号即可完整地描述某个功能的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名/&gt;
</code></pre>
<p>常见的单标签有：</p>
<pre><code class="language-html">&lt;br /&gt;
&lt;!--换行--&gt;
&lt;hr /&gt;
&lt;!--水平分隔线--&gt;
&lt;meta /&gt;
&lt;img /&gt;
</code></pre>
<p><strong>标签的关系</strong></p>
<ul>
<li>嵌套关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;title&gt; &lt;/title&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>并列关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
</code></pre>
<p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>例子：</p>
<pre><code class="language-html">&lt;p&gt;I Love You&lt;/p&gt;
</code></pre>
<p>注：这个元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 <code>，以及一个结束标签</code>。元素内容是：<code>I Love You</code>。</p>
<p><strong>h 系类标签</strong></p>
<p><code>h</code> 标签有六种 <code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>，它代表着我们的标题。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;我是一级标题&lt;/h1&gt;
    &lt;h2&gt;我是二级标题&lt;/h2&gt;
    &lt;h3&gt;我是三级标题&lt;/h3&gt;
    &lt;h4&gt;我是四级标题&lt;/h4&gt;
    &lt;h5&gt;我是五级标题&lt;/h5&gt;
    &lt;h6&gt;我是六级标题&lt;/h6&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>p 标签</strong></p>
<p><code>p</code> 标签是我们的文本标签。</p>
<p><strong>图片标签</strong></p>
<p>HTML 的图像是通过标签 &lt;img&gt;来定义的。</p>
<p><strong>a 标签</strong></p>
<p><a> 标签是超链接标签，意思就是我们点击它可以跳转到一个网页。</p>
<p><strong>div 标签</strong></p>
<div> 标签是一个块级元素，块级元素占据其父元素（容器）的整个空间，你可以把它想成一个盒子。 <div> 能够设置其宽高
<p><strong>换行标签和空格字符</strong></p>
<p>在浏览器显示页面时，浏览器会移除源代码中多余的空格和空行，所有连续的空格或空行都会被认为是一个空格。如果希望在不产生一个新段落的情况下换行，可以使用&lt;br/&gt;标签。如果想使用空格的话可以使用&amp;nbsp;字符</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;p&gt;这是一段文字 前面有很多空格但是只显示一个&lt;/p&gt;
  &lt;p&gt;这是一段文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用了空格字符&lt;/p&gt;
  &lt;br /&gt;
  &lt;p&gt;上面是换行符&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p><strong>水平分割线</strong></p>
<p>&lt;hr/&gt; 标签用于在 HTML 页面中创建一条水平线。</p>
<p>标签 <div> 可将网页页面分割成不同的独立部分，通常用于定义文档中的区域或节。该标签是一个块级元素，浏览器会自动在 <div> 和 </div> 所标记的区域前后自动放置一个换行符。</p>
<p>标签 <span> 通常作为文本的容器，它没有特定的含义和样式，只有与 CSS 同时使用才可以为指定文本设置样式属性。该标签是一个内联元素，他与块级元素相反，内联元素不会自动在前后自动放置换行符，因此内联元素会默认显示在同一行。</p>
<p>无序列表是一个项目的列表，此列项目使用实心圆、空心圆、方块进行标记，无序列表使用 <ul> 标签。同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 <ol> 标签。每个列表项始于 <li> 标签。</p>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>无序列表和有序列表的 type 属性：</strong></p>
<p>type 属性定义了列表项前项目符号的类型。</p>
<p>&lt;ul&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>disc（默认）</td>
<td>实心圆</td>
</tr>
<tr>
<td>circle</td>
<td>空心圆</td>
</tr>
<tr>
<td>square</td>
<td>小方块</td>
</tr>
</tbody>
</table>
<p>&lt;ol&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1（默认）</td>
<td>数字表示（1，2，3...)</td>
</tr>
<tr>
<td>A</td>
<td>大写字母表示（A,B,C...)</td>
</tr>
<tr>
<td>a</td>
<td>小写字母表示（a,b,c...)</td>
</tr>
<tr>
<td>I</td>
<td>大写罗马数字表示(I,II,III…)</td>
</tr>
<tr>
<td>i</td>
<td>小写罗马数字表示(i,ii,iii…)</td>
</tr>
</tbody>
</table>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul type=&quot;circle&quot;&gt;
  &lt;li&gt;空心圆列表项1&lt;/li&gt;
  &lt;li&gt;空心圆列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol type=&quot;A&quot;&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>自定义列表（dl）</strong></p>
<p>定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt;开始。自定义列表的列表项前没有任何项目符号。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<p><strong>HTML 样式实例 - 背景颜色</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;background-color:red&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过 <code>&quot;background-color&quot;</code> 属性值的设置来给背景设置颜色。</p>
<p><strong>HTML 样式实例 - 字体、颜色和尺寸</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;font-family:arial;color:green;font-size:50px;&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过对 <code>font-family</code> 属性值的设置来设置字体，通过对 <code>color</code> 属性值的设置来设置颜色，通过对 <code>font-size</code> 属性值的设计来设计字体大小。</p>
<p><strong>HTML 样式实例 - 文本对齐</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1 style=&quot;text-align:center&quot;&gt;xxx&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<pre><code class="language-html">&lt;table&gt;   //&lt;table border=&quot;1&quot;&gt;给表格加上边框
  &lt;tr&gt;
    &lt;td&gt;第一行第一列&lt;/td&gt;
    &lt;td&gt;第一行第二列&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;第二行第一列&lt;/td&gt;
    &lt;td&gt;第二行第二列&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>表格一般都有标题，在 HTML 中表格标题通过 <caption> 定义。</p>
<figure data-type="image" tabindex="1"><img src="https://doc.shiyanlou.com/document-uid897174labid9222timestamp1545370661694.png/wm" alt="img" loading="lazy"></figure>
<p>表格的表头使用 <th> 标签进行定义，表头通常用于列名字。</p>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt;
  &lt;caption&gt;
    支出表
  &lt;/caption&gt;
  &lt;tr&gt;
    &lt;th&gt;支出&lt;/th&gt;
    &lt;th&gt;备注&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;32&lt;/td&gt;
    &lt;td&gt;买苹果&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;24&lt;/td&gt;
    &lt;td&gt;买饮料&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>绘制表格的时候，我们常常需要合并单元格，而在 HTML 中提供了 colspan（合并行）和 rowspan（合并列）属性来帮助我们实现这一效果。</p>
<blockquote>
<p>colspan 又称跨列，rowspan 又称跨行。</p>
</blockquote>
<p>设置 <code>rowspan=&quot;2&quot;</code> 表示合并该列上的两个单元格，同样的我们可以通过设置 <code>colspan</code> 来合并行</p>
<p>在网页中可以使用很多个 div，在网页制作中，使用 div 可以将网页中的任何元素布局到网页中的任何位置。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;div style=&quot;样式设置&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>table 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>理解比较简单。</li>
<li>不同的浏览器看到的效果一般相同。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>显示样式和数据绑定在一起。</li>
<li>布局的时候灵活度不高。</li>
<li>一个页面可能会有大量的 table 元素，代码冗余度高。</li>
<li>增加带宽。</li>
<li>搜索引擎不喜欢这样的布局。</li>
</ol>
<p>div 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>符合 W3C 标准。</li>
<li>搜索引擎更加友好。</li>
<li>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</li>
<li>节省代宽，代码冗余度低。</li>
<li>表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。</li>
</ol>
<p>&lt;form&gt;标签用于创建 HTML 表单，常见的表单格式为：</p>
<pre><code class="language-html">&lt;form name=&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;&lt;/form&gt;
</code></pre>
<ul>
<li>name：定义表单的名字。</li>
<li>method：定义表单结果从浏览器传送到服务器的方式，默认参数为：<code>get</code> 。<code>post</code> 安全性更高，因此常用作传输密码等，而 <code>get</code> 安全性较低，一般用于查询数据。</li>
<li>action：发送数据要去的地址。它的值必须是一个有效的 URL，可以是相对 URL 也可以是绝对 URL。如果没有提供此属性或者 <code>action=&quot;#&quot;</code>，则数据将被发送到包含表单的页面的 URL。</li>
</ul>
<p>在网页中最常见的表单元素就是文字字段，用户可以在文字字段内输入字符或者单行文本。 语法：</p>
<pre><code class="language-html">&lt;input
  type=&quot;text&quot;
  name=&quot;控件名称&quot;
  value=&quot;文字字段的默认取值&quot;
  size=&quot;控件的长度&quot;
  maxlength=&quot;最长字符数&quot;
/&gt;
</code></pre>
<p>该语法包含了许多参数，除了 <code>type</code> 参数以外，其他的参数都是可选的</p>
<p>举个例子：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;40&quot; value=&quot;10&quot; maxlength=&quot;3&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>密码输入框</strong></p>
<p>密码输入框是一种特殊的文字字段，他的各个属性和文字字段是相同的，但是输入进密码输入框的字符全部是“*”表示，保证周围人看不见输入的文本。</p>
<pre><code class="language-html">&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;
</code></pre>
<p><strong>单选按钮</strong></p>
<p>单选按钮可以使用户从选择列表中选择一个选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked /&gt;男&lt;br /&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; /&gt;女
&lt;/form&gt;
</code></pre>
<p>几个单选按钮可以连接在一起，只需要把它们的 <code>name</code> 值设置为相同的。同一组中只有一个按钮可以同时被选。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，且不会随表单提交。 可以尝试如果 name 不相同或者没有 name 会是什么情况。</p>
<p>复选框可以让用户从一个选项列表中选择超出一个的选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;music&quot; checked /&gt;音乐&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;art&quot; /&gt;美术&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;math&quot; /&gt;数学&lt;br /&gt;
&lt;/form&gt;
</code></pre>
<p>复选框可以拥有自己的名字，并不需要属于一个组。</p>
<p><strong>按钮</strong><br>
HTML 表单中，有三种按钮：提交按钮，重置按钮，匿名按钮。我们可以使用 <button> 元素或者 <input> 元素来创建一个按钮。type 属性的值指定显示什么类型的按钮。</p>
<p><strong>提交按钮（submit）</strong></p>
<p>用于发送表单数据给服务器。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; value=&quot;输入的内容&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;
    This a submit button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>重置按钮（reset）</strong></p>
<p>重置按钮用来清除用户在页面中输入的信息。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; /&gt;
  &lt;button type=&quot;reset&quot;&gt;
    This a reset button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>在文本框中输入内容，点击按钮即可清除。</p>
<p><strong>匿名按钮（button）</strong></p>
<p>没有自动生效的按钮，但是可以使用 JavaScript 代码进行定制。如果你省略了 <code>type</code> 属性，那么这就是默认值。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;button&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;input type=&quot;button&quot; value=&quot;This is a anonymous button&quot; /&gt;
</code></pre>
<p>不管使用的是 <button> 元素还是 <input> 元素，按钮的行为都是一样的。它们的不同点在于：</p>
<p>从前面的例子中也可以看出 <button> 元素允许你使用 HTML 内容作为其标记内容，但 <input> 元素只接受纯文本内容。<br>
使用 <button> 元素，可以有一个不同于按钮标签的值（通过将其设置为 value 属性）。</p>
<p><strong>下拉菜单</strong></p>
<p>下拉菜单能够节省页面空间，正常状态下显示一个选项，单击展开所以选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>注意：下拉菜单的宽度是由 <option> 标记中包含的最长文本的宽度决定的。</p>
<p><strong>列表项</strong></p>
<p>在页面中列表项可以显示出几条信息，一旦超出这个信息量，在列表项右侧会出现滚动条，拖动滚动条可以看到所有选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot; size=&quot;2&quot; multiple=&quot;multiple&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>当用户想要填入多行文本时，就应该使用文本域而不是文本字段。文本域使用 <textarea> 标记。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  留下您的联系方式：
  &lt;textarea name=&quot;textarea&quot; cols=&quot;35&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
&lt;/form&gt;
</code></pre>
<p><code>clos</code> 代表列数，<code>rows</code> 代表行数。</p>
<p><strong>图像标签</strong><br>
在 HTML 中，图像由 <img> 标签定义。语法为：</p>
<pre><code class="language-html">&lt;img src=&quot;url&quot; alt=&quot;&quot; /&gt;
</code></pre>
<p><img> 是空标签，它只包含属性，没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 的值是图像文件的 URL，也就是引用该图像的文件的的绝对路径或相对路径。alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。title 设置鼠标悬停时显示的内容（一般不用设置）。此外还可以通过设置 width 和 height 的值来设置图片的宽和高。</p>
<p><strong>框架</strong></p>
<p>使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;iframe src=&quot;URL&quot;&gt;
  &lt;!-- URL指向不同的页面 --&gt;
&lt;/iframe&gt;
</code></pre>
<p><strong>iframe - 设置高度与宽度</strong></p>
<p>属性默认以像素为单位,但是你可以指定其按比例显示 (如：&quot;60%&quot;)。</p>
<p><strong>iframe - 移除边框</strong></p>
<p><code>frameborder</code> 属性用于定义 iframe 表示是否显示边框。设置属性值为 &quot;0&quot; 移除 iframe 的边框:</p>
<p>在标准 HTML5 中， <html> 和 <body> 标签是可以省略的。</p>
<p>HTML5 元素名可以使用大写和小写字母，建议使用小写字母，会显得更加好看一点，千万不要使用大小写混写，那样会显得很不专业。</p>
<p>图片通常使用 <code>alt</code> 属性。 在图片不能显示时，它能替代图片显示。建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。</p>
<p>等号的前后可以使用空格，也可以不使用，推荐少用空格。</p>
<p>不要无缘无故的添加空行，一般一个模块或一个功能添加一个空行便于区分，缩进使用两个空格，不建议使用 Tab。</p>
<p><strong>section 标签</strong></p>
<p>&lt;section&gt; 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。不要把 <section> 元素作为一个普通的 div 容器来使用。一般来说，一个 <section> 应该出现在文档大纲中。</p>
<p><strong>article 标签</strong></p>
<p>&lt;article&gt; 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。</p>
<p><strong>nav 标签</strong></p>
<p>&lt;nav&gt; 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。</p>
<p><strong>header 标签</strong></p>
<p>&lt;header&gt; 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。</p>
<p>通常 header 标签至少包含一个标题标记（h1-h6），还可以包括 hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。</p>
<p><strong>footer 标签</strong></p>
<p>&lt;footer&gt; 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。</p>
<p><strong>aside 标签</strong></p>
<p>&lt;aside&gt; 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</p>
<p><strong>datalist 元素</strong><br>
datalist 元素用于为文本框提供一个可供选择的列表，使用 datalist 元素来为表单小部件提供建议的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 <input> 元素)。</p>
<p>一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本。通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。</p>
<p><strong>autocomplete 属性</strong><br>
autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。当 autocomplete 属性值为 on 时表示启用自动完成功能，为 off 时表示关闭。autocomplete 属性适用于 <form>，以及下面的 <input> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p>
<p><strong>autofocus 属性</strong><br>
autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 <input> 标签的类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://xmweijh.github.io/post/sql-yu-yan/</id>
        <link href="https://xmweijh.github.io/post/sql-yu-yan/">
        </link>
        <updated>2020-04-28T00:13:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="select">SELECT</h3>
<pre><code>SELECT column_name,column_name FROM table_name;//选出特定列

SELECT * FROM table_name;//选取所有列

SELECT DISTINCT column_name,column_name
FROM table_name;//返回列中不同值（去除掉重复值）

SELECT column_name new_column_name FROM table_name;使用列别名可以改变查询结果的列标题
</code></pre>
<h3 id="where">WHERE</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
WHERE column_name operator value;//提取那些满足指定条件的记录
</code></pre>
<p>使用<strong>单引号来环绕文本值</strong>（大部分数据库系统也接受双引号）。如果是<strong>数值字段，请不要使用引号</strong>。</p>
<p>可以在 WHERE 子句中使用的运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 !=</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left">在某个范围内</td>
</tr>
<tr>
<td style="text-align:left">LIKE</td>
<td style="text-align:left">搜索某种模式</td>
</tr>
<tr>
<td style="text-align:left">IN</td>
<td style="text-align:left">指定针对某个列的多个可能值</td>
</tr>
</tbody>
</table>
<p>逻辑运算    not        and         or  （优先级从左到右下降）</p>
<p>空值判断：  is null</p>
<h3 id="order-by">ORDER BY</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;//对结果集按照一个列或者多个列进行排序,默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。
ORDER BY 多列的时候，先按照第一个column name排序，再按照第二个column name排序
desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。
</code></pre>
<h3 id="insert-into">INSERT INTO</h3>
<pre><code>INSERT INTO table_name
VALUES (value1,value2,value3,...);//无需指定要插入数据的列名，只需提供被插入的值即可

INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);//指定列名及被插入的值
</code></pre>
<h3 id="update">UPDATE</h3>
<pre><code>UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;//更新表中已存在的记录。
如果您省略了 WHERE 子句，所有的记录都将被更新！
</code></pre>
<h3 id="delete">DELETE</h3>
<pre><code>DELETE FROM table_name
WHERE some_column=some_value;//删除表中的行。
如果您省略了 WHERE 子句，所有的记录都将被删除！
</code></pre>
<h3 id="select-top-limit-rownum-子句">SELECT TOP, LIMIT, ROWNUM 子句</h3>
<pre><code>SELECT TOP number|percent column_name(s)
FROM table_name;

SELECT column_name(s)
FROM table_name
LIMIT number;

SELECT column_name(s)
FROM table_name
WHERE ROWNUM &lt;= number;//用于规定要返回的记录的数目
</code></pre>
<h3 id="like">LIKE</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;//操作符用于在 WHERE 子句中搜索列中的指定模式。
</code></pre>
<p>'%a'   //以a结尾的数据</p>
<p>'a%'   //以a开头的数据</p>
<p>'%a%'   //含有a的数据</p>
<p>‘_a_’   //三位且中间字母是a的</p>
<p>'_a'   //两位且结尾字母是a的</p>
<p>'a_'   //两位且开头字母是a的</p>
<h3 id="sql-通配符">SQL 通配符</h3>
<p>在 SQL 中，通配符与 SQL LIKE 操作符一起使用。</p>
<p>SQL 通配符用于搜索表中的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">替代 0 个或多个字符</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">替代一个字符</td>
</tr>
<tr>
<td style="text-align:left">[<em>charlist</em>]</td>
<td style="text-align:left">字符列中的任何单一字符</td>
</tr>
<tr>
<td style="text-align:left">[^<em>charlist</em>] 或 [!<em>charlist</em>]</td>
<td style="text-align:left">不在字符列中的任何单一字符</td>
</tr>
</tbody>
</table>
<h3 id="in">IN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);//IN 操作符允许您在 WHERE 子句中规定多个值。
</code></pre>
<h3 id="between">BETWEEN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;//用于选取介于两个值之间的数据范围内的值。
</code></pre>
<h3 id="sql-别名">SQL 别名</h3>
<pre><code>SELECT column_name AS alias_name
FROM table_name;//列的 SQL 别名语法

SELECT column_name(s)
FROM table_name AS alias_name;//表的 SQL 别名语法
</code></pre>
<h3 id="sql-连接join">SQL 连接(JOIN)</h3>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
</ul>
<p><strong>SQL INNER JOIN 语法</strong></p>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_innerjoin.gif" alt="SQL INNER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
JOIN table2
ON table1.column_name=table2.column_name;//INNER JOIN 与 JOIN 是相同的。
</code></pre>
<p>在使用 <strong>join</strong> 时，<strong>on</strong> 和 <strong>where</strong> 条件的区别如下：</p>
<ul>
<li>1、 <strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。</li>
<li>2、<strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 <strong>left join</strong> 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ul>
<p><strong>SQL LEFT JOIN 语法</strong></p>
<p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_leftjoin.gif" alt="SQL LEFT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
LEFT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，LEFT JOIN 称为 LEFT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL RIGHT JOIN 语法</strong></p>
<p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_rightjoin.gif" alt="SQL RIGHT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
RIGHT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，RIGHT JOIN 称为 RIGHT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL FULL OUTER JOIN 语法</strong></p>
<p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_fulljoin.gif" alt="SQL FULL OUTER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre>
<h3 id="union">UNION</h3>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<pre><code>SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
//默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
</code></pre>
<h3 id="select-into">SELECT INTO</h3>
<p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
<pre><code>SELECT *
INTO newtable [IN externaldb]
FROM table1;

SELECT column_name(s)
INTO newtable [IN externaldb]
FROM table1;
</code></pre>
<h3 id="insert-into-select">INSERT INTO SELECT</h3>
<p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
<pre><code>INSERT INTO table2
SELECT * FROM table1;

INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
</code></pre>
<h3 id="create-database">CREATE DATABASE</h3>
<pre><code>CREATE DATABASE dbname;//用于创建数据库。
</code></pre>
<h3 id="create-table">CREATE TABLE</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);//用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。
  //column_name 参数规定表中列的名称。
  //data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。
  //size 参数规定表中列的最大长度。
</code></pre>
<h3 id="sql-约束constraints">SQL 约束（Constraints）</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);//用于规定表中的数据规则。
</code></pre>
<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li>
<p><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</p>
<p>​	NOT NULL 约束强制列不接受 NULL 值。</p>
<p>​	NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或	者更新记录。</p>
</li>
<li>
<p><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</p>
<p>​	UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>​	UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>​	PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。</p>
<p>​	请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
</li>
<li>
<p><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p>
<p>​	PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>
<p>​	主键必须包含唯一的值。</p>
<p>​	主键列不能包含 NULL 值。</p>
<p>​	每个表都应该有一个主键，并且每个表只能有一个主键。</p>
</li>
<li>
<p><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</p>
</li>
<li>
<p><strong>CHECK</strong> - 保证列中的值符合指定的条件。</p>
<p>​	如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>
<p>​	如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限	    	制。</p>
</li>
<li>
<p><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
</li>
</ul>
<h3 id="create-index-语句">CREATE INDEX 语句</h3>
<p>CREATE INDEX 语句用于在表中创建索引。</p>
<p>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</p>
<pre><code>CREATE INDEX index_name
ON table_name (column_name)//在表上创建一个简单的索引。允许使用重复的值

CREATE UNIQUE INDEX index_name
ON table_name (column_name)//在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着						   //两个行不能拥有相同的索引值
</code></pre>
<h3 id="drop">DROP</h3>
<p>通过使用 DROP 语句，可以轻松地删除索引、表和数据库。</p>
<h3 id="alter-table">ALTER TABLE</h3>
<p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<h3 id="sql-alter-table-语法">SQL ALTER TABLE 语法</h3>
<p>如需在表中添加列，请使用下面的语法:</p>
<pre><code>ALTER TABLE table_name
ADD column_name datatype
</code></pre>
<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<pre><code>ALTER TABLE table_name
DROP COLUMN column_name
</code></pre>
<h3 id="auto-increment">AUTO INCREMENT</h3>
<p>Auto-increment 会在新记录插入表中时生成一个唯一的数字。</p>
<h3 id="视图views">视图（Views）</h3>
<p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p>SQL CREATE VIEW 语法</p>
<pre><code>CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>**注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<p>您可以使用下面的语法来更新视图：</p>
<p>SQL CREATE OR REPLACE VIEW 语法</p>
<pre><code>CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>您可以通过 DROP VIEW 命令来删除视图。</p>
<p>SQL DROP VIEW 语法</p>
<pre><code>DROP VIEW view_name
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://xmweijh.github.io/post/python/</id>
        <link href="https://xmweijh.github.io/post/python/">
        </link>
        <updated>2020-04-04T03:00:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<p>print括号中可以单引号或者双引号</p>
<p>多行打印时,使用三个引号</p>
<pre><code>print('''



''')
</code></pre>
<p>true类型只用True 和False 注意大小写</p>
<p>空值 None 表示无，与0 不同</p>
<p>input（输入）</p>
<p>当输入输出括号中字符串中还有引号，需要转义符\区别</p>
<pre><code>&gt;&gt;&gt; string = 'hello_shiyanlou'
&gt;&gt;&gt; string[0]  # 获取第一个字符
'h'
&gt;&gt;&gt; string[-2]  # 获取倒数第二个字符
'o'
</code></pre>
<p>注意负值代表倒数第几个（倒数不从0开始，毕竟 -0 = 0）</p>
<pre><code>print('你叫'+name+'，今年' + age + '岁了')
#等价于
print('你叫{}，今年{}岁了'.format(name,age))
#下面代码代表保留2位小数
print(&quot;{:.2f}&quot;.format(3.1415926))
</code></pre>
<p>#单行注释</p>
<p>逻辑运算符 and 	or 	not</p>
<p>条件判断</p>
<pre><code>if:
    ***
elif:
	***
else:
	***
</code></pre>
<p>后面加<strong>冒号</strong>  if下面的代码4个缩进</p>
<p>input 读取的为字符串类型</p>
<pre><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; if a&lt;1:
...     print(&quot;a&lt;1&quot;)
... else:
...     pass
...
&gt;&gt;&gt; #程序没有报错
</code></pre>
<p>pass会跳过这里的代码执行后面的代码</p>
<pre><code>for 元素 in 集合:
    do something 
</code></pre>
<p>range(x)函数 可以生成一个从0到x-1的整数序列</p>
<p><code>range()</code> 函数返回的并不是列表而是一种可迭代对象：</p>
<p>range(a,b)  a 到b-1，包头不包尾</p>
<pre><code>while condition:
   do something
</code></pre>
<p>所以如果是用空格，就一直用空格缩进，不要使用制表符。</p>
<p>建议遵守以下约定：</p>
<ul>
<li>使用 4 个空格来缩进</li>
<li>永远不要混用空格和制表符</li>
<li>在函数之间空一行</li>
<li>在类之间空两行</li>
<li>字典，列表，元组以及参数列表中，在 <code>,</code> 后添加一个空格。对于字典，<code>:</code> 后面也添加一个空格</li>
<li>在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：<code>a = f(1, 2) + g(3, 4)</code></li>
</ul>
<p>// 取整除 - 返回商的整数部分（<strong>向下取整</strong>）</p>
<p><code>divmod(num1, num2)</code> 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 <code>*</code> 运算符拆封这个元组，得到这两个值。</p>
<p>默认情况下，<code>print()</code> 除了打印你提供的字符串之外，还会打印一个换行符   <code>print()</code> 的另一个参数 <code>end</code> 来替换这个换行符</p>
<pre><code> print(b, end=' ') 
 print(&quot;-&quot; * 50) #打印50个-
  #列表的元素不必是同一类型
 &gt;&gt;&gt; a = [ 1, 342, 223, 'India', 'Fedora'] 
</code></pre>
<p>Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。 对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 <code>a[2:4]</code> 是 2。 返回a[2]和a[3]两个</p>
<p>切片操作还可以设置步长</p>
<pre><code>&gt;&gt;&gt; a[1::2]
[342, 'India']
</code></pre>
<p>意思是，从切片索引 1 到列表末尾，每隔两个元素取值。</p>
<p><code>len()</code> 我们可以获得列表的长度</p>
<p>如果你想要检查列表是否为空</p>
<pre><code>if list_name: # 列表不为空
    pass
else: # 列表为空
    pass
</code></pre>
<h3 id="列表">列表</h3>
<p><code>a.append(45)</code> 添加元素 <code>45</code> 到列表末尾。有些时候我们需要将数据插入到列表的任何位置，这时我们可以使用列表的 <code>insert()</code> 方法。   <code>count(s)</code> 会返回列表元素中 <code>s</code> 的数量。  如果你想要在列表中移除任意指定值，你需要使用 <code>remove()</code> 方法。  <code>a.reverse()</code> 反转整个列表。 将一个列表的所有元素添加到另一个列表的末尾呢，可以使用列表的 <code>extend()</code> 方法。  给列表排序，我们使用列表的 <code>sort()</code> 方法， 用 <code>del</code> 关键字删除指定位置的列表元素。</p>
<pre><code>&gt;&gt;&gt; a = [23, 45, 1, -3434, 43624356, 234]
&gt;&gt;&gt; a.append(45)
&gt;&gt;&gt;  a.insert(0, 1)
&gt;&gt;&gt; a.count(45)
</code></pre>
<h4 id="栈">栈</h4>
<p><code>pop()</code>。传入一个参数 i 即 <code>pop(i)</code> 会将第 i 个元素弹出。 栈使用<code>a.pop()</code> 将顶部元素弹出， <code>a.append(x)</code> 入栈</p>
<h4 id="队列">队列</h4>
<p><code>a.pop(0)</code> 出队 <code>a.append(x)</code> 入队</p>
<h4 id="列表推导式">列表推导式</h4>
<pre><code>squares = [x**2 for x in range(10)]
&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
#等价于
&gt;&gt;&gt; combs = []
&gt;&gt;&gt; for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
&gt;&gt;&gt; combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<h3 id="元组">元组</h3>
<p>元组是由数个逗号分割的值组成。</p>
<pre><code>&gt;&gt;&gt; a = 'Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus'
&gt;&gt;&gt; a
('Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus')
&gt;&gt;&gt; a[1]
'ShiYanLou'
&gt;&gt;&gt; for x in a:
...     print(x, end=' ')
...
Fedora ShiYanLou Kubuntu Pardus
</code></pre>
<p>以对任何一个元组执行拆封操作并赋值给多个变量</p>
<pre><code>&gt;&gt;&gt; x, y = divmod(15,2)
&gt;&gt;&gt; x
7
&gt;&gt;&gt; y
1
</code></pre>
<p>元组是不可变类型，这意味着你<strong>不能在元组内删除或添加或编辑</strong>任何值。</p>
<p>要创建只含有一个元素的元组，在值后面跟一个<strong>逗号</strong>。</p>
<p>通过内建函数 <code>type()</code> 你可以知道任意变量的数据类型。</p>
<h3 id="集合">集合</h3>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p>
<p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典</p>
<pre><code>&gt;&gt;&gt; basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
&gt;&gt;&gt; print(basket)                      # 你可以看到重复的元素被去除
{'orange', 'banana', 'pear', 'apple'}
&gt;&gt;&gt; 'orange' in basket
True
&gt;&gt;&gt; 'crabgrass' in basket
False

&gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作
...
&gt;&gt;&gt; a = set('abracadabra')
&gt;&gt;&gt; b = set('alacazam')
&gt;&gt;&gt; a                                  # a 去重后的字母
{'a', 'r', 'b', 'c', 'd'}
&gt;&gt;&gt; a - b                              # a 有而 b 没有的字母
{'r', 'd', 'b'}
&gt;&gt;&gt; a | b                              # 存在于 a 或 b 的字母
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
&gt;&gt;&gt; a &amp; b                              # a 和 b 都有的字母
{'a', 'c'}
&gt;&gt;&gt; a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{'r', 'd', 'b', 'm', 'z', 'l'}
#添加或弹出元素
&gt;&gt;&gt; a = {'a','e','h','g'}
&gt;&gt;&gt; a.pop()  # pop 方法随机删除一个元素并打印
'h'
&gt;&gt;&gt; a.add('c')
&gt;&gt;&gt; a
{'c', 'e', 'g', 'a'}
</code></pre>
<h3 id="字典">字典</h3>
<p>字典是是无序的键值对（<code>key:value</code>）集合，同一个字典内的键必须是互不相同的。一对大括号 <code>{}</code> 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。</p>
<pre><code>&gt;&gt;&gt; data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
&gt;&gt;&gt; data['kart_']
'Debian'
&gt;&gt;&gt; data['parthan'] = 'Ubuntu'
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
# 使用del关键字删除任意指定的键值对
&gt;&gt;&gt; del data['kushal']
&gt;&gt;&gt; data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
# 使用 in 关键字查询指定的键是否在字典中
&gt;&gt;&gt; 'ShiYanLou' in data
False
#必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作
#为键。dict() 可以从包含键值对的元组中创建字典。
&gt;&gt;&gt; dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
#遍历一个字典，使用字典的 items() 方法。
&gt;&gt;&gt; data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
&gt;&gt;&gt; for x, y in data.items():
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu
</code></pre>
<p>许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。我们可以使用 <code>dict.setdefault(key, default)</code> 更有效率的完成这个事情。</p>
<pre><code>&gt;&gt;&gt; data = {}
&gt;&gt;&gt; data.setdefault('names', []).append('Ruby')
&gt;&gt;&gt; data
{'names': ['Ruby']}
&gt;&gt;&gt; data.setdefault('names', []).append('Python')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python']}
&gt;&gt;&gt; data.setdefault('names', []).append('C')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python', 'C']}
</code></pre>
<p>试图索引一个不存在的键将会抛出一个 <em>keyError</em> 错误。我们可以使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p>
<p>如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code>。</p>
<pre><code>&gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']):
...     print(i, j)
...
0 a
1 b
2 c
</code></pre>
<p>要同时遍历两个序列类型，你可以使用 <code>zip()</code> 函数。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = ['Pradeepto', 'Kushal']
&gt;&gt;&gt; b = ['OpenSUSE', 'Fedora']
&gt;&gt;&gt; for x, y in zip(a, b):
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora
</code></pre>
<h3 id="字符串">字符串</h3>
<p><code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写。</p>
<p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写版本。</p>
<p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本</p>
<p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字</p>
<p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p>
<pre><code>&gt;&gt;&gt; s = &quot;1234&quot;
&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字
True
&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;
&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写
False
&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;
&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式
True
&gt;&gt;&gt; s = &quot;CHINA&quot;
&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写
True
</code></pre>
<p><code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>），它返回一个包含所有分割后的字符串的列表。</p>
<p><code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p>
<p>最简单的一个是 <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符</p>
<p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1</p>
<p>格式化操作符（%）</p>
<pre><code>print(&quot;my name is %s.I am %d years old&quot; % ('Shixiaolou',4))
</code></pre>
<p>在这个例子中，<code>%s</code> 为第一个格式符，表示一个字符串；<code>%d</code> 为第二个格式符，表示一个整数。格式符为真实值预留位置，并控制显示的格式。常用的有：</p>
<blockquote>
<p>%s 字符串（用 str() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%r 字符串（用 repr() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%d 十进制整数</p>
</blockquote>
<blockquote>
<p>%f 浮点数</p>
</blockquote>
<blockquote>
<p>%% 字符“%”</p>
</blockquote>
<h3 id="函数">函数</h3>
<p><code>def</code> 来定义一个函数</p>
<pre><code>def 函数名(参数):
    语句1
    语句2
</code></pre>
<p><code>global</code> 关键字，对函数中的a标志为全局变量 ， 让函数内部使用全局变量的 a。</p>
<p>函数的参数变量可以有默认值，也就是说如果我们对指定的参数变量没有给出任何值则会赋其默认值。</p>
<pre><code>&gt;&gt;&gt; def test(a , b=-99):
...     if a &gt; b:
...         return True
...     else:
...         return False
</code></pre>
<p>在函数的参数列表写出 <code>b = -99</code>。这表示如果调用者未给出 <code>b</code> 的值，那么 <code>b</code> 的值默认为 <code>-99</code>。</p>
<pre><code>&gt;&gt;&gt; test(12, 23)
False
&gt;&gt;&gt; test(12)
True
</code></pre>
<p>有两个非常重要的地方，第一个是具有默认值的参数后面不能再有普通参数，比如 <code>f(a,b=90,c)</code> 就是错误的。</p>
<p>第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。</p>
<pre><code>&gt;&gt;&gt; def f(a, data=[]):
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[1, 2]
&gt;&gt;&gt; print(f(3))
[1, 2, 3]
</code></pre>
<pre><code>&gt;&gt;&gt; def f(a, data=None):
...     if data is None:
...         data = []
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[2]
</code></pre>
<p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<ul>
<li>使用一个或多个函数作为参数</li>
<li>返回另一个函数作为输出</li>
</ul>
<p>Python 里的任何函数都可以作为高阶函数</p>
<pre><code># 创建一个函数，将参数列表中每个元素都变成全大写
&gt;&gt;&gt; def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
&gt;&gt;&gt; def test(h, l):
...     return h(l)
...
&gt;&gt;&gt; l = ['python', 'Linux', 'Git']
# 运行高阶函数，返回预期的结果
&gt;&gt;&gt; test(high, l)
['PYTHON', 'LINUX', 'GIT']
</code></pre>
<p><code>map</code> 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。</p>
<h3 id="文件">文件</h3>
<p>使用 <code>open()</code> 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li>
<p><code>&quot;r&quot;</code>，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</p>
</li>
<li>
<p><code>&quot;w&quot;</code>，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</p>
</li>
<li>
<p><code>&quot;a&quot;</code>，以追加模式打开，写入到文件中的任何数据将自动添加到末尾</p>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，<code>open()</code> 函数将会以只读模式打开文件。</p>
<p><code>close()</code> 关闭文件</p>
<p><code>read()</code> 方法一次性读取整个文件。  <code>read(size)</code> 有一个可选的参数 <code>size</code>，用于指定字符串长度。如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。</p>
</li>
</ul>
<p><code>readline()</code> 能帮助你每次读取文件的一行。  使用 <code>readlines()</code> 方法读取所有行到一个列表中。</p>
<p><code>write()</code> 方法打开一个文件写入一些文本。</p>
<p>模块 <code>sys</code>。<code>sys.argv</code> 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 <code>cp</code> 命令替代：在 <code>cp</code> 后首先输入被拷贝的文件的文件名，然后输入新文件名。</p>
<p><code>with</code> 语句处理文件对象，它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写</p>
<p>在 Linux 下你可以使用 <code>lscpu</code> 命令来查看当前电脑的 CPU 相关信息 ， 实际上 <code>lscpu</code> 命令是读取 <code>/proc/cpuinfo</code> 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 <code>/proc/cpuinfo</code> 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 <code>lscpu</code> 命令了 :）</p>
<h3 id="异常">异常</h3>
<p>我们使用 <code>try...except</code> 块来处理任意异常。基本的语法像这样：</p>
<pre><code>try:
    statements to be inside try clause
    statement2
    statement3
    ...
except ExceptionName:
    statements to evaluated in case of ExceptionName happens
</code></pre>
<p>使用 <code>raise</code> 语句抛出一个异常。</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError(&quot;A value error happened.&quot;)
... except ValueError:
...     print(&quot;ValueError in our code.&quot;)
...
ValueError in our code.
</code></pre>
<p><code>try</code> 语句还有另一个可选的 <code>finally</code> 子句，目的在于定义在任何情况下都一定要执行的功能， 不管有没有发生异常，<code>finally</code> 子句 在程序离开 <code>try</code> 后都一定会被执行。当 <code>try</code> 语句中发生了未被 <code>except</code> 捕获的异常（或者它发生在 <code>except</code> 或 <code>else</code> 子句中），在 <code>finally</code> 子句执行完后它会被重新抛出。</p>
<p><code>with</code> 语句，它是 <code>try-finally</code> 块的简写，使用 <code>with</code> 语句能保证文件始终被关闭。</p>
<h3 id="类">类</h3>
<pre><code>class nameoftheclass(parent_class):
    statement1
    statement2
    statement3
</code></pre>
<p>在类的声明中你可以写任何 Python 语句，包括定义函数（在类中我们称为方法）。</p>
<p>类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。 <code>x = MyClass()</code></p>
<p>类定义了 <code>__init__()</code> 方法的话，类的实例化操作会自动为新创建的类实例调用 <code>__init__()</code> 方法。</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre>
<p>一个类可以继承自多个类，具有父类的所有变量和方法，语法如下：</p>
<pre><code>class MyClass(Parentclass1, Parentclass2,...):
    def __init__(self):
        Parentclass1.__init__(self)
        Parentclass2.__init__(self)
        ...
        ...
</code></pre>
<p>删除一个对象使用关键字 <code>del</code> 。</p>
<p>更精确的调整控制属性访问权限，你可以使用 <code>@property</code> 装饰器，<code>@property</code> 装饰器就是负责把一个方法变成属性调用的。</p>
<h3 id="模块">模块</h3>
<p>模块是包括 Python 定义和声明的文件。文件名就是模块名加上 <code>.py</code> 后缀。</p>
<p>从模块中导入指定的函数。这样做：</p>
<pre><code>&gt;&gt;&gt; from bars import simplebar, starbar
&gt;&gt;&gt; simplebar(20)
</code></pre>
<p>含有 <code>__init__.py</code> 文件的目录可以用来作为一个包，目录里的所有 <code>.py</code> 文件都是这个包的子模块。</p>
<p><a href="http://docs.python.org/3/library/os.html#module-os"><code>os</code></a> 模块提供了与操作系统相关的功能。<code>getuid()</code> 函数返回当前进程的有效用户 id。<code>getpid()</code> 函数返回当前进程的 id。<code>getppid()</code> 返回父进程的 id。<code>uname()</code> 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 <code>uname -a</code> 命令得到。<code>uname()</code> 返回的对象是一个元组，<code>（sysname, nodename, release, version, machine）</code>。getcwd() 函数返回当前工作目录。<code>chdir(path)</code> 则是更改当前目录到 path。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/">Requests</a> 是一个第三方 Python 模块， 第三方模块并不是默认的模块，意味着你需要安装它，我们使用 <code>pip3</code> 安装它。</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install python3-pip
$ sudo pip3 install requests
</code></pre>
<p>你可以使用 <code>get()</code> 方法获取任意一个网页。</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.get('https://github.com')
&gt;&gt;&gt; req.status_code
200
</code></pre>
<p><code>req</code> 的 <code>text</code> 属性存有服务器返回的 HTML 网页使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序。</p>
<pre><code>#!/usr/bin/env python3
import requests

def download(url):
    '''
    从指定的 URL 中下载文件并存储到当前目录
    url: 要下载页面内容的网址
    '''
    # 检查 URL 是否存在
    try:
        req = requests.get(url)
    except requests.exceptions.MissingSchema:
        print('Invalid URL &quot;{}&quot;'.format(url))
        return
    # 检查是否成功访问了该网站
    if req.status_code == 403:
        print('You do not have the authority to access this page.')
        return
    filename = url.split('/')[-1]
    with open(filename, 'w') as fobj:
        fobj.write(req.content.decode('utf-8'))
    print(&quot;Download over.&quot;)

if __name__ == '__main__':
    url = input('Enter a URL: ')
    download(url)
</code></pre>
<p><code>if __name__ == '__main__':</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 <code>if</code> 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，<code>if</code> 块内的语句并不会执行。</p>
<p>命令行传入的所有参数都可以使用 <code>sys.argv</code> 获取。如果希望对参数进行处理可以使用 <code>argparse</code> 模块</p>
<h4 id="collections-模块">collections  模块</h4>
<h5 id="counter">Counter</h5>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; import re
&gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt'
&gt;&gt;&gt; words = re.findall('\w+', open(path).read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)]
</code></pre>
<p>Counter 对象有一个叫做 <code>elements()</code> 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<p><code>most_common()</code> 方法返回最常见的元素及其计数，顺序为最常见到最少。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<h5 id="defaultdict">defaultdict</h5>
<p><code>defaultdict</code> 是内建 <code>dict</code> 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同。  <code>defaultdict()</code> 第一个参数提供了 <code>default_factory</code> 属性的初始值，默认值为 <code>None</code>，<code>default_factory</code> 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数。  同样的功能使用 <code>defaultdict</code> 比使用 <code>dict.setdefault</code> 方法快。</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])])
</code></pre>
<h5 id="namedtuple">namedtuple</h5>
<p>命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息。</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])  # 定义命名元组
&gt;&gt;&gt; p = Point(10, y=20)  # 创建一个对象
&gt;&gt;&gt; p
Point(x=10, y=20)
&gt;&gt;&gt; p.x + p.y
30
&gt;&gt;&gt; p[0] + p[1]  # 像普通元组那样访问元素
30
&gt;&gt;&gt; x, y = p     # 元组拆封
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>
<h3 id="python排版">Python排版</h3>
<p>每层缩进使用4个空格。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p><code>import</code>语句分组顺序如下：</p>
<ol>
<li>导入标准库模块</li>
<li>导入相关第三方库模块</li>
<li>导入当前应用程序/库模块</li>
</ol>
<p>避免在下列情况中使用多余的空格：</p>
<ul>
<li>
<p>与括号保持紧凑（小括号、中括号、大括号）：</p>
</li>
<li>
<p>与后面的逗号、分号或冒号保持紧凑</p>
</li>
<li>
<p>切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。</p>
</li>
<li>
<p>函数名与其后参数列表的左括号应该保持紧凑</p>
</li>
<li>
<p>与切片或索引的左括号保持紧凑</p>
</li>
<li>
<p>在赋值操作符（或其它）的两侧保持多余一个的空格</p>
</li>
<li>
<p>总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。</p>
</li>
<li>
<p>在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。</p>
</li>
<li>
<p>不要在关键值参数或默认值参数的等号两边加入空格。</p>
</li>
<li>
<p>【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的<code>-&gt;</code>左右各插入一个空格。</p>
</li>
<li>
<p>打消使用复合语句（多条语句在同一行）的念头。</p>
</li>
<li>
<p>有时候把 <code>if/for/while</code> 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。</p>
<p>块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以<code>#</code>起头，并且<code>#</code>后要跟一个空格（除非是注释内的缩进文本）。</p>
<p>有节制的使用行内注释。</p>
<p>一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以<code>#</code>打头，<code>#</code>后接一个空格。</p>
<p>无谓的行内注释如果状态明显，会转移注意力。</p>
<ul>
<li>为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。</li>
<li><a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a> 描述了良好的文档字符串的约定。注意，文档字符串的结尾<code>&quot;&quot;&quot;</code>应该放在单独的一行，例如：</li>
<li>对于单行的文档字符串，把结尾<code>&quot;&quot;&quot;</code>放在同一行。</li>
</ul>
</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>Python 迭代器（<em>Iterators</em>）对象在遵守迭代器协议时需要支持如下两种方法。</p>
<p><code>__iter__()</code>，返回迭代器对象自身。这用在 <code>for</code> 和 <code>in</code> 语句中。</p>
<p><code>__next__()</code>，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 <code>StopIteration</code> 异常。</p>
<pre><code>class Counter(object):
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        #返回下一个值直到当前值大于 high
        if self.current &gt; self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
            
   
&gt;&gt;&gt; c = Counter(5,10)
&gt;&gt;&gt; for i in c:
...   print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 <code>StopIteration</code>，它会持续抛出相同的异常。</p>
<p>Python 生成器（<em>Generators</em>），生成器是更简单的创建迭代器的方法，这通过在函数中使用 <code>yield</code> 关键字完成：</p>
<pre><code>&gt;&gt;&gt; def my_generator():
...     print(&quot;Inside my generator&quot;)
...     yield 'a'
...     yield 'b'
...     yield 'c'
...
&gt;&gt;&gt; my_generator()
&lt;generator object my_generator at 0x7fbcfa0a6aa0&gt;

&gt;&gt;&gt; for char in my_generator():
...     print(char)
...
Inside my generator
a
b
c

&gt;&gt;&gt; def counter_generator(low, high):
...     while low &lt;= high:
...        yield low
...        low += 1
... 
&gt;&gt;&gt; for i in counter_generator(5,10):
...     print(i, end=' ')
... 
5 6 7 8 9 10
</code></pre>
<p>我们会发现生成器的一个特点：它们是不可重复使用的。</p>
<p>生成器表达式（<em>Generator expressions</em>），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广。</p>
<pre><code>&gt;&gt;&gt; sum([x*x for x in range(1,10)])
</code></pre>
<p>这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
</code></pre>
<p>生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。</p>
<p>闭包（<em>Closures</em>）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和。</p>
<pre><code>&gt;&gt;&gt; def add_number(num):
...     def adder(number):
...         #adder 是一个闭包
...         return num + number
...     return adder
...
&gt;&gt;&gt; a_10 = add_number(10)
&gt;&gt;&gt; a_10(21)
31
&gt;&gt;&gt; a_10(34)
44
&gt;&gt;&gt; a_5 = add_number(5)
&gt;&gt;&gt; a_5(3)
8
</code></pre>
<p>装饰器（<em>Decorators</em>）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的。</p>
<pre><code>&gt;&gt;&gt; def my_decorator(func):
...     def wrapper(*args, **kwargs):
...         print(&quot;Before call&quot;)
...         result = func(*args, **kwargs)
...         print(&quot;After call&quot;)
...         return result
...     return wrapper
...
&gt;&gt;&gt; @my_decorator
... def add(a, b):
...     #我们的求和函数
...     return a + b
...
&gt;&gt;&gt; add(1, 3)
Before call
After call
4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://xmweijh.github.io/post/git/</id>
        <link href="https://xmweijh.github.io/post/git/">
        </link>
        <updated>2020-03-21T10:38:26.000Z</updated>
        <content type="html"><![CDATA[<p>git init  将一个已存在的文件夹，置于Git的控制管理之下</p>
<p>git add  将创建或修改的文件添加到本地的暂存区</p>
<p><code>git add .</code> 命令全部添加到暂存区。</p>
<p>撤销暂存区的修改执行 <code>git reset -- [文件名]</code> 或者 <code>git rm --cached [文件名]</code> 命令即可</p>
<p>git commit  提交文件到本体仓库----每当完成一些工作，都可以创建一次提交，保存当前的版本</p>
<p>提交之前，设置名字和email   相当于签名，每次提交会包含这些信息  git config  配置</p>
<p><code>git config -l</code> 可以查看配置信息</p>
<pre><code>$ git config --global user.name &quot;YourName&quot;
$ git config --global user.email &quot;YourEmail@xxx.com&quot;

git commit -m &quot;first commit&quot;   -m&quot;注释&quot;
</code></pre>
<p>提交加注释辨别不同版本，便于理解对代码做了什么修改</p>
<p>git push 同步到远端仓库</p>
<p>git status 监测当前目录和缓存区的状态</p>
<pre><code>git remote add origin 仓库链接
git push origin master  （origin为仓库名）
</code></pre>
<p>git clone 拷贝一个Git仓库到本地，让自己能够查看修改。</p>
<p><code>git diff</code>用来查看工作区被跟踪的文件的修改详情</p>
<p><code>git diff --cached</code> 查看暂存区的全部修改</p>
<p><code>git log</code>，它用来查看版本区的提交历史记录</p>
<ul>
<li>
<p><code>git log [分支名]</code> 查看某分支的提交历史，不写分支名查看当前所在分支</p>
</li>
<li>
<p><code>git log --oneline</code> 一行显示提交历史</p>
</li>
<li>
<p><code>git log -n</code> 其中 n 是数字，查看最近 n 个提交</p>
</li>
<li>
<p><code>git log --author [贡献者名字]</code> 查看指定贡献者的提交记录</p>
</li>
<li>
<p><code>git log --graph</code> 图示法显示提交历史</p>
<p><code>git log</code> 查看提交记录  时间正序排列的信息，那么可以使用 <code>git log --reverse</code> 命令。 (按q退出此界面)</p>
<p><code>git branch -avv</code>，它用来查看全部分支信息</p>
<p><code>git reset --soft HEAD^</code> 撤销最近的一次提交，将修改还原到暂存区。  <code>--soft</code> 表示软退回，对应的还有 <code>--hard</code> 硬退，HEAD^<code>表示撤销一次提交，</code>HEAD^^<code>表示撤销两次提交，撤销 n 次可以简写为</code>HEAD~n`。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用操作]]></title>
        <id>https://xmweijh.github.io/post/linux-chang-yong-cao-zuo/</id>
        <link href="https://xmweijh.github.io/post/linux-chang-yong-cao-zuo/">
        </link>
        <updated>2020-03-21T10:37:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目录">目录</h3>
<pre><code> shiyanlou:~/ $   
</code></pre>
<p>当前所处的目录位置  shiiyanlou： 用户名   $命令提示符</p>
<p>**ls ：**查找目录中的内容    （蓝字目录，白字内容）</p>
<p><strong>cd:</strong> 进入目录</p>
<p>上下键可以快速选择前面输过的命令</p>
<p>**cd ..**可以回到上一级目录（中间有空格）</p>
<p>**cd -**上次所在的目录</p>
<p>**cd ~**回到主目录</p>
<p>**cd /**进入根目录</p>
<h3 id="文件">文件</h3>
<p><strong>tree</strong> 列出文件夹下所有子文件和文件（树形结构）</p>
<p><strong>Ctrl + c</strong> 停止</p>
<p><strong>pwd</strong> 获得当前目录的绝对路径</p>
<p><strong>mkdir</strong> 创建目录  加入**-p**一次性创建多级目录</p>
<p><strong>touch</strong> 新建文件   		<strong>cp</strong> 复制文件到指定目录</p>
<p><strong>cp -r</strong> 复制目录 		<strong>rm</strong> 删除文件 删除目录加 <strong>-r</strong></p>
<p><strong>mv</strong>移动文件或者目录  还可以用来重命名</p>
<p><strong>cat</strong> 将文件内容打印到屏幕 <strong>cat -n</strong>带上行号</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab的一些点]]></title>
        <id>https://xmweijh.github.io/post/matlab-de-yi-xie-dian/</id>
        <link href="https://xmweijh.github.io/post/matlab-de-yi-xie-dian/">
        </link>
        <updated>2020-03-14T12:48:10.000Z</updated>
        <content type="html"><![CDATA[<p>用mod时，不管被除数是正是负，余数的符号与除数相同，rem反之。</p>
<p>直接输入用中括号，同行空格或者逗号不同行用；号。</p>
<p>冒号表达式格式： 初始值：步长：终止值</p>
<p>linspace（第一个元素，最后一个元素，元素总数）</p>
<p>matlab元素按列储存，先第一列在第二列。</p>
<p>矩阵拆分用：号</p>
<p>~=是不等于</p>
<p>fix朝零方向取整，如fix(-1.3)=-1; fix(1.3)=1;</p>
<p>floor，顾名思义，就是地板，所以是取比它小的整数，即朝负无穷方向取整，如floor(-1.3)=-2; floor(1.3)=1;floor(-1.8)=-2，floor(1.8)=1</p>
<p>ceil，与floor相反，它的意思是天花板，也就是取比它大的最小整数，即朝正无穷方向取整，如ceil(-1.3)=-1; ceil(1.3)=2;ceil(-1.8)=-1，ceil(1.8)=2</p>
<p>round四舍五入到最近的整数，如round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2。</p>
<p>在进行矩阵之间的运算时“.<em>”和“</em>”的意义就有所不同了。假设a，b表示两个矩阵，a*b表示矩阵a与矩阵b进行矩阵相乘，a.*b表示矩阵a中的元素与矩阵b中的元素按位置依次相乘，得到的结果将作为新矩阵中相同位置的元素</p>
<p>a:c:b表示[a,a+c,……,a+n*c],其中n=fix((b-a)/c)</p>
<p>Syms 变量间不打符号</p>
<p>abs函数求实数的绝对值，复数的模，字符串的asc||</p>
<p>在plot写完后 加上axis([0 1 2 3])</p>
<p>则表明图线的x轴范围为0<sub>1y轴范围为2</sub>3</p>
<p>hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存</p>
<p>即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</p>
<p>hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++]]></title>
        <id>https://xmweijh.github.io/post/c/</id>
        <link href="https://xmweijh.github.io/post/c/">
        </link>
        <updated>2020-03-14T12:43:39.000Z</updated>
        <content type="html"><![CDATA[<p>C++比C更丰富</p>
<p>(1).支持面向对象，将问题域和方法域统一化。宏观面向对象，微观面向过程。</p>
<p>(2).支持泛型编程。</p>
<pre><code>int add (int a, int b) { ... }

template\&lt;typename T&gt;

T add (T a, T b) { ... }
</code></pre>
<p>(3).支持异常机制。</p>
<pre><code>int func (void) {

  ...

}
</code></pre>
<pre><code>int main (void) {

  if (func () == -1) {

​    //错误处理;

  }

}
</code></pre>
<p>(4).操作符重载</p>
<p>不再使用scanf/printf而是cin/cout。</p>
<p>头文件：#include\大多数标准库头文件没有.h后缀。</p>
<p>输出：cout – 标准输出对象</p>
<p>输入运算符：&lt;&lt;</p>
<p>提取输出运算符：&gt;&gt;</p>
<pre><code>\#include &lt;iostream&gt;
 int main (void) {
   std::cout &lt;&lt; &quot;Hello, World !&quot; &lt;&lt; std::endl;
   int i;
   double d;
   char s[256];
 //  scanf (&quot;%d%lf%s&quot;, &amp;i, &amp;d, s);
   std::cin &gt;&gt; i &gt;&gt; d &gt;&gt; s;
 //  printf (&quot;%d %lf %s\n&quot;, i, d, s);
   std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; d &lt;&lt; ' ' &lt;&lt; s &lt;&lt; '\n';
   return 0;
 }
</code></pre>
<p>A. 结构</p>
<p>定义结构型变量时，可以省略struct关键字。</p>
<p>1)结构内部可以定义函数——成员函数。</p>
<p>2)sizeof(空结构) -&gt; 1</p>
<p>C++层面上引用和指针存在以下不同：</p>
<p>(a). 指针是实体变量，但是引用不是实体变量。</p>
<pre><code> int&amp; a=b;
 sizeof (a);//4
 double&amp; d=f;
 sizeof (d);//8
</code></pre>
<p>(b). 指针可以不初始化，但是引用必须初始化。</p>
<p>(c). 指针的目标可以修改，但是引用的目标的不能修改。</p>
<p>(d). 可以定义指针的指针，但是不能定义引用的指针。</p>
<pre><code> int a;
 int* p = &amp;a;
 int** pp = &amp;p;//ok
 int&amp; r = a;
 int&amp;* pr = &amp;r;//ERROR
</code></pre>
<p>(e). 可以定义指针的引用，但是不能定义引用的引用。</p>
<pre><code> int a;
 int* p = &amp;a;
 int*&amp; q = p;//ok
 int&amp; r = a;
 int&amp;&amp; s = r;//ERROR
</code></pre>
<p>(f). 可以定义指针的数组，但不能定义引用的数组。</p>
<pre><code> int a, b, c;
 int* parr[] = {&amp;a,&amp;b,&amp;c};/ok
 int&amp; rarr[] = {a,b,c};//ERROR
 //可以定义数组的引用。
 int arr[] = {1 ,2,3};
</code></pre>
<p><strong>建议</strong>:</p>
<p>(1). 少用宏，多用const，enum和inline。</p>
<pre><code>\#define PAI 3.14159 

 const double PAI = 3.14159;

 #define ERORR_FILE -1;

 #defile ERORR_MEM -2;

 enum {

 ERORR_FILE = -1,

 ERORR_MEM = -2

 };

 #define max(a,b) ((a) &gt; (b) ? (a) : (b))

 inline int double max (double a,double b){return a &gt; b ? a : b;}
</code></pre>
<p>(2). 变量随用随时声明同时初始化。</p>
<p>(3). 少用malloc/free,多用new/delete。</p>
<p>(4). 少用C风格的强制类型转换，多用类型转换运算符。</p>
<p>(5). 少用C风格的字符串，多用string。</p>
<p>(6). 树立面向对象的编程思想。</p>
<p>类和对象</p>
<p>什么是对象</p>
<p>1 万物皆对象</p>
<p>程序就是一组对象，对象之间通过消息交换信息</p>
<p>类就是对对象的描述和抽象，对象就是类的具体化和实例化。</p>
<p>2 通过类描述对象</p>
<p>属性：姓名、年龄、学号</p>
<p>行为：吃饭、睡觉、学习</p>
<p>类就是从属性和行为两个方面对对象进行抽象。</p>
<p>3 面向对象程序设计（OOP）</p>
<p>现实世界 虚拟世界</p>
<p>对象 -&gt; 抽象 -&gt; 类 -&gt; 对象</p>
<p>至少掌握一种OOP编程语言</p>
<p>精通一种面向对象的元语言—UML</p>
<p>研究设计模式，GOF</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言的一些基础知识]]></title>
        <id>https://xmweijh.github.io/post/hui-bian-yu-yan-de-yi-xie-ji-chu-zhi-shi/</id>
        <link href="https://xmweijh.github.io/post/hui-bian-yu-yan-de-yi-xie-ji-chu-zhi-shi/">
        </link>
        <updated>2020-03-14T12:36:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<pre><code>Int add_a_and_b(int a,int b){

returna+b;

}

Int main(){

returnadd_a_and_b(2,3);

}
</code></pre>
<pre><code>_add_a_and_b:

 push%ebx mov%eax,

[%esp+8]mov%ebx,

[%esp+12]add%eax,%ebx 

pop%ebx

 ret _main:push3 push2 call _add_a_and_b add%esp,8ret
</code></pre>
<p>针对8086CPU，有14个寄存器，分别为： AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW。</p>
<p>ABCD-X，通用寄存器，存储一般性数据。 不过，在汇编中，CX 有个特殊功能，用于存储 loop的循环次数。 这里的寄存器都有分高低位，H、L分别表示高低。示例：</p>
<p>mov ax, 11  ; 将11送入寄存器ax<br>
mov bl, 3    ; 将3送入bl寄存器<br>
add ax, 5    ; 将ax寄存器的值加3</p>
<p>CS、IP 是最关键的两个寄存器，它们指示了当前 要读取指令的地址，CS是段地址，IP是指令指针寄存器。 CSx16+IP 就是CPU当前要执行的指令。换个通俗的话，要让CPU执行什么命令，只要改变这两个寄存器的值，就可以做到了。（有一种皇帝的感觉，哈哈），但是CPU不可能提供 mov cs, 11h 等命令操作，使用jmp cs:ip 进行更改值，从而跳转到想执行的命令处。</p>
<p>DS 寄存器是用于存储数据的段地址，比如要读取某段数据中的值，那么就要先DS指向那里的地址，再加上偏移地址 [...]，就可以进行数据读取了（ES作为附加段寄存器，与DS功能一致，在段太多的情况，可以视情况选用即可）</p>
<p>SS, SP, BP 是栈相关寄存器。CPU提供的栈机制</p>
<p>在语言层面表现出来就是，push, pop 两个命令，任意时刻，SS:SP都指向栈顶元素。 push 时， SP=SP-2，pop时，如果有接收的寄存器则先将栈顶值送入，然后 SP=SP+2，指向下面一个单元。 这有什么用呢？ 当然有用，它可以用来临时保存各种数据，然后再插入功能执行完成后，进行现场的恢复，事实上，大部分时候是这么用的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言的一些笔记]]></title>
        <id>https://xmweijh.github.io/post/c-yu-yan-de-yi-xie-bi-ji/</id>
        <link href="https://xmweijh.github.io/post/c-yu-yan-de-yi-xie-bi-ji/">
        </link>
        <updated>2020-03-14T12:24:35.000Z</updated>
        <content type="html"><![CDATA[<p>该运算<strong>只适合用两个整数</strong>进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。</p>
<p>注意：复合运算符中运算符和等号之间是<strong>不存在空格</strong>的。</p>
<p>* 整个逗号表达式的值是最后一个表达式的值c = (++a, a *= 2, b = a * 5); &lt;==&gt; c=b;</p>
<p>数组a的地址是ffc1，数组a[0]的地址也是ffc1，即a = a[0]；</p>
<p>注意了，尾部有个'\0'，如果没有这个结束标记，说明这个字符数组存储的并不是字符串</p>
<p>使用‘’初始化时，一定记得加‘\0’，</p>
<p>而“”初始化时，系统会自动在字符串尾部加上一个\0结束符</p>
<p>gets可以读入包含空格、tab的字符串，直到遇到回车为止；scanf<strong>不能用来读取空格</strong>、tab</p>
<p>算法：可以没有输入，<strong>但是一定要有输出</strong>。</p>
<p>%符号两边要，求是整数。不是整数就错了。</p>
<p>int x=y=10: 错啦，<strong>定义时，不可以连续赋值</strong>。int x,y; x=y=10;   对滴，定义完成后，可以连续赋值。</p>
<p>逗号表达式： 优先级别最低。表达式的数值逗号最右边的那个表达式的数值</p>
<p>z=（2，3，4）(整个是赋值表达式) 这个时候z的值为4。</p>
<p>z=  2，3，4 （整个是逗号表达式）这个时候z的值为2。</p>
<p>注释不是C语言，不占运行时间，没有分号。不可以嵌套！</p>
<p>数组名代表的值不可以改变，他是地址常量名。</p>
<p>在C语言中，二维数组元素的内存中的存放顺序是按行主顺序存放</p>
<p>while(k++&amp;&amp;n++&gt;2); k=1，n=2，因为k++为0不计算后面的n++，k变化，n不变</p>
<p>最终可以得出结论：a = a[0] = &amp;a[0][0]，以此类推，可以得出a[1] = &amp;a[1][0]</p>
<p>sqrt()算术平方根函数，fabs()绝对值函数，pow()幂函数，sin()正弦函数</p>
<p>指数形式字母e或E前必须有数字，且后面的数字必须为整数。</p>
<p>for 循环三个表达式<strong>可以省去</strong>，第二表达式只要为真就执行，无特殊格式。</p>
<p>​</p>
<pre><code>int main(int argc, const char * argv[]) {

  clock_t start,finish;

  

  start = clock();

  printf(&quot;计算结果：%d\n&quot;, fib(45));

  finish = clock();

  printf(&quot;花费时间--------%lu\n&quot;,finish - start);

 

   

  start = clock();

  printf(&quot;计算结果：%d\n&quot;, tailfib(45,1,1));

  finish = clock();

   

  printf(&quot;花费时间--------%lu\n&quot;,finish - start);

  return 0;
</code></pre>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xmweijh.github.io/</id>
    <title>小虾米的记录</title>
    <updated>2021-02-07T11:39:39.173Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xmweijh.github.io/"/>
    <link rel="self" href="https://xmweijh.github.io/atom.xml"/>
    <subtitle>努力成就自我</subtitle>
    <logo>https://xmweijh.github.io/images/avatar.png</logo>
    <icon>https://xmweijh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小虾米的记录</rights>
    <entry>
        <title type="html"><![CDATA[CSS]]></title>
        <id>https://xmweijh.github.io/post/css/</id>
        <link href="https://xmweijh.github.io/post/css/">
        </link>
        <updated>2021-02-07T11:39:17.000Z</updated>
        <content type="html"><![CDATA[<p>CSS</p>
<p>结构(html)与样式(css)相分离</p>
<p>主要用于<strong>设置</strong> HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及<strong>版面的布局和外观显示样式。</strong></p>
<h3 id="引入css样式表">引入CSS样式表</h3>
<h4 id="行内式">行内式</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称行内样式、行间样式.</p>
<p>​	是通过标签的style属性来设置元素的样式</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;
</code></pre>
<p>实际上任何HTML标签都拥有style属性，用来设置行内式。</p>
<ul>
<li>案例：</li>
</ul>
<pre><code class="language-css">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt;
</code></pre>
<ul>
<li>注意：
<ul>
<li>style其实就是标签的属性</li>
<li>样式属性和值中间是<code>:</code></li>
<li>多组属性值之间用<code>;</code>隔开。</li>
<li>只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余</li>
</ul>
</li>
<li>缺点：
<ul>
<li>没有实现样式和结构相分离</li>
</ul>
</li>
</ul>
<h4 id="内部样式表内嵌样式表">内部样式表（内嵌样式表）</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称内嵌式</p>
<p>​	是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
&lt;style type=&quot;text/CSS&quot;&gt;
    选择器（选择的标签） { 
      属性1: 属性值1;
      属性2: 属性值2; 
      属性3: 属性值3;
    }
&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<pre><code class="language-css">&lt;style&gt;
	 div {
	 	color: red;
	 	font-size: 12px;
	 }
&lt;/style&gt;
</code></pre>
<ul>
<li>
<p>注意：</p>
<ul>
<li>style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。</li>
<li>type=&quot;text/css&quot;  在html5中可以省略。</li>
<li>只能控制当前的页面</li>
</ul>
</li>
<li>
<p>缺点：</p>
<p>没有彻底分离</p>
</li>
</ul>
<h4 id="外部样式表外链式">外部样式表（外链式）</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称链入式</p>
<p>​	是将所有的样式放在一个或多个以**.CSS**为扩展名的外部样式表文件中，</p>
<p>​	通过link标签将外部样式表文件链接到HTML文档中</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot;&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>注意：
<ul>
<li>link 是个单标签</li>
<li>link标签需要放在head头部标签中，并且指定link标签的三个属性</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rel</td>
<td style="text-align:left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</td>
</tr>
<tr>
<td>href</td>
<td style="text-align:left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</td>
</tr>
</tbody>
</table>
<h3 id="三种样式表总结位置">三种样式表总结（位置）</h3>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少）</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h3 id="css选择器重点">CSS选择器（重点）</h3>
<h4 id="css选择器作用重点">CSS选择器作用（重点）</h4>
<p>找到特定的HTML页面元素      选择标签用的， 把我们想要的标签选择出来</p>
<h4 id="css基础选择器">CSS基础选择器</h4>
<h5 id="标签选择器">标签选择器</h5>
<ul>
<li>
<p>概念：</p>
<p>标签选择器（元素选择器）是指用<strong>HTML标签名</strong>称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<pre><code>标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 
</code></pre>
<ul>
<li>
<p>作用：</p>
<p>标签选择器 可以把某一类标签<strong>全部</strong>选择出来  比如所有的div标签  和 所有的 span标签</p>
</li>
<li>
<p>优点：</p>
<p>是能快速为页面中同类型的标签统一样式</p>
</li>
<li>
<p>缺点：</p>
<p>不能设计差异化样式。</p>
</li>
</ul>
<h5 id="类选择器">类选择器</h5>
<p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名.</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>类名选择器</li>
</ul>
<pre><code>.类名  {   
    属性1:属性值1; 
    属性2:属性值2; 
    属性3:属性值3;     
}
</code></pre>
<ul>
<li>标签</li>
</ul>
<pre><code>&lt;p class='类名'&gt;&lt;/p&gt;
</code></pre>
</li>
<li>
<p>优点：</p>
<ul>
<li>可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的)</li>
<li>长名称或词组可以使用中横线来为选择器命名。</li>
<li>不要纯数字、中文等命名， 尽量使用英文字母来表示。</li>
</ul>
</li>
</ul>
<h5 id="类选择器特殊用法-多类名">类选择器特殊用法- 多类名</h5>
<p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p>
<p>注意：</p>
<ul>
<li>各个类名中间用空格隔开。</li>
<li>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</li>
</ul>
<h5 id="id选择器">id选择器</h5>
<p>id选择器使用<code>#</code>进行标识，后面紧跟id名</p>
<ul>
<li>
<p>其基本语法格式如下：</p>
<ul>
<li>
<p>id选择器</p>
<pre><code>#id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
</code></pre>
</li>
<li>
<p>标签</p>
<pre><code>&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p>
</li>
<li>
<p>用法基本和类选择器相同。</p>
</li>
</ul>
<h5 id="id选择器和类选择器区别">id选择器和类选择器区别</h5>
<ul>
<li>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。
<ul>
<li>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</li>
<li>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</li>
</ul>
</li>
</ul>
<p><em><strong>id选择器和类选择器最大的不同在于 使用次数上。</strong></em></p>
<ul>
<li>类选择器我们在修改样式中，用的最多。</li>
<li>id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。</li>
</ul>
<h5 id="通配符选择器">通配符选择器</h5>
<ul>
<li>
<p>概念</p>
<p>通配符选择器用<code>*</code>号表示，  *   就是 选择所有的标签      他是所有选择器中作用范围最广的，能匹配页面中所有的元素。</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code>* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
</code></pre>
<p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p>
<pre><code class="language-css">* {
  margin: 0;                    /* 定义外边距*/
  padding: 0;                   /* 定义内边距*/
}
</code></pre>
<ul>
<li>
<p>注意：</p>
<p>会匹配页面所有的元素，降低页面响应速度，不建议随便使用</p>
</li>
</ul>
<h3 id="基础选择器总结">基础选择器总结</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>缺点</th>
<th>使用情况</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签选择器</td>
<td>可以选出所有相同的标签，比如p</td>
<td>不能差异化选择</td>
<td>较多</td>
<td>p { color：red;}</td>
</tr>
<tr>
<td>类选择器</td>
<td>可以选出1个或者多个标签</td>
<td>可以根据需求选择</td>
<td>非常多</td>
<td>.nav { color: red; }</td>
</tr>
<tr>
<td>id选择器</td>
<td>一次只能选择器1个标签</td>
<td>只能使用一次</td>
<td>不推荐使用</td>
<td>#nav {color: red;}</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>选择所有的标签</td>
<td>选择的太多，有部分不需要</td>
<td>不推荐使用</td>
<td>* {color: red;}</td>
</tr>
</tbody>
</table>
<h3 id="css字体样式属性调试工具">CSS字体样式属性调试工具</h3>
<h4 id="font字体">font字体</h4>
<h5 id="font-size大小">font-size:大小</h5>
<ul>
<li>
<p>作用：</p>
<p>font-size属性用于设置字号</p>
</li>
</ul>
<pre><code class="language-css">p {  
    font-size:20px; 
}
</code></pre>
<ul>
<li>
<p>单位：</p>
<ul>
<li>可以使用相对长度单位，也可以使用绝对长度单位。</li>
<li>相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。</li>
</ul>
</li>
</ul>
<ul>
<li>谷歌浏览器默认的文字大小为16px</li>
<li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小</li>
</ul>
<h5 id="font-family字体">font-family:字体</h5>
<ul>
<li>
<p>作用：</p>
<p>font-family属性用于设置哪一种字体。</p>
</li>
</ul>
<pre><code>p{ font-family:&quot;微软雅黑&quot;;}
</code></pre>
<ul>
<li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li>
<li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li>
</ul>
<pre><code>p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;}
</code></pre>
<pre><code>1. 各种字体之间必须使用英文状态下的逗号隔开。
2. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。
3. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。
4. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。
</code></pre>
<h5 id="font-weight字体粗细">font-weight:字体粗细</h5>
<ul>
<li>在html中如何将字体加粗我们可以用标签来实现
<ul>
<li>使用 b  和 strong 标签是文本加粗。</li>
</ul>
</li>
<li>可以使用CSS 来实现，但是CSS 是没有语义的。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td style="text-align:left">默认值（不加粗的）</td>
</tr>
<tr>
<td>bold</td>
<td style="text-align:left">定义粗体（加粗的）</td>
</tr>
<tr>
<td>100~900</td>
<td style="text-align:left">400 等同于 normal，而 700 等同于 bold  我们重点记住这句话</td>
</tr>
</tbody>
</table>
<p>提倡：</p>
<p>我们平时更喜欢用数字来表示加粗和不加粗</p>
<h5 id="font-style字体风格">font-style:字体风格</h5>
<ul>
<li>在html中如何将字体倾斜我们可以用标签来实现
<ul>
<li>字体倾斜除了用 i  和 em 标签，</li>
</ul>
</li>
<li>可以使用CSS 来实现，但是CSS 是没有语义的</li>
</ul>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td style="text-align:left">默认值，浏览器会显示标准的字体样式  font-style: normal;</td>
</tr>
<tr>
<td>italic</td>
<td style="text-align:left">浏览器会显示斜体的字体样式。</td>
</tr>
</tbody>
</table>
<h5 id="font综合设置字体样式-重点">font:综合设置字体样式 (重点)</h5>
<p>font属性用于对字体样式进行综合设置</p>
<ul>
<li>基本语法格式如下：</li>
</ul>
<pre><code class="language-css">选择器 { font: font-style  font-weight  font-size/line-height  font-family;}
</code></pre>
<ul>
<li>注意：
<ul>
<li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li>
<li>其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</li>
</ul>
</li>
</ul>
<h4 id="font总结">font总结</h4>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
<th style="text-align:left">注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">font-size</td>
<td style="text-align:left">字号</td>
<td style="text-align:left">我们通常用的单位是px 像素，一定要跟上单位</td>
</tr>
<tr>
<td style="text-align:left">font-family</td>
<td style="text-align:left">字体</td>
<td style="text-align:left">实际工作中按照团队约定来写字体</td>
</tr>
<tr>
<td style="text-align:left">font-weight</td>
<td style="text-align:left">字体粗细</td>
<td style="text-align:left">记住加粗是 700 或者 bold  不加粗 是 normal 或者  400  记住数字不要跟单位</td>
</tr>
<tr>
<td style="text-align:left">font-style</td>
<td style="text-align:left">字体样式</td>
<td style="text-align:left">记住倾斜是 italic     不倾斜 是 normal  工作中我们最常用 normal</td>
</tr>
<tr>
<td style="text-align:left">font</td>
<td style="text-align:left">字体连写</td>
<td style="text-align:left">1. 字体连写是有顺序的  不能随意换位置 2. 其中字号 和 字体 必须同时出现</td>
</tr>
</tbody>
</table>
<h3 id="css外观属性">CSS外观属性</h3>
<h4 id="color文本颜色">color:文本颜色</h4>
<ul>
<li>
<p>作用：</p>
<p>color属性用于定义文本的颜色，</p>
</li>
<li>
<p>其取值方式有如下3种：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">表示表示</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">预定义的颜色值</td>
<td style="text-align:left">red，green，blue，还有我们的御用色 pink</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">#FF0000，#FF6600，#29D794</td>
</tr>
<tr>
<td style="text-align:left">RGB代码</td>
<td style="text-align:left">rgb(255,0,0)或rgb(100%,0%,0%)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>注意</p>
<p>我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如  #f00 代表红色</p>
</li>
</ul>
<h4 id="text-align文本水平对齐方式">text-align:文本水平对齐方式</h4>
<ul>
<li>
<p>作用：</p>
<p>text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性</p>
</li>
<li>
<p>其可用属性值如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td style="text-align:center">左对齐（默认值）</td>
</tr>
<tr>
<td>right</td>
<td style="text-align:center">右对齐</td>
</tr>
<tr>
<td>center</td>
<td style="text-align:center">居中对齐</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>注意：</p>
<p>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</p>
</li>
</ul>
<h4 id="line-height行间距">line-height:行间距</h4>
<ul>
<li>
<p>作用：</p>
<p>line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p>
</li>
<li>
<p>单位：</p>
<ul>
<li>line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</li>
</ul>
</li>
<li>
<p>技巧：</p>
</li>
</ul>
<pre><code>一般情况下，行距比字号大7.8像素左右就可以了。
line-height: 24px;
</code></pre>
<h4 id="text-indent首行缩进">text-indent:首行缩进</h4>
<ul>
<li>
<p>作用：</p>
<p>text-indent属性用于设置首行文本的缩进，</p>
</li>
<li>
<p>属性值</p>
<ul>
<li>其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</li>
<li>建议使用em作为设置单位。</li>
</ul>
</li>
</ul>
<p><strong>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p>
<pre><code class="language-css">p {
      /*行间距*/
      line-height: 25px;
      /*首行缩进2个字  em  1个em 就是1个字的大小*/
      text-indent: 2em;  
 }
</code></pre>
<h4 id="text-decoration-文本的装饰">text-decoration 文本的装饰</h4>
<p>text-decoration   通常我们用于给链接修改装饰效果</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认。定义标准的文本。 取消下划线（最常用）</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线。（不用）</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线。（不常用）</td>
</tr>
</tbody>
</table>
<h4 id="css外观属性总结">CSS外观属性总结</h4>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
<th style="text-align:left">注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">颜色</td>
<td style="text-align:left">我们通常用  十六进制   比如 而且是简写形式 #fff</td>
</tr>
<tr>
<td style="text-align:left">line-height</td>
<td style="text-align:left">行高</td>
<td style="text-align:left">控制行与行之间的距离</td>
</tr>
<tr>
<td style="text-align:left">text-align</td>
<td style="text-align:left">水平对齐</td>
<td style="text-align:left">可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td style="text-align:left">text-indent</td>
<td style="text-align:left">首行缩进</td>
<td style="text-align:left">通常我们用于段落首行缩进2个字的距离   text-indent: 2em;</td>
</tr>
<tr>
<td style="text-align:left">text-decoration</td>
<td style="text-align:left">文本修饰</td>
<td style="text-align:left">记住 添加 下划线  underline  取消下划线  none</td>
</tr>
</tbody>
</table>
<p>Emmet的前身是Zen coding,它使用缩写,来提高html/css的编写速度。</p>
<ol>
<li>
<p>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div></p>
</li>
<li>
<p>如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div</p>
</li>
<li>
<p>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</p>
</li>
<li>
<p>如果有兄弟关系的标签，用  +  就可以了 比如 div+p</p>
</li>
<li>
<p>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</p>
</li>
<li>
<p>如果生成的div 类名是有顺序的， 可以用 自增符号  $</p>
<pre><code>.demo$*3        
&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
</ol>
<h4 id="后代选择器重点">后代选择器（重点）</h4>
<ul>
<li>
<p>概念：</p>
<p>后代选择器又称为包含选择器</p>
</li>
<li>
<p>作用：</p>
<p>用来选择元素或元素组的<strong>子孙后代</strong></p>
</li>
<li>
<p>其写法就是把外层标签写在前面，内层标签写在后面，中间用<strong>空格</strong>分隔，先写父亲爷爷，在写儿子孙子。</p>
</li>
</ul>
<pre><code>父级 子级{属性:属性值;属性:属性值;}
</code></pre>
<ul>
<li>语法：</li>
</ul>
<pre><code>.class h3{color:red;font-size:16px;}
</code></pre>
<ul>
<li>当标签发生嵌套时，内层标签就成为外层标签的后代。</li>
<li>子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。</li>
</ul>
<h4 id="子元素选择器">子元素选择器</h4>
<ul>
<li>
<p>作用：</p>
<p>子元素选择器只能选择作为某元素**子元素(亲儿子)**的元素。</p>
</li>
<li>
<p>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 <code>&gt;</code> 进行连接</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<pre><code>.class&gt;h3{color:red;font-size:14px;}
</code></pre>
<pre><code> 比如：  .demo &gt; h3 {color: red;}   说明  h3 一定是demo 亲儿子。  demo 元素包含着h3。
</code></pre>
<h4 id="交集选择器">交集选择器</h4>
<ul>
<li>
<p>条件</p>
<p>交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。</p>
</li>
<li>
<p>其中第一个为标签选择器，第二个为class选择器，两个选择器之间<strong>不能有空格</strong>，如h3.special。</p>
</li>
</ul>
<p><strong>记忆技巧：</strong></p>
<p>交集选择器 是 并且的意思。  即...又...的意思</p>
<pre><code>比如：   p.one   选择的是： 类名为 .one  的 段落标签。  
</code></pre>
<p>用的相对来说比较少，不太建议使用</p>
<h4 id="并集选择器重点">并集选择器（重点）</h4>
<ul>
<li>
<p>应用：</p>
<ul>
<li>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。</li>
</ul>
</li>
<li>
<p>并集选择器（CSS选择器分组）是各个选择器通过<code>,</code>连接而成的，通常用于集体声明。</p>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。</p>
</li>
<li>
<p>记忆技巧：</p>
<p>并集选择器通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。</p>
</li>
</ul>
<pre><code>比如  .one, p , #test {color: #F00;}  
表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。 
通常用于集体声明。  
</code></pre>
<h4 id="链接伪类选择器重点">链接伪类选择器（重点）</h4>
<p>伪类选择器：</p>
<p>为了和我们刚才学的类选择器相区别<br>
类选择器是一个点 比如 .demo {}<br>
而我们的伪类 用 2个点 就是 冒号  比如  :link{}    伪娘</p>
<p>作用：</p>
<p>用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p>
<p>因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。</p>
<pre><code class="language-css">
</code></pre>
<ul>
<li>
<p>a:link      /* 未访问的链接 */</p>
</li>
<li>
<p>a:visited   /* 已访问的链接 */</p>
</li>
<li>
<p>a:hover     /* 鼠标移动到链接上 */</p>
</li>
<li>
<p>a:active    /* 选定的链接 */</p>
<p><strong>注意</strong></p>
</li>
</ul>
<ul>
<li>写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。</li>
<li>记忆法
<ul>
<li><strong>l</strong>o<strong>v</strong>e   <strong>ha</strong>te     爱上了讨厌</li>
<li>**lv **包包   非常 <strong>ha</strong>o</li>
</ul>
</li>
<li>因为叫链接伪类，所以都是 利用交集选择器  a:link    a:hover</li>
<li>因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li>
<li>实际工作开发中，我们很少写全四个状态，一般我们写法如下：</li>
</ul>
<pre><code class="language-css">a {   /* a是标签选择器  所有的链接 */
			font-weight: 700;
			font-size: 16px;
			color: gray;
}
a:hover {   /* :hover 是链接伪类选择器 鼠标经过 */
			color: red; /*  鼠标经过的时候，由原来的 灰色 变成了红色 */
}
</code></pre>
<h3 id="复合选择器总结">复合选择器总结</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>特征</th>
<th>使用情况</th>
<th>隔开符号及用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>后代选择器</td>
<td>用来选择元素后代</td>
<td>是选择所有的子孙后代</td>
<td>较多</td>
<td>符号是<strong>空格</strong> .nav a</td>
</tr>
<tr>
<td>子代选择器</td>
<td>选择 最近一级元素</td>
<td>只选亲儿子</td>
<td>较少</td>
<td>符号是**&gt;**   .nav&gt;p</td>
</tr>
<tr>
<td>交集选择器</td>
<td>选择两个标签交集的部分</td>
<td>既是 又是</td>
<td>较少</td>
<td><strong>没有符号</strong>  p.one</td>
</tr>
<tr>
<td>并集选择器</td>
<td>选择某些相同样式的选择器</td>
<td>可以用于集体声明</td>
<td>较多</td>
<td>符号是<strong>逗号</strong> .nav, .header</td>
</tr>
<tr>
<td>链接伪类选择器</td>
<td>给链接更改状态</td>
<td></td>
<td>较多</td>
<td>重点记住 a{} 和 a:hover  实际开发的写法</td>
</tr>
</tbody>
</table>
<h3 id="标签显示模式display重点">标签显示模式（display）重点</h3>
<ul>
<li>
<p>什么是标签的显示模式？</p>
<p>标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个</p>
</li>
<li>
<p>作用：</p>
<p>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p>
</li>
<li>
<p>标签的类型(分类)</p>
<p>HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p>
</li>
</ul>
<h4 id="块级元素block-level">块级元素(block-level)</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。
</code></pre>
<ul>
<li>块级元素的特点</li>
</ul>
<p>（1）比较霸道，自己独占一行</p>
<p>（2）高度，宽度、外边距以及内边距都可以控制。</p>
<p>（3）宽度默认是容器（父级宽度）的100%</p>
<p>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p>
<ul>
<li>注意：
<ul>
<li>只有 文字才 能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div</li>
<li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
</li>
</ul>
<h4 id="行内元素inline-level">行内元素(inline-level)</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素
</code></pre>
<ul>
<li>行内元素的特点：</li>
</ul>
<p>（1）相邻行内元素在一行上，一行可以显示多个。</p>
<p>（2）高、宽直接设置是无效的。</p>
<p>（3）默认宽度就是它本身内容的宽度。</p>
<p>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p>
<p>​     注意：</p>
<ul>
<li>链接里面不能再放链接。</li>
<li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li>
</ul>
<h4 id="行内块元素inline-block">行内块元素（inline-block）</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。
</code></pre>
<ul>
<li>
<p>行内块元素的特点：</p>
<p>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>
（2）默认宽度就是它本身内容的宽度。<br>
（3）高度，行高、外边距以及内边距都可以控制。</p>
</li>
</ul>
<h3 id="三种模式总结区别">三种模式总结区别</h3>
<table>
<thead>
<tr>
<th>元素模式</th>
<th>元素排列</th>
<th>设置样式</th>
<th>默认宽度</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>块级元素</td>
<td>一行只能放一个块级元素</td>
<td>可以设置宽度高度</td>
<td>容器的100%</td>
<td>容器级可以包含任何标签</td>
</tr>
<tr>
<td>行内元素</td>
<td>一行可以放多个行内元素</td>
<td>不可以直接设置宽度高度</td>
<td>它本身内容的宽度</td>
<td>容纳文本或则其他行内元素</td>
</tr>
<tr>
<td>行内块元素</td>
<td>一行放多个行内块元素</td>
<td>可以设置宽度和高度</td>
<td>它本身内容的宽度</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="标签显示模式转换-display">标签显示模式转换 display</h4>
<ul>
<li>块转行内：display:inline;</li>
<li>行内转块：display:block;</li>
<li><strong>块、行内元素转换为行内块： display: inline-block;</strong></li>
</ul>
<p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p>
<h4 id="行高那些事line-height">行高那些事（line-height）</h4>
<h4 id="单行文本垂直居中">单行文本垂直居中</h4>
<p>行高   =  上距离 +  内容高度  + 下距离</p>
<p>上距离和下距离总是相等的，因此文字看上去是垂直居中的。</p>
<p><strong>行高和高度的三种关系</strong></p>
<ul>
<li>如果 行高 等 高度  文字会 垂直居中</li>
<li>如果行高 大于 高度   文字会 偏下</li>
<li>如果行高小于高度   文字会  偏上</li>
</ul>
<h3 id="css-背景background">CSS 背景(background)</h3>
<h4 id="背景颜色color">背景颜色(color)</h4>
<ul>
<li>
<p>语法：</p>
<pre><code>background-color:颜色值;   默认的值是 transparent  透明的
</code></pre>
</li>
</ul>
<h4 id="背景图片image">背景图片(image)</h4>
<ul>
<li>语法：</li>
<li></li>
</ul>
<pre><code class="language-css">background-image : none | url (url) 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td style="text-align:center">无背景图（默认的）</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">使用绝对或相对地址指定背景图像</td>
</tr>
</tbody>
</table>
<pre><code class="language-css">background-image : url(images/demo.png);
</code></pre>
<ul>
<li>小技巧：  我们提倡 背景图片后面的地址，<strong>url不要加引号。</strong></li>
</ul>
<h4 id="背景平铺repeat">背景平铺（repeat）</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background-repeat : repeat | no-repeat | repeat-x | repeat-y 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td style="text-align:center">背景图像在纵向和横向上平铺（默认的）</td>
</tr>
<tr>
<td>no-repeat</td>
<td style="text-align:center">背景图像不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td style="text-align:center">背景图像在横向上平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td style="text-align:center">背景图像在纵向平铺</td>
</tr>
</tbody>
</table>
<h4 id="背景位置position-重点">背景位置(position) 重点</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background-position : length || length

background-position : position || position 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td style="text-align:center">百分数 | 由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td style="text-align:center">top | center | bottom | left | center | right   方位名词</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：
<ul>
<li>必须先指定background-image属性</li>
<li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致</li>
<li>如果只指定了一个方位名词，另一个值默认居中对齐。</li>
<li>如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y</li>
<li>如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中</li>
<li>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
</li>
</ul>
<p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p>
<p>练习1：</p>
<p>背景大图</p>
<p>练习2：</p>
<p>小图片在盒子左侧垂直居中</p>
<h4 id="背景附着">背景附着</h4>
<ul>
<li>
<p>背景附着就是解释背景是滚动的还是固定的</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-】">background-attachment : scroll | fixed 
</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scroll</td>
<td style="text-align:center">背景图像是随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td style="text-align:center">背景图像固定</td>
</tr>
</tbody>
</table>
<h4 id="背景简写">背景简写</h4>
<ul>
<li>background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</li>
<li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li>
<li>语法：</li>
</ul>
<pre><code class="language-css">background: transparent url(image.jpg) repeat-y  scroll center top ;
</code></pre>
<p>案例：</p>
<p>导航栏案例</p>
<h4 id="背景透明css3">背景透明(CSS3)</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background: rgba(0, 0, 0, 0.3);
</code></pre>
<ul>
<li>最后一个参数是alpha 透明度  取值范围 0~1之间</li>
<li>我们习惯把0.3 的 0 省略掉  这样写  background: rgba(0, 0, 0, .3);</li>
<li>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li>
<li>因为是CSS3 ，所以 低于 ie9 的版本是不支持的。</li>
</ul>
<h4 id="背景总结">背景总结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-color</td>
<td style="text-align:left">背景颜色</td>
<td style="text-align:left">预定义的颜色值/十六进制/RGB代码</td>
</tr>
<tr>
<td>background-image</td>
<td style="text-align:left">背景图片</td>
<td style="text-align:left">url(图片路径)</td>
</tr>
<tr>
<td>background-repeat</td>
<td style="text-align:left">是否平铺</td>
<td style="text-align:left">repeat/no-repeat/repeat-x/repeat-y</td>
</tr>
<tr>
<td>background-position</td>
<td style="text-align:left">背景位置</td>
<td style="text-align:left">length/position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法</td>
</tr>
<tr>
<td>background-attachment</td>
<td style="text-align:left">背景固定还是滚动</td>
<td style="text-align:left">scroll/fixed</td>
</tr>
<tr>
<td>背景简写</td>
<td style="text-align:left">更简单</td>
<td style="text-align:left">背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序</td>
</tr>
<tr>
<td>背景透明</td>
<td style="text-align:left">让盒子半透明</td>
<td style="text-align:left">background: rgba(0,0,0,0.3);   后面必须是 4个值</td>
</tr>
</tbody>
</table>
<h3 id="css-三大特性">CSS 三大特性</h3>
<h4 id="css层叠性">CSS层叠性</h4>
<ul>
<li>
<p>概念：</p>
<p>所谓层叠性是指多种CSS样式的叠加。</p>
<p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p>
</li>
<li>
<p>原则：</p>
<ul>
<li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li>
<li>样式不冲突，不会层叠</li>
</ul>
</li>
</ul>
<pre><code>CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。
</code></pre>
<h4 id="css继承性">CSS继承性</h4>
<ul>
<li>
<p>概念：</p>
<p>子标签会继承父标签的某些样式，如文本颜色和字号。</p>
<p>想要设置一个可继承的属性，只需将它应用于父元素即可。</p>
</li>
</ul>
<p>简单的理解就是：  子承父业。</p>
<ul>
<li><strong>注意</strong>：
<ul>
<li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li>
<li>子元素可以继承父元素的样式（<strong>text-，font-，line-这些元素开头的可以继承，以及color属性</strong>）</li>
</ul>
</li>
</ul>
<pre><code>CSS继承性口诀：  龙生龙，凤生凤，老鼠生的孩子会打洞。
</code></pre>
<h4 id="css优先级重点">CSS优先级（重点）</h4>
<ul>
<li>
<p>概念：</p>
<p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，就会出现优先级的问题。</li>
</ul>
</li>
</ul>
<h5 id="1-权重计算公式">1). 权重计算公式</h5>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p>
<table>
<thead>
<tr>
<th>标签选择器</th>
<th>计算权重公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承或者 *</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>每个元素（标签选择器）</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类，伪类</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>每个行内样式 style=&quot;&quot;</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important  重要的</td>
<td>∞ 无穷大</td>
</tr>
</tbody>
</table>
<ul>
<li>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</li>
<li>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li>
<li>div {<br>
color: pink!important;<br>
}</li>
</ul>
<h5 id="2-权重叠加">2). 权重叠加</h5>
<p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p>
<p>就是一个简单的加法计算</p>
<ul>
<li>
<p>div ul  li   ------&gt;      0,0,0,3</p>
</li>
<li>
<p>.nav ul li   ------&gt;      0,0,1,2</p>
</li>
<li>
<p>a:hover      -----—&gt;   0,0,1,1</p>
</li>
<li>
<p>.nav a       ------&gt;      0,0,1,1</p>
<p>注意：</p>
</li>
</ul>
<ol>
<li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</li>
</ol>
<h5 id="3-继承的权重是0">3). 继承的权重是0</h5>
<p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p>
<p>1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>
2） 如果没有选中，那么权重是0，因为继承的权重为0.</p>
<h3 id="css注释">CSS注释</h3>
<p><strong>CSS注释规则：</strong></p>
<pre><code>/*  需要注释的内容  */  进行注释的，即在需要注释的内容前使用 &quot;/*&quot; 标记开始注释，在内容的结尾使用 &quot;*/&quot;结束。
</code></pre>
<p>例如：</p>
<pre><code class="language-css">p {
 /* 所有的字体是14像素大小*/
  font-size: 14px;                 
}
</code></pre>
<h3 id="盒子模型css重点">盒子模型（CSS重点）</h3>
<p>所谓盒子模型：</p>
<ul>
<li>就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</li>
</ul>
<ul>
<li>盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。</li>
<li>盒子里面的文字和图片等元素是 内容区域</li>
<li>盒子的厚度 我们成为 盒子的边框</li>
<li>盒子内容与边框的距离是内边距（类似单元格的 cellpadding)</li>
<li>盒子与盒子之间的距离是外边距（类似单元格的 cellspacing）</li>
</ul>
<h4 id="盒子边框border">盒子边框（border）</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">border : border-width || border-style || border-color 
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-width</td>
<td style="text-align:center">定义边框粗细，单位是px</td>
</tr>
<tr>
<td>border-style</td>
<td style="text-align:center">边框的样式</td>
</tr>
<tr>
<td>border-color</td>
<td style="text-align:center">边框颜色</td>
</tr>
</tbody>
</table>
<ul>
<li>边框的样式：
<ul>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线</li>
<li>dotted：边框为点线</li>
</ul>
</li>
</ul>
<h5 id="边框综合设置">边框综合设置</h5>
<pre><code>border : border-width || border-style || border-color 
</code></pre>
<p>例如：</p>
<pre><code class="language-css"> border: 1px solid red;  没有顺序  
</code></pre>
<h5 id="盒子边框写法总结表">盒子边框写法总结表</h5>
<p>很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">上边框</th>
<th style="text-align:left">下边框</th>
<th style="text-align:left">左边框</th>
<th style="text-align:left">右边框</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">border-top-style:样式;</td>
<td style="text-align:left">border-bottom-style:样式;</td>
<td style="text-align:left">border-left-style:样式;</td>
<td style="text-align:left">border-right-style:样式;</td>
</tr>
<tr>
<td style="text-align:left">border-top-width:宽度;</td>
<td style="text-align:left">border- bottom-width:宽度;</td>
<td style="text-align:left">border-left-width:宽度;</td>
<td style="text-align:left">border-right-width:宽度;</td>
</tr>
<tr>
<td style="text-align:left">border-top-color:颜色;</td>
<td style="text-align:left">border- bottom-color:颜色;</td>
<td style="text-align:left">border-left-color:颜色;</td>
<td style="text-align:left">border-right-color:颜色;</td>
</tr>
<tr>
<td style="text-align:left">border-top:宽度 样式 颜色;</td>
<td style="text-align:left">border-bottom:宽度 样式 颜色;</td>
<td style="text-align:left">border-left:宽度 样式 颜色;</td>
<td style="text-align:left">border-right:宽度 样式 颜色;</td>
</tr>
</tbody>
</table>
<h5 id="表格的细线边框">表格的细线边框</h5>
<ul>
<li>
<p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为0，</p>
</li>
<li>
<p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li>
<p>通过css属性：</p>
<pre><code>table{ border-collapse:collapse; }  
</code></pre>
<ul>
<li>collapse 单词是合并的意思</li>
<li>border-collapse:collapse; 表示相邻边框合并在一起。</li>
</ul>
</li>
</ul>
<pre><code class="language-css">&lt;style&gt;
	table {
		width: 500px;
		height: 300px;
		border: 1px solid red;
	}
	td {
		border: 1px solid red;
		text-align: center;
	}
	table, td {
		border-collapse: collapse;  /*合并相邻边框*/
	}
&lt;/style&gt;
</code></pre>
<h4 id="内边距padding">内边距（padding）</h4>
<p>内边距：</p>
<p>​	padding属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p>
<p>设置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>padding-left</td>
<td style="text-align:left">左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td style="text-align:left">右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td style="text-align:left">上内边距</td>
</tr>
<tr>
<td>padding-bottom</td>
<td style="text-align:left">下内边距</td>
</tr>
</tbody>
</table>
<p>当我们给盒子指定padding值之后， 发生了2件事情：</p>
<ol>
<li>内容和边框 有了距离，添加了内边距。</li>
<li>盒子会变大了。</li>
</ol>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个值</td>
<td>padding：上下左右内边距;</td>
</tr>
<tr>
<td>2个值</td>
<td>padding: 上下内边距    左右内边距 ；</td>
</tr>
<tr>
<td>3个值</td>
<td>padding：上内边距   左右内边距   下内边距；</td>
</tr>
<tr>
<td>4个值</td>
<td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td>
</tr>
</tbody>
</table>
<h4 id="内盒尺寸计算元素实际大小">内盒尺寸计算（元素实际大小）</h4>
<ul>
<li>
<p>宽度</p>
<p>Element Height = content height + padding + border （Height为内容高度）</p>
</li>
<li>
<p>高度</p>
<p>Element Width = content width + padding + border （Width为内容宽度）</p>
</li>
<li>
<p>盒子的实际的大小 =   内容的宽度和高度 +  内边距   +  边框</p>
</li>
</ul>
<p>padding不影响盒子大小情况</p>
<blockquote>
<p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p>
</blockquote>
<h4 id="外边距margin">外边距（margin）</h4>
<p>​	margin属性用于设置外边距。  margin就是控制<strong>盒子和盒子之间的距离</strong></p>
<p>设置：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-left</td>
<td style="text-align:left">左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td style="text-align:left">右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td style="text-align:left">上外边距</td>
</tr>
<tr>
<td>margin-bottom</td>
<td style="text-align:left">下外边距</td>
</tr>
</tbody>
</table>
<p>margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p>
<h4 id="块级盒子水平居中">块级盒子水平居中</h4>
<ul>
<li>可以让一个块级盒子实现水平居中必须：
<ul>
<li>盒子必须指定了宽度（width）</li>
<li>然后就给<strong>左右的外边距都设置为auto</strong>，</li>
</ul>
</li>
</ul>
<p>实际工作中常用这种方式进行网页布局，示例代码如下：</p>
<pre><code class="language-css">.header{ width:960px; margin:0 auto;}
</code></pre>
<p>常见的写法，以下下三种都可以。</p>
<ul>
<li>margin-left: auto;   margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<h4 id="文字居中和盒子居中区别">文字居中和盒子居中区别</h4>
<ol>
<li>盒子内的文字水平居中是  text-align: center,  而且还可以让 行内元素和行内块居中对齐</li>
<li>块级盒子水平居中  左右margin 改为 auto</li>
</ol>
<pre><code class="language-css">text-align: center; /*  文字 行内元素 行内块元素水平居中 */
margin: 10px auto;  /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */
</code></pre>
<h4 id="插入图片和背景图片区别">插入图片和背景图片区别</h4>
<ol>
<li>插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</li>
<li>背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</li>
</ol>
<pre><code class="language-css"> img {  
		width: 200px;/* 插入图片更改大小 width 和 height */
		height: 210px;
		margin-top: 30px;  /* 插入图片更改位置 可以用margin 或padding  盒模型 */
		margin-left: 50px; /* 插入当图片也是一个盒子 */
	}

 div {
		width: 400px;
		height: 400px;
		border: 1px solid purple;
		background: #fff url(images/sun.jpg) no-repeat;
		background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */
	}
</code></pre>
<h4 id="清除元素的默认内外边距重要">清除元素的默认内外边距(重要)</h4>
<p>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</p>
<p>代码：</p>
<pre><code class="language-css">* {
   padding:0;         /* 清除内边距 */
   margin:0;          /* 清除外边距 */
}
</code></pre>
<p>注意：</p>
<ul>
<li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li>
</ul>
<h4 id="外边距合并">外边距合并</h4>
<p>使用margin定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p>
<p><strong>(1). 相邻块元素垂直外边距的合并</strong></p>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li>
</ul>
<p><strong>解决方案：尽量给只给一个盒子添加margin值</strong>。</p>
<p><strong>(2). 嵌套块元素垂直外边距的合并（塌陷）</strong></p>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow:hidden。</li>
</ol>
<p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p>
<h4 id="盒子模型布局稳定性">盒子模型布局稳定性</h4>
<ul>
<li>
<p>学习完盒子模型，内边距和外边距，什么情况下用内边距，什么情况下用外边距？</p>
<ul>
<li>大部分情况下是可以混用的。  就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。</li>
</ul>
</li>
</ul>
<p>我们根据稳定性来分，建议如下：</p>
<p>按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。</p>
<pre><code>  width &gt;  padding  &gt;   margin   
</code></pre>
<ul>
<li>原因：
<ul>
<li>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</li>
<li>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li>
<li>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</li>
</ul>
</li>
</ul>
<h3 id="ps基本操作以及常用快捷键">ps基本操作以及常用快捷键：</h3>
<p>因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。</p>
<ul>
<li>文件--打开 --  可以打开 我们要测量的图片</li>
<li>ctrl+r 可以打开标尺  或者  视图 --  标尺</li>
<li>右击标尺，  把里面的单位改为  像素</li>
<li>ctrl+ 加号 键  可以 放大  视图  ctrl+ 减号 缩小视图</li>
<li>按住空格键，  鼠标可以 变成小手 ，拖动 ps 视图</li>
<li>用选区 拖动  可以 测量 大小</li>
<li>ctrl+ d  可以取消选区  或者旁边空白处点击一下也可以取消选区</li>
</ul>
<h3 id="圆角边框css3">圆角边框(CSS3)</h3>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">border-radius:length;  
</code></pre>
<ul>
<li>
<p>其中每一个值可以为 数值或百分比的形式。</p>
</li>
<li>
<p>技巧： 让一个正方形  变成圆圈</p>
<pre><code>border-radius: 50%;
</code></pre>
</li>
</ul>
<ul>
<li>效果图矩形的圆角， 就不要用 百分比了，因为百分比会是表示高度和宽度的一半。</li>
<li>而我们这里矩形就只用 用 高度的一半就好了。精确单位。</li>
</ul>
<h3 id="盒子阴影css3">盒子阴影(CSS3)</h3>
<ul>
<li>语法:</li>
</ul>
<pre><code class="language-css">box-shadow:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；
</code></pre>
<ul>
<li>前两个属性是必须写的。其余的可以省略。</li>
<li>外阴影 (outset) 是默认的 但是不能写           想要内阴影可以写  inset</li>
</ul>
<pre><code class="language-css">div {
			width: 200px;
			height: 200px;
			border: 10px solid red;
			/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */
			/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */
			box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);
			
}
</code></pre>
<h3 id="css书写规范">CSS书写规范</h3>
<h4 id="空格规范">空格规范</h4>
<p>【强制】 选择器 与 { 之间必须包含空格。</p>
<p>示例：</p>
<pre><code class="language-css">.selector {
}
</code></pre>
<p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</p>
<p>示例：</p>
<pre><code class="language-css">font-size: 12px;
</code></pre>
<h4 id="选择器规范">选择器规范</h4>
<p>【强制】 并集选择器，每个选择器声明必须独占一行。</p>
<p>示例：</p>
<pre><code>/* good */
.post,
.page,
.comment {
    line-height: 1.5;
}


/* bad */
.post, .page, .comment {
    line-height: 1.5;
}
</code></pre>
<p>【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
#username input {}
.comment .avatar {}

/* bad */
.page .header .login  input {}
.comment div * {}
</code></pre>
<h4 id="属性规范">属性规范</h4>
<p>【强制】 属性定义必须另起一行。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
.selector {
    margin: 0;
    padding: 0;
}

/* bad */
.selector { margin: 0; padding: 0; }
</code></pre>
<p>【强制】 属性定义后必须以分号结尾。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
.selector {
    margin: 0;
}

/* bad */
.selector {
    margin: 0
}
</code></pre>
<h3 id="浮动float">浮动(float)</h3>
<p><strong>CSS 布局的三种机制</strong></p>
<p>分别是<strong>普通流</strong>（标准流）、<strong>浮动</strong>和<strong>定位</strong></p>
<p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p>
<ol>
<li>脱离标准普通流的控制</li>
<li>移动到指定位置。</li>
</ol>
<p><strong>作用</strong></p>
<ol>
<li><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</li>
<li>可以实现盒子的左右对齐等等..</li>
<li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</li>
</ol>
<p><strong>语法</strong></p>
<p>在 CSS 中，通过 <code>float</code>  中文，  浮 漏 特    属性定义浮动，语法如下：</p>
<pre><code>选择器 { float: 属性值; }
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>none</strong></td>
<td>元素不浮动（<strong>默认值</strong>）</td>
</tr>
<tr>
<td><strong>left</strong></td>
<td>元素向<strong>左</strong>浮动</td>
</tr>
<tr>
<td><strong>right</strong></td>
<td>元素向<strong>右</strong>浮动</td>
</tr>
</tbody>
</table>
<p><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</p>
<p>浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p>
<p>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似。</p>
<p><strong>float</strong> —— <strong>浮漏特</strong></p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浮</td>
<td>加了浮动的盒子<strong>是浮起来</strong>的，漂浮在其他标准流盒子的上面。</td>
</tr>
<tr>
<td>漏</td>
<td>加了浮动的盒子<strong>是不占位置的</strong>，它原来的位置<strong>漏给了标准流的盒子</strong>。</td>
</tr>
<tr>
<td>特</td>
<td><strong>特别注意</strong>：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙</td>
</tr>
</tbody>
</table>
<h4 id="浮动float的应用重要">浮动(float)的应用（重要）</h4>
<p>注意，实际重要的导航栏中，我们不会直接用链接a 而是用 li  包含链接(li+a)的做法。</p>
<ol>
<li>li+a 语义更清晰，一看这就是有条理的列表型内容。</li>
<li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名</li>
</ol>
<h4 id="浮动float的扩展">浮动(float)的扩展</h4>
<p>浮动元素与父盒子的关系</p>
<ul>
<li>子盒子的浮动参照父盒子对齐</li>
<li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li>
</ul>
<p>浮动元素与兄弟盒子的关系</p>
<p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p>
<ul>
<li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li>
<li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。</li>
</ul>
<h4 id="清除浮动">清除浮动</h4>
<p><strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p>
<h4 id="清除浮动的方法">清除浮动的方法</h4>
<p>在CSS中，clear属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完css会再回头分析。</p>
<ul>
<li>语法：</li>
</ul>
<pre><code>选择器{clear:属性值;}   clear 清除  
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
<p>但是我们实际工作中， 几乎只用 clear: both;</p>
<h5 id="1额外标签法隔墙法">1).额外标签法(隔墙法)</h5>
<pre><code class="language-html">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。
</code></pre>
<ul>
<li>优点： 通俗易懂，书写方便</li>
<li>缺点： 添加许多无意义的标签，结构化较差。</li>
</ul>
<h5 id="2父级添加overflow属性方法">2).父级添加overflow属性方法</h5>
<pre><code class="language-css">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。
</code></pre>
<p>优点：  代码简洁</p>
<p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<h5 id="3使用after伪元素清除浮动">3).使用after伪元素清除浮动</h5>
<p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p>
<p>使用方法：</p>
<pre><code class="language-css"> .clearfix:after {  content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;  }   

 .clearfix {*zoom: 1;}   /* IE6、7 专有 */
</code></pre>
<ul>
<li>优点： 符合闭合浮动思想  结构语义化正确</li>
<li>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li>
</ul>
<h5 id="4用双伪元素清除浮动">4).用双伪元素清除浮动</h5>
<p>使用方法：</p>
<pre><code class="language-css">.clearfix:before,.clearfix:after { 
  content:&quot;&quot;;
  display:table; 
}
.clearfix:after {
 clear:both;
}
.clearfix {
  *zoom:1;
}
</code></pre>
<ul>
<li>
<p>优点：  代码更简洁</p>
</li>
<li>
<p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
</li>
</ul>
<ol>
<li>父级没高度</li>
<li>子盒子浮动了</li>
<li>影响下面布局了，我们就应该清除浮动了。</li>
</ol>
<table>
<thead>
<tr>
<th>清除浮动的方式</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>额外标签法（隔墙法）</td>
<td style="text-align:left">通俗易懂，书写方便</td>
<td style="text-align:left">添加许多无意义的标签，结构化较差。</td>
</tr>
<tr>
<td>父级overflow:hidden;</td>
<td style="text-align:left">书写简单</td>
<td style="text-align:left">溢出隐藏</td>
</tr>
<tr>
<td>父级after伪元素</td>
<td style="text-align:left">结构语义化正确</td>
<td style="text-align:left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
<tr>
<td>父级双伪元素</td>
<td style="text-align:left">结构语义化正确</td>
<td style="text-align:left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
</tbody>
</table>
<p><strong>常见的图片格式</strong></p>
<pre><code>1. jpg图像格式： 
JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的
2. gif图像格式：
GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果
3. png图像格式
是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景
4. PSD图像格式
PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。 
</code></pre>
<p>PS切图   可以 分为   利用切片工具切图 以及   利用PS的插件快速切图。</p>
<h3 id="css属性书写顺序重点">CSS属性书写顺序(重点)</h3>
<p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li>
</ol>
<pre><code class="language-css">.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre>
<h3 id="布局流程">布局流程</h3>
<p>为了提高网页制作的效率，布局时通常有以下的布局流程，具体如下：</p>
<p>1、必须确定页面的版心（可视区）， 我们测量可得知。</p>
<p>2、分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成</p>
<p>3、制作HTML结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</p>
<p>4、然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</p>
<h3 id="定位position">定位(position)</h3>
<p>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>、<strong>浮动</strong>和<strong>定位</strong>，其中：</p>
<ol>
<li>
<p><strong>普通流</strong>（<strong>标准流</strong>）</p>
</li>
<li>
<p><strong>浮动</strong></p>
<ul>
<li>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</li>
</ul>
</li>
<li>
<p><strong>定位</strong></p>
<ul>
<li>将盒子<strong>定</strong>在某一个<strong>位</strong>置  自由的漂浮在其他盒子的上面  —— CSS 离不开定位，特别是后面的 js 特效。</li>
</ul>
</li>
</ol>
<h4 id="边偏移">边偏移</h4>
<p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。</p>
<p>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th style="text-align:left">示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top</code></td>
<td style="text-align:left"><code>top: 80px</code></td>
<td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td style="text-align:left"><code>bottom: 80px</code></td>
<td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td>
</tr>
<tr>
<td><code>left</code></td>
<td style="text-align:left"><code>left: 80px</code></td>
<td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td>
</tr>
<tr>
<td><code>right</code></td>
<td style="text-align:left"><code>right: 80px</code></td>
<td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td>
</tr>
</tbody>
</table>
<p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p>
<h4 id="定位模式-position">定位模式 (position)</h4>
<p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p>
<pre><code class="language-css">选择器 { position: 属性值; }
</code></pre>
<p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th style="text-align:center">语义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static</code></td>
<td style="text-align:center"><strong>静态</strong>定位</td>
</tr>
<tr>
<td><code>relative</code></td>
<td style="text-align:center"><strong>相对</strong>定位</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td style="text-align:center"><strong>绝对</strong>定位</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td style="text-align:center"><strong>固定</strong>定位</td>
</tr>
</tbody>
</table>
<p>静态定位(static) - 了解</p>
<ul>
<li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。</li>
<li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li>
<li>静态定位在布局时我们几乎不用的</li>
</ul>
<h4 id="相对定位relative-重要">相对定位(relative) - 重要</h4>
<ul>
<li><strong>相对定位</strong>是元素<strong>相对</strong>于它  原来在标准流中的位置 来说的。（自恋型）</li>
</ul>
<p>相对定位的特点：（务必记住）</p>
<ul>
<li>相对于 自己原来在标准流中位置来移动的</li>
<li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li>
</ul>
<h4 id="绝对定位absolute-重要">绝对定位(absolute) - 重要</h4>
<p><strong>绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p>
<ol>
<li>
<p><strong>完全脱标</strong> —— 完全不占位置；</p>
</li>
<li>
<p><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）。</p>
</li>
</ol>
<p><strong>父元素要有定位</strong></p>
<ul>
<li>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li>
</ul>
<p>绝对定位的特点：（务必记住）</p>
<ul>
<li>绝对是以带有定位的父级元素来移动位置 （拼爹型） 如果父级都没有定位，则以浏览器文档为准移动位置</li>
<li>不保留原来的位置，完全是脱标的。</li>
</ul>
<p><strong>定位口诀 —— 子绝父相</strong></p>
<p>刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢？</p>
<p><strong>子绝父相</strong> —— <strong>子级</strong>是<strong>绝对</strong>定位，<strong>父级</strong>要用<strong>相对</strong>定位。</p>
<blockquote>
<p><strong>子绝父相</strong>是使用绝对定位的口诀，要牢牢记住！</p>
</blockquote>
<p><strong>疑问</strong>：为什么在布局时，<strong>子级元素</strong>使用<strong>绝对定位</strong>时，<strong>父级元素</strong>就要用<strong>相对定位</strong>呢？</p>
<h4 id="固定定位fixed-重要">固定定位(fixed) - 重要</h4>
<p><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）   如果说绝对定位是一个矩形 那么 固定定位就类似于正方形</p>
<ol>
<li><strong>完全脱标</strong> —— 完全不占位置；</li>
<li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；
<ul>
<li>跟父元素没有任何关系；单独使用的</li>
<li>不随滚动条滚动。</li>
</ul>
</li>
</ol>
<h4 id="定位position的扩展">定位(position)的扩展</h4>
<p><strong>绝对定位的盒子居中</strong></p>
<blockquote>
<p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p>
</blockquote>
<ol>
<li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li>
<li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li>
</ol>
<p><strong>堆叠顺序（z-index）</strong></p>
<ol>
<li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li>
<li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li>
<li><strong>数字后面不能加单位</strong>。</li>
</ol>
<p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p>
<p><strong>定位改变display属性</strong></p>
<p>前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式:</p>
<ul>
<li>可以用inline-block  转换为行内块</li>
<li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li>
</ul>
<p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<blockquote>
<p>完善新浪导航案例</p>
</blockquote>
<p><strong>同时注意：</strong></p>
<p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</p>
<p>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
<h4 id="圆角矩形设置4个角">圆角矩形设置4个角</h4>
<p>圆角矩形可以为4个角分别设置圆度， 但是是有顺序的</p>
<pre><code>border-top-left-radius:20px;
border-top-right-radius:20px;
border-bottom-right-radius:20px;
border-bottom-left-radius:20px;
</code></pre>
<ul>
<li>
<p>如果4个角，数值相同</p>
<pre><code class="language-css">border-radius: 15px;
</code></pre>
</li>
<li>
<p>里面数值不同，我们也可以按照简写的形式，具体格式如下:</p>
</li>
</ul>
<pre><code class="language-css">border-radius: 左上角 右上角  右下角  左下角;
</code></pre>
<p>还是遵循的顺时针。</p>
<h3 id="定位小结">定位小结</h3>
<table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标占有位置</th>
<th style="text-align:left">移动位置基准</th>
<th>模式转换（行内块）</th>
<th>使用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态static</td>
<td>不脱标，正常模式</td>
<td style="text-align:left">正常模式</td>
<td>不能</td>
<td>几乎不用</td>
</tr>
<tr>
<td>相对定位relative</td>
<td>不脱标，占有位置</td>
<td style="text-align:left">相对自身位置移动</td>
<td>不能</td>
<td>基本单独使用</td>
</tr>
<tr>
<td>绝对定位absolute</td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于定位父级移动位置</td>
<td>能</td>
<td>要和定位父级元素搭配使用</td>
</tr>
<tr>
<td>固定定位fixed</td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于浏览器移动位置</td>
<td>能</td>
<td>单独使用，不需要父级</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<ol>
<li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li>
<li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li>
<li><code>left</code> 和 <code>right</code> 不要同时使用。</li>
</ol>
<h3 id="元素的显示与隐藏">元素的显示与隐藏</h3>
<h4 id="display-显示重点">display 显示（重点）</h4>
<ul>
<li>
<p>display 设置或检索对象是否及如何显示。</p>
<pre><code>display: none 隐藏对象

display：block 除了转换为块级元素之外，同时还有显示元素的意思。
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，不再保留位置。</p>
</li>
</ul>
<p>实际开发场景：</p>
<blockquote>
<p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
</blockquote>
<h4 id="visibility-可见性-了解">visibility 可见性 (了解)</h4>
<ul>
<li>
<p>设置或检索是否显示对象。</p>
<pre><code>visibility：visible ; 　对象可视

visibility：hidden; 　  对象隐藏
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，继续保留原有位置。</p>
</li>
</ul>
<h4 id="overflow-溢出重点">overflow 溢出(重点)</h4>
<ul>
<li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>visible</strong></td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td><strong>hidden</strong></td>
<td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td><strong>scroll</strong></td>
<td>不管超出内容否，总是显示滚动条</td>
</tr>
<tr>
<td><strong>auto</strong></td>
<td>超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody>
</table>
<p>实际开发场景：</p>
<ol>
<li>清除浮动</li>
<li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li>
</ol>
<h3 id="显示与隐藏总结">显示与隐藏总结</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>区别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>display</strong></td>
<td>隐藏对象，不保留位置</td>
<td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td>
</tr>
<tr>
<td><strong>visibility</strong></td>
<td>隐藏对象，保留位置</td>
<td>使用较少</td>
</tr>
<tr>
<td><strong>overflow</strong></td>
<td>只是隐藏超出大小的部分</td>
<td>1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody>
</table>
<h3 id="css用户界面样式">CSS用户界面样式</h3>
<p>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。</p>
<ul>
<li>更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究)</li>
<li>表单轮廓等。</li>
<li>防止表单域拖拽</li>
</ul>
<h4 id="鼠标样式cursor">鼠标样式cursor</h4>
<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>default</strong></td>
<td>小白  默认</td>
</tr>
<tr>
<td><strong>pointer</strong></td>
<td>小手</td>
</tr>
<tr>
<td><strong>move</strong></td>
<td>移动</td>
</tr>
<tr>
<td><strong>text</strong></td>
<td>文本</td>
</tr>
<tr>
<td><strong>not-allowed</strong></td>
<td>禁止</td>
</tr>
</tbody>
</table>
<h4 id="轮廓线-outline">轮廓线 outline</h4>
<p>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<pre><code class="language-css"> outline : outline-color ||outline-style || outline-width 
</code></pre>
<p>但是我们都不关心可以设置多少，我们平时都是去掉的。 li</p>
<p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p>
<pre><code class="language-html"> &lt;input  type=&quot;text&quot;  style=&quot;outline: 0;&quot;/&gt;
</code></pre>
<h4 id="防止拖拽文本域resize">防止拖拽文本域resize</h4>
<p>实际开发中，我们文本域右下角是不可以拖拽：</p>
<pre><code class="language-html">&lt;textarea  style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h3 id="用户界面样式总结">用户界面样式总结</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>用途</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>鼠标样式</strong></td>
<td>更改鼠标样式cursor</td>
<td>样式很多，重点记住 pointer</td>
</tr>
<tr>
<td><strong>轮廓线</strong></td>
<td>表单默认outline</td>
<td>outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用</td>
</tr>
<tr>
<td>防止拖拽</td>
<td>主要针对文本域resize</td>
<td>防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none</td>
</tr>
</tbody>
</table>
<h3 id="vertical-align-垂直对齐">vertical-align 垂直对齐</h3>
<ul>
<li>有宽度的块级元素居中对齐，是margin: 0 auto;</li>
<li>让文字居中对齐，是 text-align: center;</li>
</ul>
<p>但是我们从来没有讲过有垂直居中的属性。</p>
<p>vertical-align 垂直对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p>
<pre><code class="language-css">vertical-align : baseline |top |middle |bottom 
</code></pre>
<p>设置或检索对象内容的垂直对其方式。</p>
<ul>
<li>
<p>注意：</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p>
<p>特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p>
</li>
</ul>
<h4 id="图片-表单和文字对齐">图片、表单和文字对齐</h4>
<figure data-type="image" tabindex="1"><img src="F:%5CAPEX-4869%5Cmd%5C1498467742995.png" alt="" loading="lazy"></figure>
<h4 id="去除图片底侧空白缝隙">去除图片底侧空白缝隙</h4>
<ul>
<li>
<p>原因：</p>
<p>图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p>
<p>就是图片底侧会有一个空白缝隙。</p>
</li>
<li>
<p>解决的方法就是：</p>
<ul>
<li>
<p>给img vertical-align:middle | top| bottom等等。  让图片不要和基线对齐。</p>
</li>
<li>
<p>给img 添加 display：block; 转换为块级元素就不会存在问题了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="溢出的文字省略号显示">溢出的文字省略号显示</h3>
<h4 id="white-space">white-space</h4>
<ul>
<li>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</li>
</ul>
<pre><code>white-space:normal ；默认处理方式

white-space:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。
</code></pre>
<h4 id="text-overflow-文字溢出">text-overflow 文字溢出</h4>
<ul>
<li>设置或检索是否使用一个省略标记（...）标示对象内文本的溢出</li>
</ul>
<pre><code>text-overflow : clip ；不显示省略标记（...），而是简单的裁切 

text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）
</code></pre>
<p><strong>注意</strong>：</p>
<p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<h4 id="总结三步曲">总结三步曲</h4>
<pre><code class="language-css">  /*1. 先强制一行内显示文本*/
      white-space: nowrap;
  /*2. 超出的部分隐藏*/
      overflow: hidden;
  /*3. 文字用省略号替代超出的部分*/
      text-overflow: ellipsis;
</code></pre>
<h3 id="css精灵技术sprite-重点">CSS精灵技术（sprite) 重点</h3>
<blockquote>
<p><strong>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</strong></p>
</blockquote>
<p>出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p>
<h4 id="精灵技术讲解">精灵技术讲解</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</p>
<p>这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</p>
<p>我们需要使用CSS的</p>
<ul>
<li>background-image、</li>
<li>background-repeat</li>
<li>background-position属性进行背景定位，</li>
<li>其中最关键的是使用background-position 属性精确地定位。</li>
</ul>
<h4 id="精灵技术使用的核心总结">精灵技术使用的核心总结</h4>
<p>首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</p>
<ol>
<li>精确测量，每个小背景图片的大小和 位置。</li>
<li>给盒子指定小背景图片时， 背景定位基本都是 负值。</li>
</ol>
<h4 id="制作精灵图了解">制作精灵图(了解)</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p>
<p>大部分情况下，精灵图都是网页美工做。</p>
<pre><code>我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。
我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙
在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。
</code></pre>
<p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p>
<h3 id="滑动门">滑动门</h3>
<h3 id="核心技术">核心技术</h3>
<p>核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p>
<p>一般的经典布局都是这样的：</p>
<pre><code class="language-html">&lt;li&gt;
  &lt;a href=&quot;#&quot;&gt;
    &lt;span&gt;导航栏内容&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;
</code></pre>
<p>css样式</p>
<pre><code class="language-css">* {
      padding:0;
      margin:0;

    }
    body{
      background: url(images/wx.jpg) repeat-x;
    }
    .father {
      padding-top:20px;
    }
    li {
      padding-left: 16px;
      height: 33px;
      float: left;
      line-height: 33px;
      margin:0  10px;
      background: url(./images/to.png) no-repeat left ;
    }
    a {
      padding-right: 16px;
      height: 33px;
      display: inline-block;
      color:#fff;
      background: url(./images/to.png) no-repeat right ;
      text-decoration: none;
    }
    li:hover,
     li:hover a {
      background-image:url(./images/ao.png);
    }
</code></pre>
<p>总结：</p>
<ol>
<li>a 设置 背景左侧，padding撑开合适宽度。</li>
<li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li>
<li>之所以a包含span就是因为 整个导航都是可以点击的。</li>
</ol>
<h3 id="margin负值之美">margin负值之美</h3>
<p><strong>1). 负边距+定位：水平垂直居中</strong></p>
<p>咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</p>
<p><strong>2). 压住盒子相邻边框</strong></p>
<h3 id="css三角形之美">CSS三角形之美</h3>
<pre><code class="language-css"> div {

 	width: 0; 

    height: 0;
    line-height:0；
    font-size: 0;
	border-top: 10px solid red;

	border-right: 10px solid green;

	border-bottom: 10px solid blue;

	border-left: 10px soli #000; 

 }

</code></pre>
<h3 id="网站ico图标">网站ico图标</h3>
<h3 id="1-使用ico图标">1). 使用ico图标</h3>
<ul>
<li>
<p>首先把favicon.ico 这个图标放到根目录下。</p>
</li>
<li>
<p>再html里面，  head 之间 引入 代码。</p>
<blockquote>
<link rel="shortcut icon" href="favicon.ico"  type="image/x-icon"/>     
</blockquote>
</li>
</ul>
<h3 id="2-制作ico图标">2). 制作ico图标</h3>
<p>我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。</p>
<p>方法步骤：</p>
<ul>
<li>首先把我们想要的切成图片。</li>
<li>要把图片转换为 ico 图标，我们借助于第三方转换网站：   http://www.bitbug.net/。  比特虫</li>
</ul>
<p>总结：</p>
<pre><code>代码：  &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;  type=&quot;image/x-icon&quot;/&gt;     
</code></pre>
<p>注意：</p>
<ol>
<li>她（它）是显示在浏览器中的网页图标。</li>
<li>它是图标形式，不是一个图片</li>
<li>位置是放到 head 标签中间。</li>
<li>后面的type=&quot;image/x-icon&quot;  属性可以省略。（我相信你也愿意省略。）</li>
<li>为了兼容性，请将favicon.ico 这个图标放到根目录下。</li>
</ol>
<h3 id="网站优化三大标签">网站优化三大标签</h3>
<h4 id="1-网页title-标题">1. 网页title 标题</h4>
<p>title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。</p>
<p>建议：</p>
<p>首页标题：网站名（产品名）- 网站的介绍</p>
<p>例如：</p>
<p>品优购-综合网购首选-正品低价、品质保障、配送及时、轻松购物！</p>
<p>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</p>
<h4 id="2-description-网站说明">2. Description  网站说明</h4>
<p>对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。<br>
我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。</p>
<p>品优购网：</p>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;品优购JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt;
</code></pre>
<p>注意点：</p>
<ol>
<li>描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。</li>
<li>同样遵循简短原则，字符数含空格在内不要超过 120  个汉字。</li>
<li>补充在 title  和 keywords  中未能充分表述的说明.</li>
<li>用英文逗号 关键词1,关键词2</li>
</ol>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt;
</code></pre>
<h4 id="3-keywords-关键字">3. Keywords 关键字</h4>
<p>Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。</p>
<p>品优购网：</p>
<pre><code>&lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,品优购&quot; /&gt;
</code></pre>
<p>小米网：</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt;
</code></pre>
<h4 id="4-总结">4. 总结</h4>
<ol>
<li>我们的网页要做的优秀，符合搜索引擎的要求，才可以让搜索引擎优先显示我们的网页。</li>
</ol>
<p>所以我们的网站要做很多的优化， 其中就有这三大标签。</p>
<ol start="2">
<li>一般情况下，三大标签里面的优化词，都是专门的优化人员写的，我们大概了解一下规范就可以了。</li>
<li>我们的主要任务是，能写出这三大标签， 然后把优化人员给我们的内容，添加到里面。</li>
</ol>
<h3 id="字体图标">字体图标</h3>
<p>​    推荐网站： http://icomoon.io</p>
<ul>
<li>
<p>icomoon字库</p>
</li>
<li>
<p>阿里icon font字库</p>
</li>
</ul>
<p>http://www.iconfont.cn/</p>
<p>在样式里面声明字体： 告诉别人我们自己定义的字体(一定注意字体文件路径的问题)</p>
<pre><code class="language-css">@font-face {
  font-family: 'icomoon';
  src:  url('fonts/icomoon.eot?7kkyc2');
  src:  url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
    url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
    url('fonts/icomoon.woff?7kkyc2') format('woff'),
    url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
  font-weight: normal;
  font-style: normal;
}
</code></pre>
<p>给盒子使用字体</p>
<pre><code class="language-css">span {
		font-family: &quot;icomoon&quot;;
	}
</code></pre>
<h3 id=""></h3>
<h3 id="过渡css3">过渡(CSS3)</h3>
<p>过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>过渡动画：   是从一个状态 渐渐的过渡到另外一个状态</p>
<p>可以让我们页面更好看，更动感十足，虽然 低版本浏览器不支持（ie9以下版本） 但是不会影响页面布局。</p>
<p>我们现在经常和 :hover 一起 搭配使用。</p>
<p>语法格式:</p>
<pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
<td>3</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称。</td>
<td>3</td>
</tr>
<tr>
<td>transition-duration</td>
<td>定义过渡效果花费的时间。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线。默认是 &quot;ease&quot;。</td>
<td>3</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始。默认是 0。</td>
<td>3</td>
</tr>
</tbody>
</table>
<ul>
<li>属性</li>
</ul>
<p>​    属性就是你想要变化的 css 属性，  宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。</p>
<ul>
<li>
<p>花费时间</p>
<p>transition-duration  花费时间  单位是  秒（必须写单位）     s   ms      比如 0.5s    这个s单位必须写      ms 毫秒</p>
</li>
<li>
<p>运动曲线   默认是 ease</p>
</li>
</ul>
<p>运动曲线示意图：</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1498445454760.png" alt="" loading="lazy"></figure>
<p><strong>案例：</strong></p>
<pre><code class="language-css">div {
			width: 200px;
			height: 100px;
			background-color: pink;
			/* transition: 要过渡的属性  花费时间  运动曲线  何时开始; */
			transition: width 0.6s ease 0s, height 0.3s ease-in 1s;
			/* transtion 过渡的意思  这句话写到div里面而不是 hover里面 */
  
			
}
div:hover {  /* 鼠标经过盒子，我们的宽度变为400 */

			width: 600px;
			height: 300px
}

transition: all 0.6s;  /* 所有属性都变化用all 就可以了  后面俩个属性可以省略 */
</code></pre>
<p>transition: all 0.5s;</p>
<h3 id="获得焦点元素">获得焦点元素</h3>
<p>:focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素</p>
<p>:hover</p>
<p>语法：</p>
<pre><code class="language-css">.total input {
  border: 1px solid #ccc;
  height: 30px;
  width: 40px;
  transition: all .5s;
}
/*这个input 获得了焦点*/
.total input:focus {
  width: 80px;
  border: 1px solid skyblue;
}
</code></pre>
<p>border: 1px solid #ccc;<br>
height: 30px;<br>
width: 40px;<br>
transition: all .5s;<br>
}<br>
/<em>这个input 获得了焦点</em>/<br>
.total input:focus {<br>
width: 80px;<br>
border: 1px solid skyblue;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[H5,C3]]></title>
        <id>https://xmweijh.github.io/post/h5c3/</id>
        <link href="https://xmweijh.github.io/post/h5c3/">
        </link>
        <updated>2021-02-07T11:38:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html5css3">HTML5+CSS3</h1>
<p><code>HTML5</code> 拓展了哪些内容</p>
<ul>
<li>语义化标签</li>
<li>本地存储</li>
<li>兼容特性</li>
<li><code>2D</code>、<code>3D</code></li>
<li>动画、过渡</li>
<li><code>CSS3</code> 特性</li>
<li>性能与集成</li>
</ul>
<h3 id="html5-新增标签"><code>HTML5</code> 新增标签</h3>
<ol>
<li>
<p>什么是语义化</p>
</li>
<li>
<p>新增了那些语义化标签</p>
<ul>
<li><code>header</code>   ---  头部标签</li>
<li><code>nav</code>        ---  导航标签</li>
<li><code>article</code> ---   内容标签</li>
<li><code>section</code> ---   块级标签</li>
<li><code>aside</code>     ---   侧边栏标签</li>
<li><code>footer</code>   ---   尾部标签</li>
</ul>
</li>
</ol>
<h4 id="多媒体音频标签">多媒体音频标签</h4>
<ol>
<li>
<p>多媒体标签有两个，分别是</p>
<ul>
<li>音频  -- <code>audio</code></li>
<li>视频  -- <code>video</code></li>
</ul>
</li>
<li>
<p><code>audio</code> 标签说明</p>
<ul>
<li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li>
<li>但是：播放格式是有限的</li>
</ul>
</li>
<li>
<p>audio 支持的音频格式</p>
<ul>
<li>audio 目前支持三种格式</li>
</ul>
</li>
</ol>
<p><strong>audio 的参数</strong></p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5Caudiocanshu.png" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;
  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;

  &lt;!-- 
    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件
   --&gt;
  &lt;audio controls&gt;
    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
  &lt;/audio&gt;
&lt;/body&gt;
</code></pre>
<h4 id="多媒体视频标签">多媒体视频标签</h4>
<p>语法格式</p>
<pre><code class="language-html">&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;
</code></pre>
<p>video 参数</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5Cvideocanshu.png" alt="" loading="lazy"></figure>
<p>video 代码演示</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;

  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;
  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;
    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;
    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;
  &lt;/video&gt;
&lt;/body&gt;
</code></pre>
<p>多媒体标签总结</p>
<ul>
<li>音频标签与视频标签使用基本一致</li>
<li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li>
<li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li>
<li>谷歌浏览器中视频添加 muted 标签可以自己播放</li>
<li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li>
</ul>
<h4 id="新增-input-标签">新增 input 标签</h4>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5Ch5input.png" alt="" loading="lazy"></figure>
<h4 id="新增表单属性">新增表单属性</h4>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5Cnewinput.png" alt="" loading="lazy"></figure>
<h3 id="css3-属性选择器"><code>CSS3</code> 属性选择器</h3>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5Cattrcanshu.png" alt="" loading="lazy"></figure>
<p>属性选择器代码演示</p>
<pre><code class="language-css">button {
  cursor: pointer;
}
button[disabled] {
  cursor: default
}
</code></pre>
<pre><code class="language-css">input[type=search] {
  color: skyblue;
}

span[class^=black] {
  color: lightgreen;
}

span[class$=black] {
  color: lightsalmon;
}

span[class*=black] {
  color: lightseagreen;
}
</code></pre>
<h4 id="结构伪类选择器">结构伪类选择器</h4>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5Cjiegouweilei.png" alt="" loading="lazy"></figure>
<pre><code class="language-css">ul li:first-child {
  background-color: lightseagreen;
}

ul li:last-child {
  background-color: lightcoral;
}

ul li:nth-child(3) {
  background-color: aqua;
}
</code></pre>
<p>nth-child 详解</p>
<ul>
<li>
<p>注意：本质上就是选中第几个子元素</p>
</li>
<li>
<p>n 可以是数字、关键字、公式</p>
</li>
<li>
<p>n 如果是数字，就是选中第几个</p>
</li>
<li>
<p>常见的关键字有 <code>even</code> 偶数、<code>odd</code> 奇数</p>
</li>
<li>
<p>常见的公式如下(如果 n 是公式，则从 0 开始计算)</p>
</li>
<li>
<p>但是第 0 个元素或者超出了元素的个数会被忽略</p>
</li>
<li>
<p><code>nth-child</code>  选择父元素里面的第几个子元素，不管是第几个类型</p>
</li>
<li>
<p><code>nt-of-type</code>  选择指定类型的元素</p>
</li>
</ul>
<h4 id="伪元素选择器">伪元素选择器</h4>
<p>伪类选择器注意事项</p>
<ul>
<li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li>
<li><code>before</code> 在内容前面，after 在内容后面</li>
<li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li>
<li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li>
<li>伪元素和标签选择器一样，权重为 1</li>
</ul>
<pre><code class="language-css">&lt;style&gt;
    div {
      width: 100px;
      height: 100px;
      border: 1px solid lightcoral;
    }

    div::after,
    div::before {
      width: 20px;
      height: 50px;
      text-align: center;
      display: inline-block;
    }
    div::after {
      content: '德';
      background-color: lightskyblue;
    }

    div::before {
      content: '道';
      background-color: mediumaquamarine;
    }
  &lt;/style&gt;
</code></pre>
<h4 id="2d-转换之-translate"><code>2D</code> 转换之 <code>translate</code></h4>
<p>2D转换</p>
<ul>
<li>
<p><code>2D</code> 转换是改变标签在二维平面上的位置和形状</p>
</li>
<li>
<p>移动： <code>translate</code></p>
</li>
<li>
<p>旋转： <code>rotate</code></p>
</li>
<li>
<p>缩放： <code>scale</code></p>
</li>
</ul>
<p>translate语法</p>
<ul>
<li>x 就是 x 轴上水平移动</li>
<li>y 就是 y 轴上水平移动</li>
</ul>
<pre><code class="language-css">transform: translate(x, y)
transform: translateX(n)
transfrom: translateY(n)
</code></pre>
<p>重点知识点</p>
<ul>
<li><code>2D</code> 的移动主要是指 水平、垂直方向上的移动</li>
<li><code>translate</code> 最大的优点就是不影响其他元素的位置</li>
<li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li>
<li>行内标签没有效果</li>
</ul>
<p>代码演示</p>
<pre><code class="language-css">div {
  background-color: lightseagreen;
  width: 200px;
  height: 100px;
  /* 平移 */
  /* 水平垂直移动 100px */
  /* transform: translate(100px, 100px); */

  /* 水平移动 100px */
  /* transform: translate(100px, 0) */

  /* 垂直移动 100px */
  /* transform: translate(0, 100px) */

  /* 水平移动 100px */
  /* transform: translateX(100px); */

  /* 垂直移动 100px */
  transform: translateY(100px)
}
</code></pre>
<p>让一个盒子水平垂直居中</p>
<pre><code>p {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            background-color: purple;
            /* margin-top: -100px;
            margin-left: -100px; */
            /* translate(-50%, -50%)  盒子往上走自己高度的一半   */
            transform: translate(-50%, -50%);
        }
        
        span {
            /* translate 对于行内元素是无效的 */
            transform: translate(300px, 300px);
        }
</code></pre>
<p>2D 转换 rotate</p>
<p>rotate 旋转</p>
<p>2D旋转指的是让元素在二维平面内顺时针或者逆时针旋转rotate</p>
<p>语法</p>
<pre><code class="language-css">/* 单位是：deg */
transform: rotate(度数) 
</code></pre>
<p>重点知识点</p>
<ul>
<li><code>rotate</code> 里面跟度数，单位是 <code>deg</code></li>
<li>角度为正时，顺时针，角度为负时，逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
<p>代码演示</p>
<pre><code class="language-css">img:hover {
  transform: rotate(360deg)
}
</code></pre>
<h6 id="rotate">rotate</h6>
<blockquote>
<p>2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</p>
</blockquote>
<p>使用步骤：</p>
<ol>
<li>给元素添加转换属性 <code>transform</code></li>
<li>属性值为 <code>rotate(角度)</code>  如 <code>transform:rotate(30deg)</code>  顺时针方向旋转<strong>30度</strong></li>
</ol>
<pre><code class="language-css">div{
      transform: rotate(0deg);
}
</code></pre>
<h6 id="三角">三角</h6>
<pre><code class="language-css">div::after {
            content: &quot;&quot;;
            position: absolute;
            top: 8px;
            right: 15px;
            width: 10px;
            height: 10px;
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            transform: rotate(45deg);
            transition: all 0.2s;
        }
        /* 鼠标经过div  里面的三角旋转 */
        
        div:hover::after {
            transform: rotate(225deg);
        }
</code></pre>
<h6 id="设置元素旋转中心点transform-origin">设置元素旋转中心点(transform-origin)</h6>
<ol>
<li>
<p><code>transform-origin</code> 基础语法</p>
<pre><code class="language-css">transform-origin: x y;
</code></pre>
</li>
<li>
<p>重要知识点</p>
<ul>
<li>注意后面的参数 x 和 y 用空格隔开</li>
<li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code></li>
<li>还可以给 x y 设置像素或者方位名词(<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>)</li>
</ul>
</li>
</ol>
<h6 id="旋转中心案例">旋转中心案例</h6>
<ul>
<li>代码演示</li>
</ul>
<h6 id="2d-转换之-scale"><code>2D</code> 转换之 <code>scale</code></h6>
<ol>
<li>
<p><code>scale</code> 的作用</p>
<ul>
<li>用来控制元素的放大与缩小</li>
</ul>
</li>
<li>
<p>语法</p>
<pre><code class="language-css">transform: scale(x, y)
</code></pre>
</li>
<li>
<p>知识要点</p>
<ul>
<li>注意，x 与 y 之间使用逗号进行分隔</li>
<li><code>transform: scale(1, 1)</code>: 宽高都放大一倍，相当于没有放大</li>
<li><code>transform: scale(2, 2)</code>: 宽和高都放大了二倍</li>
<li><code>transform: scale(2)</code>: 如果只写了一个参数，第二个参数就和第一个参数一致</li>
<li><code>transform:scale(0.5, 0.5)</code>: 缩小</li>
<li><code>scale</code> 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">   div:hover {
	   /* 注意，数字是倍数的含义，所以不需要加单位 */
	   /* transform: scale(2, 2) */
   
	   /* 实现等比缩放，同时修改宽与高 */
	   /* transform: scale(2) */
   
	   /* 小于 1 就等于缩放*/
	   transform: scale(0.5, 0.5)
   }
</code></pre>
</li>
</ol>
<h6 id="2d-转换综合写法以及顺序问题"><code>2D</code> 转换综合写法以及顺序问题</h6>
<ol>
<li>
<p>知识要点</p>
<ul>
<li>同时使用多个转换，其格式为 <code>transform: translate() rotate() scale()</code></li>
<li>顺序会影响到转换的效果(先旋转会改变坐标轴方向)</li>
<li>但我们同时有位置或者其他属性的时候，要将位移放到最前面</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div:hover {
  transform: translate(200px, 0) rotate(360deg) scale(1.2)
}
</code></pre>
</li>
</ol>
<h6 id="动画animation">动画(animation)</h6>
<ol>
<li>
<p>什么是动画</p>
<ul>
<li>动画是 <code>CSS3</code> 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果</li>
</ul>
</li>
<li>
<p>动画的基本使用</p>
<ul>
<li>先定义动画</li>
<li>在调用定义好的动画</li>
</ul>
</li>
<li>
<p>语法格式(定义动画)</p>
<pre><code class="language-css">@keyframes 动画名称 {
    0% {
        width: 100px;
    }
    100% {
        width: 200px
    }
}
</code></pre>
</li>
<li>
<p>语法格式(使用动画)</p>
<pre><code>div {
	/* 调用动画 */
    animation-name: 动画名称;
 	/* 持续时间 */
 	animation-duration: 持续时间；
}
</code></pre>
</li>
<li>
<p>动画序列</p>
<ul>
<li>0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</li>
<li>在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</li>
<li>用百分比来规定变化发生的时间，或用 <code>from</code> 和 <code>to</code>，等同于 0% 和 100%</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">&lt;style&gt;
    div {
      width: 100px;
      height: 100px;
      background-color: aquamarine;
      animation-name: move;
      animation-duration: 0.5s;
    }

    @keyframes move{
      0% {
        transform: translate(0px)
      }
      100% {
        transform: translate(500px, 0)
      }
    }
  &lt;/style&gt;
</code></pre>
</li>
</ol>
<h6 id="动画常见属性">动画常见属性</h6>
<ol>
<li>
<p>常见的属性</p>
<img src="E:\APTX-4869\md\animationcanshu.png">
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  width: 100px;
  height: 100px;
  background-color: aquamarine;
  /* 动画名称 */
  animation-name: move;
  /* 动画花费时长 */
  animation-duration: 2s;
  /* 动画速度曲线 */
  animation-timing-function: ease-in-out;
  /* 动画等待多长时间执行 */
  animation-delay: 2s;
  /* 规定动画播放次数 infinite: 无限循环 */
  animation-iteration-count: infinite;
  /* 是否逆行播放 */
  animation-direction: alternate;
  /* 动画结束之后的状态 */
  animation-fill-mode: forwards;
}

div:hover {
  /* 规定动画是否暂停或者播放 */
  animation-play-state: paused;
}
</code></pre>
</li>
</ol>
<h6 id="动画简写方式">动画简写方式</h6>
<ol>
<li>
<p>动画简写方式</p>
<pre><code class="language-css">/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */
animation: name duration timing-function delay iteration-count direction fill-mode
</code></pre>
</li>
<li>
<p>知识要点</p>
<ul>
<li>简写属性里面不包含 <code>animation-paly-state</code></li>
<li>暂停动画 <code>animation-paly-state: paused</code>; 经常和鼠标经过等其他配合使用</li>
<li>要想动画走回来，而不是直接调回来：<code>animation-direction: alternate</code></li>
<li>盒子动画结束后，停在结束位置：<code>animation-fill-mode: forwards</code></li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">animation: move 2s linear 1s infinite alternate forwards;
</code></pre>
</li>
</ol>
<h6 id="速度曲线细节">速度曲线细节</h6>
<ol>
<li>速度曲线细节
<ul>
<li><code>animation-timing-function</code>: 规定动画的速度曲线，默认是<code>ease</code></li>
</ul>
</li>
</ol>
<img src="E:\APTX-4869\md\steps.png">
<ol start="2">
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  width: 0px;
  height: 50px;
  line-height: 50px;
  white-space: nowrap;
  overflow: hidden;
  background-color: aquamarine;
  animation: move 4s steps(24) forwards;
}

@keyframes move {
  0% {
    width: 0px;
  }

  100% {
    width: 480px;
  }
}
</code></pre>
</li>
</ol>
<h6 id="奔跑的熊大">奔跑的熊大</h6>
<ol>
<li>代码演示</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body {
            background-color: #ccc;
        }      
        div {
            position: absolute;
            width: 200px;
            height: 100px;
            background: url(media/bear.png) no-repeat;
            /* 我们元素可以添加多个动画， 用逗号分隔 */
            animation: bear .4s steps(8) infinite, move 3s forwards;
        }
        
        @keyframes bear {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: -1600px 0;
            }
        }
        
        @keyframes move {
            0% {
                left: 0;
            }
            100% {
                left: 50%;
                /* margin-left: -100px; */
                transform: translateX(-50%);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>​</p>
<h6 id="3d-转换"><code>3D</code> 转换</h6>
<ol>
<li>
<p><code>3D</code> 转换知识要点</p>
<ul>
<li><code>3D</code> 位移：<code>translate3d(x, y, z)</code></li>
<li><code>3D</code> 旋转：<code>rotate3d(x, y, z)</code></li>
<li>透视：<code>perspctive</code></li>
<li><code>3D</code>呈现 <code>transfrom-style</code></li>
</ul>
</li>
<li>
<p><code>3D</code> 移动 <code>translate3d</code></p>
<ul>
<li><code>3D</code> 移动就是在 <code>2D</code> 移动的基础上多加了一个可以移动的方向，就是 z 轴方向</li>
<li><code>transform: translateX(100px)</code>：仅仅是在 x 轴上移动</li>
<li><code>transform: translateY(100px)</code>：仅仅是在 y 轴上移动</li>
<li><code>transform: translateZ(100px)</code>：仅仅是在 z 轴上移动</li>
<li><code>transform: translate3d(x, y, z)</code>：其中x、y、z 分别指要移动的轴的方向的距离</li>
<li><strong>注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充</strong></li>
</ul>
</li>
<li>
<p>语法</p>
<pre><code class="language-css"> transform: translate3d(x, y, z)
</code></pre>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">transform: translate3d(100px, 100px, 100px)
/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */
transform: translate3d(100px, 100px, 0)
</code></pre>
</li>
</ol>
<h6 id="透视-perspective">透视 <code>perspective</code></h6>
<ol>
<li>
<p>知识点讲解</p>
<ul>
<li>如果想要网页产生 <code>3D</code> 效果需要透视(理解成 <code>3D</code> 物体投影的 <code>2D</code> 平面上)</li>
<li>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</li>
<li>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li>
<li>透视的单位是像素</li>
</ul>
</li>
<li>
<p>知识要点</p>
<ul>
<li>
<p><strong>透视需要写在被视察元素的父盒子上面</strong></p>
</li>
<li>
<p>注意下方图片</p>
<ul>
<li>
<p>d：就是视距，视距就是指人的眼睛到屏幕的距离</p>
</li>
<li>
<p>z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</p>
<img src="E:\APTX-4869\md\perspective.png">
</li>
</ul>
</li>
</ul>
<p>​</p>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">body {
  perspective: 1000px;
}
</code></pre>
</li>
</ol>
<h6 id="translatez"><code>translateZ</code></h6>
<ol>
<li><code>translateZ</code> 与 <code>perspecitve</code> 的区别
<ul>
<li><code>perspecitve</code> 给父级进行设置，<code>translateZ</code> 给 子元素进行设置不同的大小</li>
</ul>
</li>
</ol>
<h6 id="3d-旋转rotatex"><code>3D</code> 旋转<code>rotateX</code></h6>
<blockquote>
<p>3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</p>
</blockquote>
<ol>
<li>
<p>语法</p>
<ul>
<li><code>transform: rotateX(45deg)</code> -- 沿着 x 轴正方向旋转 45 度</li>
<li><code>transform: rotateY(45deg)</code> -- 沿着 y 轴正方向旋转 45 度</li>
<li><code>transform: rotateZ(45deg)</code> -- 沿着 z 轴正方向旋转 45 度</li>
<li><code>transform: rotate3d(x, y, z, 45deg)</code> -- 沿着自定义轴旋转 45 deg 为角度</li>
</ul>
</li>
<li>
<p>代码案例</p>
<pre><code class="language-css">div {
  perspective: 300px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateX(-45deg)
}
</code></pre>
</li>
</ol>
<p>​</p>
<h6 id="3d-旋转-rotatey"><code>3D</code> 旋转 <code>rotateY</code></h6>
<ol>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateY(180deg)
}
</code></pre>
</li>
</ol>
<h6 id="3d-旋转-rotatez"><code>3D</code> 旋转 <code>rotateZ</code></h6>
<ol>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateZ(180deg)
}
</code></pre>
</li>
<li>
<p><code>rotate3d</code></p>
<ul>
<li><code>transform: rotate3d(x, y, z, deg)</code> -- 沿着自定义轴旋转 deg 为角度</li>
<li>x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度
<ul>
<li><code>transform: rotate3d(1, 1, 0, 180deg)</code> -- 沿着对角线旋转 45deg</li>
<li><code>transform: rotate3d(1, 0, 0, 180deg)</code> -- 沿着 x 轴旋转 45deg</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotate3d(1, 1, 0, 180deg)
}
</code></pre>
<h6 id="3d-呈现-transform-style"><code>3D</code> 呈现 <code>transform-style</code></h6>
<ol>
<li>
<p><code>transform-style</code></p>
<ul>
<li>
<p>☆☆☆☆☆</p>
</li>
<li>
<p>控制子元素是否开启三维立体环境</p>
</li>
<li>
<p><code>transform-style: flat</code>  代表子元素不开启 <code>3D</code> 立体空间，默认的</p>
</li>
<li>
<p><code>transform-style: preserve-3d</code> 子元素开启立体空间</p>
</li>
<li>
<p>代码写给父级，但是影响的是子盒子</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="移动web">移动web</h3>
<h4 id="meta标签">meta标签</h4>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C4.png" alt="" loading="lazy"></figure>
<h4 id="背景缩放background-size">背景缩放background-size</h4>
<p>background-size 属性规定背景图像的尺寸</p>
<pre><code>background-size: 背景图片宽度 背景图片高度;
</code></pre>
<p>单位： 长度|百分比|cover|contain;</p>
<p>cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</p>
<p>contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</p>
<h4 id="移动端大量使用-css3盒子模型box-sizin">移动端大量使用 CSS3盒子模型box-sizin</h4>
<p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</p>
<p>CSS3盒子模型：     盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</p>
<p>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</p>
<pre><code>/*CSS3盒子模型*/
box-sizing: border-box;
/*传统盒子模型*/
box-sizing: content-box;

</code></pre>
<p>移动端可以全部CSS3 盒子模型</p>
<p>PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</p>
<h4 id="移动端特殊样式">移动端特殊样式</h4>
<pre><code>    /*CSS3盒子模型*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮我们需要清除清除  设置为transparent 完成透明*/
    -webkit-tap-highlight-color: transparent;
    /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
    -webkit-appearance: none;
    /*禁用长按页面时的弹出菜单*/
    img,a { -webkit-touch-callout: none; }

</code></pre>
<h4 id="移动端常见布局">移动端常见布局</h4>
<p>移动端单独制作</p>
<ul>
<li>流式布局（百分比布局）</li>
<li>flex 弹性布局（强烈推荐）</li>
<li>less+rem+媒体查询布局</li>
<li>混合布局</li>
</ul>
<p>响应式</p>
<ul>
<li>媒体查询</li>
<li>bootstarp</li>
</ul>
<p>流式布局：</p>
<p>流式布局，就是百分比布局，也称非固定像素布局。</p>
<p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p>
<p>流式布局方式是移动web开发使用的比较常见的布局方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++记录]]></title>
        <id>https://xmweijh.github.io/post/cji-lu/</id>
        <link href="https://xmweijh.github.io/post/cji-lu/">
        </link>
        <updated>2021-02-07T11:36:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c">C++</h1>
<p>c++语言在c语言的基础上添加了<strong>面向对象编程</strong>和<strong>泛型编程</strong>的支持。c++继承了c语言高效，简洁，快速和可移植的传统。</p>
<h3 id="作用域运算符">::作用域运算符</h3>
<p>​         在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p>
<p>​     ::代表作用域 如果前面什么都不添加 代表全局作用域</p>
<p>namespace命名空间</p>
<h3 id="c命名空间namespace">C++命名空间(namespace)</h3>
<p>命名空间用途：解决名称冲突</p>
<p>​       可以存放 ： 变量、函数、结构体、类…</p>
<p>​	   命名空间必须要声明在全局作用域</p>
<pre><code>命名空间可以嵌套命名空

命名空间是开放的，可以随时将新成员添加到命名空间下
</code></pre>
<p>​       命名空间可以匿名的</p>
<pre><code>命名空间可以起别名
</code></pre>
<p>using声明</p>
<p>using KingGlory::sunwukongId；</p>
<p>当using声明与 就近原则同时出现，出错，尽量避免</p>
<p>using编译指令</p>
<p>using namespace KingGlory;</p>
<p>当using编译指令 与 就近原则同时出现，优先使用就近</p>
<p>当using编译指令有多个，需要加作用域 区分</p>
<h3 id="c对c语言增强以及扩展">C++对C语言增强以及扩展</h3>
<p><strong>全局变量检测增强</strong></p>
<p>int a ;</p>
<p>int a = 10; C下可以，C++重定义</p>
<p><strong>函数检测增强</strong></p>
<p>函数的返回值</p>
<p>形参类型</p>
<p>函数调用参数个数</p>
<p><strong>类型转换检测增强</strong></p>
<p>char * p = (char *)malloc(64) C++下必须等号左右一致类型</p>
<p><strong>struct 增强</strong></p>
<p>C++可以在结构体中放函数</p>
<p>创建结构体变量  可以简化关键字struct</p>
<p><strong>bool数据类型扩展</strong></p>
<p>C++才有bool类型</p>
<p>代表真 --- 1 true 假 ---- 0 false</p>
<p>sizeof = 1</p>
<p><strong>三目运算符增强</strong></p>
<p>C语言下返回的是值</p>
<p>C++语言下返回的是变量</p>
<p>a &gt; b ? a : b = 100;            结果b变为100  执行的是b=100这个式子 若是小于  a，b都不变（不要想成(a &gt; b ? a : b) = 100;   b=100是个整体式子 前面条件满足才执行这个赋值语句）</p>
<p><strong>const增强</strong></p>
<p>C语言下</p>
<p>全局const  直接修改 失败 间接修改 语法通过，运行失败</p>
<p>局部 const 直接修改 失败 间接修改 成功</p>
<p>C++语言下</p>
<p>全局 const 和C结论一样</p>
<p>局部 const 直接修改失败  间接修改 失败</p>
<p>C++const可以称为常量</p>
<p>const 链接属性</p>
<p>C语言下const修饰的全局变量默认是外部链接属性</p>
<p>C++下const修饰的全局变量默认是内部链接属性，可以加extern 提高作用域</p>
<p>const分配内存情况</p>
<p>对const变量 取地址 ，会分配临时内存</p>
<p>使用普通变量 初始化 const变量</p>
<p>对于自定义数据类型</p>
<p>尽量用const代替define</p>
<p>define出的宏常量，没有数据类型、不重视作用域</p>
<h3 id="引用"><strong>引用</strong></h3>
<p>目的：起别名</p>
<p>语法： 类型（与原名类型必须一致）  &amp;别名 = 原名</p>
<p>引用必须要初始化</p>
<p>引用一旦初始化后，就不可以引向其他变量</p>
<p>建立对数组引用</p>
<p>直接建立引用</p>
<p>int arr[10];</p>
<p>int(&amp;pArr)[10] = arr;</p>
<p>先定义出数组类型，再通过类型 定义引用</p>
<p>typedef int(ARRAY_TYPE)[10];</p>
<p>ARRAY_TYPE &amp; pArr2 = arr;</p>
<p><strong>参数的传递方式</strong></p>
<p>值传递</p>
<p>地址传递</p>
<p>引用传递</p>
<p>注意事项</p>
<p>引用必须引一块合法内存空间</p>
<p>不要返回局部变量的引用</p>
<p>当函数返回值是引用时候，那么函数的调用可以作为左值进行运算</p>
<p>指针的引用</p>
<p>利用引用可以简化指针</p>
<p>可以直接用同级指针的 引用 给同级指针分配空间</p>
<p>常量的引用</p>
<p>const int &amp;ref = 10;</p>
<p>/ 加了const之后， 相当于写成  int temp = 10; const int &amp;ref = temp;</p>
<p>常量引用的使用场景 修饰函数中的形参，防止误操作</p>
<h3 id="设计类-抽象类">设计类 抽象类</h3>
<p>class 类名{</p>
<p>public 公共权限</p>
<p>​	 设置 成员属性</p>
<p>​	设置 成员函数</p>
<p>}</p>
<p>使用类 创建对象 实例化对象</p>
<p>类名 对象名</p>
<p>通过对象 来设置属性 调用成员函数</p>
<p>类和对象 关系</p>
<p>类是对对象的抽象</p>
<p>对象是对类的实例</p>
<h3 id="内联函数-解决宏缺陷问题">内联函数 解决宏缺陷问题</h3>
<p>给编译器一个建议，加上关键字，编译器不一定按照内联处理</p>
<p>不加关键字，也许编译器还偷摸的给你加inline</p>
<p>成员函数 默认加上关键字</p>
<p>函数声明加了关键字，函数实现也要加inline关键字</p>
<p><strong>函数默认参数</strong></p>
<p>参数可以有默认值</p>
<p>如果有一个位置有了默认值，那么从这个位置开始，从左往右都必须有默认值</p>
<p>函数声明和实现 只能有一个有默认值</p>
<p><strong>函数占位参数</strong></p>
<p>void func(int) 占位参数 调用时候必须要提供这个参数</p>
<p>占位参数也可以有默认值</p>
<p>c语言中没有默认参数 和占位参数</p>
<p><strong>函数重载的基本语法</strong></p>
<p>函数名称相同 又在同一个作用域下</p>
<p>函数参数个数不同、类型不同、顺序不同都可以满足重载条件</p>
<p>函数的返回值可以作为函数重载条件吗？ 不可以</p>
<p>当函数重载碰到了函数默认参数 要注意避免二义性</p>
<h3 id="extern-c浅析"><strong>extern C浅析</strong></h3>
<p>解决了C++文件中调用C语言的代码</p>
<p>方法1:+<br>
在C++代码中加入<br>
告诉编译器show函数用C语言方式做链接/ /extern &quot;C&quot; void show() ;<br>
方法2:<br>
在c语言的头文件中加入6行代码<br>
#ifdef__cplusplus       //两个下划线</p>
<p>extern &quot;C&quot; {</p>
<p>#endif<br>
#ifdef  __cplusplus       //两个下划线</p>
<p>｝</p>
<p>#endif</p>
<h3 id="c语言的封装">C++语言的封装</h3>
<p>将属性和行为作为一个整体，来表示生活中具体的事物</p>
<p>有访问权限</p>
<p>class 和struct唯一区别 默认权限不同</p>
<p>class默认是private</p>
<p>struct 默认是public</p>
<p>public 是类内类外都可以访问到</p>
<p>protected 类内可以，类外不可以</p>
<p>private 类内可以，类外不可以</p>
<p>建议将所有成员属性设置为私有</p>
<p>自己提供公共的对外接口来进行 set或者get方法访问</p>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<p>构造函数</p>
<p>//没有返回值 不用写void</p>
<p>//函数名 与 类名相同</p>
<p>//可以有参数 ，可以发生重载</p>
<p>//构造函数 由编译器自动调用一次 无须手动调用</p>
<p>析构函数</p>
<p>//没有返回值  不用写void</p>
<p>函数名 与类名相同 函数名前 加 ~</p>
<p>不可以有参数 ，不可以发生重载</p>
<p>析构函数 也是由编译器自动调用一次，无须手动调用</p>
<p>构造函数的分类和调用</p>
<p>分类</p>
<p>按照参数分类： 有参 无参（默认）</p>
<p>按照类型分类： 普通 拷贝构造 ( const Person &amp; p )</p>
<p>调用</p>
<p>括号法</p>
<p>显示法</p>
<p>隐式法</p>
<p>注意事项</p>
<p>不要用括号法 调用无参构造函数 Person p3(); 编译器认为代码是函数的声明</p>
<p>不要用拷贝构造函数 初始化 匿名对象 Person(p3); 编译器认为 Person p3对象实例化 如果已经有p3 p3就重定义</p>
<p>匿名对象 特点： 当前行执行完后 立即释放</p>
<p>拷贝构造函数的调用时机</p>
<p>用已经创建好的对象来初始化新的对象</p>
<p>值传递的方式 给函数参数传值</p>
<p>以值方式 返回局部对象</p>
<p>构造函数的调用规则</p>
<p>//1、编译器会给一个类 至少添加3个函数  默认构造（空实现）  析构函数（空实现）  拷贝构造（值拷贝）</p>
<p>//2、如果我们自己提供了 有参构造函数，编译器就不会提供默认构造函数，但是依然会提供拷贝构造函数</p>
<p>//3、如果我们自己提供了 拷贝构造函数，编译器就不会提供其他构造函数</p>
<h3 id="深拷贝与浅拷贝的问题以及解决">深拷贝与浅拷贝的问题以及解决</h3>
<p>如果有属性开辟到堆区，利用编译器提供拷贝构造函数会调用浅拷贝带来的析构重复释放堆区内存的问题</p>
<p>利用深拷贝解决浅拷贝问题</p>
<p>自己提供拷贝构造函数，实现深拷贝</p>
<p>初始化列表</p>
<p>可以利用初始化列表语法 对类中属性进行初始化</p>
<p>语法：构造函数名称后 ： 属性(值), 属性（值）...</p>
<p>Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c)</p>
<h3 id="类对象作为类中成员">类对象作为类中成员</h3>
<p>当其他类对象 作为本类成员，先构造其他类对象，再构造自身，析构的顺序和构造相反</p>
<p>explicit关键字</p>
<p>explicit用途： 防止利用隐式类型转换方式来构造对象</p>
<p>new和delete</p>
<p>malloc 和 new 区别</p>
<p>malloc 和 free 属于 库函数   new 和delete属于 运算符</p>
<p>malloc不会调用构造函数  new会调用构造函数</p>
<p>malloc返回void* C++下要强转   new 返回创建的对象的指针</p>
<p>事项 不要用void<em>去接受new出来的对象,利用void</em>无法调用析构函数</p>
<p>利用new创建数组</p>
<p>Person * pPerson = new Person[10];</p>
<p>释放数组时候 需要加[]</p>
<p>delete [] pPerson;</p>
<p>堆区开辟数组，一定会调用默认构造函数</p>
<p>栈上开辟数组，可不可以没有默认构造,可以没有默认构造</p>
<h3 id="静态成员">静态成员</h3>
<p><strong>静态成员变量</strong></p>
<p>所有对象都共享同一份数据</p>
<p>编译阶段就分配内存</p>
<p>类内声明、类外初始化</p>
<p>访问方式有两种：通过对象访问、通过类名访问</p>
<p>静态成员变量也是有访问权限</p>
<p><strong>静态成员函数</strong></p>
<p>所有对象都共享同一份函数</p>
<p>静态成员函数 只可以访问 静态成员变量，不可以访问非静态成员变量</p>
<p>静态成员函数 也是有访问权限的</p>
<p>静态成员函数 有两种访问方式：通过对象 、通过类名</p>
<p>单例模式 – 主席类案例</p>
<p>通过一个类 只能实例化唯一的一个对象</p>
<p>私有化</p>
<p>默认构造</p>
<p>拷贝构造</p>
<p>唯一实例指针</p>
<p>对外提供 getInstance 接口，将指针返回</p>
<p>单例模式 – 打印机案例</p>
<p>和主席类案例一样设计单例模式</p>
<p>提供打印功能并且统计打印次数</p>
<p>C++对象模型初探</p>
<p>类中的成员变量 和 成员函数 是分开存储的</p>
<p>只有非静态成员变量 属于类对象上</p>
<p>空类的sizeof结果 1</p>
<p>this指针</p>
<p>this指针 指向 被调用的成员函数 所属的对象</p>
<p>this指针可以解决名称冲突</p>
<p>this指针 隐式加在每个成员函数中</p>
<p>*this 就是本体</p>
<p>​     p1.personAddPerson(p2).personAddPerson(p2).personAddPerson(p2); //链式编程</p>
<p>空指针访问成员函数</p>
<p>如果成员函数中没有用到this指针，可以用空指针调用成员函数</p>
<p>如果成员函数中用到了this，那么这个this需要加判断，防止代码down掉</p>
<p>常对象和常函数</p>
<p>常函数</p>
<p>成员函数 声明后面加const</p>
<p>void showPerson() <strong>const</strong></p>
<p>const目的是为了修饰成员函数中的this指针，让指针指向的值不可以修改</p>
<p>有些属性比较特殊，依然在常函数或者常对象中可以修改，需要加入关键字 mutable</p>
<p>常对象</p>
<p>const Person p</p>
<p>常对象也不许修改成员属性</p>
<p>常对象只能调用常函数</p>
<p>对于成员函数 ，可不可以 用static 和 const同时修饰 ，不可以</p>
<p>友元</p>
<p>全局函数作为友元函数</p>
<p>利用friend关键字让全局函数 goodGay作为本类好朋友，可以访问私有成员</p>
<p>friend  void goodGay(Building * buliding);</p>
<p>类作为友元类</p>
<p>让goodGay类作为 Building的好朋友，可以访问私有成员</p>
<p>friend class GoodGay;</p>
<p>​    类中的成员函数作为友元函数</p>
<p>​    //让GoodGay类中的 visit成员函数作为友元</p>
<p>friend void GoodGay::visit();</p>
<h3 id="加号运算符重载">加号运算符重载</h3>
<p>对于内置的数据类型，编译器知道如何进行运算</p>
<p>但是对于自定义数据类型，编译器不知道如何运算</p>
<p>利用运算符重载 可以让符号有新的含义</p>
<p>利用加号重载 实现p1 + p2 Person数据类型相加操作</p>
<p>利用成员函数 和 全局函数 都可以实现重载</p>
<p>关键字 operator +</p>
<p>成员本质 p1.operator+(p2)</p>
<p>全局本质 operator+(p1,p2)</p>
<p>简化  p1 + p2</p>
<p>运算符重载 也可以发生函数重载</p>
<p>左移运算符重载</p>
<p>不要滥用运算符重载，除非有需求</p>
<p>不能对内置数据类型进行重载</p>
<p>对于自定义数据类型，不可以直接用 cout &lt;&lt; 输出</p>
<p>需要重载 左移运算符</p>
<p>如果利用成员 函数重载 ，无法实现让cout 在左侧，因此不用成员重载</p>
<p>利用全局函数 实现左移运算符重载</p>
<p><em>ostream</em>&amp; operator&lt;&lt;(<em>ostream</em> &amp;cout, Person &amp; p1)</p>
<p>如果想访问类中私有内存，可以配置友元实现</p>
<h3 id="递增运算符重载">递增运算符重载</h3>
<p>前置递增</p>
<p>MyInter&amp; operator++()</p>
<p>后置递增</p>
<p>MyInter operator++(<strong>int</strong>)</p>
<p>前置++ 效率高于 后置++ 效率 ，因为后置++会调用拷贝构造，创建新的数据</p>
<h3 id="指针运算符重载">指针运算符重载</h3>
<p>智能指针</p>
<p>用途： 托管new出来的对象的释放</p>
<p>设计smartPoint智能指针类，内部维护 Person * ，在析构时候释放堆区new出来的person对象</p>
<p>重载 -&gt;  * 让 sp智能指针用起来向真正的指针</p>
<p>赋值运算符重载</p>
<p>编译器会默认个一个类添加4个函数</p>
<p>默认构造、析构 、 拷贝构造（值拷贝） 、 operator=（值拷贝）</p>
<p>出现 堆区内存重复释放的问题</p>
<p>解决方案：利用深拷贝 重载 =运算符</p>
<p>Person&amp; operator=( const Person &amp;p)</p>
<p>[]运算符重载</p>
<p>int&amp; operator[](int index);</p>
<p>实现访问数组时候利用[] 访问元素</p>
<h3 id="关系运算符重载">关系运算符重载</h3>
<p>对于自定义数据类型，编译器不知道如果进行比较</p>
<p>重载 ==  ！=号</p>
<p>bool operator==( Person &amp; p)</p>
<p>bool operator!=(Person &amp; p)</p>
<h3 id="函数调用运算符重载">函数调用运算符重载</h3>
<p>重载 （）</p>
<p>使用时候很像函数调用，因此称为仿函数</p>
<p>void operator()(<em>string</em> text)</p>
<p>int operator()(int a,int b)</p>
<p>仿函数写法不固定，比较灵活</p>
<p><em>cout</em> &lt;&lt; MyAdd()(1, 1) &lt;&lt; <em>endl</em>; // 匿名函数对象 特点：当前行执行完立即释放</p>
<p><strong>不要重载 &amp;&amp; 和 ||</strong></p>
<p>原因是无法实现短路特性</p>
<p>建议：将&lt;&lt; 和 &gt;&gt;写成全局函数，其他可重载的符号写到成员即可</p>
<p>强化训练-字符串类封装</p>
<p>myString类 实现自定义的字符串类</p>
<h3 id="继承基本语法">继承基本语法</h3>
<p>继承优点：减少重复的代码，提高代码复用性</p>
<p>// 语法： class 子类 ： 继承方式  父类</p>
<p>// News     子类  派生类</p>
<p>// BasePage 父类  基类</p>
<h3 id="继承方式">继承方式</h3>
<p>公共继承</p>
<p>父类中公共权限，子类中变为公共权限</p>
<p>父类中保护权限，子类中变为保护权限</p>
<p>父类中私有权限，子类访问不到</p>
<p>保护继承</p>
<p>父类中公共权限，子类中变为保护权限</p>
<p>父类中保护权限，子类中变为保护权限</p>
<p>父类中私有权限，子类访问不到</p>
<p>私有继承</p>
<p>父类中公共权限，子类中变为私有权限</p>
<p>父类中保护权限，子类中变为私有权限</p>
<p>父类中私有权限，子类访问不到</p>
<p><strong>继承中的对象模型</strong>**</p>
<p>父类中的私有属性，子类是继承下去了，只不过由编译器给隐藏了，访问不到</p>
<p>可以利用开发人员工具查看对象模型</p>
<p>C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts</p>
<p>打开开发人员命令工具</p>
<p>跳转盘符 E:</p>
<p>跳转文件路径 cd到文件路径下</p>
<p>c<strong>l</strong> /d<strong>1</strong> reportSingleClassLayout类名 文件名</p>
<h3 id="继承中的构造和析构">继承中的构造和析构</h3>
<p>先调用父类构造，再调用其他成员构造， 再调用自身构造 ，析构的顺序与构造相反</p>
<p>利用初始化列表语法 显示调用父类中的其他构造函数</p>
<p>父类中 构造、析构、拷贝构造 、operator= 是不会被子类继承下去的</p>
<p>继承中的同名成员处理</p>
<p>​     我们可以利用作用域 访问父类中的同名成员</p>
<p>当子类重新定义了父类中的同名成员函数，子类的成员函数会 隐藏掉父类中所有重载版本的同名成员，可以利用作用域显示指定调用</p>
<p>继承中的同名 静态成员处理</p>
<p>结论和 非静态成员 一致</p>
<p>只不过调用方式有两种</p>
<p>通过对象</p>
<p>通过类名</p>
<p>通过类名的方式 访问 父类作用域下的m_A静态成员变量</p>
<p>Son::Base::m_A</p>
<p>​    多继承基本语法</p>
<p>class 子类 ： 继承方式 父类1 ， 继承方式 父类2</p>
<p>当多继承的两个父类中有同名成员，需要加作用域区分</p>
<p>菱形继承</p>
<p>两个类有公共的父类 和共同的子类 ，发生菱形继承</p>
<p>​    菱形继承导致数据有两份，浪费资源</p>
<p>解决方案：利用虚继承可以解决菱形继承问题</p>
<p>class Sheep : <strong>virtual</strong> public Animal{};</p>
<p>//当发生虚继承后，sheep和tuo类中 继承了一个 vbptr指针  虚基类指针  指向的是一个 虚基类表 vbtable</p>
<p>​    //虚基类表中记录了 偏移量 ，通过偏移量 可以找到唯一的一个m_Age</p>
<p>​    利用地址偏移找到 vbtable中的偏移量 并且访问数据</p>
<p>静态联编动态联编</p>
<p><strong>静态多态和动态多态</strong></p>
<p>静态多态：函数重载，运算符重载</p>
<h3 id="动态多态">动态多态：</h3>
<p>//先有继承关系</p>
<p>//父类中有虚函数，子类重写父类中的虚函数</p>
<p>//父类的指针或引用 指向子类的对象</p>
<p>静态多态在编译阶段绑定地址，地址早绑定，静态联编</p>
<p>动态多次在运行阶段绑定地址，地址晚绑定，动态联编</p>
<h3 id="多态原理">多态原理</h3>
<p>当父类写了虚函数后，类内部结构发生改变，多了一个vfptr</p>
<p>vfptr 虚函数表指针 ---- &gt; vftable 虚函数表</p>
<p>虚函数表内部记录着 虚函数的入口地址</p>
<p>当父类指针或引用指向子类对象，发生多态，调用是时候从虚函数中找函数入口地址</p>
<p>虚函数 关键字 virtual</p>
<p>利用指针的偏移调用 函数</p>
<p>((void(<em>)()) (</em>(int <em>)</em>(int *)animal)) ();</p>
<p>typedef void( __stdcall *FUNPOINT)(int);</p>
<p>(FUNPOINT (<em>((int</em>)<em>(int</em>)animal + 1)))(10);</p>
<p>多态的好处</p>
<p>代码可读性强</p>
<p>组织结构清晰</p>
<p>扩展性强</p>
<p>开闭原则： 对扩展进行开放 对修改进行关闭</p>
<p>纯虚函数和抽象类</p>
<p>语法： virtual int getResult() = 0;</p>
<p>//如果一个类中包含了纯虚函数，那么这个类就无法实例化对象了,这个类通常我们称为 抽象类</p>
<p>//抽象类的子类 必须要重写 父类中的纯虚函数，否则也属于抽象类</p>
<p>虚析构和纯虚析构</p>
<p>虚析构语法：</p>
<p>virtual ~Animal(){}</p>
<p>如果子类中有指向堆区的属性，那么要利用虚析构技术 在delete的时候 调用子类的析构函数</p>
<p>纯虚析构语法：</p>
<p>virtual ~Animal() = 0;</p>
<p>Animal::~Animal(){ .. }</p>
<p>​     //纯虚析构 需要有声明 也需要有实现</p>
<p>​    //如果一个类中 有了 纯虚析构函数，那么这个类也属于抽象类，无法实例化对象了</p>
<p>向上类型转换和向下类型转换</p>
<p>父转子  向下类型转换  不安全</p>
<p>子转父  向上类型转换  安全</p>
<p>如果发生多态，那么转换永远都是安全的</p>
<p>重载、重写、重定义</p>
<p>重载</p>
<p>函数重载</p>
<p>同一个作用域下，函数名称相同，参数个数、顺序、类型不同</p>
<p>重写</p>
<p>子类重写父类中的虚函数，函数返回值、函数名、形参列表完全一致称为重写</p>
<p>重定义</p>
<p>子类重新定义父类中的同名成员函数，隐藏掉父类中同名成员函数，如果想调用加作用域</p>
<h3 id="函数模板">函数模板</h3>
<p><strong>泛型编程 – 模板技术 特点：类型参数化</strong></p>
<p>template&lt; typename T &gt; 告诉编译器后面紧跟着的函数或者类中出现T，不要报错，T是一个通用的数据类型</p>
<p>实现通用两个数进行交换函数</p>
<p>使用</p>
<p>1.自动类型推导  必须要推导出一致的T才可以使用</p>
<p>2.显示指定类型    mySwap<int>(a,b);</p>
<p><strong>函数模板和普通函数的区别以及调用规则</strong></p>
<p>区别</p>
<p>如果使用自动类型推导，是不可以发生隐式类型转换的</p>
<p>普通函数 可以发生隐式类型转换</p>
<p>调用规则</p>
<p>如果函数模板和普通函数都可以调用，那么优先调用普通函数</p>
<p>如果想强制调用函数模板，可以使用空模板参数列表</p>
<p>myPrint&lt;&gt;(a, b);</p>
<p>函数模板也可以发生函数重载</p>
<p>如果函数模板能产生更好的匹配，那么优先使用函数模板</p>
<p><strong>模板的实现机制</strong></p>
<p>编译器并不是把函数模板处理成能够处理任何类型的函数</p>
<p>函数模板通过具体类型产生不同的函数 --- 通过函数模板产生的函数 称为模板函数</p>
<p>编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<p><strong>模板局限性</strong></p>
<p>模板并不是真实的通用，对于自定义数据类型，可以使用具体化技术，实现对自定义数据类型特殊使用</p>
<p>template&lt;&gt;bool myCompare(<strong>Person</strong> &amp;a, <strong>Person</strong> &amp;b)</p>
<h3 id="类模板">类模板</h3>
<p>​    //类模板和函数模板区别：</p>
<p>​     //1、类模板不可以使用自动类型推导，只能用显示指定类型</p>
<p>​        //2、类模板中 可以有默认参数</p>
<p>类模板中成员函数创建时机</p>
<p>类模板中的成员函数 并不是一开始创建的，而是在运行阶段确定出T的数据类型才去创建</p>
<p><strong>类模板做函数参数</strong></p>
<p>1、指定传入类型</p>
<p>void doWork(Person &lt;string, int&gt;&amp;p)</p>
<p>2、参数模板化</p>
<p>template&lt;class T1, class T2&gt;</p>
<p>void doWork2(Person &lt;T1, T2&gt;&amp;p)</p>
<p>3、整个类 模板化</p>
<p>template<class T></p>
<p>void doWork3( T &amp;p)</p>
<p>查看T数据类型</p>
<p>typeid(T).name()</p>
<p>​     <strong>类模板碰到继承的问题以及解决</strong></p>
<p>必须要指定出父类中的T数据类型，才能给子类分配内存</p>
<p>​    template&lt;class T1 ,class T2&gt;</p>
<p>class Son2 :public Base2<T2></p>
<p>类模板中的成员函数类外实现</p>
<p>void Person&lt;T1, T2&gt;::showPerson()</p>
<p><strong>类模板的分文件编写问题以及解决</strong></p>
<p>类模板中的成员函数，不会一开始创建，因此导致分文件编写时连接不到函数的实现，出现无法解析的外部命令错误</p>
<p>解决方式1：</p>
<p>直接包含.cpp文件 （不推荐）</p>
<p>解决方式2：</p>
<p>将类声明和实现写到同一个文件中，将文件的后缀名改为 .hpp 即可</p>
<p><strong>类模板碰到友元的问题以及解决</strong></p>
<p>友元类内实现</p>
<p>friend void printPerson(Person&lt;T1, T2&gt; &amp;p)</p>
<p>友元类外实现</p>
<p>声明：</p>
<p>friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</p>
<p>实现：</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>void printPerson2(Person&lt;T1, T2&gt; &amp;p){ 。。。}</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>class Person;</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>void printPerson2(Person&lt;T1, T2&gt; &amp;p);</p>
<h3 id="类型转换">类型转换</h3>
<p>静态类型转换 static_cast</p>
<p>允许内置数据类型转换</p>
<p>允许父子之间的指针或者引用的转换</p>
<p>语法 static_cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>动态类型转换 dynamic_cast</p>
<p>不允许内置数据类型转换</p>
<p>允许父子之间指针或者引用的转换</p>
<p>父转子 不安全的 转换失败</p>
<p>子转父 安全  转换成功</p>
<p>如果发生多态，总是安全，可以成功</p>
<p>语法 dynamic_cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>常量转换  const_cast</p>
<p>只允许 指针或者引用 之间转换</p>
<p>语法 const _cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>重新解释转换</p>
<p>reinterpret_cast 最不安全一种转换，不建议使用</p>
<h3 id="异常的基本语法">异常的基本语法</h3>
<p>C++异常的处理关键字</p>
<p>try throw catch</p>
<p>可以出现异常的代码 放到 try块</p>
<p>利用throw抛出异常</p>
<p>利用catch捕获异常</p>
<p>catch( 类型) 如果想捕获其他类型 catch(…)</p>
<p>如果捕获到的异常不想处理，而继续向上抛出，利用 throw</p>
<p>异常必须有函数进行处理，如果都不去处理，程序自动调用 terminate函数，中断掉</p>
<p>异常可以是自定义数据类型</p>
<p><strong>栈解旋</strong></p>
<p>从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉，</p>
<p>释放的顺序和创建顺序相反的，这个过程我们称为栈解旋</p>
<p><strong>异常的接口声明</strong></p>
<p>在函数中 如果限定抛出异常的类型，可以用异常的接口声明</p>
<p>语法： void func()throw(int ,double)</p>
<p>throw(空)代表 不允许抛出异常</p>
<p><strong>异常变量的生命周期</strong></p>
<p>//抛出的是 throw MyException(); catch (MyException e) 调用拷贝构造函数 效率低</p>
<p>//抛出的是 throw MyException(); catch (MyException &amp;e) 只调用默认构造函数 效率高 <strong>推荐</strong></p>
<p>//抛出的是 throw &amp;MyException(); catch (MyException *e) 对象会提前释放掉，不能在非法操作</p>
<p>//抛出的是 new MyException();  catch (MyException *e) 只调用默认构造函数 自己要管理释放</p>
<p>异常的多态使用</p>
<p>提供基类异常类</p>
<p>class BaseException</p>
<p>纯虚函数 virtual void printError() = 0;</p>
<p>子类空指针异常 和 越界异常 继承 BaseException</p>
<p>重写virtual void printError()</p>
<p>测试 利用父类引用指向子类对象</p>
<p><strong>系统标准异常</strong></p>
<p>引入头文件 #include <stdexcept></p>
<p>抛出越界异常 throw out_of_range(“…”)</p>
<p>获取错误信息 catch( exception &amp; e )   e.what();</p>
<p><strong>编写自己的异常类</strong></p>
<p>编写myOutofRange 继承 Exception类</p>
<p>重写 virtual const char * what() const</p>
<p>将sting 转为 const char *</p>
<p>.c_str()</p>
<p>​    const char * 可以隐式类型转换为 string 反之不可以</p>
<p>​     测试，利用多态打印出错误提示信息</p>
<h3 id="标准输入流">标准输入流</h3>
<p>cin.get() 获取一个字符</p>
<p>cin.get(两个参数) 获取字符串</p>
<p>利用cin.get获取字符串时候，换行符遗留在缓冲区中</p>
<p>cin.getline() 获取字符串</p>
<p>利用cin.getline获取字符串时候，换行符不会被取走，也不在缓冲区中，而是直接扔掉</p>
<p>cin.ignore() 忽略 默认忽略1个字符， 如果填入参数X，代表忽略X个字符</p>
<p>cin.peek() 偷窥</p>
<p>cin.putback() 放回 放回原位置</p>
<h3 id="标准输出流">标准输出流</h3>
<p>cout.put() //向缓冲区写字符</p>
<p>cout.write() //从buffer中写num个字节到当前输出流中。</p>
<p>通过 流成员函数 格式化输出</p>
<p>int number = 99;</p>
<p>cout.width(20); //指定宽度为20</p>
<p>cout.fill('*'); //填充</p>
<p>cout.setf(ios::left); //左对齐</p>
<p>cout.unsetf(ios::dec); //卸载十进制</p>
<p>cout.setf(ios::hex); //安装十六进制</p>
<p>cout.setf(ios::showbase); //显示基数</p>
<p>cout.unsetf(ios::hex); //卸载十六进制</p>
<p>cout.setf(ios::oct);  //安装八进制</p>
<p>​    cout &lt;&lt; number &lt;&lt; endl;</p>
<p><strong>通过控制符 格式化输出</strong></p>
<p>int number = 99;</p>
<p>cout &lt;&lt; setw(20)   //设置宽度</p>
<p>​    &lt;&lt; setfill('~') //设置填充</p>
<p>&lt;&lt; setiosflags(ios::showbase) //显示基数</p>
<p>&lt;&lt; setiosflags(ios::left) //设置左对齐</p>
<p>&lt;&lt; hex  //显示十六进制</p>
<p>&lt;&lt; number</p>
<p>&lt;&lt; endl;</p>
<p>​	引入头文件 #include&lt; iomanip&gt;</p>
<h3 id="文件读写">文件读写</h3>
<p>头文件 #inlcude &lt; fstream&gt;</p>
<p>写文件</p>
<p>ofstream ofs (文件路径，打开方式 ios::out )</p>
<p>判断文件是否打开成功 ofs.is_open</p>
<p>ofs &lt;&lt; “…”</p>
<p>关闭文件 ofs.close();</p>
<p>读文件</p>
<p>ifstream ifs(文件路径，打开方式 ios::in)</p>
<p>判断文件是否打开成功 ofs.is_open</p>
<p>利用4种方式 对文件进行读取</p>
<p>关闭文件 ifs.close();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言续]]></title>
        <id>https://xmweijh.github.io/post/c-yu-yan-xu/</id>
        <link href="https://xmweijh.github.io/post/c-yu-yan-xu/">
        </link>
        <updated>2021-02-07T11:35:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c语言续">c语言续</h2>
<p>char *p1,p2       p1指针，p2字符         可用  typedef char * PCHAR    或   char *p1 ,  *p2解决</p>
<p>数据类型  编译器指定出的数据类型，为了更好地管理内存</p>
<p><code>sizeof</code>  只是一个操作符类似于+-*/，非函数。对于数据类型，必须用（），但对于变量不用。   其返回值类型为 unsigned int  无符号整型。</p>
<p>当unsigned int 和 int 做运算，编译器会把数据类型都转换为unsigned int</p>
<p>无符号打印%u</p>
<p>sizeof 可以统计数组长度，当数组名作为函数参数时，会退化为指针，指向数组的第一个元素</p>
<p>变量，可以读写的内存对象</p>
<p>data初始化全局变量，静态变量，常量     bss未初始化</p>
<p>栈区          堆区</p>
<p>栈，注意不要返回局部变量的地址（函数结束内存会被释放）</p>
<p>堆区，手动开辟的记得手动回收</p>
<p>如果主调函数中没有给指针分配内存，被调函数用同级指针是修饰不到主调函数中的指针的</p>
<p>static 静态变量 只初始化一次，在编译阶段就分配内存属于内部链接属性，只能在当前文件中使用</p>
<p>const 修饰的局部变量通过间接修改 成功</p>
<p>宏函数一定程度上比普通效率（入栈，出栈）高 ，频繁短小函数可写为宏函数           以空间换时间</p>
<p>调用惯例       出栈放、参数的传入顺序、函数名称的修饰    c和c++ 为cdecl</p>
<p>栈的生成方向 以及 内存存储方式</p>
<p>栈底   高地址      栈顶   低地址  （从高地址到低地址使用）</p>
<p>存储方式     高位字节数据  高地址  低位 低地址  （小端对齐）</p>
<p>空指针   不允许向NULL和非法地址拷贝内存</p>
<p>野指针  未初始化指针 ， malloc后free了，但没将指针置空  ， 指针操作超越作用域</p>
<p>指针的步长</p>
<p>指针变量+1后，跳跃的字节数量</p>
<p>解引用的时候，取得字节数</p>
<p>获取结构体中属性的偏移： offsetof(结构体,属性)   头文件 #include&lt;stddef.h&gt;</p>
<p>字符串是有结束标志 \0</p>
<p>三种方式拷贝字符串：利用[]  利用指针  利用while （*dest++ =  *source++）</p>
<p>char*str 字符串常量不能改变  char str[]可以改</p>
<p>calloc 分配的内存会初始化为0</p>
<p>sscanf  将已知的字符串格式化匹配出有效信息</p>
<p>指针易错点</p>
<p>越界操作  指针叠加会不断改变指针指向  返回局部变量地址  不可以释放野指针</p>
<p>将文件光标置为文件首 fseek( file, 0 ,SEEK_SET)</p>
<p>按位取反 ~</p>
<pre><code> int num =2; 
 printf(&quot;~num = %d\n&quot;,~num);//结果为-3
</code></pre>
<p>2  -&gt;  010    按位取反（符号位也取反） 101  源码      101  补码 （取反+1）  110+1（此时符号位不取反）    111   = -3</p>
<p>两数交换的其他方法</p>
<pre><code>num1 = num1 ^ num2;
num2 = num1 ^ num2;
num1 = num1 ^ num2;

num1 = num1 + num2;
num2 = num1 - num2;
num1 = num1 - num2;
</code></pre>
<p>左移&lt;&lt;  右移&gt;&gt;</p>
<p>一维数组  本质并不是一个指针</p>
<p>​		有两种特殊情况：1.对数组进行sizeof   2.对数组名称取地址 ，获取的指针步长为整个数组的长度</p>
<p>其他情况都是指向数组首元素的地址的指针</p>
<p>数组名  -- 指针常量 ，指针的指向不可以修改  int * const p</p>
<p>访问数组元素的时候下标可以为负数</p>
<p>结构体偏移量 offsetof计算 或 地址相减</p>
<p>cpu按块读取内存，块的大小为2的n次方 有了内存对齐，更好读取</p>
<p>#pragma pack(show) 查看对齐模数， 默认对齐为8 可改为2的n次方</p>
<p>对于自定义数据类型 内存对齐规则如下:</p>
<p>1、从第一个属性开始 偏移为0</p>
<p>2、从第二个属性开始，地址要放在 该类型整数倍 与 对齐模数比 取小的值的 整数倍</p>
<p>3、所有的属性都计算后，整体再做二次对齐 整体需要放在属性中最大类型与 对齐模数比 取小的值的整数倍上。</p>
<p>结构体嵌套结构体时，只需要看子结构体中最大数据类型就可以了</p>
<p>文件结尾 EOF</p>
<p>fseek(文件指针，偏移，起始位置 SEEK_SET SEEK_END SEEK_CUR)</p>
<p>rewind(文件指正) 将文件光标置首</p>
<p>error宏 全局变量 perror 打印宏提示错误信息</p>
<p>数组缺陷，静态空间，一旦分配内存就不可以动态扩展  对属于数组头进行插入和删除效率低</p>
<p>头结点 好处在于头结点永远都是固定的</p>
<p>静态链表  栈区  动态链表 堆区</p>
<p>带头节点链表好处在于头节点永远都是固定的<br>
初始化链表struct LinkNode*pHeader= init_LinkList(u<br>
遍历链表void	foreach_LinkList( struct LinkNode  pHeader )u</p>
<p>函数指针的定义<br>
先定义出函数类型，再通过类型定义出函数指针<br>
typedef void(FUNC_TYPE)();<br>
FUNC_TYPE pEunc = func</p>
<p>先定义出函躞指针类型，再定义函数指针÷<br>
typedef void(*FUNC_TYPE)();'<br>
FUNC_TYPE pFunc- func;</p>
<p>直接定义函数指针变量<br>
void(* pEunc )()= fung;<br>
函数指针和指针函数的区别<br>
函数指针是指向函数的指针<br>
指针函数―丞|数的返回值是一个指针的函数+<br>
函数指针的数组定义↓<br>
void(*pFunc[3])();.</p>
<p>本题要求实现一个函数，判断任一给定整数<code>N</code>是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int IsTheNumber(const int N);

int main()
{
    int n1, n2, i, cnt;

    scanf(&quot;%d %d&quot;, &amp;n1, &amp;n2);
    cnt = 0;
    for (i = n1; i &lt;= n2; i++) {
        if (IsTheNumber(i))
            cnt++;
    }
    printf(&quot;cnt = %d\n&quot;, cnt);
    
    return 0;

}

int IsTheNumber(const int N) {
    int n = N;
    int b;
    int p[10] = { 0 };
    int m = sqrt(n);
    if (m * m == n) {
        while (n) {
            b = n % 10;
            p[b]++;
            n /= 10;
        }
        for (int i = 0;i &lt;= 9;i++) {
            if (p[i] &gt; 1)
                return 1;
        }
    }
    return 0;
}
</code></pre>
<p>声明和定义区别</p>
<p>l 声明变量不需要建立存储空间，如：extern int a;</p>
<p>l 定义变量需要建立存储空间，如：int b;</p>
<p>从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：</p>
<p>l int b 它既是声明，同时又是定义</p>
<p>l 对于 extern b来讲它只是声明不是定义</p>
<p>​         不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型</p>
<p><strong>在计算机系统中，数值一律用补码来存储</strong>，主要原因是：</p>
<p>l 统一了零的编码</p>
<p>l 将符号位和其它位统一处理</p>
<p>l 将减法运算转变为加法运算</p>
<p>l 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃</p>
<p>斯特林(Stirling)公式 求大数阶乘的位数</p>
<pre><code>我们知道整数n的位数的计算方法为：log10(n)+1n!=10^m故n!的位数为 m = log10(n!)+1
</code></pre>
<p><strong>#pragmaonce这个宏有什么作用？</strong></p>
<p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p>
<p>在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。</p>
<p>如果我们要在一个函数内改变一个指针的值，我们就需要将形参定义了二级指针</p>
<p><strong>中缀转后缀算法∶</strong><br>
遍历中缀表达式中的数字和符号∶<br>
**对于数字︰**直接输出.<br>
<strong>对于符号∶</strong><br>
左括号∶进栈<br>
运算符号∶与栈顶符号进行优先级比较若栈顶符号优先级低∶此符号进栈<br>
(默认栈顶若是左括号，左括号优先级最低)&gt;<br>
若栈顶符号优先级不低∶将栈顶符号弹出并输出，之后进栈<br>
右括号∶将栈顶符号弹出并输出，直到匹配左括号,将左括号和右括号同时舍弃<br>
遍历结束∶将栈中的所有符号弹出并输出</p>
<p>计算规则·<br>
遍历后缀表达式中的数字和符号<br>
对于数字∶进栈<br>
对于符号:<br>
从栈中弹出右操作数<br>
从栈中弹出左操作数<br>
根据符号进行运算<br>
将运算结果压入栈中<br>
遍历结束:栈中的唯—数字为计算结果</p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C1337526379_6285.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1337526423_9040.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cc">List Reverse( List L )
{
    List head,next,prev;
    prev = NULL;
    head = L;
    while(head != NULL)
    {
        next = head-&gt;Next;
        head-&gt;Next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML]]></title>
        <id>https://xmweijh.github.io/post/html/</id>
        <link href="https://xmweijh.github.io/post/html/">
        </link>
        <updated>2021-02-07T11:35:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html">HTML</h1>
<h3 id="web-标准构成">Web 标准构成</h3>
<p><strong>构成：</strong> 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p>
<p>VSCode常用快捷键</p>
<p>1） ！+enter : 快速生称html代码框架</p>
<p>2） shift+alt+向下的方向键： 向下复制当前行</p>
<p>3） shift+alt+向上的方向键： 向上复制当前行</p>
<p>4） ctrl+S： 保存</p>
<p>5）shift+alt+F: 格式化代码</p>
<p>6） ctrl+F: 查找和替换</p>
<h3 id="文档类型doctype">文档类型&lt;!DOCTYPE&gt;</h3>
<p><strong>用法：</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt; 
</code></pre>
<p><strong>作用：</strong></p>
<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。
<h3 id="页面语言lang">页面语言lang</h3>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;  指定html 语言种类
</code></pre>
<p>最常见的2个：</p>
<ol>
<li><code>en</code>定义语言为英语</li>
<li><code>zh-CN</code>定义语言为中文</li>
</ol>
<h3 id="字符集">字符集</h3>
<pre><code class="language-html">&lt;meta charset=&quot;UTF-8&quot; /&gt;
</code></pre>
<pre><code>字符集(Character set)是多个字符的集合。

计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。
</code></pre>
<p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p>
<ul>
<li>gb2312 简单中文  包括6763个汉字  GUO BIAO</li>
<li>BIG5   繁体中文 港澳台等用</li>
<li>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</li>
<li>UTF-8则基本包含全世界所有国家需要用到的字符</li>
<li><strong>这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。</strong></li>
</ul>
<h2 id="html常用标签">HTML常用标签</h2>
<h3 id="排版标签">排版标签</h3>
<h4 id="标题标签h-熟记">标题标签h (熟记)</h4>
<p>单词缩写：  head</p>
<p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p>
<p><strong>标题标签语义：</strong>  作为标题使用，并且依据重要性递减</p>
<p>其基本语法格式如下：</p>
<pre><code class="language-html">&lt;h1&gt;   标题文本   &lt;/h1&gt;
&lt;h2&gt;   标题文本   &lt;/h2&gt;
&lt;h3&gt;   标题文本   &lt;/h3&gt;
&lt;h4&gt;   标题文本   &lt;/h4&gt;
&lt;h5&gt;   标题文本   &lt;/h5&gt;
&lt;h6&gt;   标题文本   &lt;/h6&gt;
</code></pre>
<ul>
<li>加了标题的文字会变的加粗，字号也会依次变大</li>
<li>一行是只能放一个标题的</li>
</ul>
<h4 id="段落标签p-熟记">段落标签p ( 熟记)</h4>
<p>单词缩写：  paragraph</p>
<p><strong>作用语义：</strong></p>
<p>可以把 HTML 文档分割为若干段落</p>
<p>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<pre><code class="language-html">&lt;p&gt;  文本内容  &lt;/p&gt;
</code></pre>
<p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<h4 id="水平线标签hr认识">水平线标签hr(认识)</h4>
<p>单词缩写：  horizontal</p>
<p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，<hr />就是创建横跨网页水平线的标签。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;hr /&gt;是单标签
</code></pre>
<p>在网页中显示默认样式的水平线。</p>
<h4 id="换行标签br-熟记">换行标签br (熟记)</h4>
<p>单词缩写：  break</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p>
<pre><code class="language-html">&lt;br /&gt;
</code></pre>
<p>这时如果还像在word中直接敲回车键换行就不起作用了。</p>
<h4 id="div-和-span标签重点">div 和  span标签(重点)</h4>
<p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p>
<p>span   跨度，跨距；范围</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;div&gt; 这是头部 &lt;/div&gt;    &lt;span&gt;今日价格&lt;/span&gt;
</code></pre>
<p>他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们主要记住使用方法和特点就好了</p>
<ul>
<li>div标签  用来布局的，但是现在一行只能放一个div</li>
<li>span标签  用来布局的，一行上可以放好多个span</li>
</ul>
<h4 id="排版标签总结">排版标签总结</h4>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><hx></hx></td>
<td style="text-align:left">标题标签</td>
<td style="text-align:left">作为标题使用，并且依据重要性递减</td>
</tr>
<tr>
<td><p></p></td>
<td style="text-align:left">段落标签</td>
<td style="text-align:left">可以把 HTML 文档分割为若干段落</td>
</tr>
<tr>
<td><hr /></td>
<td style="text-align:left">水平线标签</td>
<td style="text-align:left">没啥可说的，就是一条线</td>
</tr>
<tr>
<td><br /></td>
<td style="text-align:left">换行标签</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><div></div></td>
<td style="text-align:left">div标签</td>
<td style="text-align:left">用来布局的，但是现在一行只能放一个div</td>
</tr>
<tr>
<td><span></span></td>
<td style="text-align:left">span标签</td>
<td style="text-align:left">用来布局的，一行上可以放好多个span</td>
</tr>
</tbody>
</table>
<h3 id="文本格式化标签熟记">文本格式化标签(熟记)</h3>
<p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p>
<img src="D:/BaiduNetdiskDownload/web/【27】源码+课件+软件/01-03 前端开发基础/01-HTML资料/01.HTML-Day01/笔记/media/tab.png" />
<p><strong>区别：</strong></p>
<p>b  只是加粗          strong  除了可以加粗还有 强调的意思，  语义更强烈。</p>
<h3 id="标签属性">标签属性</h3>
<p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;
</code></pre>
<h3 id="图像标签img-重点">图像标签img (重点)</h3>
<p>单词缩写：   image</p>
<p>要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<img />以及和他相关的属性。</p>
<p>语法如下：</p>
<pre><code class="language-html">&lt;img src=&quot;图像URL&quot; /&gt;
</code></pre>
<p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p>
<img src="D:/BaiduNetdiskDownload/web/【27】源码+课件+软件/01-03 前端开发基础/01-HTML资料/01.HTML-Day01/笔记/media/img.png" />
<p>border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了</p>
<p>**注意: **</p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>采取  键值对 的格式   key=&quot;value&quot;  的格式</li>
</ol>
<p>比如:</p>
<pre><code class="language-html">	正常的&lt;br /&gt;
    &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;&lt;br /&gt;
     带有边框的&lt;br /&gt;
    &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; /&gt;&lt;br /&gt;
	有提示文本的&lt;br /&gt;
	&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&gt;&lt;br /&gt;
	有替换文本的&lt;br /&gt;
	&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;图片不存在&quot; /&gt;
</code></pre>
<h3 id="链接标签重点">链接标签(重点)</h3>
<p>单词缩写：  anchor 的缩写</p>
<p>在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>href</td>
<td style="text-align:left">用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td>target</td>
<td style="text-align:left">用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，__blank为在新窗口中打开方式。</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ol>
<li>外部链接 需要添加 http:// www.baidu.com</li>
<li>内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 </a ></li>
<li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。</li>
<li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</li>
</ol>
<h3 id="注释标签">注释标签</h3>
<p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p>
<p>简单解释：</p>
<p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p>
<p>语法格式：</p>
<pre><code class="language-html">    &lt;!-- 注释语句 --&gt;     快捷键是：    ctrl + /       或者 ctrl +shift + / 
</code></pre>
<h2 id="路径重点-难点">路径(重点、难点)</h2>
<p>实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。</p>
<p>**目录文件夹： **</p>
<p>就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。</p>
<p>**根目录 **</p>
<p>打开目录文件夹的第一层  就是 根目录</p>
<p>页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径</p>
<h3 id="相对路径">相对路径</h3>
<p>以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。</p>
<table>
<thead>
<tr>
<th>路径分类</th>
<th style="text-align:center">符号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一级路径</td>
<td style="text-align:center"></td>
<td style="text-align:left">只需输入图像文件的名称即可，如&lt;img src=&quot;baidu.gif&quot; /&gt;。</td>
</tr>
<tr>
<td>下一级路径</td>
<td style="text-align:center">“/”</td>
<td style="text-align:left">图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images）                         如&lt;img src=&quot;images/baidu.gif&quot; /&gt;。</td>
</tr>
<tr>
<td>上一级路径</td>
<td style="text-align:center">“../”</td>
<td style="text-align:left">在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，                    如&lt;img src=&quot;../baidu.gif&quot; /&gt;。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级  简单说，就是 图片 位于 HTML 页面的位置</p>
</blockquote>
<h3 id="绝对路径">绝对路径</h3>
<p>绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。</p>
<p>“D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。</p>
<p><strong>注意：</strong></p>
<p>绝对路径用的较少，我们理解下就可以了。  但是要注意，它的写法 特别是符号  \  并不是 相对路径的   /</p>
<h4 id="锚点定位-难点">锚点定位 （难点）</h4>
<p>通过创建锚点链接，用户能够快速定位到目标内容。</p>
<p>创建锚点链接分为两步：</p>
<pre><code class="language-html">1. 使用相应的id名标注跳转目标的位置。 (找目标)
  &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 

2. 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） （拉关系）  我也有一个姓毕的姥爷..
  &lt;a href=&quot;#two&quot;&gt;   
</code></pre>
<p>快速记忆法：</p>
<p>好比找个人办事，  首先找到他，然后拉关系，最后看效果。</p>
<h4 id="base-标签">base 标签</h4>
<p><strong>语法：</strong></p>
<pre><code class="language-html">&lt;base target=&quot;_blank&quot; /&gt;
</code></pre>
<p>**总结： **</p>
<ol>
<li>base 可以设置整体链接的打开状态</li>
<li>base 写到  <head>  </head>  之间</li>
<li>把所有的连接 都默认添加 target=&quot;_blank&quot;</li>
</ol>
<h4 id="预格式化文本pre标签">预格式化文本pre标签</h4>
<pre> 标签可定义预格式化的文本。



被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。

```html
<pre>

  此例演示如何使用 pre 标签

  对空行和 空格

  进行控制

</pre>
<pre><code>
了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。

HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体

### 表格 table

 表格的现在还是较为常用的一种标签，但不是用来布局，**常见显示、展示表格式数据。**

因为它可以让数据显示的非常的规整，可读性非常好。

**特别是后台展示数据的时候表格运用是否熟练就显得很重要**，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。

#### **创建表格的基本语法：**

```html
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;单元格内的文字&lt;/td&gt;
    ...
  &lt;/tr&gt;
  ...
&lt;/table&gt;
</code></pre>
<p>要深刻体会表格、行、单元格他们的构成。</p>
<p>在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释</p>
<ol>
<li>
<p>table用于定义一个表格标签。</p>
</li>
<li>
<p>tr标签 用于定义表格中的行，必须嵌套在 table标签中。</p>
</li>
<li>
<p>td 用于定义表格中的单元格，必须嵌套在<tr></tr>标签中。</p>
</li>
<li>
<p>字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。</p>
</li>
</ol>
<h4 id=""><img src="F:%5CAPEX-4869%5Cmd%5Ctt.png" alt="表格属性" loading="lazy"></h4>
<h4 id="表头单元格标签th">表头单元格标签th</h4>
<ul>
<li>
<p>作用：</p>
</li>
<li>
<ul>
<li>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</li>
</ul>
</li>
<li>
<p>语法：</p>
<ul>
<li>只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。</li>
</ul>
</li>
</ul>
<p>th 也是一个单元格   只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗</p>
<h4 id="表格标题caption">表格标题caption</h4>
<p><strong>定义和用法</strong></p>
<pre><code class="language-html">&lt;table&gt;
   &lt;caption&gt;我是表格标题&lt;/caption&gt;
&lt;/table&gt;
</code></pre>
<p>**注意： **</p>
<ol>
<li>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上。</li>
<li>caption 标签必须紧随 table 标签之后。</li>
<li>这个标签只存在 表格里面才有意义。</li>
</ol>
<h4 id="合并单元格">合并单元格</h4>
<h4 id="合并单元格2种方式">合并单元格2种方式</h4>
<ul>
<li>跨行合并：rowspan=&quot;合并单元格的个数&quot;</li>
<li>跨列合并：colspan=&quot;合并单元格的个数&quot;</li>
</ul>
<p>**合并的顺序我们按照   先上 后下     先左  后右 的顺序 **</p>
<h4 id="合并单元格三步曲">合并单元格三步曲</h4>
<ol>
<li>先确定是跨行还是跨列合并</li>
<li>根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ： <td colspan="3">   </td></li>
<li>删除多余的单元格 单元格</li>
</ol>
<h3 id="总结表格">总结表格</h3>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><table></table></td>
<td style="text-align:left">表格标签</td>
<td style="text-align:left">就是一个四方的盒子</td>
</tr>
<tr>
<td><tr></tr></td>
<td style="text-align:left">表格行标签</td>
<td style="text-align:left">行标签要再table标签内部才有意义</td>
</tr>
<tr>
<td><td></td></td>
<td style="text-align:left">单元格标签</td>
<td style="text-align:left">单元格标签是个容器级元素，可以放任何东西</td>
</tr>
<tr>
<td><th></th></td>
<td style="text-align:left">表头单元格标签</td>
<td style="text-align:left">它还是一个单元格，但是里面的文字会居中且加粗</td>
</tr>
<tr>
<td><caption></caption></td>
<td style="text-align:left">表格标题标签</td>
<td style="text-align:left">表格的标题，跟着表格一起走，和表格居中对齐</td>
</tr>
<tr>
<td>clospan 和 rowspan</td>
<td style="text-align:left">合并属性</td>
<td style="text-align:left">用来合并单元格的</td>
</tr>
</tbody>
</table>
<ol>
<li>表格提供了HTML 中定义表格式数据的方法。</li>
<li>表格中由行中的单元格组成。</li>
<li>表格中没有列元素，列的个数取决于行的单元格个数。</li>
<li>表格不要纠结于外观，那是CSS 的作用。</li>
<li>表格的学习要求：  能手写表格结构，并且能简单合并单元格。</li>
</ol>
<h3 id="列表标签">列表标签</h3>
<ul>
<li>
<p>概念：</p>
<p>容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表</p>
</li>
<li>
<p>特点：</p>
<p>列表最大的特点就是  整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。</p>
</li>
</ul>
<h4 id="无序列表-ul">无序列表 ul</h4>
<p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
  &lt;li&gt;列表项3&lt;/li&gt;
  ......
&lt;/ul&gt;
</code></pre>
<pre><code> 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。
 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。
 3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！
</code></pre>
<h4 id="有序列表-ol">有序列表 ol</h4>
<p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<pre><code class="language-html">&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
  &lt;li&gt;列表项3&lt;/li&gt;
  ......
&lt;/ol&gt;
</code></pre>
<p>所有特性基本与ul 一致。  但是实际中比 无序列表 用的少很多。</p>
<p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  &lt;dd&gt;名词1解释2&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  &lt;dd&gt;名词2解释2&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<h3 id="列表总结">列表总结</h3>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:center">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><ul></ul></td>
<td style="text-align:center"><strong>无序标签</strong></td>
<td style="text-align:left">里面只能包含li    没有顺序，我们以后布局中最常用的列表</td>
</tr>
<tr>
<td><ol></ol></td>
<td style="text-align:center">有序标签</td>
<td style="text-align:left">里面只能包含li    有顺序， 使用情况较少</td>
</tr>
<tr>
<td><dl></dl></td>
<td style="text-align:center">自定义列表</td>
<td style="text-align:left">里面有2个兄弟， dt 和 dd</td>
</tr>
</tbody>
</table>
<h3 id="表单标签">表单标签</h3>
<p>**表单控件： **</p>
<p>​       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p>
<p><strong>提示信息：</strong></p>
<p>​        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p>
<p><strong>表单域：</strong></p>
<p>​      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p>
<h4 id="input-控件">input 控件</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-html">&lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt;
</code></pre>
<ul>
<li>input 输入的意思</li>
<li>&lt;input /&gt;标签为单标签</li>
<li>type属性设置不同的属性值用来指定不同的控件类型</li>
<li>除了type属性还有别的属性</li>
</ul>
</li>
</ul>
<h4 id="1-type-属性">1. type 属性</h4>
<ul>
<li>这个属性通过改变值，可以决定了你属于那种input表单。</li>
<li>比如 type = 'text'  就表示 文本框 可以做 用户名， 昵称等。</li>
<li>比如 type = 'password'  就是表示密码框   用户输入的内容 是不可见的。</li>
</ul>
<pre><code class="language-html">用户名: &lt;input type=&quot;text&quot; /&gt; 
密  码：&lt;input type=&quot;password&quot; /&gt;
</code></pre>
<h4 id="2-value属性-值">2. value属性   值</h4>
<pre><code class="language-html">用户名:&lt;input type=&quot;text&quot;  name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; 
</code></pre>
<ul>
<li>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</li>
</ul>
<h4 id="3-name属性">3. name属性</h4>
<pre><code class="language-html">用户名:&lt;input type=&quot;text&quot;  name=“username” /&gt;  
</code></pre>
<p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</p>
<ul>
<li>
<p>name属性后面的值，是我们自己定义的。</p>
</li>
<li>
<p>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</p>
</li>
</ul>
<pre><code class="language-html">&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  /&gt;男
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女
</code></pre>
<ul>
<li>name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</li>
</ul>
<h4 id="4-checked属性">4. checked属性</h4>
<ul>
<li>表示默认选中状态。  较常见于 单选按钮和复选按钮。</li>
</ul>
<pre><code class="language-html">性    别:
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 
</code></pre>
<p>上面这个，表示就默认选中了 男 这个单选按钮</p>
<h4 id="5-input-属性小结">5. input 属性小结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">说明</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td style="text-align:left">表单类型</td>
<td>用来指定不同的控件类型</td>
</tr>
<tr>
<td>value</td>
<td style="text-align:left">表单值</td>
<td>表单里面默认显示的文本</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:left">表单名字</td>
<td>页面中的表单很多，name主要作用就是用于区别不同的表单。</td>
</tr>
<tr>
<td>checked</td>
<td style="text-align:left">默认选中</td>
<td>表示那个单选或者复选按钮一开始就被选中了</td>
</tr>
</tbody>
</table>
<p>lab 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p>
<p><strong>如何绑定元素呢？</strong></p>
<ol>
<li>第一种用法就是用label直接包括input表单。</li>
</ol>
<pre><code class="language-html">&lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt;   &lt;/label&gt;
</code></pre>
<p>适合单个表单选择</p>
<ol start="2">
<li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li>
</ol>
<pre><code class="language-html">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot;&gt;
</code></pre>
<h4 id="textarea控件文本域">textarea控件(文本域)</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-html">&lt;textarea &gt;
  文本内容
&lt;/textarea&gt;
</code></pre>
<ul>
<li>
<p>作用：</p>
<p>通过textarea控件可以轻松地创建多行文本输入框.</p>
<p>cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;  我们实际开发不用</p>
</li>
</ul>
<h4 id="文本框和文本域区别">文本框和文本域区别</h4>
<table>
<thead>
<tr>
<th style="text-align:left">表单</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">区别</th>
<th style="text-align:right">默认值显示</th>
<th style="text-align:right">用于场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">input type=&quot;text&quot;</td>
<td style="text-align:center">文本框</td>
<td style="text-align:center">只能显示一行文本</td>
<td style="text-align:right">单标签，通过value显示默认值</td>
<td style="text-align:right">用户名、昵称、密码等</td>
</tr>
<tr>
<td style="text-align:left">textarea</td>
<td style="text-align:center">文本域</td>
<td style="text-align:center">可以显示多行文本</td>
<td style="text-align:right">双标签，默认值写到标签中间</td>
<td style="text-align:right">留言板</td>
</tr>
</tbody>
</table>
<h4 id="select下拉列表">select下拉列表</h4>
<p><strong>语法：</strong></p>
<pre><code class="language-html">&lt;select&gt;
  &lt;option&gt;选项1&lt;/option&gt;
  &lt;option&gt;选项2&lt;/option&gt;
  &lt;option&gt;选项3&lt;/option&gt;
  ...
&lt;/select&gt;
</code></pre>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>&lt;select&gt;  中至少包含一对 option</li>
<li>在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。</li>
<li>但是我们实际开发会用的比较少</li>
</ol>
<h4 id="form表单域">form表单域</h4>
<ul>
<li>
<p>目的：</p>
<p>在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</p>
</li>
</ul>
<p>**语法: **</p>
<pre><code class="language-html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;
  各种表单控件
&lt;/form&gt;
</code></pre>
<p><strong>常用属性：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td style="text-align:left">url地址</td>
<td>用于指定接收并处理表单数据的服务器程序的url地址。</td>
</tr>
<tr>
<td>method</td>
<td style="text-align:left">get/post</td>
<td>用于设置表单数据的提交方式，其取值为get或post。</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:left">名称</td>
<td>用于指定表单的名称，以区分同一个页面中的多个表单。</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</p>
<p>经常查阅文档是一个非常好的学习习惯。</p>
<p>W3C :  http://www.w3school.com.cn/</p>
<p>MDN: https://developer.mozilla.org/zh-CN/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web代码规范]]></title>
        <id>https://xmweijh.github.io/post/web-dai-ma-gui-fan/</id>
        <link href="https://xmweijh.github.io/post/web-dai-ma-gui-fan/">
        </link>
        <updated>2021-02-07T11:32:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="代码规范">代码规范</h1>
<h2 id="1-概述">1. 概述</h2>
<p>欢迎使用品优购代码规范， 这个是我借鉴京东前端代码规范，组织的品优购内部规范。旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范，</p>
<p>以下规范是团队基本约定的内容，必须严格遵循。</p>
<h4 id="html规范">HTML规范</h4>
<p>基于 <a href="http://www.w3.org/">W3C</a>、<a href="https://developer.apple.com/">苹果开发者</a> 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p>
<h4 id="图片规范">图片规范</h4>
<p>了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p>
<h4 id="css规范">CSS规范</h4>
<p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p>
<h4 id="命名规范">命名规范</h4>
<p>从 <code>目录</code>、<code>图片</code>、<code>HTML/CSS文件</code>、<code>ClassName</code> 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p>
<h2 id="2-html-规范">2. HTML 规范</h2>
<h3 id="doctype-声明">DOCTYPE 声明</h3>
<p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>HTML5标准模版</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;zh-CN&quot;&gt;
  &lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;HTML5标准模版&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="页面语言lang">页面语言lang</h3>
<p>推荐使用属性值 <code>cmn-Hans-CN</code>（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 <code>zh-CN</code> 属性值</p>
<pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;
</code></pre>
<p>更多地区语言参考：</p>
<pre><code>zh-SG 中文 (简体, 新加坡)   对应 cmn-Hans-SG 普通话 (简体, 新加坡)
zh-HK 中文 (繁体, 香港)     对应 cmn-Hant-HK 普通话 (繁体, 香港)
zh-MO 中文 (繁体, 澳门)     对应 cmn-Hant-MO 普通话 (繁体, 澳门)
zh-TW 中文 (繁体, 台湾)     对应 cmn-Hant-TW 普通话 (繁体, 台湾)
</code></pre>
<h3 id="charset-字符集合">charset 字符集合</h3>
<p>一般情况下统一使用 “UTF-8” 编码</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;
</code></pre>
<p>由于历史原因，有些业务可能会使用 “GBK” 编码</p>
<pre><code>&lt;meta charset=&quot;GBK&quot;&gt;
</code></pre>
<p>请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 <a href="http://www.ietf.org/rfc/rfc3629">IETF对UTF-8的定义</a>，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。</p>
<h3 id="书写风格">书写风格</h3>
<h4 id="html代码大小写">HTML代码大小写</h4>
<p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p>
<p><em>推荐：</em></p>
<pre><code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;div class=&quot;DEMO&quot;&gt;&lt;/div&gt;
	
&lt;DIV CLASS=&quot;DEMO&quot;&gt;&lt;/DIV&gt;
</code></pre>
<h3 id="类型属性">类型属性</h3>
<p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含</p>
<p><em>推荐：</em></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt;
&lt;script src=&quot;&quot;&gt;&lt;/script&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; &gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
</code></pre>
<h3 id="元素属性">元素属性</h3>
<ul>
<li>元素属性值使用双引号语法</li>
<li>元素属性值可以写上的都写上</li>
</ul>
<p><em>推荐：</em></p>
<pre><code>&lt;input type=&quot;text&quot;&gt;
&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; &gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;input type=text&gt;	
&lt;input type='text'&gt;
&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked &gt;
</code></pre>
<h3 id="特殊字符引用">特殊字符引用</h3>
<p>文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。</p>
<p>在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</p>
<p><em>推荐：</em></p>
<pre><code>&lt;a href=&quot;#&quot;&gt;more&amp;gt;&amp;gt;&lt;/a&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;a href=&quot;#&quot;&gt;more&gt;&gt;&lt;/a&gt;
</code></pre>
<h3 id="代码缩进">代码缩进</h3>
<p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p>
<pre><code>&lt;div class=&quot;jdc&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<h3 id="代码嵌套">代码嵌套</h3>
<p>元素嵌套规范，每个块状元素独立一行，内联元素可选</p>
<p><em>推荐：</em></p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt; 
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>段落元素与标题元素只能嵌套内联元素</p>
<p><em>推荐：</em></p>
<pre><code>&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;
&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
</code></pre>
<h2 id="3-图片规范">3. 图片规范</h2>
<h3 id="内容图">内容图</h3>
<p>内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大</p>
<ul>
<li>优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式</li>
<li>尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大</li>
<li><strong>PC平台单张的图片的大小不应大于 200KB。</strong></li>
</ul>
<h3 id="背景图">背景图</h3>
<p>背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片</p>
<ul>
<li>PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率</li>
<li>图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式</li>
<li>图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式</li>
<li>图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式</li>
<li>条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式</li>
</ul>
<h2 id="4-css规范">4. CSS规范</h2>
<h3 id="代码格式化">代码格式化</h3>
<p>样式书写一般有两种：一种是紧凑格式 (Compact)</p>
<pre><code>.jdc{ display: block;width: 50px;}
</code></pre>
<p>一种是展开格式（Expanded）</p>
<pre><code>.jdc {
    display: block;
    width: 50px;
}
</code></pre>
<p><strong>团队约定</strong></p>
<p>统一使用展开格式书写样式</p>
<h3 id="代码大小写">代码大小写</h3>
<p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p>
<pre><code>/* 推荐 */
.jdc{
	display:block;
}
	
/* 不推荐 */
.JDC{
	DISPLAY:BLOCK;
}
</code></pre>
<h3 id="选择器">选择器</h3>
<ul>
<li>尽量少用通用选择器 <code>*</code></li>
<li>不使用 ID 选择器</li>
<li>不使用无具体语义定义的标签选择器</li>
</ul>
<pre><code class="language-css">/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}

/* 不推荐 */
*{}
#jdc {}
.jdc div{}
</code></pre>
<h3 id="代码缩进-2">代码缩进</h3>
<p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p>
<pre><code>.jdc {
    width: 100%;
    height: 100%;
}
</code></pre>
<h3 id="分号">分号</h3>
<p>每个属性声明末尾都要加分号；</p>
<pre><code>.jdc {
    width: 100%;
    height: 100%;
}
</code></pre>
<h3 id="代码易读性">代码易读性</h3>
<p>左括号与类名之间一个空格，冒号与属性值之间一个空格</p>
<p><em>推荐：</em></p>
<pre><code>.jdc { 
    width: 100%; 
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc{ 
    width:100%;
}
</code></pre>
<p>逗号分隔的取值，逗号之后一个空格</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc {
    box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;
}
</code></pre>
<p>为单个css选择器或新申明开启新行</p>
<p><em>推荐：</em></p>
<pre><code class="language-css">.jdc, 
.jdc_logo, 
.jdc_hd {
    color: #ff0;
}
.nav{
    color: #fff;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc,jdc_logo,.jdc_hd {
    color: #ff0;
}.nav{
    color: #fff;
}
</code></pre>
<p>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    color: rgba(255,255,255,.5);
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc {
    color: rgba( 255, 255, 255, 0.5 );
}
</code></pre>
<p>属性值十六进制数值能用简写的尽量用简写</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    color: #fff;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc {
    color: #ffffff;
}
</code></pre>
<p>不要为 <code>0</code> 指明单位</p>
<p><em>推荐：</em></p>
<pre><code class="language-css">.jdc {
    margin: 0 10px;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc {
    margin: 0px 10px;
}
</code></pre>
<h3 id="属性值引号">属性值引号</h3>
<p>css属性值需要用到引号时，统一使用单引号</p>
<pre><code class="language-css">/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

/* 不推荐 */
.jdc { 
	font-family: &quot;Hiragino Sans GB&quot;;
}
</code></pre>
<h3 id="属性书写顺序">属性书写顺序</h3>
<p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li>
</ol>
<pre><code class="language-css">.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre>
<p><a href="https://www.mozilla.org/css/base/content.css">mozilla官方属性顺序推荐</a></p>
<h2 id="命名规范-2">命名规范</h2>
<p>由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。</p>
<h3 id="目录命名">目录命名</h3>
<ul>
<li>项目文件夹：pinyougou</li>
<li>样式文件夹：css</li>
<li>脚本文件夹：js</li>
<li>样式类图片文件夹：img</li>
<li>产品类图片文件夹： upload</li>
<li>字体类文件夹： fonts</li>
</ul>
<h3 id="classname命名">ClassName命名</h3>
<p>ClassName的命名应该尽量精短、明确，必须以<strong>字母开头命名</strong>，且<strong>全部字母为小写</strong>，单词之间<strong>统一使用下划线</strong> “_” 连接</p>
<p>.nav_top</p>
<h4 id="常用命名推荐">常用命名推荐</h4>
<p><strong>注意</strong>：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此</p>
<pre><code>&lt;div class=&quot;ad&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这种广告的英文或拼音类名不应该出现</p>
<p>另外，<strong>敏感不和谐字眼</strong>也不应该出现，如：</p>
<pre><code>&lt;div class=&quot;fuck&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;jer&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;sm&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;gcd&quot;&gt;&lt;/div&gt; 
&lt;div class=&quot;ass&quot;&gt;&lt;/div&gt; 
&lt;div class=&quot;KMT&quot;&gt;&lt;/div&gt; 
...
</code></pre>
<table>
<thead>
<tr>
<th>ClassName</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>about</td>
<td>关于</td>
</tr>
<tr>
<td>account</td>
<td>账户</td>
</tr>
<tr>
<td>arrow</td>
<td>箭头图标</td>
</tr>
<tr>
<td>article</td>
<td>文章</td>
</tr>
<tr>
<td>aside</td>
<td>边栏</td>
</tr>
<tr>
<td>audio</td>
<td>音频</td>
</tr>
<tr>
<td>avatar</td>
<td>头像</td>
</tr>
<tr>
<td>bg,background</td>
<td>背景</td>
</tr>
<tr>
<td>bar</td>
<td>栏（工具类）</td>
</tr>
<tr>
<td>branding</td>
<td>品牌化</td>
</tr>
<tr>
<td>crumb,breadcrumbs</td>
<td>面包屑</td>
</tr>
<tr>
<td>btn,button</td>
<td>按钮</td>
</tr>
<tr>
<td>caption</td>
<td>标题，说明</td>
</tr>
<tr>
<td>category</td>
<td>分类</td>
</tr>
<tr>
<td>chart</td>
<td>图表</td>
</tr>
<tr>
<td>clearfix</td>
<td>清除浮动</td>
</tr>
<tr>
<td>close</td>
<td>关闭</td>
</tr>
<tr>
<td>col,column</td>
<td>列</td>
</tr>
<tr>
<td>comment</td>
<td>评论</td>
</tr>
<tr>
<td>community</td>
<td>社区</td>
</tr>
<tr>
<td>container</td>
<td>容器</td>
</tr>
<tr>
<td>content</td>
<td>内容</td>
</tr>
<tr>
<td>copyright</td>
<td>版权</td>
</tr>
<tr>
<td>current</td>
<td>当前态，选中态</td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
</tr>
<tr>
<td>details</td>
<td>细节</td>
</tr>
<tr>
<td>disabled</td>
<td>不可用</td>
</tr>
<tr>
<td>entry</td>
<td>文章，博文</td>
</tr>
<tr>
<td>error</td>
<td>错误</td>
</tr>
<tr>
<td>even</td>
<td>偶数，常用于多行列表或表格中</td>
</tr>
<tr>
<td>fail</td>
<td>失败（提示）</td>
</tr>
<tr>
<td>feature</td>
<td>专题</td>
</tr>
<tr>
<td>fewer</td>
<td>收起</td>
</tr>
<tr>
<td>field</td>
<td>用于表单的输入区域</td>
</tr>
<tr>
<td>figure</td>
<td>图</td>
</tr>
<tr>
<td>filter</td>
<td>筛选</td>
</tr>
<tr>
<td>first</td>
<td>第一个，常用于列表中</td>
</tr>
<tr>
<td>footer</td>
<td>页脚</td>
</tr>
<tr>
<td>forum</td>
<td>论坛</td>
</tr>
<tr>
<td>gallery</td>
<td>画廊</td>
</tr>
<tr>
<td>group</td>
<td>模块，清除浮动</td>
</tr>
<tr>
<td>header</td>
<td>页头</td>
</tr>
<tr>
<td>help</td>
<td>帮助</td>
</tr>
<tr>
<td>hide</td>
<td>隐藏</td>
</tr>
<tr>
<td>hightlight</td>
<td>高亮</td>
</tr>
<tr>
<td>home</td>
<td>主页</td>
</tr>
<tr>
<td>icon</td>
<td>图标</td>
</tr>
<tr>
<td>info,information</td>
<td>信息</td>
</tr>
<tr>
<td>last</td>
<td>最后一个，常用于列表中</td>
</tr>
<tr>
<td>links</td>
<td>链接</td>
</tr>
<tr>
<td>login</td>
<td>登录</td>
</tr>
<tr>
<td>logout</td>
<td>退出</td>
</tr>
<tr>
<td>logo</td>
<td>标志</td>
</tr>
<tr>
<td>main</td>
<td>主体</td>
</tr>
<tr>
<td>menu</td>
<td>菜单</td>
</tr>
<tr>
<td>meta</td>
<td>作者、更新时间等信息栏，一般位于标题之下</td>
</tr>
<tr>
<td>module</td>
<td>模块</td>
</tr>
<tr>
<td>more</td>
<td>更多（展开）</td>
</tr>
<tr>
<td>msg,message</td>
<td>消息</td>
</tr>
<tr>
<td>nav,navigation</td>
<td>导航</td>
</tr>
<tr>
<td>next</td>
<td>下一页</td>
</tr>
<tr>
<td>nub</td>
<td>小块</td>
</tr>
<tr>
<td>odd</td>
<td>奇数，常用于多行列表或表格中</td>
</tr>
<tr>
<td>off</td>
<td>鼠标离开</td>
</tr>
<tr>
<td>on</td>
<td>鼠标移过</td>
</tr>
<tr>
<td>output</td>
<td>输出</td>
</tr>
<tr>
<td>pagination</td>
<td>分页</td>
</tr>
<tr>
<td>pop,popup</td>
<td>弹窗</td>
</tr>
<tr>
<td>preview</td>
<td>预览</td>
</tr>
<tr>
<td>previous</td>
<td>上一页</td>
</tr>
<tr>
<td>primary</td>
<td>主要</td>
</tr>
<tr>
<td>progress</td>
<td>进度条</td>
</tr>
<tr>
<td>promotion</td>
<td>促销</td>
</tr>
<tr>
<td>rcommd,recommendations</td>
<td>推荐</td>
</tr>
<tr>
<td>reg,register</td>
<td>注册</td>
</tr>
<tr>
<td>save</td>
<td>保存</td>
</tr>
<tr>
<td>search</td>
<td>搜索</td>
</tr>
<tr>
<td>secondary</td>
<td>次要</td>
</tr>
<tr>
<td>section</td>
<td>区块</td>
</tr>
<tr>
<td>selected</td>
<td>已选</td>
</tr>
<tr>
<td>share</td>
<td>分享</td>
</tr>
<tr>
<td>show</td>
<td>显示</td>
</tr>
<tr>
<td>sidebar</td>
<td>边栏，侧栏</td>
</tr>
<tr>
<td>slide</td>
<td>幻灯片，图片切换</td>
</tr>
<tr>
<td>sort</td>
<td>排序</td>
</tr>
<tr>
<td>sub</td>
<td>次级的，子级的</td>
</tr>
<tr>
<td>submit</td>
<td>提交</td>
</tr>
<tr>
<td>subscribe</td>
<td>订阅</td>
</tr>
<tr>
<td>subtitle</td>
<td>副标题</td>
</tr>
<tr>
<td>success</td>
<td>成功（提示）</td>
</tr>
<tr>
<td>summary</td>
<td>摘要</td>
</tr>
<tr>
<td>tab</td>
<td>标签页</td>
</tr>
<tr>
<td>table</td>
<td>表格</td>
</tr>
<tr>
<td>txt,text</td>
<td>文本</td>
</tr>
<tr>
<td>thumbnail</td>
<td>缩略图</td>
</tr>
<tr>
<td>time</td>
<td>时间</td>
</tr>
<tr>
<td>tips</td>
<td>提示</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>wrap</td>
<td>容器，包，一般用于最外层</td>
</tr>
<tr>
<td>wrapper</td>
<td>容器，包，一般用于最外层</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://xmweijh.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://xmweijh.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-08-23T03:09:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<p>计算机网络:是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p>
<p>计算机网络是<strong>互连的、自治</strong>的计算机集合。<br>
互连-互联互通通信链路<br>
自治-无主从关系</p>
<p>计算机网络的功能<br>
★1. 数据通信(连通性)<br>
2.资源共享    	硬件	软件	数据<br>
3.分布式处理		多台计算机各自承担同一工作任务的不同部分 Hadoop 平台<br>
4.提高可靠性		替代机<br>
5.负载均衡		各计算机之间更亲密</p>
<p>计算机网络的组成<br>
1.组成部分硬件、软件、协议(一系列规则和约定的集合)</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594777907079.png" alt="1594777907079" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594778204294.png" alt="1594778204294" loading="lazy"></figure>
<p>标准的分类-</p>
<p>法定标准		由权威机构制定的正式的、 合法的标准	OSI</p>
<p>事实标准		某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准<br>
TCP/IP</p>
<p>RFC (Request For Comments )一因特网标准的形式<br>
RFC要上升为因特网正式标准的四个阶段:<br>
1)因特网草案(Internet Draft)这个阶段还不是RFC文档。<br>
2)建议标准(Proposed Standard)从这个阶段开始成为RFC文档。<br>
3)草案标准( Draft Standard)<br>
IETF、IAB<br>
4)因特网标准( internet Standard)</p>
<p>国际标准化组织ISO	OSI参考模型、HDLC协议<br>
国际电信联盟ITU	制定通信规则<br>
国际电气电子工程师协会IEEE	学术机构、IEEE802 系列标准、5G<br>
Internet工程任务组IETF	负责因特网相关标准的制定RFC XXXX</p>
<p>速率即数据率或称数据传输率或比特率。<br>
比特1/0 位<br>
连接在计算机网络上的主机在数字信道上传送数据位数的速率。<br>
单位是b/s，kb/s, Mb/s, Gb/s， Tb/s</p>
<p>(1) “带宽&quot;原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz)。<br>
(2)计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中<br>
的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s, kb/s, Mb/s, Gb/s。<br>
网络设备所支持的最高速度</p>
<p>吞吐量	表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s，kb/s， Mb/s等。<br>
吞吐量受网络的带宽或网络的额定速率的限制。</p>
<p>时延<br>
指数据(报文/分组/比特流)从网络( 或链路)的-端传送到另一端所需的时间。也叫延迟或迟延。单位s。<br>
时延	发送时延(传输时延)	传播时延	排队时延	处理时延</p>
<p>时延带宽积=传播时延X带宽  	时延带宽积又称为以比特为单位的链路长度。即“某段链路现在有多少比特”	容量</p>
<p>往返时延RTT	从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多。<br>
RTT包括	往返传播时延=传播时延*2	末端处理时间</p>
<p>利用率			信道利用率		网络利用率</p>
<p>分层的基本原则<br>
1.各层之间相互独立，每层只实现一种相对独立的功能。<br>
2.每层之间界面自然清晰，易于理解，相互交流尽可能少。<br>
3.结构上可分割开。每层都采用最合适的技术来实现。<br>
4.保持下层对上层的独立性，上层单向使用下层提供的服务。<br>
5.整个分层结构应该能促进标准化工作。</p>
<p>1.实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。<br>
2.协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。【水平】<br>
语法:规定传输数据的格式<br>
语义:规定所要完成的功能<br>
同步:规定各种操作的顺序<br>
3.接口（访问服务点SAP）:上层使用下层服务的入口。<br>
4.服务:下层为相邻上层提供的功能调用。【垂直】</p>
<p>SDU服务数据单元:为完成用户所要求的功能而应传送的数据。<br>
PCI协议控制信息:控制协议操作的信息。<br>
PDU协议数据单元:对等层次之间传送的数据单位。</p>
<p>网络体系结构是从功能上描述计算机网络结构。<br>
计算机网络体系结构简称网络体系结构是分层结构。<br>
每层遵循某个/些网络协议以完成本层功能。<br>
计算机网络体系结构是计算机网络的各层及其协议的集合。<br>
体系结构是抽象的，而实现是指能运行的一些软件和硬件。<br>
第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。<br>
仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595040529479.png" alt="1595040529479" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121141004.png" alt="1595121141004" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121523494.png" alt="1595121523494" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595215799893.png" alt="1595215799893" loading="lazy"></figure>
<h2 id="物理层">物理层</h2>
<p>物理层接口特性<br>
物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。<br>
物理层主要任务:确定与传输媒体<strong>接口</strong>有关的一些特性	定义标准<br>
1<strong>机械特性</strong> 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目、引脚数量</strong>和排列情况。<br>
2<strong>电气特性 <strong>规定传输二进制位时，线路上信号的</strong>电压范围</strong>、阻抗匹配、传<strong>输速率和距离</strong>限制等。<br>
3<strong>功能特性</strong>  指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途。<br>
4<strong>规程待性</strong>	(过程特性）定义各条物理线路的工作规程和时序关系。</p>
<p>数据通信相关术语<br>
通信的目的是传送消息（消息:语音、文字、图像、视频等）。<br>
数据data:传送信息的实体，通常是有意义的符号序列。<br>
信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。<br>
数字信号/离散信号:代表消息的参数的取值是离散的。<br>
模拟信号/连续信号:代表消息的参数的取值是连续的。信源:产生和发送数据的源头。<br>
信宿:接收数据的终点。<br>
条发送信道和一条接收信道。<br>
信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>
<p>三种通信方式<br>
从通信双方信息的交互方式看，可以有三种基本方式:<br>
1.单工通信<br>
只有一个方向的通信而没有反方向的交互，仅需要一条信道。<br>
2.半双工通信/双向交替通信<br>
通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。<br>
3.全双工通信/双向同时通信<br>
通信双方可以同时发送和接受信息，也需要两条信道。</p>
<p>串行传输&amp;并行传输<br>
串行传输将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。速度慢，费用低，适合远距离<br>
并行传输将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离</p>
<p>同步传输&amp;异步传输</p>
<p>同步传输:在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p>
<p>。<br>
异步传输:异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位</p>
<p>码元<br>
码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。<br>
1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>
<p>数字通信系统数据传输速率的两种表示方法<br>
速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示<br>
1）码元传输速率:别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数)，单位是波特（Baud)。1波特表示数字通信系统每秒传输一个码元。</p>
<p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。</p>
<p>2）信息传输速率:别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)，单位是比特/秒(b/s)。<br>
带宽（Bandwidth）</p>
<p>1.模拟信号系统中:当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</p>
<p>2数字设备中:表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps)。</p>
<p>失真</p>
<p>影响失真程度的因素:1.码元传输速率﹐⒉信号传输距离  3.噪声干扰  4.传输媒体质量</p>
<p>码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。</p>
<p>奈氏准则（奈奎斯特定理）</p>
<p>奈氏准则:在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰,极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>
<p>理想低通信道下的极限数据传输率=2Wlog2v (b/s)  v：几种码元/码元的离散电平数目</p>
<p>1.在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。<br>
2.信道的频带越宽（即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p>
<p>3.奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限<br>
4.由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多信息量，这就需要采用多元制的调制方法。</p>
<p>香农定理</p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即:</p>
<p>信噪比（dB） =10log10(S/N)	数值等价</p>
<p>香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<br>
信道的极限数据传输速率=Wlog2(1+S/N)	 (b/s)</p>
<p>1.信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p>
<p>2对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p>
<p>3.只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。<br>
4.香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p>
<p>基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。<strong>来自信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</p>
<p>宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)<br>
在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出基带型号）</p>
<p>数据   ------  数字信号   编码<br>
数据  ------   模拟信号   调制</p>
<p>数字数据编码为数字信号<br>
(1）非归零编码【NRZ】</p>
<p>(2）曼彻斯特编码</p>
<p>(3）差分曼彻斯特编码</p>
<p>(4）归零编码【RZ】</p>
<p>(5）反向不归零编码【NRZl】</p>
<p>(6）4B/5B编码</p>
<p>数字数据调制为模拟信号</p>
<p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<p>模拟数据编码为数字信号<br>
计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）。</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中,能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。</p>
<p>1.抽样:对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:f采样频率&gt;=2f信号最高频率<br>
⒉量化:把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p>
<p>3.编码:把量化的结果转换为与之对应的二进制编码。</p>
<p>模拟数据调制为模拟信号<br>
为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式，模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<p>数据交换方式<br>
电路交换<br>
报文交换<br>
存储转发</p>
<p>电路交换的原理:<br>
在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。</p>
<p>电路交换的阶段:<br>
建立连接（呼叫/电路建立）<br>
通信(数据传输）<br>
释放连接(拆除电路）</p>
<p>特点:独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p>
<p>电路交换优点<br>
传输时延小<br>
数据顺序传送，无失序问题<br>
实时性强，双方一旦建立物理通路，便可以实时通信，适用于交互式会话类通信。<br>
全双工通信，没有冲突，通信双方有不同的信道，不会争用物理信道<br>
适用于模拟信号和数字信号<br>
控制简单，电路的交换设备及控制较简单</p>
<p>电路交换缺点<br>
建立连接时间长<br>
线路独占，即使通信线路空闲，也不能供其他用户使用，信道使用效率低。<br>
灵活性差，双方连接通路中的任何一点除了故障，必须重新拨号建立新连接，不适应突发性通信。<br>
无数据存储能力，难以平滑通信量。<br>
电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信<br>
无法发现与纠正传输差错，难以在通信过程中进行差错控制。</p>
<p>报文:报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p>
<p>报文交换的原理:<br>
无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p>
<p>报文交换优点<br>
无需建立连接，无建立连接时延，用户可随时发送报文。<br>
动态分配线路，动态选择报文通过的最佳路径，可以平滑通信量。<br>
提高线路可靠性，某条传输路径发生故障，可重新选择另一条路径传输。<br>
提高线路利用率，通信双方在不同的时间一段一段地部分占有这条物理通道，多个报文可共享信道。<br>
提供多目标服务:一个报文可同时发往多个目的地址。<br>
在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度预同的计算机之间通行通信。</p>
<p>报文交换缺点<br>
实时性差，不适合传送实时或交互式业务的数据。数据进入交换结点后要经历存储转发过程，从而引起转发时延。<br>
只适用于数字信号。<br>
由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p>
<p>分组:大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet） 。</p>
<p>分组交换的原理:<br>
分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p>
<p>分组交换优点<br>
无建立时延，无需为通信双方预先建立一条专用通信线路，用户对随时发送分组。<br>
线路利用率高，通信双方在不同的时间一段一段地部分占有这条物理通道，多个分组可共享信道。<br>
简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>
加速传输，后一个分组的存储可以和前一个分组的转发并行操作;传输一个分组比一份报文所需缓冲区小，减少等待发送时间。<br>
减少出错几率和重发数据量，提高可靠性，减少传输时延。<br>
分组短小，适用于计算机之问突发式数据通信。</p>
<p>分组交换缺点<br>
尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>
每个分组都要加控制信息，一定程度上降低了通信效率，增加了处理的时间。<br>
当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p>1.传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。<br>
2.当端揣到揣的通路有很多段的链路组成时，采用分组交换传送数据较为合适。<br>
3.从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交<br>
换的时延小，尤其适合于计算机之间的突发式的数据通信。</p>
<p>数据报方式的特点<br>
1.数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p>
<p>无连接服务∶不事光为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<p>2.同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p>
<p>3.每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p>
<p>4.分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较太或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p>
<p>5.网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通</p>
<p>虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</p>
<p>虚电路方式的特点<br>
1.虚电路方式为网络层提供连接服务。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。</p>
<p>连接服务︰首光为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p>
<p>2.一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。</p>
<p>3.分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。<br>
4.每个节点可能与多个节点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务。</p>
<p>5.致命弱点:当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将会遭到破坏</p>
<p>传输介质及分类<br>
传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。<br>
<strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。<br>
但物理层规定了电气特性，因此能够识别所传送的比特流。<br>
导向性传输介质——1.双绞线<br>
双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP），无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。</p>
<p>同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类:5OQ同轴电缆和7sQ同轴电缆。其中，50Q同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用;75Q同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。</p>
<p>光纤主要由纤芯(实心的! )和包层构成，光波通过纤芯进行传导，包尾较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<p>光纤的特点:<br>
1.传输损耗小，中继距离长，对远距离传输特别经济。<br>
2.抗雷电和电磁干扰性能好。<br>
3.无串音干扰，保密性好，也不易被窃听或截取数据。<br>
4.体积小，重量轻。</p>
<p>非导向性传输介质<br>
无线电波:较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）。<br>
信号向所有方向传播</p>
<p>微波</p>
<p>红外线、激光</p>
<p>中继器的功能:对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（再生数字信号）</p>
<p>中继器的两端:两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。<br>
5-4-3规则:网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p>
<p>集线器（多口中继器）<br>
集线器的功能:对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。(再生，放大信号)</p>
<h2 id="数据链路层">数据链路层</h2>
<p>数据链路层功能概述</p>
<p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<p>功能一:为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p>
<p>功能二:链路管理，即连接的建立、维持、释放（用于面向连接的服务）</p>
<p>功能三:组帧。<br>
功能四:流量控制。<br>
功能五:差错控制（帧错/位错）。</p>
<p>封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。<br>
帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。<br>
组帧的四种方法:1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。</p>
<p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<p>决定局域网的主要要素为:网络拓扑，传输介质与介质访问控制方法。</p>
<p>局域网介质访问控制方法<br>
1.CSMA/CD常用于总线型局域网，也用于树型网络<br>
2令牌总线常用于总线型局域网，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。3.令牌环用于环形局域网，如令牌环网</p>
<p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD(载波监听多路访问及冲突检测）技术。</p>
<p>以太网两个标准<br>
DIX Ethernet V2:第一个局域网产品（以太网）规约。<br>
IEEE 802.3: IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动）</p>
<p>以太网提供无连接、不可靠的服务</p>
<p>以太网只实现无差错接收，不实现可靠传输</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。<br>
以太网拓扑:逻辑上总线型，物理上星型。</p>
<p>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。</p>
<p>物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。</p>
<p>采用曼彻斯特编码。</p>
<p>采用CSMA/CD介质访问控制。</p>
<p>计算机与外界有局域网的连接是通过通信适配器的。</p>
<p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符</p>
<p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准。</p>
<p>点对点协议PPP ( Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。<br>
只支持全双工链路。</p>
<p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪-一个接口，或者是把它丢弃(即过滤)。</p>
<h2 id="网络层">网络层</h2>
<p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层传输单位是数据报。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML基础]]></title>
        <id>https://xmweijh.github.io/post/html-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/html-ji-chu/">
        </link>
        <updated>2020-04-30T00:53:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html">HTML</h2>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)  是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>常见状态码</strong></p>
<ul>
<li>200 ：成功。</li>
<li>400 ：客户端请求有语法错误，服务器端不能理解。</li>
<li>401 ：该请求可能未经过授权。</li>
<li>403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。</li>
<li>404 ：该资源没找到。</li>
<li>500 ：服务器端发生了一个不可预知的错误。</li>
<li>503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。</li>
</ul>
<p>HTML（超文本标记语言）是一种用于创建网页的标准标记语言。 HTML 不需要编译，可以直接由浏览器执行，它的解析依赖于浏览器的内核。 它不是一种编程语言，而是一种标记语言。</p>
<p>一个网页的基本结构：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>&lt;!DOCTYPE html&gt;是我们的文档声明头。他告诉了浏览器，本文档处理的是 HTML 文档。<code>html</code> 标签即根元素，此处表示文档的开始。<code>head</code> 标签是网页的头部，设置网页的相关信息。<code>title</code> 标签设置网页标题。<code>body</code> 标签定义文档的主体，也就是我们的主要内容。</p>
<p>在 HTML 中满足以下格式的内容即为注释，被注释的内容将不会被渲染和显示。</p>
<pre><code>&lt;!-- 在此处写注释 --&gt;
</code></pre>
<p>**注：**在开始标签中有一个惊叹号，但是结束标签中没有。浏览器不会显示注释，但是能够帮助记录。</p>
<p>HTML 标签的大小写无关的，例如 <code>和</code> 表示的意思是一样的，都代表“主体”，推荐使用小写。</p>
<p><strong>双标签（双标记）</strong></p>
<p>双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名&gt;&lt;/标记名&gt;
</code></pre>
<p>常见的双标签有：</p>
<pre><code class="language-html">&lt;html&gt;&lt;/html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;body&gt;&lt;/body&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;span&gt;&lt;/span&gt;
&lt;a&gt;&lt;/a&gt;
&lt;ul&gt;&lt;/ul&gt;
</code></pre>
<p><strong>单标签（单标记）</strong></p>
<p>单标记也称空标记，是指用一个标记符号即可完整地描述某个功能的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名/&gt;
</code></pre>
<p>常见的单标签有：</p>
<pre><code class="language-html">&lt;br /&gt;
&lt;!--换行--&gt;
&lt;hr /&gt;
&lt;!--水平分隔线--&gt;
&lt;meta /&gt;
&lt;img /&gt;
</code></pre>
<p><strong>标签的关系</strong></p>
<ul>
<li>嵌套关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;title&gt; &lt;/title&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>并列关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
</code></pre>
<p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>例子：</p>
<pre><code class="language-html">&lt;p&gt;I Love You&lt;/p&gt;
</code></pre>
<p>注：这个元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 <code>，以及一个结束标签</code>。元素内容是：<code>I Love You</code>。</p>
<p><strong>h 系类标签</strong></p>
<p><code>h</code> 标签有六种 <code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>，它代表着我们的标题。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;我是一级标题&lt;/h1&gt;
    &lt;h2&gt;我是二级标题&lt;/h2&gt;
    &lt;h3&gt;我是三级标题&lt;/h3&gt;
    &lt;h4&gt;我是四级标题&lt;/h4&gt;
    &lt;h5&gt;我是五级标题&lt;/h5&gt;
    &lt;h6&gt;我是六级标题&lt;/h6&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>p 标签</strong></p>
<p><code>p</code> 标签是我们的文本标签。</p>
<p><strong>图片标签</strong></p>
<p>HTML 的图像是通过标签 &lt;img&gt;来定义的。</p>
<p><strong>a 标签</strong></p>
<p><a> 标签是超链接标签，意思就是我们点击它可以跳转到一个网页。</p>
<p><strong>div 标签</strong></p>
<div> 标签是一个块级元素，块级元素占据其父元素（容器）的整个空间，你可以把它想成一个盒子。 <div> 能够设置其宽高
<p><strong>换行标签和空格字符</strong></p>
<p>在浏览器显示页面时，浏览器会移除源代码中多余的空格和空行，所有连续的空格或空行都会被认为是一个空格。如果希望在不产生一个新段落的情况下换行，可以使用&lt;br/&gt;标签。如果想使用空格的话可以使用&amp;nbsp;字符</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;p&gt;这是一段文字 前面有很多空格但是只显示一个&lt;/p&gt;
  &lt;p&gt;这是一段文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用了空格字符&lt;/p&gt;
  &lt;br /&gt;
  &lt;p&gt;上面是换行符&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p><strong>水平分割线</strong></p>
<p>&lt;hr/&gt; 标签用于在 HTML 页面中创建一条水平线。</p>
<p>标签 <div> 可将网页页面分割成不同的独立部分，通常用于定义文档中的区域或节。该标签是一个块级元素，浏览器会自动在 <div> 和 </div> 所标记的区域前后自动放置一个换行符。</p>
<p>标签 <span> 通常作为文本的容器，它没有特定的含义和样式，只有与 CSS 同时使用才可以为指定文本设置样式属性。该标签是一个内联元素，他与块级元素相反，内联元素不会自动在前后自动放置换行符，因此内联元素会默认显示在同一行。</p>
<p>无序列表是一个项目的列表，此列项目使用实心圆、空心圆、方块进行标记，无序列表使用 <ul> 标签。同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 <ol> 标签。每个列表项始于 <li> 标签。</p>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>无序列表和有序列表的 type 属性：</strong></p>
<p>type 属性定义了列表项前项目符号的类型。</p>
<p>&lt;ul&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>disc（默认）</td>
<td>实心圆</td>
</tr>
<tr>
<td>circle</td>
<td>空心圆</td>
</tr>
<tr>
<td>square</td>
<td>小方块</td>
</tr>
</tbody>
</table>
<p>&lt;ol&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1（默认）</td>
<td>数字表示（1，2，3...)</td>
</tr>
<tr>
<td>A</td>
<td>大写字母表示（A,B,C...)</td>
</tr>
<tr>
<td>a</td>
<td>小写字母表示（a,b,c...)</td>
</tr>
<tr>
<td>I</td>
<td>大写罗马数字表示(I,II,III…)</td>
</tr>
<tr>
<td>i</td>
<td>小写罗马数字表示(i,ii,iii…)</td>
</tr>
</tbody>
</table>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul type=&quot;circle&quot;&gt;
  &lt;li&gt;空心圆列表项1&lt;/li&gt;
  &lt;li&gt;空心圆列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol type=&quot;A&quot;&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>自定义列表（dl）</strong></p>
<p>定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt;开始。自定义列表的列表项前没有任何项目符号。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<p><strong>HTML 样式实例 - 背景颜色</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;background-color:red&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过 <code>&quot;background-color&quot;</code> 属性值的设置来给背景设置颜色。</p>
<p><strong>HTML 样式实例 - 字体、颜色和尺寸</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;font-family:arial;color:green;font-size:50px;&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过对 <code>font-family</code> 属性值的设置来设置字体，通过对 <code>color</code> 属性值的设置来设置颜色，通过对 <code>font-size</code> 属性值的设计来设计字体大小。</p>
<p><strong>HTML 样式实例 - 文本对齐</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1 style=&quot;text-align:center&quot;&gt;xxx&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<pre><code class="language-html">&lt;table&gt;   //&lt;table border=&quot;1&quot;&gt;给表格加上边框
  &lt;tr&gt;
    &lt;td&gt;第一行第一列&lt;/td&gt;
    &lt;td&gt;第一行第二列&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;第二行第一列&lt;/td&gt;
    &lt;td&gt;第二行第二列&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>表格一般都有标题，在 HTML 中表格标题通过 <caption> 定义。</p>
<figure data-type="image" tabindex="1"><img src="https://doc.shiyanlou.com/document-uid897174labid9222timestamp1545370661694.png/wm" alt="img" loading="lazy"></figure>
<p>表格的表头使用 <th> 标签进行定义，表头通常用于列名字。</p>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt;
  &lt;caption&gt;
    支出表
  &lt;/caption&gt;
  &lt;tr&gt;
    &lt;th&gt;支出&lt;/th&gt;
    &lt;th&gt;备注&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;32&lt;/td&gt;
    &lt;td&gt;买苹果&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;24&lt;/td&gt;
    &lt;td&gt;买饮料&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>绘制表格的时候，我们常常需要合并单元格，而在 HTML 中提供了 colspan（合并行）和 rowspan（合并列）属性来帮助我们实现这一效果。</p>
<blockquote>
<p>colspan 又称跨列，rowspan 又称跨行。</p>
</blockquote>
<p>设置 <code>rowspan=&quot;2&quot;</code> 表示合并该列上的两个单元格，同样的我们可以通过设置 <code>colspan</code> 来合并行</p>
<p>在网页中可以使用很多个 div，在网页制作中，使用 div 可以将网页中的任何元素布局到网页中的任何位置。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;div style=&quot;样式设置&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>table 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>理解比较简单。</li>
<li>不同的浏览器看到的效果一般相同。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>显示样式和数据绑定在一起。</li>
<li>布局的时候灵活度不高。</li>
<li>一个页面可能会有大量的 table 元素，代码冗余度高。</li>
<li>增加带宽。</li>
<li>搜索引擎不喜欢这样的布局。</li>
</ol>
<p>div 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>符合 W3C 标准。</li>
<li>搜索引擎更加友好。</li>
<li>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</li>
<li>节省代宽，代码冗余度低。</li>
<li>表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。</li>
</ol>
<p>&lt;form&gt;标签用于创建 HTML 表单，常见的表单格式为：</p>
<pre><code class="language-html">&lt;form name=&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;&lt;/form&gt;
</code></pre>
<ul>
<li>name：定义表单的名字。</li>
<li>method：定义表单结果从浏览器传送到服务器的方式，默认参数为：<code>get</code> 。<code>post</code> 安全性更高，因此常用作传输密码等，而 <code>get</code> 安全性较低，一般用于查询数据。</li>
<li>action：发送数据要去的地址。它的值必须是一个有效的 URL，可以是相对 URL 也可以是绝对 URL。如果没有提供此属性或者 <code>action=&quot;#&quot;</code>，则数据将被发送到包含表单的页面的 URL。</li>
</ul>
<p>在网页中最常见的表单元素就是文字字段，用户可以在文字字段内输入字符或者单行文本。 语法：</p>
<pre><code class="language-html">&lt;input
  type=&quot;text&quot;
  name=&quot;控件名称&quot;
  value=&quot;文字字段的默认取值&quot;
  size=&quot;控件的长度&quot;
  maxlength=&quot;最长字符数&quot;
/&gt;
</code></pre>
<p>该语法包含了许多参数，除了 <code>type</code> 参数以外，其他的参数都是可选的</p>
<p>举个例子：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;40&quot; value=&quot;10&quot; maxlength=&quot;3&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>密码输入框</strong></p>
<p>密码输入框是一种特殊的文字字段，他的各个属性和文字字段是相同的，但是输入进密码输入框的字符全部是“*”表示，保证周围人看不见输入的文本。</p>
<pre><code class="language-html">&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;
</code></pre>
<p><strong>单选按钮</strong></p>
<p>单选按钮可以使用户从选择列表中选择一个选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked /&gt;男&lt;br /&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; /&gt;女
&lt;/form&gt;
</code></pre>
<p>几个单选按钮可以连接在一起，只需要把它们的 <code>name</code> 值设置为相同的。同一组中只有一个按钮可以同时被选。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，且不会随表单提交。 可以尝试如果 name 不相同或者没有 name 会是什么情况。</p>
<p>复选框可以让用户从一个选项列表中选择超出一个的选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;music&quot; checked /&gt;音乐&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;art&quot; /&gt;美术&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;math&quot; /&gt;数学&lt;br /&gt;
&lt;/form&gt;
</code></pre>
<p>复选框可以拥有自己的名字，并不需要属于一个组。</p>
<p><strong>按钮</strong><br>
HTML 表单中，有三种按钮：提交按钮，重置按钮，匿名按钮。我们可以使用 <button> 元素或者 <input> 元素来创建一个按钮。type 属性的值指定显示什么类型的按钮。</p>
<p><strong>提交按钮（submit）</strong></p>
<p>用于发送表单数据给服务器。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; value=&quot;输入的内容&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;
    This a submit button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>重置按钮（reset）</strong></p>
<p>重置按钮用来清除用户在页面中输入的信息。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; /&gt;
  &lt;button type=&quot;reset&quot;&gt;
    This a reset button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>在文本框中输入内容，点击按钮即可清除。</p>
<p><strong>匿名按钮（button）</strong></p>
<p>没有自动生效的按钮，但是可以使用 JavaScript 代码进行定制。如果你省略了 <code>type</code> 属性，那么这就是默认值。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;button&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;input type=&quot;button&quot; value=&quot;This is a anonymous button&quot; /&gt;
</code></pre>
<p>不管使用的是 <button> 元素还是 <input> 元素，按钮的行为都是一样的。它们的不同点在于：</p>
<p>从前面的例子中也可以看出 <button> 元素允许你使用 HTML 内容作为其标记内容，但 <input> 元素只接受纯文本内容。<br>
使用 <button> 元素，可以有一个不同于按钮标签的值（通过将其设置为 value 属性）。</p>
<p><strong>下拉菜单</strong></p>
<p>下拉菜单能够节省页面空间，正常状态下显示一个选项，单击展开所以选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>注意：下拉菜单的宽度是由 <option> 标记中包含的最长文本的宽度决定的。</p>
<p><strong>列表项</strong></p>
<p>在页面中列表项可以显示出几条信息，一旦超出这个信息量，在列表项右侧会出现滚动条，拖动滚动条可以看到所有选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot; size=&quot;2&quot; multiple=&quot;multiple&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>当用户想要填入多行文本时，就应该使用文本域而不是文本字段。文本域使用 <textarea> 标记。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  留下您的联系方式：
  &lt;textarea name=&quot;textarea&quot; cols=&quot;35&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
&lt;/form&gt;
</code></pre>
<p><code>clos</code> 代表列数，<code>rows</code> 代表行数。</p>
<p><strong>图像标签</strong><br>
在 HTML 中，图像由 <img> 标签定义。语法为：</p>
<pre><code class="language-html">&lt;img src=&quot;url&quot; alt=&quot;&quot; /&gt;
</code></pre>
<p><img> 是空标签，它只包含属性，没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 的值是图像文件的 URL，也就是引用该图像的文件的的绝对路径或相对路径。alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。title 设置鼠标悬停时显示的内容（一般不用设置）。此外还可以通过设置 width 和 height 的值来设置图片的宽和高。</p>
<p><strong>框架</strong></p>
<p>使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;iframe src=&quot;URL&quot;&gt;
  &lt;!-- URL指向不同的页面 --&gt;
&lt;/iframe&gt;
</code></pre>
<p><strong>iframe - 设置高度与宽度</strong></p>
<p>属性默认以像素为单位,但是你可以指定其按比例显示 (如：&quot;60%&quot;)。</p>
<p><strong>iframe - 移除边框</strong></p>
<p><code>frameborder</code> 属性用于定义 iframe 表示是否显示边框。设置属性值为 &quot;0&quot; 移除 iframe 的边框:</p>
<p>在标准 HTML5 中， <html> 和 <body> 标签是可以省略的。</p>
<p>HTML5 元素名可以使用大写和小写字母，建议使用小写字母，会显得更加好看一点，千万不要使用大小写混写，那样会显得很不专业。</p>
<p>图片通常使用 <code>alt</code> 属性。 在图片不能显示时，它能替代图片显示。建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。</p>
<p>等号的前后可以使用空格，也可以不使用，推荐少用空格。</p>
<p>不要无缘无故的添加空行，一般一个模块或一个功能添加一个空行便于区分，缩进使用两个空格，不建议使用 Tab。</p>
<p><strong>section 标签</strong></p>
<p>&lt;section&gt; 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。不要把 <section> 元素作为一个普通的 div 容器来使用。一般来说，一个 <section> 应该出现在文档大纲中。</p>
<p><strong>article 标签</strong></p>
<p>&lt;article&gt; 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。</p>
<p><strong>nav 标签</strong></p>
<p>&lt;nav&gt; 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。</p>
<p><strong>header 标签</strong></p>
<p>&lt;header&gt; 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。</p>
<p>通常 header 标签至少包含一个标题标记（h1-h6），还可以包括 hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。</p>
<p><strong>footer 标签</strong></p>
<p>&lt;footer&gt; 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。</p>
<p><strong>aside 标签</strong></p>
<p>&lt;aside&gt; 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</p>
<p><strong>datalist 元素</strong><br>
datalist 元素用于为文本框提供一个可供选择的列表，使用 datalist 元素来为表单小部件提供建议的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 <input> 元素)。</p>
<p>一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本。通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。</p>
<p><strong>autocomplete 属性</strong><br>
autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。当 autocomplete 属性值为 on 时表示启用自动完成功能，为 off 时表示关闭。autocomplete 属性适用于 <form>，以及下面的 <input> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p>
<p><strong>autofocus 属性</strong><br>
autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 <input> 标签的类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://xmweijh.github.io/post/sql-yu-yan/</id>
        <link href="https://xmweijh.github.io/post/sql-yu-yan/">
        </link>
        <updated>2020-04-28T00:13:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="select">SELECT</h3>
<pre><code>SELECT column_name,column_name FROM table_name;//选出特定列

SELECT * FROM table_name;//选取所有列

SELECT DISTINCT column_name,column_name
FROM table_name;//返回列中不同值（去除掉重复值）

SELECT column_name new_column_name FROM table_name;使用列别名可以改变查询结果的列标题
</code></pre>
<h3 id="where">WHERE</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
WHERE column_name operator value;//提取那些满足指定条件的记录
</code></pre>
<p>使用<strong>单引号来环绕文本值</strong>（大部分数据库系统也接受双引号）。如果是<strong>数值字段，请不要使用引号</strong>。</p>
<p>可以在 WHERE 子句中使用的运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 !=</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left">在某个范围内</td>
</tr>
<tr>
<td style="text-align:left">LIKE</td>
<td style="text-align:left">搜索某种模式</td>
</tr>
<tr>
<td style="text-align:left">IN</td>
<td style="text-align:left">指定针对某个列的多个可能值</td>
</tr>
</tbody>
</table>
<p>逻辑运算    not        and         or  （优先级从左到右下降）</p>
<p>空值判断：  is null</p>
<h3 id="order-by">ORDER BY</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;//对结果集按照一个列或者多个列进行排序,默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。
ORDER BY 多列的时候，先按照第一个column name排序，再按照第二个column name排序
desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。
</code></pre>
<h3 id="insert-into">INSERT INTO</h3>
<pre><code>INSERT INTO table_name
VALUES (value1,value2,value3,...);//无需指定要插入数据的列名，只需提供被插入的值即可

INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);//指定列名及被插入的值
</code></pre>
<h3 id="update">UPDATE</h3>
<pre><code>UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;//更新表中已存在的记录。
如果您省略了 WHERE 子句，所有的记录都将被更新！
</code></pre>
<h3 id="delete">DELETE</h3>
<pre><code>DELETE FROM table_name
WHERE some_column=some_value;//删除表中的行。
如果您省略了 WHERE 子句，所有的记录都将被删除！
</code></pre>
<h3 id="select-top-limit-rownum-子句">SELECT TOP, LIMIT, ROWNUM 子句</h3>
<pre><code>SELECT TOP number|percent column_name(s)
FROM table_name;

SELECT column_name(s)
FROM table_name
LIMIT number;

SELECT column_name(s)
FROM table_name
WHERE ROWNUM &lt;= number;//用于规定要返回的记录的数目
</code></pre>
<h3 id="like">LIKE</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;//操作符用于在 WHERE 子句中搜索列中的指定模式。
</code></pre>
<p>'%a'   //以a结尾的数据</p>
<p>'a%'   //以a开头的数据</p>
<p>'%a%'   //含有a的数据</p>
<p>‘_a_’   //三位且中间字母是a的</p>
<p>'_a'   //两位且结尾字母是a的</p>
<p>'a_'   //两位且开头字母是a的</p>
<h3 id="sql-通配符">SQL 通配符</h3>
<p>在 SQL 中，通配符与 SQL LIKE 操作符一起使用。</p>
<p>SQL 通配符用于搜索表中的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">替代 0 个或多个字符</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">替代一个字符</td>
</tr>
<tr>
<td style="text-align:left">[<em>charlist</em>]</td>
<td style="text-align:left">字符列中的任何单一字符</td>
</tr>
<tr>
<td style="text-align:left">[^<em>charlist</em>] 或 [!<em>charlist</em>]</td>
<td style="text-align:left">不在字符列中的任何单一字符</td>
</tr>
</tbody>
</table>
<h3 id="in">IN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);//IN 操作符允许您在 WHERE 子句中规定多个值。
</code></pre>
<h3 id="between">BETWEEN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;//用于选取介于两个值之间的数据范围内的值。
</code></pre>
<h3 id="sql-别名">SQL 别名</h3>
<pre><code>SELECT column_name AS alias_name
FROM table_name;//列的 SQL 别名语法

SELECT column_name(s)
FROM table_name AS alias_name;//表的 SQL 别名语法
</code></pre>
<h3 id="sql-连接join">SQL 连接(JOIN)</h3>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
</ul>
<p><strong>SQL INNER JOIN 语法</strong></p>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_innerjoin.gif" alt="SQL INNER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
JOIN table2
ON table1.column_name=table2.column_name;//INNER JOIN 与 JOIN 是相同的。
</code></pre>
<p>在使用 <strong>join</strong> 时，<strong>on</strong> 和 <strong>where</strong> 条件的区别如下：</p>
<ul>
<li>1、 <strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。</li>
<li>2、<strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 <strong>left join</strong> 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ul>
<p><strong>SQL LEFT JOIN 语法</strong></p>
<p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_leftjoin.gif" alt="SQL LEFT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
LEFT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，LEFT JOIN 称为 LEFT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL RIGHT JOIN 语法</strong></p>
<p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_rightjoin.gif" alt="SQL RIGHT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
RIGHT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，RIGHT JOIN 称为 RIGHT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL FULL OUTER JOIN 语法</strong></p>
<p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_fulljoin.gif" alt="SQL FULL OUTER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre>
<h3 id="union">UNION</h3>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<pre><code>SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
//默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
</code></pre>
<h3 id="select-into">SELECT INTO</h3>
<p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
<pre><code>SELECT *
INTO newtable [IN externaldb]
FROM table1;

SELECT column_name(s)
INTO newtable [IN externaldb]
FROM table1;
</code></pre>
<h3 id="insert-into-select">INSERT INTO SELECT</h3>
<p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
<pre><code>INSERT INTO table2
SELECT * FROM table1;

INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
</code></pre>
<h3 id="create-database">CREATE DATABASE</h3>
<pre><code>CREATE DATABASE dbname;//用于创建数据库。
</code></pre>
<h3 id="create-table">CREATE TABLE</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);//用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。
  //column_name 参数规定表中列的名称。
  //data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。
  //size 参数规定表中列的最大长度。
</code></pre>
<h3 id="sql-约束constraints">SQL 约束（Constraints）</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);//用于规定表中的数据规则。
</code></pre>
<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li>
<p><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</p>
<p>​	NOT NULL 约束强制列不接受 NULL 值。</p>
<p>​	NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或	者更新记录。</p>
</li>
<li>
<p><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</p>
<p>​	UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>​	UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>​	PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。</p>
<p>​	请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
</li>
<li>
<p><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p>
<p>​	PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>
<p>​	主键必须包含唯一的值。</p>
<p>​	主键列不能包含 NULL 值。</p>
<p>​	每个表都应该有一个主键，并且每个表只能有一个主键。</p>
</li>
<li>
<p><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</p>
</li>
<li>
<p><strong>CHECK</strong> - 保证列中的值符合指定的条件。</p>
<p>​	如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>
<p>​	如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限	    	制。</p>
</li>
<li>
<p><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
</li>
</ul>
<h3 id="create-index-语句">CREATE INDEX 语句</h3>
<p>CREATE INDEX 语句用于在表中创建索引。</p>
<p>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</p>
<pre><code>CREATE INDEX index_name
ON table_name (column_name)//在表上创建一个简单的索引。允许使用重复的值

CREATE UNIQUE INDEX index_name
ON table_name (column_name)//在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着						   //两个行不能拥有相同的索引值
</code></pre>
<h3 id="drop">DROP</h3>
<p>通过使用 DROP 语句，可以轻松地删除索引、表和数据库。</p>
<h3 id="alter-table">ALTER TABLE</h3>
<p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<h3 id="sql-alter-table-语法">SQL ALTER TABLE 语法</h3>
<p>如需在表中添加列，请使用下面的语法:</p>
<pre><code>ALTER TABLE table_name
ADD column_name datatype
</code></pre>
<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<pre><code>ALTER TABLE table_name
DROP COLUMN column_name
</code></pre>
<h3 id="auto-increment">AUTO INCREMENT</h3>
<p>Auto-increment 会在新记录插入表中时生成一个唯一的数字。</p>
<h3 id="视图views">视图（Views）</h3>
<p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p>SQL CREATE VIEW 语法</p>
<pre><code>CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>**注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<p>您可以使用下面的语法来更新视图：</p>
<p>SQL CREATE OR REPLACE VIEW 语法</p>
<pre><code>CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>您可以通过 DROP VIEW 命令来删除视图。</p>
<p>SQL DROP VIEW 语法</p>
<pre><code>DROP VIEW view_name
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://xmweijh.github.io/post/python/</id>
        <link href="https://xmweijh.github.io/post/python/">
        </link>
        <updated>2020-04-04T03:00:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<p>print括号中可以单引号或者双引号</p>
<p>多行打印时,使用三个引号</p>
<pre><code>print('''



''')
</code></pre>
<p>true类型只用True 和False 注意大小写</p>
<p>空值 None 表示无，与0 不同</p>
<p>input（输入）</p>
<p>当输入输出括号中字符串中还有引号，需要转义符\区别</p>
<pre><code>&gt;&gt;&gt; string = 'hello_shiyanlou'
&gt;&gt;&gt; string[0]  # 获取第一个字符
'h'
&gt;&gt;&gt; string[-2]  # 获取倒数第二个字符
'o'
</code></pre>
<p>注意负值代表倒数第几个（倒数不从0开始，毕竟 -0 = 0）</p>
<pre><code>print('你叫'+name+'，今年' + age + '岁了')
#等价于
print('你叫{}，今年{}岁了'.format(name,age))
#下面代码代表保留2位小数
print(&quot;{:.2f}&quot;.format(3.1415926))
</code></pre>
<p>#单行注释</p>
<p>逻辑运算符 and 	or 	not</p>
<p>条件判断</p>
<pre><code>if:
    ***
elif:
	***
else:
	***
</code></pre>
<p>后面加<strong>冒号</strong>  if下面的代码4个缩进</p>
<p>input 读取的为字符串类型</p>
<pre><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; if a&lt;1:
...     print(&quot;a&lt;1&quot;)
... else:
...     pass
...
&gt;&gt;&gt; #程序没有报错
</code></pre>
<p>pass会跳过这里的代码执行后面的代码</p>
<pre><code>for 元素 in 集合:
    do something 
</code></pre>
<p>range(x)函数 可以生成一个从0到x-1的整数序列</p>
<p><code>range()</code> 函数返回的并不是列表而是一种可迭代对象：</p>
<p>range(a,b)  a 到b-1，包头不包尾</p>
<pre><code>while condition:
   do something
</code></pre>
<p>所以如果是用空格，就一直用空格缩进，不要使用制表符。</p>
<p>建议遵守以下约定：</p>
<ul>
<li>使用 4 个空格来缩进</li>
<li>永远不要混用空格和制表符</li>
<li>在函数之间空一行</li>
<li>在类之间空两行</li>
<li>字典，列表，元组以及参数列表中，在 <code>,</code> 后添加一个空格。对于字典，<code>:</code> 后面也添加一个空格</li>
<li>在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：<code>a = f(1, 2) + g(3, 4)</code></li>
</ul>
<p>// 取整除 - 返回商的整数部分（<strong>向下取整</strong>）</p>
<p><code>divmod(num1, num2)</code> 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 <code>*</code> 运算符拆封这个元组，得到这两个值。</p>
<p>默认情况下，<code>print()</code> 除了打印你提供的字符串之外，还会打印一个换行符   <code>print()</code> 的另一个参数 <code>end</code> 来替换这个换行符</p>
<pre><code> print(b, end=' ') 
 print(&quot;-&quot; * 50) #打印50个-
  #列表的元素不必是同一类型
 &gt;&gt;&gt; a = [ 1, 342, 223, 'India', 'Fedora'] 
</code></pre>
<p>Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。 对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 <code>a[2:4]</code> 是 2。 返回a[2]和a[3]两个</p>
<p>切片操作还可以设置步长</p>
<pre><code>&gt;&gt;&gt; a[1::2]
[342, 'India']
</code></pre>
<p>意思是，从切片索引 1 到列表末尾，每隔两个元素取值。</p>
<p><code>len()</code> 我们可以获得列表的长度</p>
<p>如果你想要检查列表是否为空</p>
<pre><code>if list_name: # 列表不为空
    pass
else: # 列表为空
    pass
</code></pre>
<h3 id="列表">列表</h3>
<p><code>a.append(45)</code> 添加元素 <code>45</code> 到列表末尾。有些时候我们需要将数据插入到列表的任何位置，这时我们可以使用列表的 <code>insert()</code> 方法。   <code>count(s)</code> 会返回列表元素中 <code>s</code> 的数量。  如果你想要在列表中移除任意指定值，你需要使用 <code>remove()</code> 方法。  <code>a.reverse()</code> 反转整个列表。 将一个列表的所有元素添加到另一个列表的末尾呢，可以使用列表的 <code>extend()</code> 方法。  给列表排序，我们使用列表的 <code>sort()</code> 方法， 用 <code>del</code> 关键字删除指定位置的列表元素。</p>
<pre><code>&gt;&gt;&gt; a = [23, 45, 1, -3434, 43624356, 234]
&gt;&gt;&gt; a.append(45)
&gt;&gt;&gt;  a.insert(0, 1)
&gt;&gt;&gt; a.count(45)
</code></pre>
<h4 id="栈">栈</h4>
<p><code>pop()</code>。传入一个参数 i 即 <code>pop(i)</code> 会将第 i 个元素弹出。 栈使用<code>a.pop()</code> 将顶部元素弹出， <code>a.append(x)</code> 入栈</p>
<h4 id="队列">队列</h4>
<p><code>a.pop(0)</code> 出队 <code>a.append(x)</code> 入队</p>
<h4 id="列表推导式">列表推导式</h4>
<pre><code>squares = [x**2 for x in range(10)]
&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
#等价于
&gt;&gt;&gt; combs = []
&gt;&gt;&gt; for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
&gt;&gt;&gt; combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<h3 id="元组">元组</h3>
<p>元组是由数个逗号分割的值组成。</p>
<pre><code>&gt;&gt;&gt; a = 'Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus'
&gt;&gt;&gt; a
('Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus')
&gt;&gt;&gt; a[1]
'ShiYanLou'
&gt;&gt;&gt; for x in a:
...     print(x, end=' ')
...
Fedora ShiYanLou Kubuntu Pardus
</code></pre>
<p>以对任何一个元组执行拆封操作并赋值给多个变量</p>
<pre><code>&gt;&gt;&gt; x, y = divmod(15,2)
&gt;&gt;&gt; x
7
&gt;&gt;&gt; y
1
</code></pre>
<p>元组是不可变类型，这意味着你<strong>不能在元组内删除或添加或编辑</strong>任何值。</p>
<p>要创建只含有一个元素的元组，在值后面跟一个<strong>逗号</strong>。</p>
<p>通过内建函数 <code>type()</code> 你可以知道任意变量的数据类型。</p>
<h3 id="集合">集合</h3>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p>
<p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典</p>
<pre><code>&gt;&gt;&gt; basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
&gt;&gt;&gt; print(basket)                      # 你可以看到重复的元素被去除
{'orange', 'banana', 'pear', 'apple'}
&gt;&gt;&gt; 'orange' in basket
True
&gt;&gt;&gt; 'crabgrass' in basket
False

&gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作
...
&gt;&gt;&gt; a = set('abracadabra')
&gt;&gt;&gt; b = set('alacazam')
&gt;&gt;&gt; a                                  # a 去重后的字母
{'a', 'r', 'b', 'c', 'd'}
&gt;&gt;&gt; a - b                              # a 有而 b 没有的字母
{'r', 'd', 'b'}
&gt;&gt;&gt; a | b                              # 存在于 a 或 b 的字母
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
&gt;&gt;&gt; a &amp; b                              # a 和 b 都有的字母
{'a', 'c'}
&gt;&gt;&gt; a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{'r', 'd', 'b', 'm', 'z', 'l'}
#添加或弹出元素
&gt;&gt;&gt; a = {'a','e','h','g'}
&gt;&gt;&gt; a.pop()  # pop 方法随机删除一个元素并打印
'h'
&gt;&gt;&gt; a.add('c')
&gt;&gt;&gt; a
{'c', 'e', 'g', 'a'}
</code></pre>
<h3 id="字典">字典</h3>
<p>字典是是无序的键值对（<code>key:value</code>）集合，同一个字典内的键必须是互不相同的。一对大括号 <code>{}</code> 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。</p>
<pre><code>&gt;&gt;&gt; data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
&gt;&gt;&gt; data['kart_']
'Debian'
&gt;&gt;&gt; data['parthan'] = 'Ubuntu'
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
# 使用del关键字删除任意指定的键值对
&gt;&gt;&gt; del data['kushal']
&gt;&gt;&gt; data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
# 使用 in 关键字查询指定的键是否在字典中
&gt;&gt;&gt; 'ShiYanLou' in data
False
#必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作
#为键。dict() 可以从包含键值对的元组中创建字典。
&gt;&gt;&gt; dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
#遍历一个字典，使用字典的 items() 方法。
&gt;&gt;&gt; data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
&gt;&gt;&gt; for x, y in data.items():
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu
</code></pre>
<p>许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。我们可以使用 <code>dict.setdefault(key, default)</code> 更有效率的完成这个事情。</p>
<pre><code>&gt;&gt;&gt; data = {}
&gt;&gt;&gt; data.setdefault('names', []).append('Ruby')
&gt;&gt;&gt; data
{'names': ['Ruby']}
&gt;&gt;&gt; data.setdefault('names', []).append('Python')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python']}
&gt;&gt;&gt; data.setdefault('names', []).append('C')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python', 'C']}
</code></pre>
<p>试图索引一个不存在的键将会抛出一个 <em>keyError</em> 错误。我们可以使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p>
<p>如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code>。</p>
<pre><code>&gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']):
...     print(i, j)
...
0 a
1 b
2 c
</code></pre>
<p>要同时遍历两个序列类型，你可以使用 <code>zip()</code> 函数。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = ['Pradeepto', 'Kushal']
&gt;&gt;&gt; b = ['OpenSUSE', 'Fedora']
&gt;&gt;&gt; for x, y in zip(a, b):
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora
</code></pre>
<h3 id="字符串">字符串</h3>
<p><code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写。</p>
<p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写版本。</p>
<p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本</p>
<p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字</p>
<p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p>
<pre><code>&gt;&gt;&gt; s = &quot;1234&quot;
&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字
True
&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;
&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写
False
&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;
&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式
True
&gt;&gt;&gt; s = &quot;CHINA&quot;
&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写
True
</code></pre>
<p><code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>），它返回一个包含所有分割后的字符串的列表。</p>
<p><code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p>
<p>最简单的一个是 <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符</p>
<p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1</p>
<p>格式化操作符（%）</p>
<pre><code>print(&quot;my name is %s.I am %d years old&quot; % ('Shixiaolou',4))
</code></pre>
<p>在这个例子中，<code>%s</code> 为第一个格式符，表示一个字符串；<code>%d</code> 为第二个格式符，表示一个整数。格式符为真实值预留位置，并控制显示的格式。常用的有：</p>
<blockquote>
<p>%s 字符串（用 str() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%r 字符串（用 repr() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%d 十进制整数</p>
</blockquote>
<blockquote>
<p>%f 浮点数</p>
</blockquote>
<blockquote>
<p>%% 字符“%”</p>
</blockquote>
<h3 id="函数">函数</h3>
<p><code>def</code> 来定义一个函数</p>
<pre><code>def 函数名(参数):
    语句1
    语句2
</code></pre>
<p><code>global</code> 关键字，对函数中的a标志为全局变量 ， 让函数内部使用全局变量的 a。</p>
<p>函数的参数变量可以有默认值，也就是说如果我们对指定的参数变量没有给出任何值则会赋其默认值。</p>
<pre><code>&gt;&gt;&gt; def test(a , b=-99):
...     if a &gt; b:
...         return True
...     else:
...         return False
</code></pre>
<p>在函数的参数列表写出 <code>b = -99</code>。这表示如果调用者未给出 <code>b</code> 的值，那么 <code>b</code> 的值默认为 <code>-99</code>。</p>
<pre><code>&gt;&gt;&gt; test(12, 23)
False
&gt;&gt;&gt; test(12)
True
</code></pre>
<p>有两个非常重要的地方，第一个是具有默认值的参数后面不能再有普通参数，比如 <code>f(a,b=90,c)</code> 就是错误的。</p>
<p>第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。</p>
<pre><code>&gt;&gt;&gt; def f(a, data=[]):
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[1, 2]
&gt;&gt;&gt; print(f(3))
[1, 2, 3]
</code></pre>
<pre><code>&gt;&gt;&gt; def f(a, data=None):
...     if data is None:
...         data = []
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[2]
</code></pre>
<p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<ul>
<li>使用一个或多个函数作为参数</li>
<li>返回另一个函数作为输出</li>
</ul>
<p>Python 里的任何函数都可以作为高阶函数</p>
<pre><code># 创建一个函数，将参数列表中每个元素都变成全大写
&gt;&gt;&gt; def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
&gt;&gt;&gt; def test(h, l):
...     return h(l)
...
&gt;&gt;&gt; l = ['python', 'Linux', 'Git']
# 运行高阶函数，返回预期的结果
&gt;&gt;&gt; test(high, l)
['PYTHON', 'LINUX', 'GIT']
</code></pre>
<p><code>map</code> 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。</p>
<h3 id="文件">文件</h3>
<p>使用 <code>open()</code> 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li>
<p><code>&quot;r&quot;</code>，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</p>
</li>
<li>
<p><code>&quot;w&quot;</code>，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</p>
</li>
<li>
<p><code>&quot;a&quot;</code>，以追加模式打开，写入到文件中的任何数据将自动添加到末尾</p>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，<code>open()</code> 函数将会以只读模式打开文件。</p>
<p><code>close()</code> 关闭文件</p>
<p><code>read()</code> 方法一次性读取整个文件。  <code>read(size)</code> 有一个可选的参数 <code>size</code>，用于指定字符串长度。如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。</p>
</li>
</ul>
<p><code>readline()</code> 能帮助你每次读取文件的一行。  使用 <code>readlines()</code> 方法读取所有行到一个列表中。</p>
<p><code>write()</code> 方法打开一个文件写入一些文本。</p>
<p>模块 <code>sys</code>。<code>sys.argv</code> 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 <code>cp</code> 命令替代：在 <code>cp</code> 后首先输入被拷贝的文件的文件名，然后输入新文件名。</p>
<p><code>with</code> 语句处理文件对象，它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写</p>
<p>在 Linux 下你可以使用 <code>lscpu</code> 命令来查看当前电脑的 CPU 相关信息 ， 实际上 <code>lscpu</code> 命令是读取 <code>/proc/cpuinfo</code> 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 <code>/proc/cpuinfo</code> 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 <code>lscpu</code> 命令了 :）</p>
<h3 id="异常">异常</h3>
<p>我们使用 <code>try...except</code> 块来处理任意异常。基本的语法像这样：</p>
<pre><code>try:
    statements to be inside try clause
    statement2
    statement3
    ...
except ExceptionName:
    statements to evaluated in case of ExceptionName happens
</code></pre>
<p>使用 <code>raise</code> 语句抛出一个异常。</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError(&quot;A value error happened.&quot;)
... except ValueError:
...     print(&quot;ValueError in our code.&quot;)
...
ValueError in our code.
</code></pre>
<p><code>try</code> 语句还有另一个可选的 <code>finally</code> 子句，目的在于定义在任何情况下都一定要执行的功能， 不管有没有发生异常，<code>finally</code> 子句 在程序离开 <code>try</code> 后都一定会被执行。当 <code>try</code> 语句中发生了未被 <code>except</code> 捕获的异常（或者它发生在 <code>except</code> 或 <code>else</code> 子句中），在 <code>finally</code> 子句执行完后它会被重新抛出。</p>
<p><code>with</code> 语句，它是 <code>try-finally</code> 块的简写，使用 <code>with</code> 语句能保证文件始终被关闭。</p>
<h3 id="类">类</h3>
<pre><code>class nameoftheclass(parent_class):
    statement1
    statement2
    statement3
</code></pre>
<p>在类的声明中你可以写任何 Python 语句，包括定义函数（在类中我们称为方法）。</p>
<p>类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。 <code>x = MyClass()</code></p>
<p>类定义了 <code>__init__()</code> 方法的话，类的实例化操作会自动为新创建的类实例调用 <code>__init__()</code> 方法。</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre>
<p>一个类可以继承自多个类，具有父类的所有变量和方法，语法如下：</p>
<pre><code>class MyClass(Parentclass1, Parentclass2,...):
    def __init__(self):
        Parentclass1.__init__(self)
        Parentclass2.__init__(self)
        ...
        ...
</code></pre>
<p>删除一个对象使用关键字 <code>del</code> 。</p>
<p>更精确的调整控制属性访问权限，你可以使用 <code>@property</code> 装饰器，<code>@property</code> 装饰器就是负责把一个方法变成属性调用的。</p>
<h3 id="模块">模块</h3>
<p>模块是包括 Python 定义和声明的文件。文件名就是模块名加上 <code>.py</code> 后缀。</p>
<p>从模块中导入指定的函数。这样做：</p>
<pre><code>&gt;&gt;&gt; from bars import simplebar, starbar
&gt;&gt;&gt; simplebar(20)
</code></pre>
<p>含有 <code>__init__.py</code> 文件的目录可以用来作为一个包，目录里的所有 <code>.py</code> 文件都是这个包的子模块。</p>
<p><a href="http://docs.python.org/3/library/os.html#module-os"><code>os</code></a> 模块提供了与操作系统相关的功能。<code>getuid()</code> 函数返回当前进程的有效用户 id。<code>getpid()</code> 函数返回当前进程的 id。<code>getppid()</code> 返回父进程的 id。<code>uname()</code> 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 <code>uname -a</code> 命令得到。<code>uname()</code> 返回的对象是一个元组，<code>（sysname, nodename, release, version, machine）</code>。getcwd() 函数返回当前工作目录。<code>chdir(path)</code> 则是更改当前目录到 path。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/">Requests</a> 是一个第三方 Python 模块， 第三方模块并不是默认的模块，意味着你需要安装它，我们使用 <code>pip3</code> 安装它。</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install python3-pip
$ sudo pip3 install requests
</code></pre>
<p>你可以使用 <code>get()</code> 方法获取任意一个网页。</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.get('https://github.com')
&gt;&gt;&gt; req.status_code
200
</code></pre>
<p><code>req</code> 的 <code>text</code> 属性存有服务器返回的 HTML 网页使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序。</p>
<pre><code>#!/usr/bin/env python3
import requests

def download(url):
    '''
    从指定的 URL 中下载文件并存储到当前目录
    url: 要下载页面内容的网址
    '''
    # 检查 URL 是否存在
    try:
        req = requests.get(url)
    except requests.exceptions.MissingSchema:
        print('Invalid URL &quot;{}&quot;'.format(url))
        return
    # 检查是否成功访问了该网站
    if req.status_code == 403:
        print('You do not have the authority to access this page.')
        return
    filename = url.split('/')[-1]
    with open(filename, 'w') as fobj:
        fobj.write(req.content.decode('utf-8'))
    print(&quot;Download over.&quot;)

if __name__ == '__main__':
    url = input('Enter a URL: ')
    download(url)
</code></pre>
<p><code>if __name__ == '__main__':</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 <code>if</code> 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，<code>if</code> 块内的语句并不会执行。</p>
<p>命令行传入的所有参数都可以使用 <code>sys.argv</code> 获取。如果希望对参数进行处理可以使用 <code>argparse</code> 模块</p>
<h4 id="collections-模块">collections  模块</h4>
<h5 id="counter">Counter</h5>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; import re
&gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt'
&gt;&gt;&gt; words = re.findall('\w+', open(path).read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)]
</code></pre>
<p>Counter 对象有一个叫做 <code>elements()</code> 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<p><code>most_common()</code> 方法返回最常见的元素及其计数，顺序为最常见到最少。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<h5 id="defaultdict">defaultdict</h5>
<p><code>defaultdict</code> 是内建 <code>dict</code> 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同。  <code>defaultdict()</code> 第一个参数提供了 <code>default_factory</code> 属性的初始值，默认值为 <code>None</code>，<code>default_factory</code> 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数。  同样的功能使用 <code>defaultdict</code> 比使用 <code>dict.setdefault</code> 方法快。</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])])
</code></pre>
<h5 id="namedtuple">namedtuple</h5>
<p>命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息。</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])  # 定义命名元组
&gt;&gt;&gt; p = Point(10, y=20)  # 创建一个对象
&gt;&gt;&gt; p
Point(x=10, y=20)
&gt;&gt;&gt; p.x + p.y
30
&gt;&gt;&gt; p[0] + p[1]  # 像普通元组那样访问元素
30
&gt;&gt;&gt; x, y = p     # 元组拆封
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>
<h3 id="python排版">Python排版</h3>
<p>每层缩进使用4个空格。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p><code>import</code>语句分组顺序如下：</p>
<ol>
<li>导入标准库模块</li>
<li>导入相关第三方库模块</li>
<li>导入当前应用程序/库模块</li>
</ol>
<p>避免在下列情况中使用多余的空格：</p>
<ul>
<li>
<p>与括号保持紧凑（小括号、中括号、大括号）：</p>
</li>
<li>
<p>与后面的逗号、分号或冒号保持紧凑</p>
</li>
<li>
<p>切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。</p>
</li>
<li>
<p>函数名与其后参数列表的左括号应该保持紧凑</p>
</li>
<li>
<p>与切片或索引的左括号保持紧凑</p>
</li>
<li>
<p>在赋值操作符（或其它）的两侧保持多余一个的空格</p>
</li>
<li>
<p>总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。</p>
</li>
<li>
<p>在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。</p>
</li>
<li>
<p>不要在关键值参数或默认值参数的等号两边加入空格。</p>
</li>
<li>
<p>【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的<code>-&gt;</code>左右各插入一个空格。</p>
</li>
<li>
<p>打消使用复合语句（多条语句在同一行）的念头。</p>
</li>
<li>
<p>有时候把 <code>if/for/while</code> 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。</p>
<p>块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以<code>#</code>起头，并且<code>#</code>后要跟一个空格（除非是注释内的缩进文本）。</p>
<p>有节制的使用行内注释。</p>
<p>一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以<code>#</code>打头，<code>#</code>后接一个空格。</p>
<p>无谓的行内注释如果状态明显，会转移注意力。</p>
<ul>
<li>为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。</li>
<li><a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a> 描述了良好的文档字符串的约定。注意，文档字符串的结尾<code>&quot;&quot;&quot;</code>应该放在单独的一行，例如：</li>
<li>对于单行的文档字符串，把结尾<code>&quot;&quot;&quot;</code>放在同一行。</li>
</ul>
</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>Python 迭代器（<em>Iterators</em>）对象在遵守迭代器协议时需要支持如下两种方法。</p>
<p><code>__iter__()</code>，返回迭代器对象自身。这用在 <code>for</code> 和 <code>in</code> 语句中。</p>
<p><code>__next__()</code>，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 <code>StopIteration</code> 异常。</p>
<pre><code>class Counter(object):
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        #返回下一个值直到当前值大于 high
        if self.current &gt; self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
            
   
&gt;&gt;&gt; c = Counter(5,10)
&gt;&gt;&gt; for i in c:
...   print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 <code>StopIteration</code>，它会持续抛出相同的异常。</p>
<p>Python 生成器（<em>Generators</em>），生成器是更简单的创建迭代器的方法，这通过在函数中使用 <code>yield</code> 关键字完成：</p>
<pre><code>&gt;&gt;&gt; def my_generator():
...     print(&quot;Inside my generator&quot;)
...     yield 'a'
...     yield 'b'
...     yield 'c'
...
&gt;&gt;&gt; my_generator()
&lt;generator object my_generator at 0x7fbcfa0a6aa0&gt;

&gt;&gt;&gt; for char in my_generator():
...     print(char)
...
Inside my generator
a
b
c

&gt;&gt;&gt; def counter_generator(low, high):
...     while low &lt;= high:
...        yield low
...        low += 1
... 
&gt;&gt;&gt; for i in counter_generator(5,10):
...     print(i, end=' ')
... 
5 6 7 8 9 10
</code></pre>
<p>我们会发现生成器的一个特点：它们是不可重复使用的。</p>
<p>生成器表达式（<em>Generator expressions</em>），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广。</p>
<pre><code>&gt;&gt;&gt; sum([x*x for x in range(1,10)])
</code></pre>
<p>这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
</code></pre>
<p>生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。</p>
<p>闭包（<em>Closures</em>）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和。</p>
<pre><code>&gt;&gt;&gt; def add_number(num):
...     def adder(number):
...         #adder 是一个闭包
...         return num + number
...     return adder
...
&gt;&gt;&gt; a_10 = add_number(10)
&gt;&gt;&gt; a_10(21)
31
&gt;&gt;&gt; a_10(34)
44
&gt;&gt;&gt; a_5 = add_number(5)
&gt;&gt;&gt; a_5(3)
8
</code></pre>
<p>装饰器（<em>Decorators</em>）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的。</p>
<pre><code>&gt;&gt;&gt; def my_decorator(func):
...     def wrapper(*args, **kwargs):
...         print(&quot;Before call&quot;)
...         result = func(*args, **kwargs)
...         print(&quot;After call&quot;)
...         return result
...     return wrapper
...
&gt;&gt;&gt; @my_decorator
... def add(a, b):
...     #我们的求和函数
...     return a + b
...
&gt;&gt;&gt; add(1, 3)
Before call
After call
4
</code></pre>
]]></content>
    </entry>
</feed>
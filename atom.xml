<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xmweijh.github.io/</id>
    <title>小虾米的记录</title>
    <updated>2020-04-30T00:54:22.813Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xmweijh.github.io/"/>
    <link rel="self" href="https://xmweijh.github.io/atom.xml"/>
    <subtitle>努力成就自我</subtitle>
    <logo>https://xmweijh.github.io/images/avatar.png</logo>
    <icon>https://xmweijh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小虾米的记录</rights>
    <entry>
        <title type="html"><![CDATA[HTML基础]]></title>
        <id>https://xmweijh.github.io/post/html-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/html-ji-chu/">
        </link>
        <updated>2020-04-30T00:53:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html">HTML</h2>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)  是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>常见状态码</strong></p>
<ul>
<li>200 ：成功。</li>
<li>400 ：客户端请求有语法错误，服务器端不能理解。</li>
<li>401 ：该请求可能未经过授权。</li>
<li>403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。</li>
<li>404 ：该资源没找到。</li>
<li>500 ：服务器端发生了一个不可预知的错误。</li>
<li>503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。</li>
</ul>
<p>HTML（超文本标记语言）是一种用于创建网页的标准标记语言。 HTML 不需要编译，可以直接由浏览器执行，它的解析依赖于浏览器的内核。 它不是一种编程语言，而是一种标记语言。</p>
<p>一个网页的基本结构：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>&lt;!DOCTYPE html&gt;是我们的文档声明头。他告诉了浏览器，本文档处理的是 HTML 文档。<code>html</code> 标签即根元素，此处表示文档的开始。<code>head</code> 标签是网页的头部，设置网页的相关信息。<code>title</code> 标签设置网页标题。<code>body</code> 标签定义文档的主体，也就是我们的主要内容。</p>
<p>在 HTML 中满足以下格式的内容即为注释，被注释的内容将不会被渲染和显示。</p>
<pre><code>&lt;!-- 在此处写注释 --&gt;
</code></pre>
<p>**注：**在开始标签中有一个惊叹号，但是结束标签中没有。浏览器不会显示注释，但是能够帮助记录。</p>
<p>HTML 标签的大小写无关的，例如 <code>和</code> 表示的意思是一样的，都代表“主体”，推荐使用小写。</p>
<p><strong>双标签（双标记）</strong></p>
<p>双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名&gt;&lt;/标记名&gt;
</code></pre>
<p>常见的双标签有：</p>
<pre><code class="language-html">&lt;html&gt;&lt;/html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;body&gt;&lt;/body&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;span&gt;&lt;/span&gt;
&lt;a&gt;&lt;/a&gt;
&lt;ul&gt;&lt;/ul&gt;
</code></pre>
<p><strong>单标签（单标记）</strong></p>
<p>单标记也称空标记，是指用一个标记符号即可完整地描述某个功能的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名/&gt;
</code></pre>
<p>常见的单标签有：</p>
<pre><code class="language-html">&lt;br /&gt;
&lt;!--换行--&gt;
&lt;hr /&gt;
&lt;!--水平分隔线--&gt;
&lt;meta /&gt;
&lt;img /&gt;
</code></pre>
<p><strong>标签的关系</strong></p>
<ul>
<li>嵌套关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;title&gt; &lt;/title&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>并列关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
</code></pre>
<p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>例子：</p>
<pre><code class="language-html">&lt;p&gt;I Love You&lt;/p&gt;
</code></pre>
<p>注：这个元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 <code>，以及一个结束标签</code>。元素内容是：<code>I Love You</code>。</p>
<p><strong>h 系类标签</strong></p>
<p><code>h</code> 标签有六种 <code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>，它代表着我们的标题。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;我是一级标题&lt;/h1&gt;
    &lt;h2&gt;我是二级标题&lt;/h2&gt;
    &lt;h3&gt;我是三级标题&lt;/h3&gt;
    &lt;h4&gt;我是四级标题&lt;/h4&gt;
    &lt;h5&gt;我是五级标题&lt;/h5&gt;
    &lt;h6&gt;我是六级标题&lt;/h6&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>p 标签</strong></p>
<p><code>p</code> 标签是我们的文本标签。</p>
<p><strong>图片标签</strong></p>
<p>HTML 的图像是通过标签 &lt;img&gt;来定义的。</p>
<p><strong>a 标签</strong></p>
<p><a> 标签是超链接标签，意思就是我们点击它可以跳转到一个网页。</p>
<p><strong>div 标签</strong></p>
<div> 标签是一个块级元素，块级元素占据其父元素（容器）的整个空间，你可以把它想成一个盒子。 <div> 能够设置其宽高
<p><strong>换行标签和空格字符</strong></p>
<p>在浏览器显示页面时，浏览器会移除源代码中多余的空格和空行，所有连续的空格或空行都会被认为是一个空格。如果希望在不产生一个新段落的情况下换行，可以使用&lt;br/&gt;标签。如果想使用空格的话可以使用&amp;nbsp;字符</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;p&gt;这是一段文字 前面有很多空格但是只显示一个&lt;/p&gt;
  &lt;p&gt;这是一段文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用了空格字符&lt;/p&gt;
  &lt;br /&gt;
  &lt;p&gt;上面是换行符&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p><strong>水平分割线</strong></p>
<p>&lt;hr/&gt; 标签用于在 HTML 页面中创建一条水平线。</p>
<p>标签 <div> 可将网页页面分割成不同的独立部分，通常用于定义文档中的区域或节。该标签是一个块级元素，浏览器会自动在 <div> 和 </div> 所标记的区域前后自动放置一个换行符。</p>
<p>标签 <span> 通常作为文本的容器，它没有特定的含义和样式，只有与 CSS 同时使用才可以为指定文本设置样式属性。该标签是一个内联元素，他与块级元素相反，内联元素不会自动在前后自动放置换行符，因此内联元素会默认显示在同一行。</p>
<p>无序列表是一个项目的列表，此列项目使用实心圆、空心圆、方块进行标记，无序列表使用 <ul> 标签。同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 <ol> 标签。每个列表项始于 <li> 标签。</p>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>无序列表和有序列表的 type 属性：</strong></p>
<p>type 属性定义了列表项前项目符号的类型。</p>
<p>&lt;ul&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>disc（默认）</td>
<td>实心圆</td>
</tr>
<tr>
<td>circle</td>
<td>空心圆</td>
</tr>
<tr>
<td>square</td>
<td>小方块</td>
</tr>
</tbody>
</table>
<p>&lt;ol&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1（默认）</td>
<td>数字表示（1，2，3...)</td>
</tr>
<tr>
<td>A</td>
<td>大写字母表示（A,B,C...)</td>
</tr>
<tr>
<td>a</td>
<td>小写字母表示（a,b,c...)</td>
</tr>
<tr>
<td>I</td>
<td>大写罗马数字表示(I,II,III…)</td>
</tr>
<tr>
<td>i</td>
<td>小写罗马数字表示(i,ii,iii…)</td>
</tr>
</tbody>
</table>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul type=&quot;circle&quot;&gt;
  &lt;li&gt;空心圆列表项1&lt;/li&gt;
  &lt;li&gt;空心圆列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol type=&quot;A&quot;&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>自定义列表（dl）</strong></p>
<p>定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt;开始。自定义列表的列表项前没有任何项目符号。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<p><strong>HTML 样式实例 - 背景颜色</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;background-color:red&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过 <code>&quot;background-color&quot;</code> 属性值的设置来给背景设置颜色。</p>
<p><strong>HTML 样式实例 - 字体、颜色和尺寸</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;font-family:arial;color:green;font-size:50px;&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过对 <code>font-family</code> 属性值的设置来设置字体，通过对 <code>color</code> 属性值的设置来设置颜色，通过对 <code>font-size</code> 属性值的设计来设计字体大小。</p>
<p><strong>HTML 样式实例 - 文本对齐</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1 style=&quot;text-align:center&quot;&gt;xxx&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<pre><code class="language-html">&lt;table&gt;   //&lt;table border=&quot;1&quot;&gt;给表格加上边框
  &lt;tr&gt;
    &lt;td&gt;第一行第一列&lt;/td&gt;
    &lt;td&gt;第一行第二列&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;第二行第一列&lt;/td&gt;
    &lt;td&gt;第二行第二列&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>表格一般都有标题，在 HTML 中表格标题通过 <caption> 定义。</p>
<figure data-type="image" tabindex="1"><img src="https://doc.shiyanlou.com/document-uid897174labid9222timestamp1545370661694.png/wm" alt="img" loading="lazy"></figure>
<p>表格的表头使用 <th> 标签进行定义，表头通常用于列名字。</p>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt;
  &lt;caption&gt;
    支出表
  &lt;/caption&gt;
  &lt;tr&gt;
    &lt;th&gt;支出&lt;/th&gt;
    &lt;th&gt;备注&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;32&lt;/td&gt;
    &lt;td&gt;买苹果&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;24&lt;/td&gt;
    &lt;td&gt;买饮料&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>绘制表格的时候，我们常常需要合并单元格，而在 HTML 中提供了 colspan（合并行）和 rowspan（合并列）属性来帮助我们实现这一效果。</p>
<blockquote>
<p>colspan 又称跨列，rowspan 又称跨行。</p>
</blockquote>
<p>设置 <code>rowspan=&quot;2&quot;</code> 表示合并该列上的两个单元格，同样的我们可以通过设置 <code>colspan</code> 来合并行</p>
<p>在网页中可以使用很多个 div，在网页制作中，使用 div 可以将网页中的任何元素布局到网页中的任何位置。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;div style=&quot;样式设置&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>table 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>理解比较简单。</li>
<li>不同的浏览器看到的效果一般相同。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>显示样式和数据绑定在一起。</li>
<li>布局的时候灵活度不高。</li>
<li>一个页面可能会有大量的 table 元素，代码冗余度高。</li>
<li>增加带宽。</li>
<li>搜索引擎不喜欢这样的布局。</li>
</ol>
<p>div 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>符合 W3C 标准。</li>
<li>搜索引擎更加友好。</li>
<li>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</li>
<li>节省代宽，代码冗余度低。</li>
<li>表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。</li>
</ol>
<p>&lt;form&gt;标签用于创建 HTML 表单，常见的表单格式为：</p>
<pre><code class="language-html">&lt;form name=&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;&lt;/form&gt;
</code></pre>
<ul>
<li>name：定义表单的名字。</li>
<li>method：定义表单结果从浏览器传送到服务器的方式，默认参数为：<code>get</code> 。<code>post</code> 安全性更高，因此常用作传输密码等，而 <code>get</code> 安全性较低，一般用于查询数据。</li>
<li>action：发送数据要去的地址。它的值必须是一个有效的 URL，可以是相对 URL 也可以是绝对 URL。如果没有提供此属性或者 <code>action=&quot;#&quot;</code>，则数据将被发送到包含表单的页面的 URL。</li>
</ul>
<p>在网页中最常见的表单元素就是文字字段，用户可以在文字字段内输入字符或者单行文本。 语法：</p>
<pre><code class="language-html">&lt;input
  type=&quot;text&quot;
  name=&quot;控件名称&quot;
  value=&quot;文字字段的默认取值&quot;
  size=&quot;控件的长度&quot;
  maxlength=&quot;最长字符数&quot;
/&gt;
</code></pre>
<p>该语法包含了许多参数，除了 <code>type</code> 参数以外，其他的参数都是可选的</p>
<p>举个例子：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;40&quot; value=&quot;10&quot; maxlength=&quot;3&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>密码输入框</strong></p>
<p>密码输入框是一种特殊的文字字段，他的各个属性和文字字段是相同的，但是输入进密码输入框的字符全部是“*”表示，保证周围人看不见输入的文本。</p>
<pre><code class="language-html">&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;
</code></pre>
<p><strong>单选按钮</strong></p>
<p>单选按钮可以使用户从选择列表中选择一个选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked /&gt;男&lt;br /&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; /&gt;女
&lt;/form&gt;
</code></pre>
<p>几个单选按钮可以连接在一起，只需要把它们的 <code>name</code> 值设置为相同的。同一组中只有一个按钮可以同时被选。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，且不会随表单提交。 可以尝试如果 name 不相同或者没有 name 会是什么情况。</p>
<p>复选框可以让用户从一个选项列表中选择超出一个的选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;music&quot; checked /&gt;音乐&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;art&quot; /&gt;美术&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;math&quot; /&gt;数学&lt;br /&gt;
&lt;/form&gt;
</code></pre>
<p>复选框可以拥有自己的名字，并不需要属于一个组。</p>
<p><strong>按钮</strong><br>
HTML 表单中，有三种按钮：提交按钮，重置按钮，匿名按钮。我们可以使用 <button> 元素或者 <input> 元素来创建一个按钮。type 属性的值指定显示什么类型的按钮。</p>
<p><strong>提交按钮（submit）</strong></p>
<p>用于发送表单数据给服务器。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; value=&quot;输入的内容&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;
    This a submit button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>重置按钮（reset）</strong></p>
<p>重置按钮用来清除用户在页面中输入的信息。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; /&gt;
  &lt;button type=&quot;reset&quot;&gt;
    This a reset button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>在文本框中输入内容，点击按钮即可清除。</p>
<p><strong>匿名按钮（button）</strong></p>
<p>没有自动生效的按钮，但是可以使用 JavaScript 代码进行定制。如果你省略了 <code>type</code> 属性，那么这就是默认值。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;button&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;input type=&quot;button&quot; value=&quot;This is a anonymous button&quot; /&gt;
</code></pre>
<p>不管使用的是 <button> 元素还是 <input> 元素，按钮的行为都是一样的。它们的不同点在于：</p>
<p>从前面的例子中也可以看出 <button> 元素允许你使用 HTML 内容作为其标记内容，但 <input> 元素只接受纯文本内容。<br>
使用 <button> 元素，可以有一个不同于按钮标签的值（通过将其设置为 value 属性）。</p>
<p><strong>下拉菜单</strong></p>
<p>下拉菜单能够节省页面空间，正常状态下显示一个选项，单击展开所以选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>注意：下拉菜单的宽度是由 <option> 标记中包含的最长文本的宽度决定的。</p>
<p><strong>列表项</strong></p>
<p>在页面中列表项可以显示出几条信息，一旦超出这个信息量，在列表项右侧会出现滚动条，拖动滚动条可以看到所有选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot; size=&quot;2&quot; multiple=&quot;multiple&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>当用户想要填入多行文本时，就应该使用文本域而不是文本字段。文本域使用 <textarea> 标记。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  留下您的联系方式：
  &lt;textarea name=&quot;textarea&quot; cols=&quot;35&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
&lt;/form&gt;
</code></pre>
<p><code>clos</code> 代表列数，<code>rows</code> 代表行数。</p>
<p><strong>图像标签</strong><br>
在 HTML 中，图像由 <img> 标签定义。语法为：</p>
<pre><code class="language-html">&lt;img src=&quot;url&quot; alt=&quot;&quot; /&gt;
</code></pre>
<p><img> 是空标签，它只包含属性，没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 的值是图像文件的 URL，也就是引用该图像的文件的的绝对路径或相对路径。alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。title 设置鼠标悬停时显示的内容（一般不用设置）。此外还可以通过设置 width 和 height 的值来设置图片的宽和高。</p>
<p><strong>框架</strong></p>
<p>使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;iframe src=&quot;URL&quot;&gt;
  &lt;!-- URL指向不同的页面 --&gt;
&lt;/iframe&gt;
</code></pre>
<p><strong>iframe - 设置高度与宽度</strong></p>
<p>属性默认以像素为单位,但是你可以指定其按比例显示 (如：&quot;60%&quot;)。</p>
<p><strong>iframe - 移除边框</strong></p>
<p><code>frameborder</code> 属性用于定义 iframe 表示是否显示边框。设置属性值为 &quot;0&quot; 移除 iframe 的边框:</p>
<p>在标准 HTML5 中， <html> 和 <body> 标签是可以省略的。</p>
<p>HTML5 元素名可以使用大写和小写字母，建议使用小写字母，会显得更加好看一点，千万不要使用大小写混写，那样会显得很不专业。</p>
<p>图片通常使用 <code>alt</code> 属性。 在图片不能显示时，它能替代图片显示。建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。</p>
<p>等号的前后可以使用空格，也可以不使用，推荐少用空格。</p>
<p>不要无缘无故的添加空行，一般一个模块或一个功能添加一个空行便于区分，缩进使用两个空格，不建议使用 Tab。</p>
<p><strong>section 标签</strong></p>
<p>&lt;section&gt; 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。不要把 <section> 元素作为一个普通的 div 容器来使用。一般来说，一个 <section> 应该出现在文档大纲中。</p>
<p><strong>article 标签</strong></p>
<p>&lt;article&gt; 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。</p>
<p><strong>nav 标签</strong></p>
<p>&lt;nav&gt; 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。</p>
<p><strong>header 标签</strong></p>
<p>&lt;header&gt; 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。</p>
<p>通常 header 标签至少包含一个标题标记（h1-h6），还可以包括 hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。</p>
<p><strong>footer 标签</strong></p>
<p>&lt;footer&gt; 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。</p>
<p><strong>aside 标签</strong></p>
<p>&lt;aside&gt; 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</p>
<p><strong>datalist 元素</strong><br>
datalist 元素用于为文本框提供一个可供选择的列表，使用 datalist 元素来为表单小部件提供建议的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 <input> 元素)。</p>
<p>一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本。通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。</p>
<p><strong>autocomplete 属性</strong><br>
autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。当 autocomplete 属性值为 on 时表示启用自动完成功能，为 off 时表示关闭。autocomplete 属性适用于 <form>，以及下面的 <input> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p>
<p><strong>autofocus 属性</strong><br>
autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 <input> 标签的类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://xmweijh.github.io/post/sql-yu-yan/</id>
        <link href="https://xmweijh.github.io/post/sql-yu-yan/">
        </link>
        <updated>2020-04-28T00:13:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="select">SELECT</h3>
<pre><code>SELECT column_name,column_name FROM table_name;//选出特定列

SELECT * FROM table_name;//选取所有列

SELECT DISTINCT column_name,column_name
FROM table_name;//返回列中不同值（去除掉重复值）

SELECT column_name new_column_name FROM table_name;使用列别名可以改变查询结果的列标题
</code></pre>
<h3 id="where">WHERE</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
WHERE column_name operator value;//提取那些满足指定条件的记录
</code></pre>
<p>使用<strong>单引号来环绕文本值</strong>（大部分数据库系统也接受双引号）。如果是<strong>数值字段，请不要使用引号</strong>。</p>
<p>可以在 WHERE 子句中使用的运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 !=</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left">在某个范围内</td>
</tr>
<tr>
<td style="text-align:left">LIKE</td>
<td style="text-align:left">搜索某种模式</td>
</tr>
<tr>
<td style="text-align:left">IN</td>
<td style="text-align:left">指定针对某个列的多个可能值</td>
</tr>
</tbody>
</table>
<p>逻辑运算    not        and         or  （优先级从左到右下降）</p>
<p>空值判断：  is null</p>
<h3 id="order-by">ORDER BY</h3>
<pre><code>SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;//对结果集按照一个列或者多个列进行排序,默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。
ORDER BY 多列的时候，先按照第一个column name排序，再按照第二个column name排序
desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。
</code></pre>
<h3 id="insert-into">INSERT INTO</h3>
<pre><code>INSERT INTO table_name
VALUES (value1,value2,value3,...);//无需指定要插入数据的列名，只需提供被插入的值即可

INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);//指定列名及被插入的值
</code></pre>
<h3 id="update">UPDATE</h3>
<pre><code>UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;//更新表中已存在的记录。
如果您省略了 WHERE 子句，所有的记录都将被更新！
</code></pre>
<h3 id="delete">DELETE</h3>
<pre><code>DELETE FROM table_name
WHERE some_column=some_value;//删除表中的行。
如果您省略了 WHERE 子句，所有的记录都将被删除！
</code></pre>
<h3 id="select-top-limit-rownum-子句">SELECT TOP, LIMIT, ROWNUM 子句</h3>
<pre><code>SELECT TOP number|percent column_name(s)
FROM table_name;

SELECT column_name(s)
FROM table_name
LIMIT number;

SELECT column_name(s)
FROM table_name
WHERE ROWNUM &lt;= number;//用于规定要返回的记录的数目
</code></pre>
<h3 id="like">LIKE</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;//操作符用于在 WHERE 子句中搜索列中的指定模式。
</code></pre>
<p>'%a'   //以a结尾的数据</p>
<p>'a%'   //以a开头的数据</p>
<p>'%a%'   //含有a的数据</p>
<p>‘_a_’   //三位且中间字母是a的</p>
<p>'_a'   //两位且结尾字母是a的</p>
<p>'a_'   //两位且开头字母是a的</p>
<h3 id="sql-通配符">SQL 通配符</h3>
<p>在 SQL 中，通配符与 SQL LIKE 操作符一起使用。</p>
<p>SQL 通配符用于搜索表中的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">替代 0 个或多个字符</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">替代一个字符</td>
</tr>
<tr>
<td style="text-align:left">[<em>charlist</em>]</td>
<td style="text-align:left">字符列中的任何单一字符</td>
</tr>
<tr>
<td style="text-align:left">[^<em>charlist</em>] 或 [!<em>charlist</em>]</td>
<td style="text-align:left">不在字符列中的任何单一字符</td>
</tr>
</tbody>
</table>
<h3 id="in">IN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);//IN 操作符允许您在 WHERE 子句中规定多个值。
</code></pre>
<h3 id="between">BETWEEN</h3>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;//用于选取介于两个值之间的数据范围内的值。
</code></pre>
<h3 id="sql-别名">SQL 别名</h3>
<pre><code>SELECT column_name AS alias_name
FROM table_name;//列的 SQL 别名语法

SELECT column_name(s)
FROM table_name AS alias_name;//表的 SQL 别名语法
</code></pre>
<h3 id="sql-连接join">SQL 连接(JOIN)</h3>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
</ul>
<p><strong>SQL INNER JOIN 语法</strong></p>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_innerjoin.gif" alt="SQL INNER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
JOIN table2
ON table1.column_name=table2.column_name;//INNER JOIN 与 JOIN 是相同的。
</code></pre>
<p>在使用 <strong>join</strong> 时，<strong>on</strong> 和 <strong>where</strong> 条件的区别如下：</p>
<ul>
<li>1、 <strong>on</strong> 条件是在生成临时表时使用的条件，它不管 <strong>on</strong> 中的条件是否为真，都会返回左边表中的记录。</li>
<li>2、<strong>where</strong> 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 <strong>left join</strong> 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ul>
<p><strong>SQL LEFT JOIN 语法</strong></p>
<p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_leftjoin.gif" alt="SQL LEFT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
LEFT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，LEFT JOIN 称为 LEFT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL RIGHT JOIN 语法</strong></p>
<p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_rightjoin.gif" alt="SQL RIGHT JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name=table2.column_name;

SELECT column_name(s)
FROM table1
RIGHT OUTER JOIN table2
ON table1.column_name=table2.column_name;//在某些数据库中，RIGHT JOIN 称为 RIGHT 											 //OUTER JOIN。
</code></pre>
<p><strong>SQL FULL OUTER JOIN 语法</strong></p>
<p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2013/09/img_fulljoin.gif" alt="SQL FULL OUTER JOIN" loading="lazy"></figure>
<pre><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre>
<h3 id="union">UNION</h3>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<pre><code>SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
//默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
</code></pre>
<h3 id="select-into">SELECT INTO</h3>
<p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
<pre><code>SELECT *
INTO newtable [IN externaldb]
FROM table1;

SELECT column_name(s)
INTO newtable [IN externaldb]
FROM table1;
</code></pre>
<h3 id="insert-into-select">INSERT INTO SELECT</h3>
<p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
<pre><code>INSERT INTO table2
SELECT * FROM table1;

INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
</code></pre>
<h3 id="create-database">CREATE DATABASE</h3>
<pre><code>CREATE DATABASE dbname;//用于创建数据库。
</code></pre>
<h3 id="create-table">CREATE TABLE</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);//用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。
  //column_name 参数规定表中列的名称。
  //data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。
  //size 参数规定表中列的最大长度。
</code></pre>
<h3 id="sql-约束constraints">SQL 约束（Constraints）</h3>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);//用于规定表中的数据规则。
</code></pre>
<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li>
<p><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</p>
<p>​	NOT NULL 约束强制列不接受 NULL 值。</p>
<p>​	NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或	者更新记录。</p>
</li>
<li>
<p><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</p>
<p>​	UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>​	UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>​	PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。</p>
<p>​	请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
</li>
<li>
<p><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p>
<p>​	PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>
<p>​	主键必须包含唯一的值。</p>
<p>​	主键列不能包含 NULL 值。</p>
<p>​	每个表都应该有一个主键，并且每个表只能有一个主键。</p>
</li>
<li>
<p><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</p>
</li>
<li>
<p><strong>CHECK</strong> - 保证列中的值符合指定的条件。</p>
<p>​	如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>
<p>​	如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限	    	制。</p>
</li>
<li>
<p><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
</li>
</ul>
<h3 id="create-index-语句">CREATE INDEX 语句</h3>
<p>CREATE INDEX 语句用于在表中创建索引。</p>
<p>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</p>
<pre><code>CREATE INDEX index_name
ON table_name (column_name)//在表上创建一个简单的索引。允许使用重复的值

CREATE UNIQUE INDEX index_name
ON table_name (column_name)//在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着						   //两个行不能拥有相同的索引值
</code></pre>
<h3 id="drop">DROP</h3>
<p>通过使用 DROP 语句，可以轻松地删除索引、表和数据库。</p>
<h3 id="alter-table">ALTER TABLE</h3>
<p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<h3 id="sql-alter-table-语法">SQL ALTER TABLE 语法</h3>
<p>如需在表中添加列，请使用下面的语法:</p>
<pre><code>ALTER TABLE table_name
ADD column_name datatype
</code></pre>
<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<pre><code>ALTER TABLE table_name
DROP COLUMN column_name
</code></pre>
<h3 id="auto-increment">AUTO INCREMENT</h3>
<p>Auto-increment 会在新记录插入表中时生成一个唯一的数字。</p>
<h3 id="视图views">视图（Views）</h3>
<p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p>SQL CREATE VIEW 语法</p>
<pre><code>CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>**注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<p>您可以使用下面的语法来更新视图：</p>
<p>SQL CREATE OR REPLACE VIEW 语法</p>
<pre><code>CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>
<p>您可以通过 DROP VIEW 命令来删除视图。</p>
<p>SQL DROP VIEW 语法</p>
<pre><code>DROP VIEW view_name
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://xmweijh.github.io/post/python/</id>
        <link href="https://xmweijh.github.io/post/python/">
        </link>
        <updated>2020-04-04T03:00:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<p>print括号中可以单引号或者双引号</p>
<p>多行打印时,使用三个引号</p>
<pre><code>print('''



''')
</code></pre>
<p>true类型只用True 和False 注意大小写</p>
<p>空值 None 表示无，与0 不同</p>
<p>input（输入）</p>
<p>当输入输出括号中字符串中还有引号，需要转义符\区别</p>
<pre><code>&gt;&gt;&gt; string = 'hello_shiyanlou'
&gt;&gt;&gt; string[0]  # 获取第一个字符
'h'
&gt;&gt;&gt; string[-2]  # 获取倒数第二个字符
'o'
</code></pre>
<p>注意负值代表倒数第几个（倒数不从0开始，毕竟 -0 = 0）</p>
<pre><code>print('你叫'+name+'，今年' + age + '岁了')
#等价于
print('你叫{}，今年{}岁了'.format(name,age))
#下面代码代表保留2位小数
print(&quot;{:.2f}&quot;.format(3.1415926))
</code></pre>
<p>#单行注释</p>
<p>逻辑运算符 and 	or 	not</p>
<p>条件判断</p>
<pre><code>if:
    ***
elif:
	***
else:
	***
</code></pre>
<p>后面加<strong>冒号</strong>  if下面的代码4个缩进</p>
<p>input 读取的为字符串类型</p>
<pre><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; if a&lt;1:
...     print(&quot;a&lt;1&quot;)
... else:
...     pass
...
&gt;&gt;&gt; #程序没有报错
</code></pre>
<p>pass会跳过这里的代码执行后面的代码</p>
<pre><code>for 元素 in 集合:
    do something 
</code></pre>
<p>range(x)函数 可以生成一个从0到x-1的整数序列</p>
<p><code>range()</code> 函数返回的并不是列表而是一种可迭代对象：</p>
<p>range(a,b)  a 到b-1，包头不包尾</p>
<pre><code>while condition:
   do something
</code></pre>
<p>所以如果是用空格，就一直用空格缩进，不要使用制表符。</p>
<p>建议遵守以下约定：</p>
<ul>
<li>使用 4 个空格来缩进</li>
<li>永远不要混用空格和制表符</li>
<li>在函数之间空一行</li>
<li>在类之间空两行</li>
<li>字典，列表，元组以及参数列表中，在 <code>,</code> 后添加一个空格。对于字典，<code>:</code> 后面也添加一个空格</li>
<li>在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：<code>a = f(1, 2) + g(3, 4)</code></li>
</ul>
<p>// 取整除 - 返回商的整数部分（<strong>向下取整</strong>）</p>
<p><code>divmod(num1, num2)</code> 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 <code>*</code> 运算符拆封这个元组，得到这两个值。</p>
<p>默认情况下，<code>print()</code> 除了打印你提供的字符串之外，还会打印一个换行符   <code>print()</code> 的另一个参数 <code>end</code> 来替换这个换行符</p>
<pre><code> print(b, end=' ') 
 print(&quot;-&quot; * 50) #打印50个-
  #列表的元素不必是同一类型
 &gt;&gt;&gt; a = [ 1, 342, 223, 'India', 'Fedora'] 
</code></pre>
<p>Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。 对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 <code>a[2:4]</code> 是 2。 返回a[2]和a[3]两个</p>
<p>切片操作还可以设置步长</p>
<pre><code>&gt;&gt;&gt; a[1::2]
[342, 'India']
</code></pre>
<p>意思是，从切片索引 1 到列表末尾，每隔两个元素取值。</p>
<p><code>len()</code> 我们可以获得列表的长度</p>
<p>如果你想要检查列表是否为空</p>
<pre><code>if list_name: # 列表不为空
    pass
else: # 列表为空
    pass
</code></pre>
<h3 id="列表">列表</h3>
<p><code>a.append(45)</code> 添加元素 <code>45</code> 到列表末尾。有些时候我们需要将数据插入到列表的任何位置，这时我们可以使用列表的 <code>insert()</code> 方法。   <code>count(s)</code> 会返回列表元素中 <code>s</code> 的数量。  如果你想要在列表中移除任意指定值，你需要使用 <code>remove()</code> 方法。  <code>a.reverse()</code> 反转整个列表。 将一个列表的所有元素添加到另一个列表的末尾呢，可以使用列表的 <code>extend()</code> 方法。  给列表排序，我们使用列表的 <code>sort()</code> 方法， 用 <code>del</code> 关键字删除指定位置的列表元素。</p>
<pre><code>&gt;&gt;&gt; a = [23, 45, 1, -3434, 43624356, 234]
&gt;&gt;&gt; a.append(45)
&gt;&gt;&gt;  a.insert(0, 1)
&gt;&gt;&gt; a.count(45)
</code></pre>
<h4 id="栈">栈</h4>
<p><code>pop()</code>。传入一个参数 i 即 <code>pop(i)</code> 会将第 i 个元素弹出。 栈使用<code>a.pop()</code> 将顶部元素弹出， <code>a.append(x)</code> 入栈</p>
<h4 id="队列">队列</h4>
<p><code>a.pop(0)</code> 出队 <code>a.append(x)</code> 入队</p>
<h4 id="列表推导式">列表推导式</h4>
<pre><code>squares = [x**2 for x in range(10)]
&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
#等价于
&gt;&gt;&gt; combs = []
&gt;&gt;&gt; for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
&gt;&gt;&gt; combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<h3 id="元组">元组</h3>
<p>元组是由数个逗号分割的值组成。</p>
<pre><code>&gt;&gt;&gt; a = 'Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus'
&gt;&gt;&gt; a
('Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus')
&gt;&gt;&gt; a[1]
'ShiYanLou'
&gt;&gt;&gt; for x in a:
...     print(x, end=' ')
...
Fedora ShiYanLou Kubuntu Pardus
</code></pre>
<p>以对任何一个元组执行拆封操作并赋值给多个变量</p>
<pre><code>&gt;&gt;&gt; x, y = divmod(15,2)
&gt;&gt;&gt; x
7
&gt;&gt;&gt; y
1
</code></pre>
<p>元组是不可变类型，这意味着你<strong>不能在元组内删除或添加或编辑</strong>任何值。</p>
<p>要创建只含有一个元素的元组，在值后面跟一个<strong>逗号</strong>。</p>
<p>通过内建函数 <code>type()</code> 你可以知道任意变量的数据类型。</p>
<h3 id="集合">集合</h3>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p>
<p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典</p>
<pre><code>&gt;&gt;&gt; basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
&gt;&gt;&gt; print(basket)                      # 你可以看到重复的元素被去除
{'orange', 'banana', 'pear', 'apple'}
&gt;&gt;&gt; 'orange' in basket
True
&gt;&gt;&gt; 'crabgrass' in basket
False

&gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作
...
&gt;&gt;&gt; a = set('abracadabra')
&gt;&gt;&gt; b = set('alacazam')
&gt;&gt;&gt; a                                  # a 去重后的字母
{'a', 'r', 'b', 'c', 'd'}
&gt;&gt;&gt; a - b                              # a 有而 b 没有的字母
{'r', 'd', 'b'}
&gt;&gt;&gt; a | b                              # 存在于 a 或 b 的字母
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
&gt;&gt;&gt; a &amp; b                              # a 和 b 都有的字母
{'a', 'c'}
&gt;&gt;&gt; a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{'r', 'd', 'b', 'm', 'z', 'l'}
#添加或弹出元素
&gt;&gt;&gt; a = {'a','e','h','g'}
&gt;&gt;&gt; a.pop()  # pop 方法随机删除一个元素并打印
'h'
&gt;&gt;&gt; a.add('c')
&gt;&gt;&gt; a
{'c', 'e', 'g', 'a'}
</code></pre>
<h3 id="字典">字典</h3>
<p>字典是是无序的键值对（<code>key:value</code>）集合，同一个字典内的键必须是互不相同的。一对大括号 <code>{}</code> 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。</p>
<pre><code>&gt;&gt;&gt; data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
&gt;&gt;&gt; data['kart_']
'Debian'
&gt;&gt;&gt; data['parthan'] = 'Ubuntu'
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
# 使用del关键字删除任意指定的键值对
&gt;&gt;&gt; del data['kushal']
&gt;&gt;&gt; data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
# 使用 in 关键字查询指定的键是否在字典中
&gt;&gt;&gt; 'ShiYanLou' in data
False
#必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作
#为键。dict() 可以从包含键值对的元组中创建字典。
&gt;&gt;&gt; dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
#遍历一个字典，使用字典的 items() 方法。
&gt;&gt;&gt; data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
&gt;&gt;&gt; for x, y in data.items():
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu
</code></pre>
<p>许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。我们可以使用 <code>dict.setdefault(key, default)</code> 更有效率的完成这个事情。</p>
<pre><code>&gt;&gt;&gt; data = {}
&gt;&gt;&gt; data.setdefault('names', []).append('Ruby')
&gt;&gt;&gt; data
{'names': ['Ruby']}
&gt;&gt;&gt; data.setdefault('names', []).append('Python')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python']}
&gt;&gt;&gt; data.setdefault('names', []).append('C')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python', 'C']}
</code></pre>
<p>试图索引一个不存在的键将会抛出一个 <em>keyError</em> 错误。我们可以使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p>
<p>如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code>。</p>
<pre><code>&gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']):
...     print(i, j)
...
0 a
1 b
2 c
</code></pre>
<p>要同时遍历两个序列类型，你可以使用 <code>zip()</code> 函数。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = ['Pradeepto', 'Kushal']
&gt;&gt;&gt; b = ['OpenSUSE', 'Fedora']
&gt;&gt;&gt; for x, y in zip(a, b):
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora
</code></pre>
<h3 id="字符串">字符串</h3>
<p><code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写。</p>
<p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写版本。</p>
<p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本</p>
<p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字</p>
<p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p>
<pre><code>&gt;&gt;&gt; s = &quot;1234&quot;
&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字
True
&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;
&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写
False
&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;
&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式
True
&gt;&gt;&gt; s = &quot;CHINA&quot;
&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写
True
</code></pre>
<p><code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>），它返回一个包含所有分割后的字符串的列表。</p>
<p><code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p>
<p>最简单的一个是 <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符</p>
<p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1</p>
<p>格式化操作符（%）</p>
<pre><code>print(&quot;my name is %s.I am %d years old&quot; % ('Shixiaolou',4))
</code></pre>
<p>在这个例子中，<code>%s</code> 为第一个格式符，表示一个字符串；<code>%d</code> 为第二个格式符，表示一个整数。格式符为真实值预留位置，并控制显示的格式。常用的有：</p>
<blockquote>
<p>%s 字符串（用 str() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%r 字符串（用 repr() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%d 十进制整数</p>
</blockquote>
<blockquote>
<p>%f 浮点数</p>
</blockquote>
<blockquote>
<p>%% 字符“%”</p>
</blockquote>
<h3 id="函数">函数</h3>
<p><code>def</code> 来定义一个函数</p>
<pre><code>def 函数名(参数):
    语句1
    语句2
</code></pre>
<p><code>global</code> 关键字，对函数中的a标志为全局变量 ， 让函数内部使用全局变量的 a。</p>
<p>函数的参数变量可以有默认值，也就是说如果我们对指定的参数变量没有给出任何值则会赋其默认值。</p>
<pre><code>&gt;&gt;&gt; def test(a , b=-99):
...     if a &gt; b:
...         return True
...     else:
...         return False
</code></pre>
<p>在函数的参数列表写出 <code>b = -99</code>。这表示如果调用者未给出 <code>b</code> 的值，那么 <code>b</code> 的值默认为 <code>-99</code>。</p>
<pre><code>&gt;&gt;&gt; test(12, 23)
False
&gt;&gt;&gt; test(12)
True
</code></pre>
<p>有两个非常重要的地方，第一个是具有默认值的参数后面不能再有普通参数，比如 <code>f(a,b=90,c)</code> 就是错误的。</p>
<p>第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。</p>
<pre><code>&gt;&gt;&gt; def f(a, data=[]):
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[1, 2]
&gt;&gt;&gt; print(f(3))
[1, 2, 3]
</code></pre>
<pre><code>&gt;&gt;&gt; def f(a, data=None):
...     if data is None:
...         data = []
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[2]
</code></pre>
<p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<ul>
<li>使用一个或多个函数作为参数</li>
<li>返回另一个函数作为输出</li>
</ul>
<p>Python 里的任何函数都可以作为高阶函数</p>
<pre><code># 创建一个函数，将参数列表中每个元素都变成全大写
&gt;&gt;&gt; def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
&gt;&gt;&gt; def test(h, l):
...     return h(l)
...
&gt;&gt;&gt; l = ['python', 'Linux', 'Git']
# 运行高阶函数，返回预期的结果
&gt;&gt;&gt; test(high, l)
['PYTHON', 'LINUX', 'GIT']
</code></pre>
<p><code>map</code> 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。</p>
<h3 id="文件">文件</h3>
<p>使用 <code>open()</code> 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li>
<p><code>&quot;r&quot;</code>，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</p>
</li>
<li>
<p><code>&quot;w&quot;</code>，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</p>
</li>
<li>
<p><code>&quot;a&quot;</code>，以追加模式打开，写入到文件中的任何数据将自动添加到末尾</p>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，<code>open()</code> 函数将会以只读模式打开文件。</p>
<p><code>close()</code> 关闭文件</p>
<p><code>read()</code> 方法一次性读取整个文件。  <code>read(size)</code> 有一个可选的参数 <code>size</code>，用于指定字符串长度。如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。</p>
</li>
</ul>
<p><code>readline()</code> 能帮助你每次读取文件的一行。  使用 <code>readlines()</code> 方法读取所有行到一个列表中。</p>
<p><code>write()</code> 方法打开一个文件写入一些文本。</p>
<p>模块 <code>sys</code>。<code>sys.argv</code> 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 <code>cp</code> 命令替代：在 <code>cp</code> 后首先输入被拷贝的文件的文件名，然后输入新文件名。</p>
<p><code>with</code> 语句处理文件对象，它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写</p>
<p>在 Linux 下你可以使用 <code>lscpu</code> 命令来查看当前电脑的 CPU 相关信息 ， 实际上 <code>lscpu</code> 命令是读取 <code>/proc/cpuinfo</code> 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 <code>/proc/cpuinfo</code> 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 <code>lscpu</code> 命令了 :）</p>
<h3 id="异常">异常</h3>
<p>我们使用 <code>try...except</code> 块来处理任意异常。基本的语法像这样：</p>
<pre><code>try:
    statements to be inside try clause
    statement2
    statement3
    ...
except ExceptionName:
    statements to evaluated in case of ExceptionName happens
</code></pre>
<p>使用 <code>raise</code> 语句抛出一个异常。</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError(&quot;A value error happened.&quot;)
... except ValueError:
...     print(&quot;ValueError in our code.&quot;)
...
ValueError in our code.
</code></pre>
<p><code>try</code> 语句还有另一个可选的 <code>finally</code> 子句，目的在于定义在任何情况下都一定要执行的功能， 不管有没有发生异常，<code>finally</code> 子句 在程序离开 <code>try</code> 后都一定会被执行。当 <code>try</code> 语句中发生了未被 <code>except</code> 捕获的异常（或者它发生在 <code>except</code> 或 <code>else</code> 子句中），在 <code>finally</code> 子句执行完后它会被重新抛出。</p>
<p><code>with</code> 语句，它是 <code>try-finally</code> 块的简写，使用 <code>with</code> 语句能保证文件始终被关闭。</p>
<h3 id="类">类</h3>
<pre><code>class nameoftheclass(parent_class):
    statement1
    statement2
    statement3
</code></pre>
<p>在类的声明中你可以写任何 Python 语句，包括定义函数（在类中我们称为方法）。</p>
<p>类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。 <code>x = MyClass()</code></p>
<p>类定义了 <code>__init__()</code> 方法的话，类的实例化操作会自动为新创建的类实例调用 <code>__init__()</code> 方法。</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre>
<p>一个类可以继承自多个类，具有父类的所有变量和方法，语法如下：</p>
<pre><code>class MyClass(Parentclass1, Parentclass2,...):
    def __init__(self):
        Parentclass1.__init__(self)
        Parentclass2.__init__(self)
        ...
        ...
</code></pre>
<p>删除一个对象使用关键字 <code>del</code> 。</p>
<p>更精确的调整控制属性访问权限，你可以使用 <code>@property</code> 装饰器，<code>@property</code> 装饰器就是负责把一个方法变成属性调用的。</p>
<h3 id="模块">模块</h3>
<p>模块是包括 Python 定义和声明的文件。文件名就是模块名加上 <code>.py</code> 后缀。</p>
<p>从模块中导入指定的函数。这样做：</p>
<pre><code>&gt;&gt;&gt; from bars import simplebar, starbar
&gt;&gt;&gt; simplebar(20)
</code></pre>
<p>含有 <code>__init__.py</code> 文件的目录可以用来作为一个包，目录里的所有 <code>.py</code> 文件都是这个包的子模块。</p>
<p><a href="http://docs.python.org/3/library/os.html#module-os"><code>os</code></a> 模块提供了与操作系统相关的功能。<code>getuid()</code> 函数返回当前进程的有效用户 id。<code>getpid()</code> 函数返回当前进程的 id。<code>getppid()</code> 返回父进程的 id。<code>uname()</code> 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 <code>uname -a</code> 命令得到。<code>uname()</code> 返回的对象是一个元组，<code>（sysname, nodename, release, version, machine）</code>。getcwd() 函数返回当前工作目录。<code>chdir(path)</code> 则是更改当前目录到 path。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/">Requests</a> 是一个第三方 Python 模块， 第三方模块并不是默认的模块，意味着你需要安装它，我们使用 <code>pip3</code> 安装它。</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install python3-pip
$ sudo pip3 install requests
</code></pre>
<p>你可以使用 <code>get()</code> 方法获取任意一个网页。</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.get('https://github.com')
&gt;&gt;&gt; req.status_code
200
</code></pre>
<p><code>req</code> 的 <code>text</code> 属性存有服务器返回的 HTML 网页使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序。</p>
<pre><code>#!/usr/bin/env python3
import requests

def download(url):
    '''
    从指定的 URL 中下载文件并存储到当前目录
    url: 要下载页面内容的网址
    '''
    # 检查 URL 是否存在
    try:
        req = requests.get(url)
    except requests.exceptions.MissingSchema:
        print('Invalid URL &quot;{}&quot;'.format(url))
        return
    # 检查是否成功访问了该网站
    if req.status_code == 403:
        print('You do not have the authority to access this page.')
        return
    filename = url.split('/')[-1]
    with open(filename, 'w') as fobj:
        fobj.write(req.content.decode('utf-8'))
    print(&quot;Download over.&quot;)

if __name__ == '__main__':
    url = input('Enter a URL: ')
    download(url)
</code></pre>
<p><code>if __name__ == '__main__':</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 <code>if</code> 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，<code>if</code> 块内的语句并不会执行。</p>
<p>命令行传入的所有参数都可以使用 <code>sys.argv</code> 获取。如果希望对参数进行处理可以使用 <code>argparse</code> 模块</p>
<h4 id="collections-模块">collections  模块</h4>
<h5 id="counter">Counter</h5>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; import re
&gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt'
&gt;&gt;&gt; words = re.findall('\w+', open(path).read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)]
</code></pre>
<p>Counter 对象有一个叫做 <code>elements()</code> 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<p><code>most_common()</code> 方法返回最常见的元素及其计数，顺序为最常见到最少。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<h5 id="defaultdict">defaultdict</h5>
<p><code>defaultdict</code> 是内建 <code>dict</code> 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同。  <code>defaultdict()</code> 第一个参数提供了 <code>default_factory</code> 属性的初始值，默认值为 <code>None</code>，<code>default_factory</code> 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数。  同样的功能使用 <code>defaultdict</code> 比使用 <code>dict.setdefault</code> 方法快。</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])])
</code></pre>
<h5 id="namedtuple">namedtuple</h5>
<p>命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息。</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])  # 定义命名元组
&gt;&gt;&gt; p = Point(10, y=20)  # 创建一个对象
&gt;&gt;&gt; p
Point(x=10, y=20)
&gt;&gt;&gt; p.x + p.y
30
&gt;&gt;&gt; p[0] + p[1]  # 像普通元组那样访问元素
30
&gt;&gt;&gt; x, y = p     # 元组拆封
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>
<h3 id="python排版">Python排版</h3>
<p>每层缩进使用4个空格。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p><code>import</code>语句分组顺序如下：</p>
<ol>
<li>导入标准库模块</li>
<li>导入相关第三方库模块</li>
<li>导入当前应用程序/库模块</li>
</ol>
<p>避免在下列情况中使用多余的空格：</p>
<ul>
<li>
<p>与括号保持紧凑（小括号、中括号、大括号）：</p>
</li>
<li>
<p>与后面的逗号、分号或冒号保持紧凑</p>
</li>
<li>
<p>切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。</p>
</li>
<li>
<p>函数名与其后参数列表的左括号应该保持紧凑</p>
</li>
<li>
<p>与切片或索引的左括号保持紧凑</p>
</li>
<li>
<p>在赋值操作符（或其它）的两侧保持多余一个的空格</p>
</li>
<li>
<p>总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。</p>
</li>
<li>
<p>在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。</p>
</li>
<li>
<p>不要在关键值参数或默认值参数的等号两边加入空格。</p>
</li>
<li>
<p>【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的<code>-&gt;</code>左右各插入一个空格。</p>
</li>
<li>
<p>打消使用复合语句（多条语句在同一行）的念头。</p>
</li>
<li>
<p>有时候把 <code>if/for/while</code> 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。</p>
<p>块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以<code>#</code>起头，并且<code>#</code>后要跟一个空格（除非是注释内的缩进文本）。</p>
<p>有节制的使用行内注释。</p>
<p>一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以<code>#</code>打头，<code>#</code>后接一个空格。</p>
<p>无谓的行内注释如果状态明显，会转移注意力。</p>
<ul>
<li>为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。</li>
<li><a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a> 描述了良好的文档字符串的约定。注意，文档字符串的结尾<code>&quot;&quot;&quot;</code>应该放在单独的一行，例如：</li>
<li>对于单行的文档字符串，把结尾<code>&quot;&quot;&quot;</code>放在同一行。</li>
</ul>
</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>Python 迭代器（<em>Iterators</em>）对象在遵守迭代器协议时需要支持如下两种方法。</p>
<p><code>__iter__()</code>，返回迭代器对象自身。这用在 <code>for</code> 和 <code>in</code> 语句中。</p>
<p><code>__next__()</code>，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 <code>StopIteration</code> 异常。</p>
<pre><code>class Counter(object):
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        #返回下一个值直到当前值大于 high
        if self.current &gt; self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
            
   
&gt;&gt;&gt; c = Counter(5,10)
&gt;&gt;&gt; for i in c:
...   print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 <code>StopIteration</code>，它会持续抛出相同的异常。</p>
<p>Python 生成器（<em>Generators</em>），生成器是更简单的创建迭代器的方法，这通过在函数中使用 <code>yield</code> 关键字完成：</p>
<pre><code>&gt;&gt;&gt; def my_generator():
...     print(&quot;Inside my generator&quot;)
...     yield 'a'
...     yield 'b'
...     yield 'c'
...
&gt;&gt;&gt; my_generator()
&lt;generator object my_generator at 0x7fbcfa0a6aa0&gt;

&gt;&gt;&gt; for char in my_generator():
...     print(char)
...
Inside my generator
a
b
c

&gt;&gt;&gt; def counter_generator(low, high):
...     while low &lt;= high:
...        yield low
...        low += 1
... 
&gt;&gt;&gt; for i in counter_generator(5,10):
...     print(i, end=' ')
... 
5 6 7 8 9 10
</code></pre>
<p>我们会发现生成器的一个特点：它们是不可重复使用的。</p>
<p>生成器表达式（<em>Generator expressions</em>），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广。</p>
<pre><code>&gt;&gt;&gt; sum([x*x for x in range(1,10)])
</code></pre>
<p>这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
</code></pre>
<p>生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。</p>
<p>闭包（<em>Closures</em>）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和。</p>
<pre><code>&gt;&gt;&gt; def add_number(num):
...     def adder(number):
...         #adder 是一个闭包
...         return num + number
...     return adder
...
&gt;&gt;&gt; a_10 = add_number(10)
&gt;&gt;&gt; a_10(21)
31
&gt;&gt;&gt; a_10(34)
44
&gt;&gt;&gt; a_5 = add_number(5)
&gt;&gt;&gt; a_5(3)
8
</code></pre>
<p>装饰器（<em>Decorators</em>）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的。</p>
<pre><code>&gt;&gt;&gt; def my_decorator(func):
...     def wrapper(*args, **kwargs):
...         print(&quot;Before call&quot;)
...         result = func(*args, **kwargs)
...         print(&quot;After call&quot;)
...         return result
...     return wrapper
...
&gt;&gt;&gt; @my_decorator
... def add(a, b):
...     #我们的求和函数
...     return a + b
...
&gt;&gt;&gt; add(1, 3)
Before call
After call
4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://xmweijh.github.io/post/git/</id>
        <link href="https://xmweijh.github.io/post/git/">
        </link>
        <updated>2020-03-21T10:38:26.000Z</updated>
        <content type="html"><![CDATA[<p>git init  将一个已存在的文件夹，置于Git的控制管理之下</p>
<p>git add  将创建或修改的文件添加到本地的暂存区</p>
<p><code>git add .</code> 命令全部添加到暂存区。</p>
<p>撤销暂存区的修改执行 <code>git reset -- [文件名]</code> 或者 <code>git rm --cached [文件名]</code> 命令即可</p>
<p>git commit  提交文件到本体仓库----每当完成一些工作，都可以创建一次提交，保存当前的版本</p>
<p>提交之前，设置名字和email   相当于签名，每次提交会包含这些信息  git config  配置</p>
<p><code>git config -l</code> 可以查看配置信息</p>
<pre><code>$ git config --global user.name &quot;YourName&quot;
$ git config --global user.email &quot;YourEmail@xxx.com&quot;

git commit -m &quot;first commit&quot;   -m&quot;注释&quot;
</code></pre>
<p>提交加注释辨别不同版本，便于理解对代码做了什么修改</p>
<p>git push 同步到远端仓库</p>
<p>git status 监测当前目录和缓存区的状态</p>
<pre><code>git remote add origin 仓库链接
git push origin master  （origin为仓库名）
</code></pre>
<p>git clone 拷贝一个Git仓库到本地，让自己能够查看修改。</p>
<p><code>git diff</code>用来查看工作区被跟踪的文件的修改详情</p>
<p><code>git diff --cached</code> 查看暂存区的全部修改</p>
<p><code>git log</code>，它用来查看版本区的提交历史记录</p>
<ul>
<li>
<p><code>git log [分支名]</code> 查看某分支的提交历史，不写分支名查看当前所在分支</p>
</li>
<li>
<p><code>git log --oneline</code> 一行显示提交历史</p>
</li>
<li>
<p><code>git log -n</code> 其中 n 是数字，查看最近 n 个提交</p>
</li>
<li>
<p><code>git log --author [贡献者名字]</code> 查看指定贡献者的提交记录</p>
</li>
<li>
<p><code>git log --graph</code> 图示法显示提交历史</p>
<p><code>git log</code> 查看提交记录  时间正序排列的信息，那么可以使用 <code>git log --reverse</code> 命令。 (按q退出此界面)</p>
<p><code>git branch -avv</code>，它用来查看全部分支信息</p>
<p><code>git reset --soft HEAD^</code> 撤销最近的一次提交，将修改还原到暂存区。  <code>--soft</code> 表示软退回，对应的还有 <code>--hard</code> 硬退，HEAD^<code>表示撤销一次提交，</code>HEAD^^<code>表示撤销两次提交，撤销 n 次可以简写为</code>HEAD~n`。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用操作]]></title>
        <id>https://xmweijh.github.io/post/linux-chang-yong-cao-zuo/</id>
        <link href="https://xmweijh.github.io/post/linux-chang-yong-cao-zuo/">
        </link>
        <updated>2020-03-21T10:37:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目录">目录</h3>
<pre><code> shiyanlou:~/ $   
</code></pre>
<p>当前所处的目录位置  shiiyanlou： 用户名   $命令提示符</p>
<p>**ls ：**查找目录中的内容    （蓝字目录，白字内容）</p>
<p><strong>cd:</strong> 进入目录</p>
<p>上下键可以快速选择前面输过的命令</p>
<p>**cd ..**可以回到上一级目录（中间有空格）</p>
<p>**cd -**上次所在的目录</p>
<p>**cd ~**回到主目录</p>
<p>**cd /**进入根目录</p>
<h3 id="文件">文件</h3>
<p><strong>tree</strong> 列出文件夹下所有子文件和文件（树形结构）</p>
<p><strong>Ctrl + c</strong> 停止</p>
<p><strong>pwd</strong> 获得当前目录的绝对路径</p>
<p><strong>mkdir</strong> 创建目录  加入**-p**一次性创建多级目录</p>
<p><strong>touch</strong> 新建文件   		<strong>cp</strong> 复制文件到指定目录</p>
<p><strong>cp -r</strong> 复制目录 		<strong>rm</strong> 删除文件 删除目录加 <strong>-r</strong></p>
<p><strong>mv</strong>移动文件或者目录  还可以用来重命名</p>
<p><strong>cat</strong> 将文件内容打印到屏幕 <strong>cat -n</strong>带上行号</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab的一些点]]></title>
        <id>https://xmweijh.github.io/post/matlab-de-yi-xie-dian/</id>
        <link href="https://xmweijh.github.io/post/matlab-de-yi-xie-dian/">
        </link>
        <updated>2020-03-14T12:48:10.000Z</updated>
        <content type="html"><![CDATA[<p>用mod时，不管被除数是正是负，余数的符号与除数相同，rem反之。</p>
<p>直接输入用中括号，同行空格或者逗号不同行用；号。</p>
<p>冒号表达式格式： 初始值：步长：终止值</p>
<p>linspace（第一个元素，最后一个元素，元素总数）</p>
<p>matlab元素按列储存，先第一列在第二列。</p>
<p>矩阵拆分用：号</p>
<p>~=是不等于</p>
<p>fix朝零方向取整，如fix(-1.3)=-1; fix(1.3)=1;</p>
<p>floor，顾名思义，就是地板，所以是取比它小的整数，即朝负无穷方向取整，如floor(-1.3)=-2; floor(1.3)=1;floor(-1.8)=-2，floor(1.8)=1</p>
<p>ceil，与floor相反，它的意思是天花板，也就是取比它大的最小整数，即朝正无穷方向取整，如ceil(-1.3)=-1; ceil(1.3)=2;ceil(-1.8)=-1，ceil(1.8)=2</p>
<p>round四舍五入到最近的整数，如round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2。</p>
<p>在进行矩阵之间的运算时“.<em>”和“</em>”的意义就有所不同了。假设a，b表示两个矩阵，a*b表示矩阵a与矩阵b进行矩阵相乘，a.*b表示矩阵a中的元素与矩阵b中的元素按位置依次相乘，得到的结果将作为新矩阵中相同位置的元素</p>
<p>a:c:b表示[a,a+c,……,a+n*c],其中n=fix((b-a)/c)</p>
<p>Syms 变量间不打符号</p>
<p>abs函数求实数的绝对值，复数的模，字符串的asc||</p>
<p>在plot写完后 加上axis([0 1 2 3])</p>
<p>则表明图线的x轴范围为0<sub>1y轴范围为2</sub>3</p>
<p>hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存</p>
<p>即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</p>
<p>hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++]]></title>
        <id>https://xmweijh.github.io/post/c/</id>
        <link href="https://xmweijh.github.io/post/c/">
        </link>
        <updated>2020-03-14T12:43:39.000Z</updated>
        <content type="html"><![CDATA[<p>C++比C更丰富</p>
<p>(1).支持面向对象，将问题域和方法域统一化。宏观面向对象，微观面向过程。</p>
<p>(2).支持泛型编程。</p>
<pre><code>int add (int a, int b) { ... }

template\&lt;typename T&gt;

T add (T a, T b) { ... }
</code></pre>
<p>(3).支持异常机制。</p>
<pre><code>int func (void) {

  ...

}
</code></pre>
<pre><code>int main (void) {

  if (func () == -1) {

​    //错误处理;

  }

}
</code></pre>
<p>(4).操作符重载</p>
<p>不再使用scanf/printf而是cin/cout。</p>
<p>头文件：#include\大多数标准库头文件没有.h后缀。</p>
<p>输出：cout – 标准输出对象</p>
<p>输入运算符：&lt;&lt;</p>
<p>提取输出运算符：&gt;&gt;</p>
<pre><code>\#include &lt;iostream&gt;
 int main (void) {
   std::cout &lt;&lt; &quot;Hello, World !&quot; &lt;&lt; std::endl;
   int i;
   double d;
   char s[256];
 //  scanf (&quot;%d%lf%s&quot;, &amp;i, &amp;d, s);
   std::cin &gt;&gt; i &gt;&gt; d &gt;&gt; s;
 //  printf (&quot;%d %lf %s\n&quot;, i, d, s);
   std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; d &lt;&lt; ' ' &lt;&lt; s &lt;&lt; '\n';
   return 0;
 }
</code></pre>
<p>A. 结构</p>
<p>定义结构型变量时，可以省略struct关键字。</p>
<p>1)结构内部可以定义函数——成员函数。</p>
<p>2)sizeof(空结构) -&gt; 1</p>
<p>C++层面上引用和指针存在以下不同：</p>
<p>(a). 指针是实体变量，但是引用不是实体变量。</p>
<pre><code> int&amp; a=b;
 sizeof (a);//4
 double&amp; d=f;
 sizeof (d);//8
</code></pre>
<p>(b). 指针可以不初始化，但是引用必须初始化。</p>
<p>(c). 指针的目标可以修改，但是引用的目标的不能修改。</p>
<p>(d). 可以定义指针的指针，但是不能定义引用的指针。</p>
<pre><code> int a;
 int* p = &amp;a;
 int** pp = &amp;p;//ok
 int&amp; r = a;
 int&amp;* pr = &amp;r;//ERROR
</code></pre>
<p>(e). 可以定义指针的引用，但是不能定义引用的引用。</p>
<pre><code> int a;
 int* p = &amp;a;
 int*&amp; q = p;//ok
 int&amp; r = a;
 int&amp;&amp; s = r;//ERROR
</code></pre>
<p>(f). 可以定义指针的数组，但不能定义引用的数组。</p>
<pre><code> int a, b, c;
 int* parr[] = {&amp;a,&amp;b,&amp;c};/ok
 int&amp; rarr[] = {a,b,c};//ERROR
 //可以定义数组的引用。
 int arr[] = {1 ,2,3};
</code></pre>
<p><strong>建议</strong>:</p>
<p>(1). 少用宏，多用const，enum和inline。</p>
<pre><code>\#define PAI 3.14159 

 const double PAI = 3.14159;

 #define ERORR_FILE -1;

 #defile ERORR_MEM -2;

 enum {

 ERORR_FILE = -1,

 ERORR_MEM = -2

 };

 #define max(a,b) ((a) &gt; (b) ? (a) : (b))

 inline int double max (double a,double b){return a &gt; b ? a : b;}
</code></pre>
<p>(2). 变量随用随时声明同时初始化。</p>
<p>(3). 少用malloc/free,多用new/delete。</p>
<p>(4). 少用C风格的强制类型转换，多用类型转换运算符。</p>
<p>(5). 少用C风格的字符串，多用string。</p>
<p>(6). 树立面向对象的编程思想。</p>
<p>类和对象</p>
<p>什么是对象</p>
<p>1 万物皆对象</p>
<p>程序就是一组对象，对象之间通过消息交换信息</p>
<p>类就是对对象的描述和抽象，对象就是类的具体化和实例化。</p>
<p>2 通过类描述对象</p>
<p>属性：姓名、年龄、学号</p>
<p>行为：吃饭、睡觉、学习</p>
<p>类就是从属性和行为两个方面对对象进行抽象。</p>
<p>3 面向对象程序设计（OOP）</p>
<p>现实世界 虚拟世界</p>
<p>对象 -&gt; 抽象 -&gt; 类 -&gt; 对象</p>
<p>至少掌握一种OOP编程语言</p>
<p>精通一种面向对象的元语言—UML</p>
<p>研究设计模式，GOF</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言的一些基础知识]]></title>
        <id>https://xmweijh.github.io/post/hui-bian-yu-yan-de-yi-xie-ji-chu-zhi-shi/</id>
        <link href="https://xmweijh.github.io/post/hui-bian-yu-yan-de-yi-xie-ji-chu-zhi-shi/">
        </link>
        <updated>2020-03-14T12:36:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<pre><code>Int add_a_and_b(int a,int b){

returna+b;

}

Int main(){

returnadd_a_and_b(2,3);

}
</code></pre>
<pre><code>_add_a_and_b:

 push%ebx mov%eax,

[%esp+8]mov%ebx,

[%esp+12]add%eax,%ebx 

pop%ebx

 ret _main:push3 push2 call _add_a_and_b add%esp,8ret
</code></pre>
<p>针对8086CPU，有14个寄存器，分别为： AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW。</p>
<p>ABCD-X，通用寄存器，存储一般性数据。 不过，在汇编中，CX 有个特殊功能，用于存储 loop的循环次数。 这里的寄存器都有分高低位，H、L分别表示高低。示例：</p>
<p>mov ax, 11  ; 将11送入寄存器ax<br>
mov bl, 3    ; 将3送入bl寄存器<br>
add ax, 5    ; 将ax寄存器的值加3</p>
<p>CS、IP 是最关键的两个寄存器，它们指示了当前 要读取指令的地址，CS是段地址，IP是指令指针寄存器。 CSx16+IP 就是CPU当前要执行的指令。换个通俗的话，要让CPU执行什么命令，只要改变这两个寄存器的值，就可以做到了。（有一种皇帝的感觉，哈哈），但是CPU不可能提供 mov cs, 11h 等命令操作，使用jmp cs:ip 进行更改值，从而跳转到想执行的命令处。</p>
<p>DS 寄存器是用于存储数据的段地址，比如要读取某段数据中的值，那么就要先DS指向那里的地址，再加上偏移地址 [...]，就可以进行数据读取了（ES作为附加段寄存器，与DS功能一致，在段太多的情况，可以视情况选用即可）</p>
<p>SS, SP, BP 是栈相关寄存器。CPU提供的栈机制</p>
<p>在语言层面表现出来就是，push, pop 两个命令，任意时刻，SS:SP都指向栈顶元素。 push 时， SP=SP-2，pop时，如果有接收的寄存器则先将栈顶值送入，然后 SP=SP+2，指向下面一个单元。 这有什么用呢？ 当然有用，它可以用来临时保存各种数据，然后再插入功能执行完成后，进行现场的恢复，事实上，大部分时候是这么用的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言的一些笔记]]></title>
        <id>https://xmweijh.github.io/post/c-yu-yan-de-yi-xie-bi-ji/</id>
        <link href="https://xmweijh.github.io/post/c-yu-yan-de-yi-xie-bi-ji/">
        </link>
        <updated>2020-03-14T12:24:35.000Z</updated>
        <content type="html"><![CDATA[<p>该运算<strong>只适合用两个整数</strong>进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。</p>
<p>注意：复合运算符中运算符和等号之间是<strong>不存在空格</strong>的。</p>
<p>* 整个逗号表达式的值是最后一个表达式的值c = (++a, a *= 2, b = a * 5); &lt;==&gt; c=b;</p>
<p>数组a的地址是ffc1，数组a[0]的地址也是ffc1，即a = a[0]；</p>
<p>注意了，尾部有个'\0'，如果没有这个结束标记，说明这个字符数组存储的并不是字符串</p>
<p>使用‘’初始化时，一定记得加‘\0’，</p>
<p>而“”初始化时，系统会自动在字符串尾部加上一个\0结束符</p>
<p>gets可以读入包含空格、tab的字符串，直到遇到回车为止；scanf<strong>不能用来读取空格</strong>、tab</p>
<p>算法：可以没有输入，<strong>但是一定要有输出</strong>。</p>
<p>%符号两边要，求是整数。不是整数就错了。</p>
<p>int x=y=10: 错啦，<strong>定义时，不可以连续赋值</strong>。int x,y; x=y=10;   对滴，定义完成后，可以连续赋值。</p>
<p>逗号表达式： 优先级别最低。表达式的数值逗号最右边的那个表达式的数值</p>
<p>z=（2，3，4）(整个是赋值表达式) 这个时候z的值为4。</p>
<p>z=  2，3，4 （整个是逗号表达式）这个时候z的值为2。</p>
<p>注释不是C语言，不占运行时间，没有分号。不可以嵌套！</p>
<p>数组名代表的值不可以改变，他是地址常量名。</p>
<p>在C语言中，二维数组元素的内存中的存放顺序是按行主顺序存放</p>
<p>while(k++&amp;&amp;n++&gt;2); k=1，n=2，因为k++为0不计算后面的n++，k变化，n不变</p>
<p>最终可以得出结论：a = a[0] = &amp;a[0][0]，以此类推，可以得出a[1] = &amp;a[1][0]</p>
<p>sqrt()算术平方根函数，fabs()绝对值函数，pow()幂函数，sin()正弦函数</p>
<p>指数形式字母e或E前必须有数字，且后面的数字必须为整数。</p>
<p>for 循环三个表达式<strong>可以省去</strong>，第二表达式只要为真就执行，无特殊格式。</p>
<p>​</p>
<pre><code>int main(int argc, const char * argv[]) {

  clock_t start,finish;

  

  start = clock();

  printf(&quot;计算结果：%d\n&quot;, fib(45));

  finish = clock();

  printf(&quot;花费时间--------%lu\n&quot;,finish - start);

 

   

  start = clock();

  printf(&quot;计算结果：%d\n&quot;, tailfib(45,1,1));

  finish = clock();

   

  printf(&quot;花费时间--------%lu\n&quot;,finish - start);

  return 0;
</code></pre>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xmweijh.github.io/</id>
    <title>小虾米的记录</title>
    <updated>2021-07-04T09:13:33.997Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xmweijh.github.io/"/>
    <link rel="self" href="https://xmweijh.github.io/atom.xml"/>
    <subtitle>努力成就自我</subtitle>
    <logo>https://xmweijh.github.io/images/avatar.png</logo>
    <icon>https://xmweijh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小虾米的记录</rights>
    <entry>
        <title type="html"><![CDATA[Linux基础]]></title>
        <id>https://xmweijh.github.io/post/linux-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/linux-ji-chu/">
        </link>
        <updated>2021-07-04T09:12:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="linux基础">Linux基础</h2>
<h3 id="终端命令">终端命令</h3>
<p><strong>command</strong> [-options] [parameter]</p>
<ul>
<li>command：命令名, 比如: ls、pwd</li>
<li>[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。</li>
<li>[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。</li>
<li>[]：代表可选</li>
<li>对于命令，它的选项和参数一般情况下没有顺序要求，但是scp命令是必须先选项然后在跟上参数。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ls</td>
<td style="text-align:left">查看当前目录信息（只能查看当层目录信息）</td>
</tr>
<tr>
<td style="text-align:left">tree</td>
<td style="text-align:left">以树状方式显示目录信息(可以查看多层目录信息)</td>
</tr>
<tr>
<td style="text-align:left">pwd</td>
<td style="text-align:left">查看当前目录路径</td>
</tr>
<tr>
<td style="text-align:left">clear</td>
<td style="text-align:left">清除终端内容</td>
</tr>
<tr>
<td style="text-align:left">cd 目录</td>
<td style="text-align:left">切换到指定目录(cd 空白也是同功能)</td>
</tr>
<tr>
<td style="text-align:left">cd ~</td>
<td style="text-align:left">切换到当前用户的主目录</td>
</tr>
<tr>
<td style="text-align:left">cd ..</td>
<td style="text-align:left">切换到上一级目录</td>
</tr>
<tr>
<td style="text-align:left">cd .</td>
<td style="text-align:left">切换到当前目录</td>
</tr>
<tr>
<td style="text-align:left">cd -</td>
<td style="text-align:left">切换到上一次目录</td>
</tr>
<tr>
<td style="text-align:left">./</td>
<td style="text-align:left">当前路径</td>
</tr>
<tr>
<td style="text-align:left">../</td>
<td style="text-align:left">上一路径</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">touch 文件名</td>
<td style="text-align:left">创建指定文件</td>
</tr>
<tr>
<td style="text-align:left">mkdir 目录名</td>
<td style="text-align:left">创建目录(文件夹)</td>
</tr>
<tr>
<td style="text-align:left">rm 文件名或者目录名</td>
<td style="text-align:left">删除指定文件或者目录<strong>rm命令想要删除目录需要加上-r选项</strong>，-r表示递归删除目录及其内容</td>
</tr>
<tr>
<td style="text-align:left">rmdir 目录名</td>
<td style="text-align:left">删除空目录</td>
</tr>
<tr>
<td style="text-align:left">cp</td>
<td style="text-align:left">拷贝文件、拷贝目录    拷贝目录需要加上-r选项</td>
</tr>
<tr>
<td style="text-align:left">mv</td>
<td style="text-align:left">移动文件、移动目录、重命名</td>
</tr>
</tbody>
</table>
<h3 id="看命令帮助方式">看命令帮助方式</h3>
<ul>
<li>--help 使用说明: 命令 --help</li>
<li>man 使用说明: man 命令</li>
</ul>
<p><strong>man命令的说明:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">操作键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">空格</td>
<td style="text-align:left">显示下一屏信息</td>
</tr>
<tr>
<td style="text-align:left">回车</td>
<td style="text-align:left">显示下一行信息</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">显示上一屏信息</td>
</tr>
<tr>
<td style="text-align:left">f</td>
<td style="text-align:left">显示下一屏信息</td>
</tr>
<tr>
<td style="text-align:left">q</td>
<td style="text-align:left">退出</td>
</tr>
</tbody>
</table>
<h3 id="ls命令选项使用">ls命令选项使用</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">以列表方式显示</td>
</tr>
<tr>
<td style="text-align:left">-h</td>
<td style="text-align:left">件大小单位显示，默认是字节</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">显示隐藏文件和隐藏目录</td>
</tr>
</tbody>
</table>
<ul>
<li>ls不同选项会呈现不同的显示方式，其中-l和-a选项最常用</li>
<li>可以 ls -alh 三者功能都有</li>
</ul>
<h3 id="mkdir命令选项">mkdir命令选项</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">创建所依赖的文件夹</td>
</tr>
</tbody>
</table>
<p>如直接 mkdir -p AA/BB/C.txt  会自动创建前面需要的文件夹AA/BB/</p>
<h3 id="rm命令选项">rm命令选项</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">交互式提示  没有重名会直接覆盖 有则会提示</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">递归删除目录及其内容</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">删除空目录</td>
</tr>
</tbody>
</table>
<ul>
<li>创建嵌套文件夹使用 <strong>“mkdir –p”</strong> 嵌套目录</li>
<li>删除空目录使用 <strong>“rmdir 目录名”</strong> 或者 <strong>“rm –d 目录名”</strong></li>
<li>删除非空目录使用 <strong>“rm –r 目录名”</strong></li>
</ul>
<h3 id="cp命令选项">cp命令选项</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">交互式提示</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">递归拷贝目录及其内容</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示拷贝后的路径描述</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">保留文件的原有权限   而且可以拷贝文件夹同时保留里面文件权限只需要-a  而不需要-ar</td>
</tr>
</tbody>
</table>
<h3 id="mv命令选项">mv命令选项</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">交互式提示</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示移动后的路径描述</td>
</tr>
</tbody>
</table>
<ul>
<li>拷贝文件防止覆盖使用 <strong>“cp –i”</strong> 操作</li>
<li>拷贝文件夹使用 <strong>“cp –r”</strong> 操作，拷贝文件夹并且文件权限不丢失使用 <strong>“cp –a”</strong> 操作。</li>
<li>移动文件防止覆盖使用 <strong>“mv –i”</strong> 操作</li>
<li>移动文件夹直接使用 <strong>“mv”</strong> 即可，<strong>“mv”</strong> 还可以给文件和文件夹重命名。</li>
</ul>
<h3 id="重定向命令">重定向命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式</td>
</tr>
</tbody>
</table>
<p>重定向也称为输出重定向，把在终端执行命令的结果保存到目标文件。</p>
<p>如  ls xx  &gt;1.txt</p>
<h3 id="查看文件内容命令">查看文件内容命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cat</td>
<td style="text-align:left">查看小型文件</td>
</tr>
<tr>
<td style="text-align:left">more</td>
<td style="text-align:left">分屏查看大型文件</td>
</tr>
</tbody>
</table>
<p>控制命令与man相同</p>
<ul>
<li>gedit 文件编辑命令，可以查看和编辑文件</li>
</ul>
<p>管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。</p>
<p>管道(|)一般结合 more 命令使用，主要是分配查看终端显示内容。</p>
<p>is/bin | more</p>
<h3 id="链接命令">链接命令</h3>
<p>链接命令是创建链接文件，链接文件分为:</p>
<ul>
<li>软链接</li>
<li>硬链接</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ln -s</td>
<td style="text-align:left">创建软链接</td>
</tr>
<tr>
<td style="text-align:left">ln</td>
<td style="text-align:left">创建硬链接</td>
</tr>
</tbody>
</table>
<p>ll相当于ls -la</p>
<ul>
<li><strong>软链接的作用是方便文件的快速访问，比如:给一个复杂路径下的文件创建一个软链接，以后就可以通过软链接完成快速访问操作。</strong></li>
<li><strong>创建软链接命令格式: ln -s 源文件路径(使用绝对路径) 软链接(你输入什么他就怎么找)</strong></li>
<li><strong>删除源文件则软链接失效</strong></li>
<li><strong>可以给目录创建软链接</strong></li>
</ul>
<p><strong>硬链接</strong></p>
<p>类似于<strong>源文件的一个别名</strong>，也就是说这两个名字指向的是同一个文件数据。(修改都要变化  与cp拷贝不同)</p>
<ul>
<li><strong>创建硬链接使用相对路径和绝对路径都可以</strong></li>
<li><strong>删除源文件，硬链接还可以访问到数据。</strong></li>
<li><strong>创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。</strong></li>
<li><strong>创建软链接，硬链接数不会加1</strong></li>
<li><strong>不能给目录创建硬链接</strong></li>
</ul>
<p><strong>硬链接数:</strong></p>
<p><strong>硬链接数就是文件数据被文件名使用的次数, 好比引用计数</strong></p>
<ul>
<li>硬链接的作用是可以给重要文件创建硬链接，能够防止文件数据被误删。</li>
<li>删除源文件，软链接失效，但是硬链接依然可以使用。</li>
<li>创建硬链接命令格式: ln 源文件路径 硬链接</li>
</ul>
<h3 id="文本搜索命令">文本搜索命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grep</td>
<td style="text-align:left">文本搜索</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">命令选项</td>
<td style="text-align:left">说明</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">忽略大小写</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">显示匹配行号</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示不包含匹配文本的所有行</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">正则表达式</td>
<td style="text-align:left">说明</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">以指定字符串开头</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">以指定字符串结尾</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>grep</strong> 命令还可以文本搜索管道中的内容，比如: <strong>ls / | grep ‘lib’</strong></li>
<li>在使用 <strong>grep</strong> 命令的时候还可以省略搜索内容的引号，比如: <strong>ls / | grep lib</strong>， <strong>grep hello 1.txt</strong></li>
</ul>
<h3 id="查找文件命令">查找文件命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">find</td>
<td style="text-align:left">在指定目录下查找文件(包括目录)</td>
</tr>
<tr>
<td style="text-align:left">-name</td>
<td style="text-align:left">根据文件名(包括目录名)字查找</td>
</tr>
<tr>
<td style="text-align:left">通配符</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">代表0个或多个任意字符</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">代表任意一个字符</td>
</tr>
</tbody>
</table>
<p>通配符不仅能结合 <strong>find</strong> 命令使用，还可以结合其它命令使用, 比如: <strong>ls、mv、cp</strong> 等，这里需要注意只有 <strong>find</strong> 命令使用通配符需要加上引号。</p>
<h3 id="压缩和解压缩命令">压缩和解压缩命令</h3>
<p>Linux默认支持的压缩格式:</p>
<ul>
<li>.gz</li>
<li>.bz2</li>
<li>.zip</li>
<li>.gz和.bz2的压缩包需要使用tar命令来压缩和解压缩</li>
<li>.zip的压缩包需要使用zip命令来压缩，使用unzip命令来解压缩</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tar</td>
<td style="text-align:left">压缩和解压缩命令</td>
</tr>
<tr>
<td style="text-align:left">选项</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">创建打包文件</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示打包或者解包的详细信息</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">指定文件名称, 必须放到所有选项后面</td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td style="text-align:left">压缩或解压缩(.gz)</td>
</tr>
<tr>
<td style="text-align:left">-j</td>
<td style="text-align:left">压缩或解压缩(.bz2)</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">解包</td>
</tr>
<tr>
<td style="text-align:left">-C</td>
<td style="text-align:left">解压缩到指定目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zip</td>
<td style="text-align:left">压缩成.zip格式文件</td>
</tr>
<tr>
<td style="text-align:left">unzip</td>
<td style="text-align:left">解压缩.zip格式文件</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">解压缩到指定目录</td>
</tr>
</tbody>
</table>
<h3 id="文件权限命令">文件权限命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">chmod</td>
<td style="text-align:left">修改文件权限</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>u</th>
<th>user, 表示该文件的所有者</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>group, 表示用户组</td>
</tr>
<tr>
<td>o</td>
<td>other, 表示其他用户</td>
</tr>
<tr>
<td>a</td>
<td>all, 表示所有用户</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">增加权限</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">撤销权限</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">设置权限</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">权限</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">可读</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">可写</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">可执行</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">无任何权限</td>
</tr>
</tbody>
</table>
<p><strong>chmod 数字法的使用</strong></p>
<p>数字法就是“rwx” 这些权限也可以用<strong>数字来代替</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">权限</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">可读，权限值是4</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">无任何权限，权限值是0</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">可写，权限值是2</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">可执行，权限值是1</td>
</tr>
</tbody>
</table>
<h3 id="获取管理员权限的相关命令获取管理员权限的相关命令">获取管理员权限的相关命令获取管理员权限的相关命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sudo -s</td>
<td style="text-align:left">切换到root用户，获取管理员权限</td>
</tr>
<tr>
<td style="text-align:left">sudo</td>
<td style="text-align:left">某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo</td>
</tr>
<tr>
<td style="text-align:left">whoami</td>
<td style="text-align:left">查看当前用户限</td>
</tr>
<tr>
<td style="text-align:left">exit</td>
<td style="text-align:left">退出登录用户</td>
</tr>
<tr>
<td style="text-align:left">who</td>
<td style="text-align:left">查看所有的登录用户</td>
</tr>
<tr>
<td style="text-align:left">passwd</td>
<td style="text-align:left">修改用户密码，不指定用户默认修改当前登录用户密码</td>
</tr>
<tr>
<td style="text-align:left">which</td>
<td style="text-align:left">查看命令位置</td>
</tr>
<tr>
<td style="text-align:left">shutdown –h now</td>
<td style="text-align:left">立刻关机</td>
</tr>
<tr>
<td style="text-align:left">reboot</td>
<td style="text-align:left">重启</td>
</tr>
</tbody>
</table>
<ul>
<li>sudo 是临时获取管理员权限</li>
<li>sudo -s 是切换到管理员用户，一直使用管理员权限，需要谨慎操作。</li>
<li>exit 是退出当前用户</li>
<li>passwd 默认修改当前用户密码</li>
</ul>
<h3 id="用户相关操作">用户相关操作</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">useradd</td>
<td style="text-align:left">创建(添加)用户</td>
</tr>
<tr>
<td style="text-align:left">选项</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">自动创建用户主目录,主目录的名字就是用户名</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td style="text-align:left">指定用户所属的用户组，默认不指定会自动创建一个同名的用户组</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>useradd</strong> 命令的使用需要使用管理员权限，前面需要加上 <strong>sudo</strong></li>
<li>创建用户如果不指定用户组，默认会自动创建一个同名的用户组</li>
<li>查看用户是否创建成功，可以查看**/etc/passwd**这个文件</li>
<li>查看用户组是否创建成功，可以查看**/etc/group**这个文件</li>
</ul>
<p><strong>id命令查看用户信息:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">查看用户信息</td>
</tr>
</tbody>
</table>
<p>给其它用户设置密码，需要使用: <strong>sudo passwd 用户名</strong></p>
<p><strong>切换用户</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">su</td>
<td style="text-align:left">切换用户</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">usermod</td>
<td style="text-align:left">修改用户信息</td>
</tr>
</tbody>
</table>
<p><strong>usermod选项:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-G</td>
<td style="text-align:left">设置一个附加组</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td style="text-align:left">修改用户组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">gpasswd</td>
<td style="text-align:left">添加和删除附加组信息</td>
</tr>
</tbody>
</table>
<p><strong>gpasswd命令选项:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-a 用户名</td>
<td style="text-align:left">给用户添加附加组</td>
</tr>
<tr>
<td style="text-align:left">-d 用户名</td>
<td style="text-align:left">给用户删除附加组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">userdel</td>
<td style="text-align:left">删除用户</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-r 用户名</td>
<td style="text-align:left">删除用户主目录，必须要设置，否则用户主目录不会删除</td>
</tr>
</tbody>
</table>
<h3 id="用户组相关操作">用户组相关操作</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">groupadd</td>
<td style="text-align:left">创建(添加)用户组</td>
</tr>
<tr>
<td style="text-align:left">groupdel</td>
<td style="text-align:left">删除用户组</td>
</tr>
</tbody>
</table>
<ul>
<li>创建用户组使用: <strong>sudo groupadd 用户组名</strong></li>
<li>创建用户并指定用户组使用: <strong>sudo useradd -m -g 用户组 用户名</strong></li>
<li>修改用户组使用: <strong>sudo usermod -g 用户组 用户名</strong></li>
<li>删除用户组使用: <strong>sudo groupdel 用户组名</strong></li>
</ul>
<h3 id="远程登录-远程拷贝命令">远程登录、远程拷贝命令</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ssh</td>
<td style="text-align:left">远程登录</td>
</tr>
<tr>
<td style="text-align:left">scp</td>
<td style="text-align:left">远程拷贝   拷贝文件夹需要加-r选项。</td>
</tr>
</tbody>
</table>
<ul>
<li>大量的文件上传和下载可以通过可视化工具FileZilla来完成。</li>
</ul>
<h3 id="vim">vim</h3>
<ul>
<li>命令模式       按i进入编辑模式   :进入 末行模式</li>
<li>编辑模式     ESC退出到命令模式</li>
<li>末行模式     ESC退出到命令模式</li>
</ul>
<p><strong>说明:</strong></p>
<p>vim 打开文件进入的是命令模式</p>
<p><strong>末行模式命令</strong></p>
<ul>
<li>:w 保存</li>
<li>:wq 保存退出</li>
<li>:x 保存退出</li>
<li>:q! 强制退出</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>yy</strong></td>
<td style="text-align:left"><strong>复制光标所在行</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>p</strong></td>
<td style="text-align:left"><strong>粘贴</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>dd</strong></td>
<td style="text-align:left"><strong>删除/剪切当前行</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>V</strong></td>
<td style="text-align:left"><strong>按行选中</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>u</strong></td>
<td style="text-align:left"><strong>撤销</strong></td>
</tr>
<tr>
<td style="text-align:left">ctr+r</td>
<td style="text-align:left">反撤销</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">往右缩进</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">往左缩进</td>
</tr>
<tr>
<td style="text-align:left">:/搜索的内容</td>
<td style="text-align:left">搜索指定内容</td>
</tr>
<tr>
<td style="text-align:left">:%s/要替换的内容/替换后的内容/g</td>
<td style="text-align:left">全局替换</td>
</tr>
<tr>
<td style="text-align:left">:开始行数,结束行数s/要替换的内容/替换后的内容</td>
<td style="text-align:left">局部替换</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">重复上一次命令操作</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">回到最后一行</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td style="text-align:left">回到第一行</td>
</tr>
<tr>
<td style="text-align:left">数字+G</td>
<td style="text-align:left">回到指定行</td>
</tr>
<tr>
<td style="text-align:left">shift+6</td>
<td style="text-align:left">回到当前行的行首</td>
</tr>
<tr>
<td style="text-align:left">shift+4</td>
<td style="text-align:left">回到当前行的行末</td>
</tr>
<tr>
<td style="text-align:left">ctr+f</td>
<td style="text-align:left">下一屏</td>
</tr>
<tr>
<td style="text-align:left">ctr+b</td>
<td style="text-align:left">上一屏</td>
</tr>
</tbody>
</table>
<p>Ubuntu 操作系统安装软件有两种方式:</p>
<ul>
<li>
<p><strong>sudo dpkg -i 安装包</strong> 命令</p>
</li>
<li>
<p><strong>sudo apt-get install 安装包</strong> 命令卸载</p>
</li>
<li>
<p>Ubuntu 操作系统卸载软件有两种方式:</p>
<ul>
<li><strong>dpkg -r 安装包</strong> 命令</li>
<li><strong>apt-get remove 安装包</strong> 命令卸载</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器学习Coursera-ML]]></title>
        <id>https://xmweijh.github.io/post/ji-qi-xue-xi-coursera-ml/</id>
        <link href="https://xmweijh.github.io/post/ji-qi-xue-xi-coursera-ml/">
        </link>
        <updated>2021-06-26T08:36:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="机器学习coursera-ml">机器学习Coursera-ML</h1>
<h3 id="定义">定义：</h3>
<p>第一个机器学习的定义来自于<strong>Arthur Samuel</strong>。他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。</p>
<p>另一个定义，由<strong>Tom Mitchell</strong>提出，<strong>Tom</strong>定义的机器学习是，一个好的学习问题定义如下，他说，一个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。</p>
<h3 id="监督学习">监督学习</h3>
<p>监督学习指的就是我们给学习算法一个数据集。</p>
<p>回归问题（连续）   分类问题（离散）</p>
<p><strong>支持向量机，里面有一个巧妙的数学技巧，能让计算机处理无限多个特征</strong></p>
<h3 id="无监督学习">无监督学习</h3>
<p>不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。</p>
<h2 id="单变量线性回归">单变量线性回归</h2>
<p>只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。</p>
<p>型所预测的值与训练集中实际值之间的差距就是<strong>建模误差</strong>（<strong>modeling error</strong>）</p>
<p>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。 即使得代价函数 最小。</p>
<h3 id="梯度下降">梯度下降</h3>
<p>梯度下降是一个用来求函数最小值的算法</p>
<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>
<pre><code class="language-python">def computeCost(X, y, theta):
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))
</code></pre>
<p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。</p>
<p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。</p>
<p>梯度下降算法的每次迭代受到学习率的影响，如果学习率过小，则达到收敛所需的迭代次数会非常高；如果学习率过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p>
<p>正规方程</p>
<figure data-type="image" tabindex="1"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210614112326242-1623641023485.png" alt="image-20210614112326242" loading="lazy"></figure>
<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。</p>
<pre><code class="language-python">import numpy as np
    
 def normalEqn(X, y):
    
   theta = np.linalg.inv(X.T@X)@X.T@y #X.T@X等价于X.T.dot(X)
    
   return theta
</code></pre>
<h2 id="逻辑回归logistic-regression">逻辑回归(Logistic Regression)</h2>
<p>线性回归算法不适合于来解决一个分类问题，而适合于回归问题</p>
<blockquote>
<p>分类和回归的区别在于输出变量的类型。<br>
定量输出称为回归，或者说是连续变量预测；<br>
定性输出称为分类，或者说是离散变量预测。</p>
</blockquote>
<p>而逻辑回归算法是分类算法，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法，它适用于标签 y取值离散的情况，如：1 0 0 1。</p>
<figure data-type="image" tabindex="2"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210615151842853.png" alt="image-20210615151842853" loading="lazy"></figure>
<pre><code class="language-python">import numpy as np
    
def sigmoid(z):
    
   return 1 / (1 + np.exp(-z))
</code></pre>
<p>决策边界(<strong>decision boundary</strong>)</p>
<figure data-type="image" tabindex="3"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210615154450765.png" alt="image-20210615154450765" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210615154609670.png" alt="image-20210615154609670" loading="lazy"></figure>
<pre><code class="language-python">import numpy as np
    
def cost(theta, X, y):
    
  theta = np.matrix(theta)
  X = np.matrix(X)
  y = np.matrix(y)
  first = np.multiply(-y, np.log(sigmoid(X* theta.T)))
  second = np.multiply((1 - y), np.log(1 - sigmoid(X* theta.T)))
  return np.sum(first - second) / (len(X))
</code></pre>
<p><strong>共轭梯度法 BFGS</strong> (<strong>变尺度法</strong>) 和<strong>L-BFGS</strong> (<strong>限制变尺度法</strong>)</p>
<h2 id="正则化regularization">正则化(Regularization)</h2>
<p>如果我们发现了过拟合问题，应该如何处理？</p>
<ol>
<li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li>
<li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li>
</ol>
<pre><code class="language-python">import numpy as np
​
def costReg(theta, X, y, learningRate):
    theta = np.matrix(theta)
    X = np.matrix(X)
    y = np.matrix(y)
    first = np.multiply(-y, np.log(sigmoid(X*theta.T)))
    second = np.multiply((1 - y), np.log(1 - sigmoid(X*theta.T)))
    reg = (learningRate / (2 * len(X))* np.sum(np.power(theta[:,1:theta.shape[1]],2))
    return np.sum(first - second) / (len(X)) + reg
</code></pre>
<h2 id="神经网络">神经网络</h2>
<p>无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p>
<p>使用神经网络时的步骤：</p>
<p>网络结构：第一件要做的事是选择网络结构，即决定选择多少层以及决定每层分别有多少个单元。</p>
<p>第一层的单元数即我们训练集的特征数量。</p>
<p>最后一层的单元数是我们训练集的结果的类的数量。</p>
<p>如果隐藏层数大于1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数越多越好。</p>
<p>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</p>
<p>训练神经网络：</p>
<ol>
<li>参数的随机初始化</li>
<li>利用正向传播方法计算所有的hx</li>
<li>编写计算代价函数 的代码</li>
<li>利用反向传播方法计算所有偏导数</li>
<li>利用数值检验方法检验这些偏导数</li>
<li>使用优化算法来最小化代价函数</li>
</ol>
<h2 id="应用机器学习的建议advice-for-applying-machine-learning">应用机器学习的建议(Advice for Applying Machine Learning)</h2>
<pre><code>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？
</code></pre>
<ol>
<li>
<p>获得更多的训练样本——通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</p>
</li>
<li>
<p>尝试减少特征的数量</p>
</li>
<li>
<p>尝试获得更多的特征</p>
</li>
<li>
<p>尝试增加多项式特征</p>
</li>
<li>
<p>尝试减少正则化程度</p>
</li>
<li>
<p>尝试增加正则化程度</p>
<pre><code> 我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。
</code></pre>
</li>
</ol>
<p>它们也被称为&quot;机器学习诊断法&quot;。“诊断法”的意思是：这是一种测试法，你通过执行这种测试，能够深入了解某种算法到底是否有用。这通常也能够告诉你，要想改进一种算法的效果，什么样的尝试，才是有意义的。</p>
<pre><code>为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。
</code></pre>
<h3 id="模型选择和交叉验证集">模型选择和交叉验证集</h3>
<p>模型选择的方法为：</p>
<ol>
<li>使用训练集训练出10个模型</li>
<li>用10个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</li>
<li>选取代价函数值最小的模型</li>
<li>用步骤3中选出的模型对测试集计算得出推广误差（代价函数的值）</li>
</ol>
<pre><code>高偏差和高方差的问题基本上来说是欠拟合和过拟合的问题。

训练集误差和交叉验证集误差近似时：偏差/欠拟合
​
交叉验证集误差远大于训练集误差时：方差/过拟合
</code></pre>
<p>选择λ的方法为：</p>
<ol>
<li>使用训练集训练出12个不同程度正则化的模型</li>
<li>用12个模型分别对交叉验证集计算的出交叉验证误差</li>
<li>选择得出交叉验证误差<strong>最小</strong>的模型</li>
<li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上</li>
</ol>
<pre><code>• 当λ较小时，训练集误差较小（过拟合）而交叉验证集误差较大• 随着λ的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加在高偏差/欠拟合的情况下，增加数据到训练集不一定能有帮助。假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。也就是说在高方差/过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。
</code></pre>
<ol>
<li>获得更多的训练样本——解决高方差</li>
<li>尝试减少特征的数量——解决高方差</li>
<li>尝试获得更多的特征——解决高偏差</li>
<li>尝试增加多项式特征——解决高偏差</li>
<li>尝试减少正则化程度λ——解决高偏差</li>
<li>尝试增加正则化程度λ——解决高方差</li>
</ol>
<pre><code>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。

通常选择较大的神经网络并采用正则化处理会比采用较小的神经网络效果要好。

对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，然后选择交叉验证集代价最小的神经网络。
</code></pre>
<h2 id="机器学习系统的设计">机器学习系统的设计</h2>
<p>构建一个学习算法的推荐方法为：</p>
<ol>
<li>从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</li>
<li>绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</li>
<li>进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的样本，看看这些样本是否有某种系统化的趋势</li>
</ol>
<p>偏斜类（skewed classes）的问题。类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本。</p>
<h3 id="查准率和查全率之间的权衡">查准率和查全率之间的权衡</h3>
<figure data-type="image" tabindex="5"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210621173328942.png" alt="image-20210621173328942" loading="lazy"></figure>
<h2 id="支持向量机support-vector-machines">支持向量机(Support Vector Machines)</h2>
<figure data-type="image" tabindex="6"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210623090847215.png" alt="image-20210623090847215" loading="lazy"></figure>
<p>支持向量机有时被称为<strong>大间距分类器</strong></p>
<p>较大时，相当于λ 较小，可能会导致过拟合，高方差。</p>
<p>较小时，相当于λ 较大，可能会导致低拟合，高偏差。</p>
<figure data-type="image" tabindex="7"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210623104225022.png" alt="image-20210623104225022" loading="lazy"></figure>
<p>σ较大时，可能会导致低方差，高偏差；</p>
<p>σ较小时，可能会导致低偏差，高方差。</p>
<h2 id="聚类clustering">聚类(Clustering)</h2>
<p><strong>K-均值</strong>是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。</p>
<p><strong>K-均值</strong>是一个迭代算法，假设我们想要将数据聚类成n个组，其方法为:</p>
<p>首先选择K个随机的点，称为<strong>聚类中心</strong>（<strong>cluster centroids</strong>）；</p>
<p>对于数据集中的每一个数据，按照距离个中心点的距离，将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类。</p>
<p>计算每一个组的平均值，将该组所关联的中心点移动到平均值的位置。</p>
<p>重复步骤2-4直至中心点不再变化。</p>
<figure data-type="image" tabindex="8"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210624092652680.png" alt="image-20210624092652680" loading="lazy"></figure>
<p>在运行K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做:</p>
<p>1.我们应该选择K&lt;m，即聚类中心点的个数要小于所有训练集实例的数量<br>
2.随机选择K个训练实例，然后令K个聚类中心分别与这K个训练实例相等</p>
<p>没有所谓最好的选择聚类数的方法，通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用<strong>K-均值</strong>算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。</p>
<h2 id="降维dimensionality-reduction">降维(Dimensionality Reduction)</h2>
<h3 id="动机一数据压缩">动机一：数据压缩</h3>
<h3 id="动机二数据可视化">动机二：数据可视化</h3>
<h3 id="主成分分析问题">主成分分析问题</h3>
<p>主成分分析(<strong>PCA</strong>)是最常见的降维算法。</p>
<p>在<strong>PCA</strong>中，我们要做的是找到一个方向向量（<strong>Vector direction</strong>），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p>
<figure data-type="image" tabindex="9"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210624105033999.png" alt="image-20210624105033999" loading="lazy"></figure>
<p>主要成分分析是减少投射的平均均方误差：</p>
<p>我们希望在平均均方误差与训练集方差的比例尽可能小的情况下选择尽可能小的k值。</p>
<figure data-type="image" tabindex="10"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210624112150628.png" alt="image-20210624112150628" loading="lazy"></figure>
<p>错误的主要成分分析情况：一个常见错误使用主要成分分析的情况是，将其用于减少过拟合（减少了特征的数量）。这样做非常不好，不如尝试正则化处理。原因在于主要成分分析只是近似地丢弃掉一些特征，它并不考虑任何与结果变量有关的信息，因此可能会丢失非常重要的特征。然而当我们进行正则化处理时，会考虑到结果变量，不会丢掉重要的数据。</p>
<p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分，这虽然很多时候有效果，最好还是从所有原始特征开始，只在有必要的时候（算法运行太慢或者占用太多内存）才考虑采用主要成分分析。</p>
<h2 id="异常检测anomaly-detection">异常检测(Anomaly Detection)</h2>
<figure data-type="image" tabindex="11"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210625095319096.png" alt="image-20210625095319096" loading="lazy"></figure>
<p>之前我们构建的异常检测系统也使用了带标记的数据，与监督学习有些相似，下面的对比有助于选择采用监督学习还是异常检测：</p>
<p>两者比较：</p>
<table>
<thead>
<tr>
<th style="text-align:left">异常检测</th>
<th style="text-align:left">监督学习</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">非常少量的正向类（异常数据 y=1）, 大量的负向类（y=0）</td>
<td style="text-align:left">同时有大量的正向类和负向类</td>
</tr>
<tr>
<td style="text-align:left">许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。</td>
<td style="text-align:left">有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。</td>
</tr>
<tr>
<td style="text-align:left">未来遇到的异常可能与已掌握的异常、非常的不同。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td>
<td style="text-align:left">例如：邮件过滤器 天气预报 肿瘤分类</td>
</tr>
</tbody>
</table>
<p>原高斯分布模型和多元高斯分布模型的比较：</p>
<table>
<thead>
<tr>
<th style="text-align:left">原高斯分布模型</th>
<th style="text-align:left">多元高斯分布模型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">不能捕捉特征之间的相关性 但可以通过将特征进行组合的方法来解决</td>
<td style="text-align:left">自动捕捉特征之间的相关性</td>
</tr>
<tr>
<td style="text-align:left">计算代价低，能适应大规模的特征</td>
<td style="text-align:left">计算代价较高 训练集较小时也同样适用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">必须要有 m&gt;n，不然的话协方差矩阵 不可逆的，通常需要 m&gt;10n 另外特征冗余也会导致协方差矩阵不可逆</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="12"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210625114024157.png" alt="image-20210625114024157" loading="lazy"></figure>
<h3 id="协同过滤算法">协同过滤算法<img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210626160916302.png" alt="image-20210626160916302" loading="lazy"></h3>
<h3 id="随机梯度下降法">随机梯度下降法</h3>
<figure data-type="image" tabindex="13"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210626162433415.png" alt="image-20210626162433415" loading="lazy"></figure>
<h3 id="小批量梯度下降">小批量梯度下降</h3>
<figure data-type="image" tabindex="14"><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210626162447571.png" alt="image-20210626162447571" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python小记]]></title>
        <id>https://xmweijh.github.io/post/python-xiao-ji/</id>
        <link href="https://xmweijh.github.io/post/python-xiao-ji/">
        </link>
        <updated>2021-05-12T10:58:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python小记">Python小记</h1>
<p>最近要开始准备毕设了，要用到Python，记录一些容易搞混搞错的地方。</p>
<p>截取切片时候：</p>
<ul>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li>
</ul>
<p><strong>[头下标:尾下标]</strong> 获取的子字符串包含头下标的字符，<strong>但不包含尾下标的字符</strong>。</p>
<pre><code>str = 'Hello World!'
print(str[2:7])

llo W
</code></pre>
<p>数据类型</p>
<ul>
<li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<p>isinstance 和 type 都可以查询变量所指的对象类型。</p>
<p>区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<p>Python 使用反斜杠 \转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串</p>
<h3 id="列表-元组-字典-集合区别">列表 元组 字典 集合区别</h3>
<p>List（列表） 是 Python 中使用最频繁的数据类型。[]</p>
<p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。()</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。{}</p>
<p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。{}</p>
<p>整数除法中，除法 <strong>/</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>//</strong> ,但是**//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系(类似于c语言的/。</p>
<p>在 python 中，类型属于对象，变量是没有类型的：</p>
<pre><code>a=[1,2,3]

a=&quot;Runoob&quot;
</code></pre>
<p>以上代码中，<strong>[1,2,3]</strong> 是 List 类型，<strong>&quot;Runoob&quot;</strong> 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<p>**不可变类型：**变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</p>
<p>**可变类型：**变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p>
<h3 id="python如何调用另一个文件的类出现no-module-named">python如何调用另一个文件的类出现No module named**</h3>
<p><strong>解决办法：将文件设置为root路径（重要步骤！！！）</strong></p>
<p>右键文件夹  mark dictionary as</p>
<p>感觉忘了很多 抽空还是系统学习下pyhton</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL常见容器函数用法]]></title>
        <id>https://xmweijh.github.io/post/stl-chang-jian-rong-qi-han-shu-yong-fa/</id>
        <link href="https://xmweijh.github.io/post/stl-chang-jian-rong-qi-han-shu-yong-fa/">
        </link>
        <updated>2021-03-18T07:49:47.000Z</updated>
        <content type="html"><![CDATA[<p>本文列出一些常用STL用法，一些注意点在上一篇STL中，两者搭配效果更佳☺</p>
<h2 id="string">string</h2>
<pre><code class="language-c">	#include &lt;string&gt;
	
/*
string 构造函数
string();//创建一个空的字符串 例如: string str;
string(const string&amp; str);//使用一个string对象初始化另一个string对象
string(const char* s);//使用字符串s初始化
string(int n, char c);//使用n个字符c初始化

3.1.2.2 string基本赋值操作
string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串
string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串
string&amp; operator=(char c);//字符赋值给当前的字符串
string&amp; assign(const char *s);//把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串
string&amp; assign(int n, char c);//用n个字符c赋给当前字符串
string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串

*/
	//常见构造
	string str; //默认构造
	string str2(str); //拷贝构造
	string str3 = str;

	string str4 = &quot;abcd&quot;;
	string str5(10, 'a');


	//基本赋值
	str = &quot;hello&quot;;
	str2 = str4;

	//string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
	str3.assign(&quot;abcdef&quot;, 4);

	//string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串
	string str6;
	str6.assign(str, 1, 3); //ell ? hel 从0索引


/*
string存取字符操作
char&amp; operator[](int n);//通过[]方式取字符
char&amp; at(int n);//通过at方法获取字符

*/
	string s = &quot;hello world&quot;;

	for (int i = 0; i &lt; s.size();i++)
	{
		//cout &lt;&lt; s[i] &lt;&lt; endl;
		cout &lt;&lt; s.at(i) &lt;&lt; endl;
	}
	//[] 和at区别？[]访问越界  直接挂掉 at会抛出异常

	


/*
string拼接操作
string&amp; operator+=(const string&amp; str);//重载+=操作符
string&amp; operator+=(const char* str);//重载+=操作符
string&amp; operator+=(const char c);//重载+=操作符
string&amp; append(const char *s);//把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾
string&amp; append(const string &amp;s);//同operator+=()
string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾
string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c

string查找和替换
int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置
int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置
string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s

*/

	//拼接
	string s1 = &quot;我&quot;;
	string s2 = &quot;爱北京&quot;;
	s1 += s2;
	cout &lt;&lt; s1 &lt;&lt; endl;
	s1.append(&quot;天安门&quot;);

	cout &lt;&lt; s1 &lt;&lt; endl;

	//find查找

	string s = &quot;abcdefg&quot;;
	int pos = s.find(&quot;bcf&quot;); //找不到返回是 -1
	cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
	
	int pos2 = s.rfind(&quot;bc&quot;); //rfind  和find 结果一样，内部查找顺序相反
	cout &lt;&lt; &quot;pos2 = &quot; &lt;&lt; pos2 &lt;&lt; endl; // 4 2 


	//替换
	string s3 = &quot;hello&quot;; //替换从pos开始n个字符为字符串str
	s3.replace(1, 3, &quot;1111&quot;);
	cout &lt;&lt; s3 &lt;&lt; endl; // h1111o



/*
string比较操作
/*
compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。
比较区分大小写，比较时参考字典顺序，排越前面的越小。
大写的A比小写的a小。

int compare(const string &amp;s) const;//与字符串s比较
int compare(const char *s) const;//与字符串s比较
*/
	string s1 = &quot;abc&quot;;
	string s2 = &quot;abcd&quot;;

	if (s1.compare(s2) == 0)
	{
		cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;
	}
	else if (s1.compare(s2) == 1)
	{
		cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;
	}

/*
string子串
string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串

*/
	string s1 = &quot;abcde&quot;;

	string s2 = s1.substr(1, 3);
	cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

	//需求  查找一个右键的 用户名
	string email = &quot;zhangtao@sina.com&quot;;

	int pos = email.find(&quot;@&quot;);//8 
	cout &lt;&lt; &quot;pos &quot; &lt;&lt; pos &lt;&lt; endl;

	string usrName = email.substr(0, pos);
	cout &lt;&lt; &quot;用户名为：&quot; &lt;&lt; usrName &lt;&lt; endl;


/*
string插入和删除操作
string&amp; insert(int pos, const char* s); //插入字符串
string&amp; insert(int pos, const string&amp; str); //插入字符串
string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c
string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符

*/
	string s1 = &quot;hello&quot;;
	s1.insert(1, &quot;111&quot;);
	cout &lt;&lt; s1 &lt;&lt; endl; //h111ello

	//删除 111
	s1.erase(1, 3);
	cout &lt;&lt; s1 &lt;&lt; endl;

/*
string和c-style字符串转换
*/
void func(string s)
{
	cout &lt;&lt; s &lt;&lt; endl;
}

void func2(const char * s)
{
	cout &lt;&lt; s &lt;&lt; endl;
}
	string s = &quot;abc&quot;;
	//string -&gt; const char *

	const char * p = s.c_str();

	func(p); //const char * 隐式类型转换为 string

	//const char * -&gt; string 

	string s2(p);
	//func2(s2); //string 不能隐式类型转换为 char * 


/*
写一个函数，函数内部将string字符串中的所有小写字母都变为大写字母。
*/
	string s = &quot;abCdEfg&quot;;

	for (int i = 0; i &lt; s.size();i++)
	{
		//s[i] = toupper(s[i]);

		//全变小写
		s[i] = tolower(s[i]);
	}

	cout &lt;&lt; s &lt;&lt; endl;
</code></pre>
<h2 id="vector">vector</h2>
<pre><code class="language-c">#include &lt;vector&gt;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++){
		v.push_back(i);
		cout &lt;&lt; v.capacity() &lt;&lt; endl;  // v.capacity()容器的容量
	}

/*
vector构造函数
vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);//构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);//拷贝构造函数。

//例子 使用第二个构造函数 我们可以...
int arr[] = {2,3,4,1,9};
vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));

vector常用赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector&amp; operator=(const vector  &amp;vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。

vector大小操作
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。

*/
void printVector( vector&lt;int&gt;&amp;v)
{
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}
void test02()
{
	vector &lt;int &gt;v;
	int arr[] = { 2, 3, 4, 1, 9 };
	vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));

	vector&lt;int&gt;v2(v1.begin(), v1.end());

	printVector(v2);

	vector&lt;int&gt;v3(10, 100);

	printVector(v3);

	//赋值使用
	vector&lt;int&gt;v4;
	v4.assign(v3.begin(), v3.end());
	printVector(v4);


	v4.swap(v2);

	cout &lt;&lt; &quot;交换后的v4 &quot; &lt;&lt; endl;
	printVector(v4);

	cout &lt;&lt; &quot;v4容器的大小&quot; &lt;&lt; v4.size() &lt;&lt; endl;

	if (v4.empty())
	{
		cout &lt;&lt; &quot;v4空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;v4不空&quot; &lt;&lt; endl;
	}
	
	//v4 23419
	v4.resize(10,-1); //第二个参数是默认值 ，默认0 
	printVector(v4);

	v4.resize(3);
	printVector(v4);

}
//巧用swap收缩空间
void test03()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 100000; i++)
	{
		v.push_back(i);
	}

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;

	v.resize(3);

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;

	//巧用swap
	vector&lt;int&gt;(v).swap(v);

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;
}

//reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
void test04()
{
	vector&lt;int&gt;v;

	v.reserve(100000); //预留出空间

	int * p = NULL;
	int num = 0;
	for (int i = 0; i &lt; 100000;i++)
	{
		v.push_back(i);
		if (p!=&amp;v[0])
		{
			p = &amp;v[0];
			num++;
		}
	}
	cout &lt;&lt; num &lt;&lt; endl;
	// 开辟100000数据用了多少次
}



/*
vector数据存取操作
at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素

 vector插入和删除操作
insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素

*/

void test05()
{
	vector&lt;int&gt;v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(20);
	v.push_back(50);

	cout &lt;&lt; &quot;v的front&quot; &lt;&lt; v.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的back&quot; &lt;&lt; v.back() &lt;&lt; endl;


	v.insert(v.begin(), 2 ,100); //参数1  迭代器   参数2  N个数  参数3 具体插入的内容

	printVector(v);

	v.pop_back(); //尾删
	printVector(v);

	v.erase(v.begin()); //删除 
	printVector(v);

	//v.erase(v.begin(), v.end());
	//v.clear(); //清空所有数据
	if (v.empty() )
	{
		cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl;
	}

}
void test06()
{
	//逆序遍历
	vector&lt;int&gt;v;
	for ( int  i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

//	printVector(v);
	//reverse_iterator 逆序迭代器
	for (vector&lt;int&gt;::reverse_iterator it = v.rbegin(); it != v.rend();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//vector迭代器是随机访问的迭代器  支持跳跃式访问
	vector&lt;int&gt;::iterator itBegin = v.begin();
	itBegin = itBegin + 3;
	//如果上述写法不报错，这个迭代器是随机访问迭代器


	list&lt;int&gt;l;
	for (int i = 0; i &lt; 10;i++)
	{
		l.push_back(i);
	}
	list&lt;int&gt;::iterator lIt = l.begin();
	//lIt = lIt + 1; //不支持随机访问

}
</code></pre>
<h2 id="deque">deque</h2>
<pre><code class="language-c">#include &lt;deque&gt;

/*
deque构造函数
deque&lt;T&gt; deqT;//默认构造形式
deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);//构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);//拷贝构造函数。

deque赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
deque&amp; operator=(const deque &amp;deq); //重载等号操作符
swap(deq);// 将deq与本身的元素互换

deque大小操作
deque.size();//返回容器中元素的个数
deque.empty();//判断容器是否为空
deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
*/
void printDeque(const deque&lt;int&gt;&amp;d)
{
	//iterator 普通迭代器  reverse_iterator 逆序迭代器  const_iterator 只读迭代器
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end();it++)
	{
		//*it = 100000;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	deque&lt;int&gt;d;

	d.push_back(10);
	d.push_back(40);
	d.push_back(30);
	d.push_back(20);

	printDeque(d);

	deque&lt;int&gt;d2(d.begin(), d.end());
	d2.push_back(10000);

	//交换
	d.swap(d2);

	printDeque(d);


	// d2  10 40 30 20
	if (d2.empty())
	{
		cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;不为空 大小为：&quot; &lt;&lt;d2.size() &lt;&lt; endl;
	}
}

/*
deque双端插入和删除操作
push_back(elem);//在容器尾部添加一个数据
push_front(elem);//在容器头部插入一个数据
pop_back();//删除容器最后一个数据
pop_front();//删除容器第一个数据

3.3.3.5 deque数据存取
at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();//返回第一个数据。
back();//返回最后一个数据
3.3.3.6 deque插入操作
insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
3.3.3.7 deque删除操作
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。

*/

void test02()
{
	deque&lt;int&gt;d;
	d.push_back(10);
	d.push_back(30);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	printDeque(d); // 200 100 10 30 20

	//删除 头删 尾删
	d.pop_back();
	d.pop_front();
	printDeque(d); // 100 10 30

	cout &lt;&lt; &quot;front: &quot; &lt;&lt; d.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;back: &quot; &lt;&lt; d.back() &lt;&lt; endl;

	//插入
	deque&lt;int&gt;d2;
	d2.push_back(50);
	d2.push_back(60);
	d2.insert(d2.begin(), d.begin(), d.end());
	printDeque(d2);  //  100 10 30 50 60


}

//排序规则
bool myCompare(int v1, int v2)
{
	return v1 &gt; v2; // 100 10
}

//排序 sort
void test03()
{
	deque&lt;int&gt;d;
	d.push_back(5);
	d.push_back(15);
	d.push_back(3);
	d.push_back(40);
	d.push_back(7);

	printDeque(d);
	//排序
	sort(d.begin(), d.end());

	printDeque(d);

	//从大到小
	sort(d.begin(), d.end(), myCompare);
	printDeque(d);

}
</code></pre>
<h2 id="stack">stack</h2>
<pre><code class="language-c">#include &lt;stack&gt;
/*
stack构造函数
stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &amp;stk);//拷贝构造函数
stack赋值操作
stack&amp; operator=(const stack &amp;stk);//重载等号操作符
stack数据存取操作
push(elem);//向栈顶添加元素
pop();//从栈顶移除第一个元素
top();//返回栈顶元素
stack大小操作
empty();//判断堆栈是否为空
size();//返回堆栈的大小
*/

void test01()
{
	stack&lt;int&gt;s;
	//放入数据 push
	s.push(10);
	s.push(30);
	s.push(20);
	s.push(40);

	while (s.size() != 0)
	{
		cout &lt;&lt; &quot;栈顶为 &quot; &lt;&lt; s.top() &lt;&lt; endl;  //40  20  30  10
		//弹出栈顶元素
		s.pop();
	}
	cout &lt;&lt; &quot;size = &quot; &lt;&lt; s.size() &lt;&lt; endl;
	
}

</code></pre>
<h2 id="queue">queue</h2>
<pre><code class="language-c">#include &lt;queue&gt;

/*
queue构造函数
queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &amp;que);//拷贝构造函数
queue存取、插入和删除操作
push(elem);//往队尾添加元素
pop();//从队头移除第一个元素
back();//返回最后一个元素
front();//返回第一个元素

queue赋值操作
queue&amp; operator=(const queue &amp;que);//重载等号操作符
 queue大小操作
empty();//判断队列是否为空
size();//返回队列的大小

*/

void test01()
{
	queue&lt;int&gt;q;
	q.push(10);//往队尾添加元素
	q.push(20); 
	q.push(30); 
	q.push(40);

	while (!q.empty())
	{

		//  10 40  20 40  30  40  40  40
		cout &lt;&lt; &quot;队头: &quot; &lt;&lt; q.front() &lt;&lt; endl; 
		cout &lt;&lt; &quot;队尾: &quot; &lt;&lt; q.back() &lt;&lt; endl; 
		//弹出队头元素
		q.pop();
	}

	cout &lt;&lt; &quot;size : &quot; &lt;&lt; q.size() &lt;&lt; endl;
}
</code></pre>
<h2 id="list">list</h2>
<pre><code class="language-c">#include &lt;list&gt;
//list是双向循环链表
void test01()
{
	list&lt;int&gt; myList;
	for (int i = 0; i &lt; 10; i++){
		myList.push_back(i);
	}

	list&lt;int&gt;::_Nodeptr node = myList._Myhead-&gt;_Next;

	for ( int i = 0; i &lt; myList._Mysize * 2; i++){
		cout &lt;&lt; &quot;Node:&quot; &lt;&lt; node-&gt;_Myval &lt;&lt; endl;
		node = node-&gt;_Next;
		if (node == myList._Myhead){
			node = node-&gt;_Next;
		}
	}


}

//list常用API
/*
list构造函数
list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：
list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);//构造函数将n个elem拷贝给本身。
list(const list &amp;lst);//拷贝构造函数。
list数据元素插入和删除操作
push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。
*/

void printList(list&lt;int&gt;&amp;L)
{
	for (list&lt;int&gt;::iterator it = L.begin(); it != L.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test02()
{
	list&lt;int&gt;L(10,10);
	list&lt;int&gt;L2(L.begin(), L.end());

	printList(L);
	printList(L2);
	L2.push_back(100);

	//逆序打印
	for (list&lt;int&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//list迭代器不支持随机访问
	list&lt;int&gt;::iterator itBegin = L2.begin();
	//itBegin = itBegin + 1;


	//插入数据
	list&lt;int&gt;L3;
	L3.push_back(10);
	L3.push_back(30);
	L3.push_back(20);
	L3.push_front(100);
	L3.push_front(300);
	L3.push_front(200);

	printList(L3); //  200 300 100 10 30 20 

	//删除两端数据
	L3.pop_front(); //头删
	L3.pop_back(); //尾删
	printList(L3); // 300 100 10 30

	L3.insert(L3.begin(), 1000);
	printList(L3); // 1000 300 100 10 30

	//remove(elem);//删除容器中所有与elem值匹配的元素。
	L3.push_back(10);// 1000 300 100 10 30 10
	L3.remove(10); //参数 直接放值

	printList(L3);//1000 300 100  30
}


/*
list大小操作
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。

 list赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list&amp; operator=(const list &amp;lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换。
 list数据的存取
front();//返回第一个元素。
back();//返回最后一个元素。
*/

void test03()
{
	list&lt;int&gt;L3;
	L3.push_back(10);
	L3.push_back(30);
	L3.push_back(20);
	L3.push_front(100);
	L3.push_front(300);
	L3.push_front(200);

	cout &lt;&lt; &quot;大小：&quot; &lt;&lt; L3.size() &lt;&lt; endl;
	if (L3.empty())
	{
		cout &lt;&lt; &quot;L3为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;L3不为空&quot; &lt;&lt; endl;
	}

	L3.resize(10);
	printList(L3);

	L3.resize(3);
	printList(L3);

	list&lt;int&gt; L4;
	L4.assign(L3.begin(), L3.end());

	//200 300 100
	cout &lt;&lt; &quot;front: &quot; &lt;&lt; L4.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;back: &quot; &lt;&lt; L4.back() &lt;&lt; endl;
}

/*
list反转排序
reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); //list排序
*/

bool myCompare(int v1, int v2)
{	
	return v1 &gt; v2; //降序
}

void test04()
{
	list&lt;int&gt;L;

	L.push_back(10);
	L.push_back(20);
	L.push_back(40);
	L.push_back(30);

	L.reverse();
	printList(L); // 30 40 20 10

	//所有不支持随机访问的迭代器 不可以用系统提供的算法
	// 如果不支持用系统提供算法，那么这个类内部会提供
	//sort(L.begin(), L.end()); 
	L.sort(); //从小到大

	printList(L);

	//从大到小
	L.sort(myCompare);
	printList(L);

}

//自定义数据类型
class Person
{
public:
	Person(string name, int age,int height)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
		this-&gt;m_Height = height;
	}

	//重载 == 让remove 可以删除自定义的person类型
	bool operator==( const  Person &amp; p)
	{
		if ( this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Height == p.m_Height)
		{
			return true;
		}
		return false;
	}

	string m_Name;
	int m_Age;
	int m_Height; //身高 
};

//Person排序规则 如果年龄 相同  按照身高的升序排序
bool myComparePerson( Person &amp; p1,Person &amp; p2 )
{
	//if (p1.m_Age &gt; p2.m_Age)
	//{
	//	return true;
	//}
	//return false;

	if (p1.m_Age == p2.m_Age)
	{
		return p1.m_Height &lt; p2.m_Height;
	}
	else
	{
		return p1.m_Age &gt; p2.m_Age;
	}
	

}

void test05()
{
	list&lt;Person&gt; L;

	Person p1(&quot;亚瑟&quot;, 10 , 165);
	Person p2(&quot;德玛西亚&quot;, 20 , 170);
	Person p3(&quot;火枪&quot;, 17,177);
	Person p4(&quot;德雷福斯&quot;, 19, 120);
	Person p5(&quot;MT&quot;, 18,200);
	Person p6(&quot;狗蛋&quot;, 18, 166);
	Person p7(&quot;狗剩&quot;, 18, 210);

	L.push_back(p1);
	L.push_back(p2);
	L.push_back(p3);
	L.push_back(p4);
	L.push_back(p5);
	L.push_back(p6);
	L.push_back(p7);

	//需求 打印数据时候 按照年龄的降序 输出
	//对于自定义数据类型 ，必须要指定排序规则
	L.sort( myComparePerson);
	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end();it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot;&lt;&lt; it-&gt;m_Height&lt;&lt; endl;
	}

	//删除 狗蛋 
	cout &lt;&lt; &quot; -------------------- &quot; &lt;&lt; endl;

	L.remove(p6);
	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
	}

}

</code></pre>
<h2 id="set">set</h2>
<pre><code class="language-c">//set  multiset头文件
#include &lt;set&gt;

/*
set构造函数
set&lt;T&gt; st;//set默认构造函数：
mulitset&lt;T&gt; mst; //multiset默认构造函数:
set(const set &amp;st);//拷贝构造函数
set赋值操作
set&amp; operator=(const set &amp;st);//重载等号操作符
swap(st);//交换两个集合容器
 set大小操作
size();//返回容器中元素的数目
empty();//判断容器是否为空

set插入和删除操作
insert(elem);//在容器中插入元素。
clear();//清除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);//删除容器中值为elem的元素。

*/

void printSet( set&lt;int&gt;&amp; s)
{
	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	set&lt;int&gt;s1;
	//关联式容器 key进行排序，从小到大
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);
	printSet(s1);

	if (s1.empty())
	{
		cout &lt;&lt; &quot;空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; endl;
	}

	s1.erase(s1.begin()); // 3 5 7 9
	printSet(s1);
	s1.erase(3); //  5 7 9
	printSet(s1);
}

/*
set查找操作
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);//查找键key的元素个数
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。

*/

void test02()
{
	set&lt;int&gt;s1;
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);
	//对于set 没有value  key就是value

	set&lt;int&gt;::iterator pos = s1.find(2);
	//判断是否找到
	if (pos != s1.end())
	{
		cout &lt;&lt; &quot;找到了：值为：&quot; &lt;&lt; *pos &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//count(key);//查找键key的元素个数 set而言 结果 0或者1 

	int num =  s1.count(2);
	cout &lt;&lt;  &quot;2的个数为： &quot; &lt;&lt; num &lt;&lt; endl;


	//lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
	set&lt;int&gt;::iterator it =  s1.lower_bound(3); // 10就是未找到
	if (it!= s1.end())
	{
		cout &lt;&lt; &quot;找到了 lower_bound (3)的值为：&quot; &lt;&lt; *it &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
	// upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
	set&lt;int&gt;::iterator it2 = s1.upper_bound(3);
	if (it2 != s1.end())
	{
		cout &lt;&lt; &quot;找到了 upper_bound (3)的值为：&quot; &lt;&lt; *it2 &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
	//上下限 就是lower_bound   upper_bound
	pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt;  ret =  s1.equal_range(3);
	//获取第一个值

	if (ret.first != s1.end())
	{
		cout &lt;&lt; &quot;找到equal_range中 lower_bound 的值 ：&quot; &lt;&lt; *(ret.first) &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//获取第二个值
	if (ret.second != s1.end())
	{
		cout &lt;&lt; &quot;找到equal_range中 upper_bound 的值 ：&quot; &lt;&lt; *(ret.second) &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
	
}


//set容器 不允许插入重复的键值
void test03()
{
	set&lt;int&gt; s1;
	pair&lt;set&lt;int&gt;::iterator,bool&gt; ret =  s1.insert(10);

	if (ret.second)
	{
		cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl;
	}

	ret = s1.insert(10);
	if (ret.second)
	{
		cout &lt;&lt; &quot;第二次插入成功&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;第二次插入失败&quot; &lt;&lt; endl;
	}

	printSet(s1);
	

	//multiset允许插入重复值
	multiset&lt;int&gt; mul;
	mul.insert(10);
	mul.insert(10);

}

//指定set排序规则 从大到小
//仿函数
class myCompare
{
public:
	//重载 ()
	bool operator()( int v1 ,int v2)
	{
		return v1 &gt; v2;
	}
};


//set容器排序
void test04()
{
	set&lt;int,myCompare&gt;s1;
	
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);

	//printSet(s1);

	//从大到小排序
	//在插入之前就指定排序规则

	for (set&lt;int, myCompare&gt;::iterator it = s1.begin(); it != s1.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

class myComparePerson
{
public:
	bool operator()( const Person &amp; p1, const Person &amp; p2)
	{
		if (p1.m_Age &gt; p2.m_Age) //降序
		{
			return true;
		}
		return false;
	}

};

void test05()
{
	set&lt;Person, myComparePerson&gt; s1;

	Person p1(&quot;大娃&quot;, 100);
	Person p2(&quot;二娃&quot;, 90);
	Person p3(&quot;六娃&quot;, 10);
	Person p4(&quot;爷爷&quot;, 1000);

	s1.insert(p1);
	s1.insert(p2);
	s1.insert(p3);
	s1.insert(p4);

	//插入自定义数据类型，上来就指定好排序规则

	//显示
	for (set&lt;Person, myComparePerson&gt;::iterator it = s1.begin(); it != s1.end();it++)
	{
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	}

}
</code></pre>
<h2 id="pair">pair</h2>
<pre><code class="language-c">//创建对组
void test01()
{
	//第一种
	pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 100);

	//取值
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; endl;
	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;

	//第二种创建
	pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 200);
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p2.first &lt;&lt; endl;
	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;

}
</code></pre>
<h2 id="map">map</h2>
<pre><code class="language-c">#include &lt;map&gt;

/*
map构造函数
map&lt;T1, T2&gt; mapTT;//map默认构造函数:
map(const map &amp;mp);//拷贝构造函数
 map赋值操作
map&amp; operator=(const map &amp;mp);//重载等号操作符
swap(mp);//交换两个集合容器

 map大小操作
size();//返回容器中元素的数目
empty();//判断容器是否为空
 map插入数据元素操作
map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;
// 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));
// 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, &quot;校长&quot;));
// 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));
// 第四种 通过数组的方式插入值
mapStu[3] = &quot;小刘&quot;;
mapStu[5] = &quot;小王&quot;;

*/

void test01()
{
	map&lt;int, int&gt; m;
	//插入值
	// 4种方式
	//第一种
	m.insert(pair&lt;int, int&gt;(1, 10));
	//第二种 推荐
	m.insert(make_pair(2, 20));
	//第三种 不推荐
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	//第四种 如果保证key存在 ，那么可以通过[]访问
	m[4] = 40;

	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end();it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}

	cout &lt;&lt; m[5] &lt;&lt;endl;

	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}

	//cout &lt;&lt; m[4] &lt;&lt; endl;

	if ( m.empty())
	{
		cout &lt;&lt; &quot;空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; m.size() &lt;&lt; endl;
	}
}

/*
map删除操作
clear();//删除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);//删除容器中key为keyElem的对组。
 map查找操作
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();
count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
*/
void test02()
{
	map&lt;int, int&gt; m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	m[4] = 40;

	m.erase(1);
	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}


	map&lt;int,int&gt;::iterator pos = m.find(2);
	if (pos != m.end())
	{
		cout &lt;&lt; &quot;找到：key&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	int num  = m.count(3); //map的count 要么0 要么1 
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;

	// lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。

	map&lt;int,int&gt;::iterator ret = m.lower_bound(3);
	if (ret != m.end())
	{
		cout &lt;&lt; &quot;lower_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
	ret = m.upper_bound(3);
	if (ret != m.end())
	{
		cout &lt;&lt; &quot;upper_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。

	pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt; ret2 = m.equal_range(3);

	if (ret2.first != m.end())
	{
		cout &lt;&lt; &quot;找到了equal_range 中的lower_bound 的key &quot; &lt;&lt; ret2.first-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.first-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	if (ret2.second != m.end())
	{
		cout &lt;&lt; &quot;找到了equal_range 中的upper_bound 的key &quot; &lt;&lt; ret2.second-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.second-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

}

//指定排序规则
class myCompare
{
public:
	bool operator()(int v1, int v2)
	{
		return v1 &gt; v2;
	}

};

void test03()
{
	//从大到小排序
	map&lt;int, int, myCompare&gt; m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	m[4] = 40;

	for (map&lt;int, int, myCompare&gt;::iterator it = m.begin(); it != m.end();it++)
	{
		cout &lt;&lt; &quot;key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}


}
</code></pre>
<h2 id="常用算法">常用算法</h2>
<p>算法主要是由头文件<algorithm> <functional> <numeric>组成</p>
<p><algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等...</p>
<p><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</p>
<p><functional> 定义了一些模板类,用以声明函数对象。</p>
<h3 id="遍历">遍历</h3>
<pre><code class="language-c">/*
    遍历算法 遍历容器元素
	@param beg 开始迭代器
	@param end 结束迭代器
	@param _callback  函数回调或者函数对象
	@return 函数对象
*/
for_each(iterator beg, iterator end, _callback);

/*
	transform算法 将指定容器区间元素搬运到另一容器中
	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存
	@param beg1 源容器开始迭代器
	@param end1 源容器结束迭代器
	@param beg2 目标容器开始迭代器
	@param _cakkback 回调函数或者函数对象
	@return 返回目标容器迭代器
*/
transform(iterator beg1, iterator end1, iterator beg2, _callbakc)

</code></pre>
<h3 id="查找">查找</h3>
<pre><code class="language-c">/*
	find算法 查找元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return 返回查找元素的位置
*/
find(iterator beg, iterator end, value)
/*
	find_if算法 条件查找
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return bool 查找返回true 否则false
*/
find_if(iterator beg, iterator end, _callback);

/*
	adjacent_find算法 查找相邻重复元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)
	@return 返回相邻元素的第一个位置的迭代器
*/
adjacent_find(iterator beg, iterator end, _callback);
/*
	binary_search算法 二分查找法
	注意: 在无序序列中不可用
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return bool 查找返回true 否则false
*/
bool binary_search(iterator beg, iterator end, value);
/*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  value回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count(iterator beg, iterator end, value);
/*
count_if算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count_if(iterator beg, iterator end, _callback);

</code></pre>
<h3 id="排序">排序</h3>
<pre><code class="language-c">/*
	merge算法 容器元素合并，并存储到另一容器中
	注意:两个容器必须是有序的
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
*/
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	sort算法 容器元素排序
	@param beg 容器1开始迭代器
	@param end 容器1结束迭代器
	@param _callback 回调函数或者谓词(返回bool类型的函数对象)
*/
sort(iterator beg, iterator end, _callback)
/*
	random_shuffle算法 对指定范围内的元素随机调整次序
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
random_shuffle(iterator beg, iterator end)
/*
	reverse算法 反转指定范围的元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
reverse(iterator beg, iterator end)

</code></pre>
<h3 id="常用拷贝和替换算法">常用拷贝和替换算法</h3>
<pre><code class="language-c">/*
	copy算法 将容器内指定范围的元素拷贝到另一容器中
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param dest 目标起始迭代器
*/
copy(iterator beg, iterator end, iterator dest)
/*
	replace算法 将容器内指定范围的旧元素修改为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param oldvalue 旧元素
	@param oldvalue 新元素
*/
replace(iterator beg, iterator end, oldvalue, newvalue)
/*
	replace_if算法 将容器内指定范围满足条件的元素替换为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param callback函数回调或者谓词(返回Bool类型的函数对象)
	@param oldvalue 新元素
*/
replace_if(iterator beg, iterator end, _callback, newvalue)
/*
	swap算法 互换两个容器的元素
	@param c1容器1
	@param c2容器2
*/
swap(container c1, container c2)

</code></pre>
<h3 id="常用算数生成算法">常用算数生成算法</h3>
<pre><code class="language-c">/*
	accumulate算法 计算容器元素累计总和
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value累加值
*/
accumulate(iterator beg, iterator end, value)
/*
	fill算法 向容器中添加元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value t填充元素
*/
fill(iterator beg, iterator end, value)

</code></pre>
<h3 id="常用集合算法">常用集合算法</h3>
<pre><code class="language-c">/*
	set_intersection算法 求两个set集合的交集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_union算法 求两个set集合的并集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_difference算法 求两个set集合的差集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂记]]></title>
        <id>https://xmweijh.github.io/post/za-ji/</id>
        <link href="https://xmweijh.github.io/post/za-ji/">
        </link>
        <updated>2021-03-17T03:50:36.000Z</updated>
        <content type="html"><![CDATA[<p>平常做题 写代码遇到的一些问题</p>
<h1 id="test">TEST</h1>
<h3 id="阶乘计算升级版"><strong>阶乘计算升级版</strong></h3>
<p>本题要求实现一个打印非负整数阶乘的函数。</p>
<p>函数接口定义：</p>
<pre><code class="language-c++">void Print_Factorial ( const int N );
</code></pre>
<p>其中<code>N</code>是用户传入的参数，其值不超过1000。如果<code>N</code>是非负整数，则该函数必须在一行中打印出<code>N</code>!的值，否则打印“Invalid input”。</p>
<p>首先想到的方法是</p>
<pre><code class="language-c">void Print_Factorial ( const int N )
{
    long long sum = 1;
    if(N == 0)
        printf(&quot;%lld&quot;,sum);
    else if (N &gt;0)
    {
        int i;
        for(i = 1;i&lt;=N;i++)
        {
                sum = sum *i;
        }
         printf(&quot;%lld&quot;,sum);
    }
    else
        printf(&quot;Invalid input&quot;);
}

</code></pre>
<p>但是 N取最大时不能正确运行。重点在与阶乘的结果很大，即便是long long int 任然不够<code>，*long long int的范围最大为10的18次方，使用斯特林公式计算可知，n为12时，结果的位数已经为9,故N取1000一定远远超过了long long Int的范围*</code>， 因此需要另辟蹊径。</p>
<hr>
<p><strong>求大数n！的位数。</strong></p>
<p>根据n! = (int)log(n!)+1</p>
<p>方法1：</p>
<p>log(n!) = log(1<em>2</em>3*...*n) = log1+log2+...+logn</p>
<p>方法2：</p>
<p>斯大林公式：</p>
<p>n! = sqrt(2<em>PI</em>n)*(n/e)^n</p>
<p>两侧取对数有</p>
<p>log10(n!) = 1/2log(2<em>PI</em>n) + n*log(n/e)</p>
<hr>
<p>利用类似乘法竖式计算的方法逐位相乘</p>
<pre><code class="language-c">else if(N&gt;12&amp;&amp;N&lt;=1000){
		int num[3000] = {0};
		num[0] = 1;
		int k=1;  //位数
		int n=0;  //进位
		int temp;
		for(int i=2 ;i&lt;=N ;i++){
			for(int j=0;j&lt;k;j++){
				temp = num[j]*i+n;  //每一位相乘 再+进位
				num[j] = temp%10;	//更新每一位的数字
				n = temp/10;		//判断能否进位
			}	
			while(n!=0){  //如果可以进位
				num[k] = n%10;  //新增一位
				n /=10;  //继续判断能否进位
				k++;
			}
		}
		for(int x=k-1;x&gt;=0;x--){		//输出数字
			printf(&quot;%d&quot;,num[x]);
		}
	}

</code></pre>
<h3 id="单链表逆转">单链表逆转</h3>
<pre><code class="language-c">List Reverse( List L )
{
    List head,next,prev;
    prev = NULL;
    head = L;
    while(head != NULL)
    {
        next = head-&gt;Next;
        head-&gt;Next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
</code></pre>
<h3 id="链式表操作集">链式表操作集</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR NULL
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;

Position Find( List L, ElementType X );
List Insert( List L, ElementType X, Position P );
List Delete( List L, Position P );

int main()
{
    List L;
    ElementType X;
    Position P, tmp;
    int N;

    L = NULL;
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        L = Insert(L, X, L);
        if ( L==ERROR ) printf(&quot;Wrong Answer\n&quot;);
    }
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        P = Find(L, X);
        if ( P == ERROR )
            printf(&quot;Finding Error: %d is not in.\n&quot;, X);
        else {
            L = Delete(L, P);
            printf(&quot;%d is found and deleted.\n&quot;, X);
            if ( L==ERROR )
                printf(&quot;Wrong Answer or Empty List.\n&quot;);
        }
    }
    L = Insert(L, X, NULL);
    if ( L==ERROR ) printf(&quot;Wrong Answer\n&quot;);
    else
        printf(&quot;%d is inserted as the last element.\n&quot;, X);
    P = (Position)malloc(sizeof(struct LNode));
    tmp = Insert(L, X, P);
    if ( tmp!=ERROR ) printf(&quot;Wrong Answer\n&quot;);
    tmp = Delete(L, P);
    if ( tmp!=ERROR ) printf(&quot;Wrong Answer\n&quot;);
    for ( P=L; P; P = P-&gt;Next ) printf(&quot;%d &quot;, P-&gt;Data);
    return 0;
}

/* 你的代码将被嵌在这里 */
Position Find( List L, ElementType X ){
    while(L!=NULL){
        if(L-&gt;Data == X){
            return L;
        }
        L = L-&gt;Next;
    }
    return ERROR;
}
List Insert( List L, ElementType X, Position P ){
    List head = L;
    List p = (List)malloc(sizeof(List));
    p-&gt;Data=X;
    p-&gt;Next=NULL;
    if(L==P){
        p-&gt;Next=L;
        return p;
    }
    while(L){
        if(P==L-&gt;Next){
            p-&gt;Next=L-&gt;Next;
            L-&gt;Next=p;
            return head;
        }
        L=L-&gt;Next;
    }
    printf(&quot;Wrong Position for Insertion\n&quot;);
     return ERROR;
}
List Delete( List L, Position P ){
    if(L==P){
        L=L-&gt;Next;
        return L;
    }
    List head = L;
    while(L){
        if(L-&gt;Next==P){
            L-&gt;Next=P-&gt;Next;
            return head;
        }
        L=L-&gt;Next;
    }
    printf(&quot;Wrong Position for Deletion\n&quot;);
    return ERROR;
}

</code></pre>
<h3 id="带头结点的链式表操作集">带头结点的链式表操作集</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR NULL
typedef enum {false, true} bool;
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;

List MakeEmpty();
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );

int main()
{
    List L;
    ElementType X;
    Position P;
    int N;
    bool flag;

    L = MakeEmpty();
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        flag = Insert(L, X, L-&gt;Next);
        if ( flag==false ) printf(&quot;Wrong Answer\n&quot;);
    }
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        P = Find(L, X);
        if ( P == ERROR )
            printf(&quot;Finding Error: %d is not in.\n&quot;, X);
        else {
            flag = Delete(L, P);
            printf(&quot;%d is found and deleted.\n&quot;, X);
            if ( flag==false )
                printf(&quot;Wrong Answer.\n&quot;);
        }
    }
    flag = Insert(L, X, NULL);
    if ( flag==false ) printf(&quot;Wrong Answer\n&quot;);
    else
        printf(&quot;%d is inserted as the last element.\n&quot;, X);
    P = (Position)malloc(sizeof(struct LNode));
    flag = Insert(L, X, P);
    if ( flag==true ) printf(&quot;Wrong Answer\n&quot;);
    flag = Delete(L, P);
    if ( flag==true ) printf(&quot;Wrong Answer\n&quot;);
    for ( P=L-&gt;Next; P; P = P-&gt;Next ) printf(&quot;%d &quot;, P-&gt;Data);
    return 0;
}
/* 你的代码将被嵌在这里 */
List MakeEmpty() {
    List L = (List)malloc(sizeof(List));
    L-&gt;Next=NULL;
    return L;
}
Position Find( List L, ElementType X ) {
    L=L-&gt;Next;
    while(L) {
        if(L-&gt;Data==X) {
            return L;
        }
        L=L-&gt;Next;
    }
    return ERROR;
}

bool Insert( List L, ElementType X, Position P ) {
    List p = (List)malloc(sizeof(List));
    p-&gt;Data=X;
    p-&gt;Next=NULL;
    List k=L;
    while(k) {
        if(k-&gt;Next==P) {
            p-&gt;Next=P;
            k-&gt;Next=p;
            return true;
        }
        k=k-&gt;Next;
    }
    printf(&quot;Wrong Position for Insertion\n&quot;);
    return false;
}


bool Delete( List L, Position P ){
    if(L==P){
        L=L-&gt;Next;
        return true;
    }
    while(L){
        if(L-&gt;Next==P){
            L-&gt;Next=P-&gt;Next;
            return true;
        }
        L=L-&gt;Next;
    }
    printf(&quot;Wrong Position for Deletion\n&quot;);
    return false;
}

</code></pre>
<h3 id="在一个数组中实现两个堆栈"><strong>在一个数组中实现两个堆栈</strong></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 1e8
typedef int ElementType;
typedef enum { push, pop, end } Operation;
typedef enum { false, true } bool;
typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );

Operation GetOp();  /* details omitted */
void PrintStack( Stack S, int Tag ); /* details omitted */

int main()
{
    int N, Tag, X;
    Stack S;
    int done = 0;

    scanf(&quot;%d&quot;, &amp;N);
    S = CreateStack(N);
    while ( !done ) {
        switch( GetOp() ) {
        case push:
            scanf(&quot;%d %d&quot;, &amp;Tag, &amp;X);
            if (!Push(S, X, Tag)) printf(&quot;Stack %d is Full!\n&quot;, Tag);
            break;
        case pop:
            scanf(&quot;%d&quot;, &amp;Tag);
            X = Pop(S, Tag);
            if ( X==ERROR ) printf(&quot;Stack %d is Empty!\n&quot;, Tag);
            break;
        case end:
            PrintStack(S, 1);
            PrintStack(S, 2);
            done = 1;
            break;
        }
    }
    return 0;
}

/* 你的代码将被嵌在这里 */
Stack CreateStack(int MaxSize) {
    Stack stack = (Stack)malloc(sizeof(Stack));
    stack-&gt;Data = (ElementType *)malloc(sizeof(ElementType)*MaxSize);
    stack-&gt;Top1 = -1;
    stack-&gt;Top2 = MaxSize;
    stack-&gt;MaxSize = MaxSize;
    return stack;
}
bool Push( Stack S, ElementType X, int Tag ) {
    if (S == NULL)return false;
    if (S-&gt;Top1+1==S-&gt;Top2) {
        printf(&quot;Stack Full\n&quot;);
        return false;
    }
    if (Tag == 1)
        S-&gt;Data[++S-&gt;Top1] = X;
    else
        S-&gt;Data[--S-&gt;Top2] = X;
    return true;
}
ElementType Pop( Stack S, int Tag ) {
    if(S==NULL)
        return ERROR;
    if(Tag == 1) {
        if(S-&gt;Top1==-1) {
            printf(&quot;Stack 1 Empty\n&quot;);
            return ERROR;
        }
        return S-&gt;Data[S-&gt;Top1--];
    } else {
        if(S-&gt;Top2==S-&gt;MaxSize) {
            printf(&quot;Stack 2 Empty\n&quot;);
            return ERROR;
        }
        return S-&gt;Data[S-&gt;Top2++];
    }
}

</code></pre>
<h3 id="二叉树高度">二叉树高度</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef char ElementType;
typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

BinTree CreatBinTree(); /* 实现细节忽略 */
int GetHeight( BinTree BT );

int main()
{
    BinTree BT = CreatBinTree();
    printf(&quot;%d\n&quot;, GetHeight(BT));
    return 0;
}
/* 你的代码将被嵌在这里 */
int GetHeight( BinTree BT )
{
    int hl = 0,hr = 0;
    if(!BT)
        return 0;
    if(BT)
    {
        hl = GetHeight(BT-&gt;Left);
        hr = GetHeight(BT-&gt;Right);
        return (hl &gt;= hr ? hl:hr) + 1;
    }
}

</code></pre>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<pre><code class="language-c">void InorderTraversal( BinTree BT )//中序遍历
{
    //①中序遍历其左子树；②访问根节点；③中序遍历其右子树
    if(BT)
    {
        InorderTraversal(BT-&gt;Left);
        printf(&quot; %c&quot;,BT-&gt;Data);
        InorderTraversal(BT-&gt;Right);
    }
}
void PreorderTraversal( BinTree BT )//先序遍历
{
    //①访问根节点；②先序遍历其左子树；③先序遍历其右子树
    if(BT)
    {
        printf(&quot; %c&quot;,BT-&gt;Data);
        PreorderTraversal(BT-&gt;Left);
        PreorderTraversal(BT-&gt;Right);
    }
}
void PostorderTraversal( BinTree BT )//后序遍历
{
    //①后序遍历其左子树；②后序遍历其右子树；③访问根节点
    if(BT)
    {
        PostorderTraversal(BT-&gt;Left);
        PostorderTraversal(BT-&gt;Right);
        printf(&quot; %c&quot;,BT-&gt;Data);
    }
}
void LevelorderTraversal( BinTree BT )//层次遍历
{
    /*
    ①从队列中取出一个元素；
    ②访问该元素所指结点（出队）；
    ③若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。
    */
    if(!BT)
        return;//空树返回
    BinTree q[100];
    int head=0,rear=0;
    q[rear++] = BT;
    while(head&lt;rear)
    {//队列非空
        if(q[head]-&gt;Left) 
            q[rear++] = q[head]-&gt;Left;
        if(q[head]-&gt;Right) 
            q[rear++] = q[head]-&gt;Right;
        printf(&quot; %c&quot;,q[head++]-&gt;Data);
    }
}

</code></pre>
<h3 id="二分查找">二分查找</h3>
<pre><code class="language-c">Position BinarySearch(List L,ElementType x)
{
        int low=0,high=L-&gt;Last;
        while(low&lt;=high){
            int mid=(low+high)/2;
            //这一步得记住
            if(L-&gt;Data[mid]==x){
                return mid;
            }
            if(L-&gt;Data[mid]&gt;x){
                high=mid-1;
            }
            if(L-&gt;Data[mid]&lt;x){
                low=mid+1;
            }
        }
        return NotFound;
}

</code></pre>
<h3 id="二叉搜索树">二叉搜索树</h3>
<pre><code class="language-c">BinTree Insert( BinTree BST, ElementType X ){
// 函数Insert将X插入二叉搜索树BST并返回结果树的根结点指针；
    if(BST==NULL){
        BST=(BinTree)malloc(sizeof(struct TNode));
        BST-&gt;Data=X;
        BST-&gt;Left=NULL;
        BST-&gt;Right=NULL;
        return BST;
    }
    BinTree BT=(BinTree)malloc(sizeof(struct TNode));
    BT=BST;
    int flag=0;
    while(BT!=NULL){
        if(X&gt;BT-&gt;Data){
            if(BT-&gt;Right!=NULL){
                BT=BT-&gt;Right;
            }else{
                flag=1;
                break;
            }
        }else{
            if(BT-&gt;Left!=NULL){
                BT=BT-&gt;Left;
            }else{
                flag=2;
                break;
            }
        }
    }
    if(flag==2){
        BT-&gt;Left=(BinTree)malloc(sizeof(struct TNode));
        BT-&gt;Left-&gt;Data=X;
        BT-&gt;Left-&gt;Left=NULL;
        BT-&gt;Left-&gt;Right=NULL;
    }else if(flag==1){
        BT-&gt;Right=(BinTree)malloc(sizeof(struct TNode));
        BT-&gt;Right-&gt;Data=X;
        BT-&gt;Right-&gt;Left=NULL;
        BT-&gt;Right-&gt;Right=NULL;
    }
    return BST;
}
Position Find( BinTree BST, ElementType X ){
// 函数Find在二叉搜索树BST中找到X，返回该结点的指针；如果找不到则返回空指针；
    while(BST!=NULL){
        if(X&gt;BST-&gt;Data){
            BST=BST-&gt;Right;
        }else if(X&lt;BST-&gt;Data){
            BST=BST-&gt;Left;
        }else{
            break;
        }
    }
    return BST;
}
BinTree Delete( BinTree BST, ElementType X ){
// 函数Delete将X从二叉搜索树BST中删除，并返回结果树的根结点指针；如果X不在树中，则打印一行Not Found并返回原树的根结点指针；
    if(BST==NULL){
        printf(&quot;Not Found\n&quot;);
        return BST;
    }
    if(BST-&gt;Data==X){
        if(BST-&gt;Left!=NULL &amp;&amp; BST-&gt;Right!=NULL){
            BinTree insert=(BinTree)malloc(sizeof(struct TNode));
            insert=BST-&gt;Right;
            BinTree father=(BinTree)malloc(sizeof(struct TNode));
            father=BST-&gt;Left;
            BST=BST-&gt;Left;
            while(father-&gt;Right!=NULL){
                father=father-&gt;Right;
            }
            father-&gt;Right=insert;
            return BST;
        }else if(BST-&gt;Left!=NULL &amp;&amp; BST-&gt;Right==NULL){
            return BST-&gt;Left;
        }else if(BST-&gt;Left==NULL &amp;&amp; BST-&gt;Right!=NULL){
            return BST-&gt;Right;
        }else{
            return NULL;
        }
    }
    int flag=0;
    BinTree father=(BinTree)malloc(sizeof(struct TNode));
    father=BST;
    while(father!=NULL){
        if(father-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Data==X){
            flag=1;
            break;
        }
        if(father-&gt;Right!=NULL &amp;&amp; father-&gt;Right-&gt;Data==X){
            flag=2;
            break;
        }
        if(father-&gt;Data&lt;X){
            father=father-&gt;Right;
        }else{
            father=father-&gt;Left;
        }
    }
    if(father==NULL){
        printf(&quot;Not Found\n&quot;);
        return BST;
    }
    if(flag==1){
        if(father-&gt;Left-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Right!=NULL){
            BinTree insert=(BinTree)malloc(sizeof(struct TNode));
            insert=father-&gt;Left-&gt;Right;
            BinTree move=(BinTree)malloc(sizeof(struct TNode));
            move=father-&gt;Left-&gt;Left;
            father-&gt;Left=move;
            while(move-&gt;Right!=NULL){
                move=move-&gt;Right;
            }
            move-&gt;Right=insert;
            return BST;
        }else if(father-&gt;Left-&gt;Left==NULL &amp;&amp; father-&gt;Left-&gt;Right!=NULL){
            father-&gt;Left=father-&gt;Left-&gt;Right;
            return BST;
        }else if(father-&gt;Left-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Right==NULL){
            father-&gt;Left=father-&gt;Left-&gt;Left;
            return BST;
        }else{
            father-&gt;Left=NULL;
            return BST;
        }
    }else{
        if(father-&gt;Right-&gt;Left!=NULL &amp;&amp; father-&gt;Right-&gt;Right!=NULL){
            BinTree insert=(BinTree)malloc(sizeof(struct TNode));
            insert=father-&gt;Right-&gt;Right;
            BinTree move=(BinTree)malloc(sizeof(struct TNode));
            move=father-&gt;Right-&gt;Left;
            father-&gt;Right=move;
            while(move-&gt;Right!=NULL){
                move=move-&gt;Right;
            }
            move-&gt;Right=insert;
            return BST;
        }else if(father-&gt;Right-&gt;Left==NULL &amp;&amp; father-&gt;Right-&gt;Right!=NULL){
            father-&gt;Right=father-&gt;Right-&gt;Right;
            return BST;
        }else if(father-&gt;Right-&gt;Left!=NULL &amp;&amp; father-&gt;Right-&gt;Right==NULL){
            father-&gt;Right=father-&gt;Right-&gt;Left;
            return BST;
        }else{
            father-&gt;Right=NULL;
            return BST;
        }
    }
}
Position FindMin( BinTree BST ){
// 函数FindMin返回二叉搜索树BST中最小元结点的指针；
    if(BST==NULL){
        return NULL;
    }
    while(BST-&gt;Left!=NULL){
        BST=BST-&gt;Left;
    }
    return BST;
}
Position FindMax( BinTree BST ){
// 函数FindMax返回二叉搜索树BST中最大元结点的指针。
    if(BST==NULL){
        return NULL;
    }
    while(BST-&gt;Right!=NULL){
        BST=BST-&gt;Right;
    }
    return BST;
}

</code></pre>
<h3 id="公约数公倍数">公约数公倍数</h3>
<p>两个自然数的乘积等于这两个自然数的最大公约数和最小公倍数的乘积。公倍数辗转相除法</p>
<p>1不是完数完数的定义决定了。定义:某自然数<strong>除它本身以外</strong>的所有因子之和等于该数,则该数被称为完数。</p>
<p>输出所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。利用计数器控制</p>
<p>第一个直接输出，后续的加上空格</p>
<pre><code class="language-c">if(count==1)
        {
           printf(&quot;%d&quot;,fib(i));
        }
        else
        {
              printf(&quot; %d&quot;,fib(i));
        }
</code></pre>
<h3 id="数组循环右移"><strong>数组循环右移</strong></h3>
<p><em>注意考虑m=n,m&gt;n,m=kn(k为N</em>)的情况.</p>
<pre><code class="language-c">int ArrayShift( int a[], int n, int m )
{
	int i;
	if(!(m%n)){/*记住优先级单目高于双目所以 !m%n 是错的*/	
		return 0;//如果 m 为 n 的倍数不操作 
	}
	else
		if(m%n){
		m%=n;
	}
		int b[MAXN]={0};
		for(i=0;i&lt;m;++i){
			b[m-i-1]=a[n-1-i];//先把右侧被挤出的存起来,存在数组b的相应位置,存b[0]~b[m-1]; 	
		}
		for(i=0;i&lt;n-m;++i){
			b[i+m]=a[i];//把左侧要向右移动的存到数组b的相应位置	
			//若 a[i+m]=a[i];右边数组用到之前自己改变自己元素了 ,所以错了. 
	
		}
		for(i=0;i&lt;n;++i){
			a[i]=b[i];//把b里正确的顺序赋给a 
		}	
}




</code></pre>
<h3 id="报数">报数</h3>
<p>报数游戏是这样的：有<em>n</em>个人围成一圈，按顺序从1到<em>n</em>编好号。从第一个人开始报数，报到<em>m</em>（&lt;<em>n</em>）的人退出圈子；下一个人从1开始报数，报到<em>m</em>的人退出圈子。如此下去，直到留下最后一个人。</p>
<pre><code class="language-c">void CountOff( int n, int m, int out[] ){
    int k,i,j=0;
    for(i=0;i&lt;n;i++)out[i]=0;

    for(i=0;i&lt;n;i++){
        k=0;//k记录报数值
        while(j&gt;=0){
            j%=n;//j记录当前位置
            if(out[j]==0)k++;//为0说明还没出去，此时k才加加
            if(k==m){
                out[j]=i+1;
                break;//报数成功，跳出while循环，进行下次报数
            }
            j++;
        }
    }
}
</code></pre>
<p>if 是条件判断语句,当其中一个条件成立时,另外<strong>同级别的条件语句(else if)就不再去判断了</strong>，所以可以不用continue。</p>
<p>if-else语句中，if和else的配对原则都是在同一个复合语句括号“{}”作用域内就近配对的原则。如果不属于同一个复合语句括号“{}”作用域内，则不会被配对，此时如果配对存在问题，会报语法错误。</p>
<pre><code class="language-c">if(表达式1)
	if(表达式2)
	语句1;
	else
	语句2;
else 
语句3;


</code></pre>
<p>此题故意将格式错乱，让读者以为else if 和第一个if匹配，实则是最里面的if匹配。但不影响输出，用就近原则处理。</p>
<pre><code class="language-c">int main()
{
    int x=10,a=10,b=20,ok1=5,ok2=0;
    if(a&lt;b)
    	if(b!=15)
    		if(!ok1)
    		x=1;
    else if(ok2)
    x=10;
    else x=-1;
    printf(&quot;%d&quot;,x);
    return 0;
}

</code></pre>
<p>实则为</p>
<pre><code class="language-c">int main()
{
    int x=10,a=10,b=20,ok1=5,ok2=0;
    if(a&lt;b)
        if(b!=15)
            if(!ok1)
                x=1;
            else if(ok2)
                x=10;
            else x=-1;
    printf(&quot;%d&quot;,x);
    return 0;
}
</code></pre>
<p>所以输出结果为-1</p>
<h3 id="最长公共前缀">最长公共前缀</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>将第一个作为返回结果 不断与后面比较，每次不同时更新结果，最终找到公共前缀。</p>
<pre><code class="language-c">char * longestCommonPrefix(char ** strs, int strsSize){
    if(strsSize == 0)
        return &quot;&quot;;
    char *ans = strs[0];
    int i, j;
    for(i = 1; i &lt; strsSize; i++){
        j = 0;
        for(; ans[j] != '\0' &amp;&amp; strs[i][j] != '\0'; j++){
            if(ans[j] != strs[i][j]){
                break;
            }
        }
        ans[j] = '\0';
        if(ans == NULL){
            return &quot;&quot;;
        }
    }
    return ans;

}

</code></pre>
<p>数组内存分配连续的，且从高位到低位分配</p>
<pre><code class="language-c">int main()
{
    char a[4]={0};
    char b[4]={0};
    b[0]=1;b[1]=2;b[2]=3;b[3]=4;b[4]=5;
    printf(&quot;%d,%d,%d,%d&quot;,a[0],a[1],a[2],a[3]);
    return 0;
}

</code></pre>
<p>所以b[4]地址为a[0]地址。</p>
<h3 id="cahr">cahr*</h3>
<p>对于 char *str = &quot;resource&quot;;*</p>
<p>把&quot;resource&quot;的值----也就是字符串常量字面值，也就是&quot;resource&quot;的地址，准确来说是起始地址----赋给字符指针 str，Linux下，&quot;resource&quot;字符串常量是存放于<strong>只读数据区</strong>的，一般来说，32位机器上，在Linux中，堆，全局数据，常量等都是存放于从0x8048000开始的内存地址，向上增长。可以打印一下&quot;resource&quot;的地址来进行验证。char *str = &quot;resource&quot;，就是把&quot;resource&quot;的首地址赋给str，所以str 存放的是一个只读数据区的地址，对只读区的数据进行写操作是禁止，具体由相应的操作系统进行判断以及处理。</p>
<p>这篇文章作了详细解释:</p>
<p>https://www.cnblogs.com/yylqinghao/archive/2010/04/27/1721752.html</p>
<h3 id="1003-我要通过"><strong>1003 我要通过！</strong></h3>
<p>得到“<strong>答案正确</strong>”的条件是：</p>
<ol>
<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>
<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>
<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li>
</ol>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p>
<p>a.条件1：字符串中必须仅有  P、 A、 T  这三种字符，不可以包含其它字符；</p>
<p>b.由条件2可得：PAT   或   A(n个)+PAT+A(n个)</p>
<p>c.由条件3可得：</p>
<p>a P b T c	a P bA T ca<br>
A(0个)+  P+  A（1个）  +T  +A(0个)	A(0个)+  P+  A(1个)+A(n个)  +T  +1个<em>A(0个)+n个</em>A(0个)<br>
A(n个)+  P+  A（1个）+  T  +A(n个)	A(n个)+  P+  A(1个)+A(n个)   +T  +1个<em>A(n个)+n个</em>A(n个)<br>
d.结论：（只能由条件1、2（原型）根据条件3（规则）推得的字符串才是YES）</p>
<p>（1）只能有P、A、T；（2）P和T只能有一个，且中间至少一个A；（3）首项A个数*中间A个数==尾项。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
 
int main()
{
	int n;
	scanf(&quot;%d\n&quot;,&amp;n);//这里的\n是为了下面的getchar而使用
	char ch;
	for(int i=0;i&lt;n;i++)
	{
		int position=0,aa[3]={0}; 
		while((ch=getchar())!='\n')//该处理方式主要在于，通过每位读取，成功限定了
		{                          //每位的表达，不是我们需要的表达，直接NO
                                           //是我们需要的表达，我们就记录下
			if(ch=='A') aa[position]++;//每个A的位置所在
			else if(ch=='P'&amp;&amp;position==0) position=1;   //遇到P就转移了，
			else if(ch=='T'&amp;&amp;position==1) position=2; //再次遇到就break
			else break;//相当于ch=='P'&amp;&amp;position==1，这是不在前三个if中的
		}
		if(ch=='\n'&amp;&amp;position==2&amp;&amp;aa[1]&amp;&amp;aa[2]==aa[0]*aa[1])//条件的判定
			printf(&quot;%s\n&quot;,&quot;YES&quot;);
		else printf(&quot;%s\n&quot;,&quot;NO&quot;);
		if(ch!='\n')//若中途停止，剩下的也要读完哦！！！
			while((ch=getchar())!='\n');
	}
	return 0;
}
</code></pre>
<p><strong>test.cpp:8:5: error: use of undeclared identifier 'vector'</strong></p>
<p>#include <vector></p>
<p>要加上using namespace std;才行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[window.onload与setInterval的作用域问题]]></title>
        <id>https://xmweijh.github.io/post/windowonload-yu-setinterval-de-zuo-yong-yu-wen-ti/</id>
        <link href="https://xmweijh.github.io/post/windowonload-yu-setinterval-de-zuo-yong-yu-wen-ti/">
        </link>
        <updated>2021-02-23T07:38:03.000Z</updated>
        <content type="html"><![CDATA[<p>今天用js做一个黑白块小游戏时，将函数体封装到window.load中时，结果显示</p>
<pre><code class="language-js">//错误
Uncaught ReferenceError: start is not defined
    at HTMLButtonElement.onclick (index.html:15)
    //代码
    //&lt;button class=&quot;start&quot; onclick=&quot;start()&quot;&gt;
</code></pre>
<p>检查后发现，点击事件在行内式声明，由于作用域的原因是读取不到onload中的start函数的</p>
<p>然后将点击事件封装在onload中</p>
<pre><code class="language-js">star.addEventListener('click', start);
//点击开始游戏按钮 开始游戏
function start() {
    if (!flag) {
        init();
    } else {
        alert('游戏已经开始，无须再次点击！');
    }
}
</code></pre>
<p>本以为解决了问题，兴致勃勃的打开浏览器。等来的却是又一个错误TAT</p>
<pre><code class="language-js">VM28:1 Uncaught ReferenceError: move is not defined
    at &lt;anonymous&gt;:1:1
</code></pre>
<p>又是作用域的原因！结果调试发现在定时器这里出问题了</p>
<pre><code> clock = window.setInterval('move()', 30);
</code></pre>
<p>通过查阅资料得知，setInterval这个方法是<strong>window对象</strong>的方法，window对象，window对象，window对象！！！（重要的事情说三遍,而且他前面明明这么大的<strong>window.</strong>)，没错！又是作用域的问题！也就是说这个方法是执行在全局作用域下，而我定义的方法没有在全局作用域下，肯定找不到了。</p>
<p>window.onload = function(){};是一个作用域i，函数调用在window.onload这个作用域的外面调用就会出错</p>
<p>所以再写代码的时候一定要注意<strong>作用域</strong>！</p>
<p>最后乖乖的去掉了onload，将js引用在下面，果然一举成功！🐂</p>
<p>还有一点值得注意的是</p>
<pre><code>window.onload = function () {};    // JavaScript 
$(document).ready(function () {}); // jQuery
</code></pre>
<p>二者的区别，window.onload只能用一次，第二次会覆盖第一次的执行。而$(function() {});可以多次使用 ，且只是DOM元素加载完就执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS续]]></title>
        <id>https://xmweijh.github.io/post/js-xu/</id>
        <link href="https://xmweijh.github.io/post/js-xu/">
        </link>
        <updated>2021-02-21T11:50:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="js续">js续</h1>
<h2 id="面向过程与面向对象">面向过程与面向对象</h2>
<h3 id="面向过程">面向过程</h3>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</li>
</ul>
<h3 id="面向对象">面向对象</h3>
<ul>
<li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</li>
</ul>
<h3 id="面向过程与面向对象对比">面向过程与面向对象对比</h3>
<table>
<thead>
<tr>
<th></th>
<th>面向过程</th>
<th>面向对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td>
<td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td>
</tr>
<tr>
<td>缺点</td>
<td>不易维护、不易复用、不易扩展</td>
<td>性能比面向过程低</td>
</tr>
</tbody>
</table>
<h2 id="对象与类">对象与类</h2>
<h3 id="对象">对象</h3>
<p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</p>
<ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词）</li>
</ul>
<h4 id="创建对象">创建对象</h4>
<pre><code class="language-js">//以下代码是对对象的复习
//字面量创建对象
var ldh = {
    name: '刘德华',
    age: 18
}
console.log(ldh);

//构造函数创建对象
  function Star(name, age) {
    this.name = name;
    this.age = age;
 }
var ldh = new Star('刘德华', 18)//实例化对象
console.log(ldh);	
</code></pre>
<h3 id="类">类</h3>
<ul>
<li>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</li>
</ul>
<h4 id="创建类">创建类</h4>
<ol>
<li>语法:</li>
</ol>
<pre><code class="language-js">//步骤1 使用class关键字
class name {
  // class body
}     
//步骤2使用定义的类创建实例  注意new关键字
var xx = new name();     
</code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-js"> // 1. 创建类 class  创建一个 明星类
 class Star {
   // 类的共有属性放到 constructor 里面
   constructor(name, age) {
   this.name = name;
   this.age = age;
   }
 }
   // 2. 利用类创建对象 new
   var ldh = new Star('刘德华', 18);
   console.log(ldh);
</code></pre>
<h4 id="类创建添加属性和方法">类创建添加属性和方法</h4>
<pre><code class="language-js"> // 1. 创建类 class  创建一个类
class Star {
    // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数
    constructor(uname, age) {
      this.uname = uname;
      this.age = age;
    }//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号
    sing(song) {
      console.log(this.uname + '唱' + song);
    }
}
// 2. 利用类创建对象 new
var ldh = new Star('刘德华', 18);
console.log(ldh); // Star {uname: &quot;刘德华&quot;, age: 18}
ldh.sing('冰雨'); // 刘德华唱冰雨
</code></pre>
<p><strong>注意哟:</strong></p>
<ol>
<li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li>
<li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li>
<li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li>
<li>多个函数方法之间不需要添加逗号分隔</li>
<li>生成实例 new 不能省略</li>
<li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li>
</ol>
<h4 id="类的继承">类的继承</h4>
<ol>
<li>语法</li>
</ol>
<pre><code class="language-js">// 父类
class Father{   
} 

// 子类继承父类
class  Son  extends Father {  
}       
</code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-js">class Father {
      constructor(surname) {
        this.surname= surname;
      }
      say() {
        console.log('你的姓是' + this.surname);
       }
}

class Son extends Father{  // 这样子类就继承了父类的属性和方法
}
var damao= new Son('刘');
damao.say();      //结果为 你的姓是刘
</code></pre>
<ul>
<li>
<p>子类使用super关键字访问父类的方法</p>
<pre><code class="language-js">//定义了父类
class Father {
   constructor(x, y) {
   this.x = x;
   this.y = y;
   }
   sum() {
   console.log(this.x + this.y);
	}
 }
//子元素继承父类
    class Son extends Father {
   		 constructor(x, y) {
    		super(x, y); //使用super调用了父类中的构造函数
    	}
    }
    var son = new Son(1, 2);
    son.sum(); //结果为3
</code></pre>
<p><strong>注意:</strong></p>
<ol>
<li>
<p>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</p>
</li>
<li>
<p>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</p>
</li>
<li>
<p>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</p>
<pre><code class="language-js"> // 父类有加法方法
 class Father {
   constructor(x, y) {
   this.x = x;
   this.y = y;
   }
   sum() {
   console.log(this.x + this.y);
   }
 }
 // 子类继承父类加法方法 同时 扩展减法方法
 class Son extends Father {
   constructor(x, y) {
   // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错
   super(x, y);
   this.x = x;
   this.y = y;

  }
  subtract() {
  console.log(this.x - this.y);
  }
}
var son = new Son(5, 3);
son.subtract(); //2
son.sum();//8
</code></pre>
<p>以上代码运行结果为:</p>
</li>
<li>
<p>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</p>
<ol>
<li>constructor中的this指向的是new出来的实例对象</li>
<li>自定义的方法,一般也指向的new出来的实例对象</li>
<li>绑定事件之后this指向的就是触发事件的事件源</li>
</ol>
</li>
<li>
<p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
<h2 id=""></h2>
</li>
</ol>
</li>
</ul>
<h2 id="面向对象版tab-栏切换">面向对象版tab 栏切换</h2>
<h3 id="功能需求">功能需求</h3>
<ol>
<li>点击 tab栏,可以切换效果.</li>
<li>点击 + 号, 可以添加 tab 项和内容项.</li>
<li>点击 x 号, 可以删除当前的tab项和内容项.</li>
<li>双击tab项文字或者内容项文字可以修改里面的文字内容</li>
</ol>
<h3 id="案例准备">案例准备</h3>
<ol>
<li>获取到标题元素</li>
<li>获取到内容元素</li>
<li>获取到删除的小按钮 x号</li>
<li>新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</li>
<li>时刻注意this的指向问题</li>
</ol>
<h3 id="切换">切换</h3>
<ul>
<li>
<p>为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</p>
<pre><code class="language-js"> this.lis[i].index = i;
 this.lis[i].onclick = this.toggleTab;
</code></pre>
</li>
<li>
<p>使用排他,实现只有一个元素的显示</p>
<pre><code class="language-js"> toggleTab() {
   //将所有的标题与内容类样式全部移除
     for (var i = 0; i &lt; this.lis.length; i++) {
     this.lis[i].className = '';
     this.sections[i].className = '';
     }
   //为当前的标题添加激活样式
     this.className = 'liactive';
    //为当前的内容添加激活样式
     that.sections[this.index].className = 'conactive';
  }
</code></pre>
</li>
</ul>
<h3 id="添加">添加</h3>
<ul>
<li>
<p>为添加按钮+ 绑定点击事件</p>
<pre><code class="language-js"> this.add.onclick = this.addTab;
</code></pre>
</li>
<li>
<p>实现标题与内容的添加,做好排他处理</p>
<pre><code class="language-js">addTab() {
    that.clearClass();
    // (1) 创建li元素和section元素 
    var random = Math.random();
    var li = '&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;				&lt;/span&gt;&lt;/li&gt;';
    var section = '&lt;section class=&quot;conactive&quot;&gt;测试 ' + random + '&lt;/section&gt;';
    // (2) 把这两个元素追加到对应的父元素里面
    that.ul.insertAdjacentHTML('beforeend', li);
    that.fsection.insertAdjacentHTML('beforeend', section);
    that.init();
    }
</code></pre>
</li>
</ul>
<h3 id="删除">删除</h3>
<ul>
<li>
<p>为元素的删除按钮x绑定点击事件</p>
<pre><code class="language-js"> this.remove[i].onclick = this.removeTab;
</code></pre>
</li>
<li>
<p>获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</p>
<pre><code class="language-js"> removeTab(e) {
     e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件
     var index = this.parentNode.index;
     console.log(index);
     // 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素
     that.lis[index].remove();
     that.sections[index].remove();
     that.init();
     // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变
     if (document.querySelector('.liactive')) return;
     // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态
     index--;
     // 手动调用我们的点击事件  不需要鼠标触发
     that.lis[index] &amp;&amp; that.lis[index].click();
 }
</code></pre>
</li>
</ul>
<h3 id="编辑">编辑</h3>
<ul>
<li>
<p>为元素(标题与内容)绑定双击事件</p>
<pre><code class="language-js"> this.spans[i].ondblclick = this.editTab;
 this.sections[i].ondblclick = this.editTab;
</code></pre>
</li>
<li>
<p>在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递</p>
<pre><code class="language-js">editTab() {
    var str = this.innerHTML;
    // 双击禁止选定文字
    window.getSelection ? window.getSelection().removeAllRanges() : 				    document.selection.empty();
    // alert(11);
      this.innerHTML = '&lt;input type=&quot;text&quot; /&gt;';
      var input = this.children[0];
      input.value = str;
      input.select(); // 文本框里面的文字处于选定状态
      // 当我们离开文本框就把文本框里面的值给span 
      input.onblur = function() {
      this.parentNode.innerHTML = this.value;
      };
      // 按下回车也可以把文本框里面的值给span
      input.onkeyup = function(e) {
      if (e.keyCode === 13) {
      // 手动调用表单失去焦点事件  不需要鼠标离开操作
      this.blur();
      }
    }
}
</code></pre>
</li>
</ul>
<h2 id="构造函数和原型">构造函数和原型</h2>
<h3 id="对象的三种创建方式">对象的三种创建方式</h3>
<ol>
<li>
<p>字面量方式</p>
<pre><code class="language-js">var obj = {};
</code></pre>
</li>
<li>
<p>new关键字</p>
<pre><code class="language-js">var obj = new Object();
</code></pre>
</li>
<li>
<p>构造函数方式</p>
<pre><code class="language-js">function Person(name,age){
  this.name = name;
  this.age = age;
}
var obj = new Person('zs',12);
</code></pre>
</li>
</ol>
<h3 id="静态成员和实例成员">静态成员和实例成员</h3>
<h4 id="实例成员">实例成员</h4>
<p>实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问</p>
<pre><code class="language-js"> function Star(uname, age) {
     this.uname = uname;
     this.age = age;
     this.sing = function() {
     console.log('我会唱歌');
    }
}
var ldh = new Star('刘德华', 18);
console.log(ldh.uname);//实例成员只能通过实例化的对象来访问
</code></pre>
<h4 id="静态成员">静态成员</h4>
<p>静态成员 在构造函数本身上添加的成员  如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问</p>
<pre><code class="language-js"> function Star(uname, age) {
     this.uname = uname;
     this.age = age;
     this.sing = function() {
     console.log('我会唱歌');
    }
}
Star.sex = '男';
var ldh = new Star('刘德华', 18);
console.log(Star.sex);//静态成员只能通过构造函数来访问
</code></pre>
<h3 id="构造函数的问题">构造函数的问题</h3>
<p>构造函数方法很好用，但是存在浪费内存的问题。</p>
<h3 id="构造函数原型prototype">构造函数原型prototype</h3>
<p>构造函数通过原型分配的函数是所有对象所共享的。</p>
<p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p>
<p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p>
<pre><code class="language-js">function Star(uname, age) {
    this.uname = uname;
    this.age = age;
}
Star.prototype.sing = function() {
	console.log('我会唱歌');
}
var ldh = new Star('刘德华', 18);
var zxy = new Star('张学友', 19);
ldh.sing();//我会唱歌
zxy.sing();//我会唱歌
</code></pre>
<h3 id="对象原型">对象原型</h3>
<pre><code class="language-html">对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。
__proto__对象原型和原型对象 prototype 是等价的
__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype
</code></pre>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5Cimg2.png" alt="" loading="lazy"></figure>
<h3 id="constructor构造函数">constructor构造函数</h3>
<pre><code class="language-html">对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。
constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。
一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。
</code></pre>
<p>如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如:</p>
<pre><code class="language-js"> function Star(uname, age) {
     this.uname = uname;
     this.age = age;
 }
 // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
 Star.prototype = {
 // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
   constructor: Star, // 手动设置指回原来的构造函数
   sing: function() {
     console.log('我会唱歌');
   },
   movie: function() {
     console.log('我会演电影');
   }
}
var zxy = new Star('张学友', 19);
console.log(zxy)
</code></pre>
<h3 id="原型链">原型链</h3>
<p>​	每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5Cimg5.png" alt="" loading="lazy"></figure>
<h3 id="构造函数实例和原型对象三角关系">构造函数实例和原型对象三角关系</h3>
<pre><code class="language-js">1.构造函数的prototype属性指向了构造函数原型对象
2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象
3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数
</code></pre>
<h3 id="原型链和成员的查找机制">原型链和成员的查找机制</h3>
<p>任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;</p>
<pre><code class="language-html">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。
如果还没有就查找原型对象的原型（Object的原型对象）。
依此类推一直找到 Object 为止（null）。
__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。
</code></pre>
<h3 id="原型对象中this指向">原型对象中this指向</h3>
<p>构造函数中的this和原型对象的this,都指向我们new出来的实例对象</p>
<pre><code class="language-js">function Star(uname, age) {
    this.uname = uname;
    this.age = age;
}
var that;
Star.prototype.sing = function() {
    console.log('我会唱歌');
    that = this;
}
var ldh = new Star('刘德华', 18);
// 1. 在构造函数中,里面this指向的是对象实例 ldh
console.log(that === ldh);//true
// 2.原型对象函数里面的this 指向的是 实例对象 ldh
</code></pre>
<h3 id="通过原型为数组扩展内置方法">通过原型为数组扩展内置方法</h3>
<pre><code class="language-js"> Array.prototype.sum = function() {
   var sum = 0;
   for (var i = 0; i &lt; this.length; i++) {
   sum += this[i];
   }
   return sum;
 };
 //此时数组对象中已经存在sum()方法了  可以始终 数组.sum()进行数据的求
</code></pre>
<h2 id="继承">继承</h2>
<h3 id="call">call()</h3>
<ul>
<li>call()可以调用函数</li>
<li>call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接</li>
</ul>
<pre><code class="language-js"> function fn(x, y) {
     console.log(this);
     console.log(x + y);
}
  var o = {
  	name: 'andy'
  };
  fn.call(o, 1, 2);//调用了函数此时的this指向了对象o,
</code></pre>
<h3 id="子构造函数继承父构造函数中的属性">子构造函数继承父构造函数中的属性</h3>
<ol>
<li>先定义一个父构造函数</li>
<li>再定义一个子构造函数</li>
<li>子构造函数继承父构造函数的属性(使用call方法)</li>
</ol>
<pre><code class="language-js"> // 1. 父构造函数
 function Father(uname, age) {
   // this 指向父构造函数的对象实例
   this.uname = uname;
   this.age = age;
 }
  // 2 .子构造函数 
function Son(uname, age, score) {
  // this 指向子构造函数的对象实例
  3.使用call方式实现子继承父的属性
  Father.call(this, uname, age);
  this.score = score;
}
var son = new Son('刘德华', 18, 100);
console.log(son);
</code></pre>
<h3 id="借用原型对象继承方法">借用原型对象继承方法</h3>
<ol>
<li>先定义一个父构造函数</li>
<li>再定义一个子构造函数</li>
<li>子构造函数继承父构造函数的属性(使用call方法)</li>
</ol>
<pre><code class="language-js">// 1. 父构造函数
function Father(uname, age) {
  // this 指向父构造函数的对象实例
  this.uname = uname;
  this.age = age;
}
Father.prototype.money = function() {
  console.log(100000);
 };
 // 2 .子构造函数 
  function Son(uname, age, score) {
      // this 指向子构造函数的对象实例
      Father.call(this, uname, age);
      this.score = score;
  }
// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化
  Son.prototype = new Father();
  // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
  Son.prototype.constructor = Son;
  // 这个是子构造函数专门的方法
  Son.prototype.exam = function() {
    console.log('孩子要考试');

  }
  var son = new Son('刘德华', 18, 100);
  console.log(son);
</code></pre>
<h2 id="es5新增方法">ES5新增方法</h2>
<h3 id="数组方法foreach遍历数组">数组方法forEach遍历数组</h3>
<pre><code class="language-js"> arr.forEach(function(value, index, array) {
       //参数一是:数组元素
       //参数二是:数组元素的索引
       //参数三是:当前的数组
 })
  //相当于数组遍历的 for循环 没有返回值
</code></pre>
<h3 id="数组方法filter过滤数组">数组方法filter过滤数组</h3>
<pre><code class="language-js">  var arr = [12, 66, 4, 88, 3, 7];
  var newArr = arr.filter(function(value, index,array) {
  	 //参数一是:数组元素
     //参数二是:数组元素的索引
     //参数三是:当前的数组
     return value &gt;= 20;
  });
  console.log(newArr);//[66,88] //返回值是一个新数组
</code></pre>
<h3 id="数组方法some">数组方法some</h3>
<pre><code class="language-js">some 查找数组中是否有满足条件的元素 
 var arr = [10, 30, 4];
 var flag = arr.some(function(value,index,array) {
    //参数一是:数组元素
     //参数二是:数组元素的索引
     //参数三是:当前的数组
     return value &lt; 3;
  });
console.log(flag);//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环
</code></pre>
<h3 id="筛选商品案例">筛选商品案例</h3>
<ol>
<li>
<p>定义数组对象数据</p>
<pre><code class="language-js">var data = [{
            id: 1,
            pname: '小米',
            price: 3999
        }, {
            id: 2,
            pname: 'oppo',
            price: 999
        }, {
            id: 3,
            pname: '荣耀',
            price: 1299
        }, {
            id: 4,
            pname: '华为',
            price: 1999
        }, ];
</code></pre>
</li>
<li>
<p>使用forEach遍历数据并渲染到页面中</p>
<pre><code class="language-js">data.forEach(function(value) {
  var tr = document.createElement('tr');
  tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;';
  tbody.appendChild(tr);
 });
</code></pre>
</li>
<li>
<p>根据价格筛选数据</p>
<ol>
<li>
<p>获取到搜索按钮并为其绑定点击事件</p>
<pre><code class="language-js">search_price.addEventListener('click', function() {
});
</code></pre>
</li>
<li>
<p>使用filter将用户输入的价格信息筛选出来</p>
<pre><code class="language-js">search_price.addEventListener('click', function() {
      var newDate = data.filter(function(value) {
        //start.value是开始区间
        //end.value是结束的区间
      	return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;
      });
      console.log(newDate);
 });
</code></pre>
</li>
<li>
<p>将筛选出来的数据重新渲染到表格中</p>
<ol>
<li>
<p>将渲染数据的逻辑封装到一个函数中</p>
<pre><code class="language-js">function setDate(mydata) {
      // 先清空原来tbody 里面的数据
  tbody.innerHTML = '';
  mydata.forEach(function(value) {
    var tr = document.createElement('tr');
    tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;';
      tbody.appendChild(tr);
  });
 }
</code></pre>
</li>
<li>
<p>将筛选之后的数据重新渲染</p>
<pre><code class="language-js"> search_price.addEventListener('click', function() {
     var newDate = data.filter(function(value) {
     return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;
     });
     console.log(newDate);
     // 把筛选完之后的对象渲染到页面中
     setDate(newDate);
});
</code></pre>
</li>
</ol>
</li>
<li>
<p>根据商品名称筛选</p>
<ol>
<li>
<p>获取用户输入的商品名称</p>
</li>
<li>
<p>为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选</p>
<pre><code class="language-js"> search_pro.addEventListener('click', function() {
     var arr = [];
     data.some(function(value) {
       if (value.pname === product.value) {
         // console.log(value);
         arr.push(value);
         return true; // return 后面必须写true  
       }
     });
     // 把拿到的数据渲染到页面中
     setDate(arr);
})
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="some和foreach区别">some和forEach区别</h3>
<ul>
<li>如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高</li>
<li>在forEach 里面 return 不会终止迭代</li>
</ul>
<h3 id="trim方法去除字符串两端的空格">trim方法去除字符串两端的空格</h3>
<pre><code class="language-js">var str = '   hello   '
console.log(str.trim()）  //hello 去除两端空格
var str1 = '   he l l o   '
console.log(str.trim()）  //he l l o  去除两端空格
</code></pre>
<h3 id="获取对象的属性名">获取对象的属性名</h3>
<p>Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组</p>
<pre><code class="language-js"> var obj = {
     id: 1,
     pname: '小米',
     price: 1999,
     num: 2000
};
var result = Object.keys(obj)
console.log(result)//[id，pname,price,num]
</code></pre>
<h3 id="objectdefineproperty">Object.defineProperty</h3>
<p>Object.defineProperty设置或修改对象中的属性</p>
<pre><code class="language-js">Object.defineProperty(对象，修改或新增的属性名，{
		value:修改或新增的属性的值,
		writable:true/false,//如果值为false 不允许修改这个属性值
		enumerable: false,//enumerable 如果值为false 则不允许遍历
        configurable: false  //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性
})	
</code></pre>
<h2 id="函数的定义和调用">函数的定义和调用</h2>
<h3 id="函数的定义方式">函数的定义方式</h3>
<ol>
<li>
<p>方式1 函数声明方式 function 关键字 (命名函数)</p>
<pre><code class="language-js">function fn(){}
</code></pre>
</li>
<li>
<p>方式2 函数表达式(匿名函数)</p>
<pre><code class="language-js">var fn = function(){}
</code></pre>
</li>
<li>
<p>方式3 new Function()</p>
<pre><code class="language-js">var f = new Function('a', 'b', 'console.log(a + b)');
f(1, 2);

var fn = new Function('参数1','参数2'..., '函数体')
注意
/*Function 里面参数都必须是字符串格式
第三种方式执行效率低，也不方便书写，因此较少使用
所有函数都是 Function 的实例(对象)  
函数也属于对象
*/
</code></pre>
</li>
</ol>
<h3 id="函数的调用">函数的调用</h3>
<pre><code class="language-js">/* 1. 普通函数 */
function fn() {
	console.log('人生的巅峰');
}
 fn(); 
/* 2. 对象的方法 */
var o = {
  sayHi: function() {
  	console.log('人生的巅峰');
  }
}
o.sayHi();
/* 3. 构造函数*/
function Star() {};
new Star();
/* 4. 绑定事件函数*/
 btn.onclick = function() {};   // 点击了按钮就可以调用这个函数
/* 5. 定时器函数*/
setInterval(function() {}, 1000);  这个函数是定时器自动1秒钟调用一次
/* 6. 立即执行函数(自调用函数)*/
(function() {
	console.log('人生的巅峰');
})();
</code></pre>
<h2 id="this">this</h2>
<h3 id="函数内部的this指向">函数内部的this指向</h3>
<p>这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同</p>
<p>一般指向我们的调用者.</p>
<p>![](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/04-JavaScript高级资料/JavaScript 高级_day03/4-笔记/images/img1.png)</p>
<h3 id="改变函数内部-this-指向">改变函数内部 this 指向</h3>
<h4 id="call方法">call方法</h4>
<p>call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</p>
<p>应用场景:  经常做继承.</p>
<pre><code class="language-js">var o = {
	name: 'andy'
}
 function fn(a, b) {
      console.log(this);
      console.log(a+b)
};
fn(1,2)// 此时的this指向的是window 运行结果为3
fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3
</code></pre>
<h4 id="apply方法">apply方法</h4>
<p>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p>
<p>应用场景:  经常跟数组有关系</p>
<pre><code class="language-js">var o = {
	name: 'andy'
}
 function fn(a, b) {
      console.log(this);
      console.log(a+b)
};
fn()// 此时的this指向的是window 运行结果为3
fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3
</code></pre>
<h4 id="bind方法">bind方法</h4>
<p>bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数</p>
<p>如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind</p>
<p>应用场景:不调用函数,但是还想改变this指向</p>
<pre><code class="language-js"> var o = {
 name: 'andy'
 };

function fn(a, b) {
	console.log(this);
	console.log(a + b);
};
var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数
f();//调用新函数  this指向的是对象o 参数使用逗号隔开
</code></pre>
<h4 id="call-apply-bind三者的异同">call、apply、bind三者的异同</h4>
<ul>
<li>
<p>共同点 : 都可以改变this指向</p>
</li>
<li>
<p>不同点:</p>
<ul>
<li>call 和 apply  会调用函数, 并且改变函数内部this指向.</li>
<li>call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</li>
<li>bind  不会调用函数, 可以改变函数内部this指向.</li>
</ul>
</li>
<li>
<p>应用场景</p>
<ol>
<li>call 经常做继承.</li>
<li>apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</li>
<li>bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</li>
</ol>
</li>
</ul>
<h2 id="严格模式">严格模式</h2>
<h3 id="什么是严格模式">什么是严格模式</h3>
<p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。</p>
<p>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p>
<p>严格模式对正常的 JavaScript 语义做了一些更改：</p>
<p>1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</p>
<p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p>
<p>3.提高编译器效率，增加运行速度。</p>
<p>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p>
<h3 id="开启严格模式">开启严格模式</h3>
<p>严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。</p>
<ul>
<li>
<p>情况一 :为脚本开启严格模式</p>
<ul>
<li>
<p>有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他<br>
script 脚本文件。</p>
<pre><code class="language-js">(function (){
  //在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式
　　　　&quot;use strict&quot;;
       var num = 10;
　　　　function fn() {}
})();
//或者 
&lt;script&gt;
  　&quot;use strict&quot;; //当前script标签开启了严格模式
&lt;/script&gt;
&lt;script&gt;
  			//当前script标签未开启严格模式
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>情况二: 为函数开启严格模式</p>
<ul>
<li>
<p>要给某个函数开启严格模式，需要把“use strict”;  (或 'use strict'; ) 声明放在函数体所有语句之前。</p>
<pre><code class="language-js">function fn(){
　　&quot;use strict&quot;;
　　return &quot;123&quot;;
} 
//当前fn函数开启了严格模式
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="严格模式中的变化">严格模式中的变化</h3>
<p>严格模式对 Javascript 的语法和行为，都做了一些改变。</p>
<pre><code class="language-js">'use strict'
num = 10 
console.log(num)//严格模式后使用未声明的变量
--------------------------------------------------------------------------------
var num2 = 1;
delete num2;//严格模式不允许删除变量
--------------------------------------------------------------------------------
function fn() {
 console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined
}
fn();  
---------------------------------------------------------------------------------
function Star() {
	 this.sex = '男';
}
// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.
var ldh = new Star();
console.log(ldh.sex);
----------------------------------------------------------------------------------
setTimeout(function() {
  console.log(this); //严格模式下，定时器 this 还是指向 window
}, 2000);  
</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">更多严格模式要求参考</a></p>
<h2 id="高阶函数">高阶函数</h2>
<p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p>
<p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</p>
<p>同理函数也可以作为返回值传递回来</p>
<h2 id="闭包">闭包</h2>
<h3 id="变量的作用域复习">变量的作用域复习</h3>
<p>变量根据作用域的不同分为两种：全局变量和局部变量。</p>
<ol>
<li>函数内部可以使用全局变量。</li>
<li>函数外部不可以使用局部变量。</li>
<li>当函数执行完毕，本作用域内的局部变量会销毁。</li>
</ol>
<h3 id="什么是闭包">什么是闭包</h3>
<p>闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</p>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5Cimg3.png" alt="" loading="lazy"></figure>
<h3 id="闭包的作用">闭包的作用</h3>
<p>作用：延伸变量的作用范围。</p>
<pre><code class="language-js"> function fn() {
   var num = 10;
   function fun() {
       console.log(num);
 	}
    return fun;
 }
var f = fn();
f();
</code></pre>
<h3 id="闭包的案例">闭包的案例</h3>
<ol>
<li>利用闭包的方式得到当前li 的索引号</li>
</ol>
<pre><code class="language-js">for (var i = 0; i &lt; lis.length; i++) {
// 利用for循环创建了4个立即执行函数
// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
(function(i) {
    lis[i].onclick = function() {
      console.log(i);
    }
 })(i);
}
</code></pre>
<ol start="2">
<li>闭包应用-3秒钟之后,打印所有li元素的内容</li>
</ol>
<pre><code class="language-js"> for (var i = 0; i &lt; lis.length; i++) {
   (function(i) {
     setTimeout(function() {
     console.log(lis[i].innerHTML);
     }, 3000)
   })(i);
}
</code></pre>
<ol start="3">
<li>闭包应用-计算打车价格</li>
</ol>
<pre><code class="language-js">/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/

 var car = (function() {
     var start = 13; // 起步价  局部变量
     var total = 0; // 总价  局部变量
     return {
       // 正常的总价
       price: function(n) {
         if (n &lt;= 3) {
           total = start;
         } else {
           total = start + (n - 3) * 5
         }
         return total;
       },
       // 拥堵之后的费用
       yd: function(flag) {
         return flag ? total + 10 : total;
       }
	}
 })();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33
</code></pre>
<h3 id="案例">案例</h3>
<pre><code class="language-js"> var name = &quot;The Window&quot;;
   var object = {
     name: &quot;My Object&quot;,
     getNameFunc: function() {
     return function() {
     return this.name;
     };
   }
 };
console.log(object.getNameFunc()())
-----------------------------------------------------------------------------------
var name = &quot;The Window&quot;;　　
  var object = {　　　　
    name: &quot;My Object&quot;,
    getNameFunc: function() {
    var that = this;
    return function() {
    return that.name;
    };
  }
};
console.log(object.getNameFunc()())
       
</code></pre>
<h2 id="递归">递归</h2>
<h3 id="什么是递归">什么是递归</h3>
<p>**递归：**如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数</p>
<p>**注意：**递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。</p>
<h3 id="利用递归求1~n的阶乘">利用递归求1~n的阶乘</h3>
<pre><code class="language-js">//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
 function fn(n) {
     if (n == 1) { //结束条件
       return 1;
     }
     return n * fn(n - 1);
 }
 console.log(fn(3));
</code></pre>
<h3 id="利用递归求斐波那契数列">利用递归求斐波那契数列</h3>
<pre><code class="language-js">// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...
// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值
// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值
function fb(n) {
  if (n === 1 || n === 2) {
        return 1;
  }
  return fb(n - 1) + fb(n - 2);
}
console.log(fb(3));
</code></pre>
<h3 id="利用递归遍历数据">利用递归遍历数据</h3>
<pre><code class="language-js">// 我们想要做输入id号,就可以返回的数据对象
 var data = [{
   id: 1,
   name: '家电',
   goods: [{
     id: 11,
     gname: '冰箱',
     goods: [{
       id: 111,
       gname: '海尔'
     }, {
       id: 112,
       gname: '美的'
     },

            ]

   }, {
     id: 12,
     gname: '洗衣机'
   }]
 }, {
   id: 2,
   name: '服饰'
}];
//1.利用 forEach 去遍历里面的每一个对象
 function getID(json, id) {
   var o = {};
   json.forEach(function(item) {
     // console.log(item); // 2个数组元素
     if (item.id == id) {
       // console.log(item);
       o = item;
       return o;
       // 2. 我们想要得里层的数据 11 12 可以利用递归函数
       // 里面应该有goods这个数组并且数组的长度不为 0 
     } else if (item.goods &amp;&amp; item.goods.length &gt; 0) {
       o = getID(item.goods, id);
     }
   });
   return o;
}
</code></pre>
<h2 id="正则表达式概述">正则表达式概述</h2>
<h3 id="什么是正则表达式">什么是正则表达式</h3>
<p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p>
<p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(<strong>匹配</strong>)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(<strong>替换</strong>)，或从字符串中获取我们想要的特定部分(<strong>提取</strong>)等 。</p>
<p>其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。</p>
<h3 id="正则表达式的特点">正则表达式的特点</h3>
<ol>
<li>灵活性、逻辑性和功能性非常的强。</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>
<li>对于刚接触的人来说，比较晦涩难懂。比如：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</li>
<li>实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:   /<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>{3,16}$/</li>
</ol>
<h2 id="正则表达式在js中的使用">正则表达式在js中的使用</h2>
<h3 id="正则表达式的创建">正则表达式的创建</h3>
<p>在 JavaScript 中，可以通过两种方式创建一个正则表达式。</p>
<p>方式一：通过调用RegExp对象的构造函数创建</p>
<pre><code class="language-js">var regexp = new RegExp(/123/);
console.log(regexp);
</code></pre>
<p>方式二：利用字面量创建 正则表达式</p>
<pre><code class="language-js"> var rg = /123/;
</code></pre>
<h3 id="测试正则表达式">测试正则表达式</h3>
<p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p>
<pre><code class="language-js">var rg = /123/;
console.log(rg.test(123));//匹配字符中是否出现123  出现结果为true
console.log(rg.test('abc'));//匹配字符中是否出现123 未出现结果为false
</code></pre>
<h2 id="正则表达式中的特殊字符">正则表达式中的特殊字符</h2>
<h3 id="正则表达式的组成">正则表达式的组成</h3>
<p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p>
<p>特殊字符非常多，可以参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p>
<p>jQuery 手册：正则表达式部分</p>
<p>[正则测试工具]( &lt;http://tool.oschina.net/regex)</p>
<h3 id="边界符">边界符</h3>
<p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示匹配行首的文本（以谁开始）</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody>
</table>
<p>如果 ^和 $ 在一起，表示必须是精确匹配。</p>
<pre><code class="language-js">var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型
// /abc/ 只要包含有abc这个字符串返回的都是true
console.log(rg.test('abc'));
console.log(rg.test('abcd'));
console.log(rg.test('aabcd'));
console.log('---------------------------');
var reg = /^abc/;
console.log(reg.test('abc')); // true
console.log(reg.test('abcd')); // true
console.log(reg.test('aabcd')); // false
console.log('---------------------------');
var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范
console.log(reg1.test('abc')); // true
console.log(reg1.test('abcd')); // false
console.log(reg1.test('aabcd')); // false
console.log(reg1.test('abcabc')); // false
</code></pre>
<h3 id="字符类">字符类</h3>
<p>字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p>
<h4 id="方括号">[] 方括号</h4>
<p>表示有一系列字符可供选择，只要匹配其中<strong>一个</strong>就可以了</p>
<pre><code class="language-js">var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true
console.log(rg.test('andy'));//true
console.log(rg.test('baby'));//true
console.log(rg.test('color'));//true
console.log(rg.test('red'));//false
var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true
console.log(rg1.test('aa'));//false
console.log(rg1.test('a'));//true
console.log(rg1.test('b'));//true
console.log(rg1.test('c'));//true
console.log(rg1.test('abc'));//true
----------------------------------------------------------------------------------
var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  
console.log(reg.test('a'));//true
console.log(reg.test('z'));//true
console.log(reg.test('A'));//false
-----------------------------------------------------------------------------------
//字符组合
var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true  
------------------------------------------------------------------------------------
//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。
var reg2 = /^[^a-zA-Z0-9]$/;
console.log(reg2.test('a'));//false
console.log(reg2.test('B'));//false
console.log(reg2.test(8));//false
console.log(reg2.test('!'));//true
</code></pre>
<h4 id="量词符">量词符</h4>
<p>量词符用来设定某个模式出现的次数。</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复0次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复1次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复0次或1次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<h4 id="用户名表单验证">用户名表单验证</h4>
<p>功能需求:</p>
<ol>
<li>如果用户名输入合法, 则后面提示信息为:  用户名合法,并且颜色为绿色</li>
<li>如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为红色</li>
</ol>
<p>分析:</p>
<ol>
<li>用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位.</li>
<li>首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/</li>
<li>当表单失去焦点就开始验证.</li>
<li>如果符合正则规范, 则让后面的span标签添加 right类.</li>
<li>如果不符合正则规范, 则让后面的span标签添加 wrong类.</li>
</ol>
<pre><code class="language-js">&lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; &lt;span&gt;请输入用户名&lt;/span&gt;
 &lt;script&gt;
 //  量词是设定某个模式出现的次数
 var reg = /^[a-zA-Z0-9_-]{6,16}$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线
 var uname = document.querySelector('.uname');
 var span = document.querySelector('span');
 uname.onblur = function() {
   if (reg.test(this.value)) {
   console.log('正确的');
   span.className = 'right';
   span.innerHTML = '用户名格式输入正确';
   } else {
   console.log('错误的');
   span.className = 'wrong';
   span.innerHTML = '用户名格式输入不正确';
   }
 }
&lt;/script&gt;
</code></pre>
<h4 id="括号总结">括号总结</h4>
<p>1.大括号  量词符.  里面表示重复次数</p>
<p>2.中括号 字符集合。匹配方括号中的任意字符.</p>
<p>3.小括号表示优先级</p>
<p><a href="https://c.runoob.com/">正则表达式在线测试</a></p>
<h3 id="预定义类">预定义类</h3>
<p>预定义类指的是某些常见模式的简写方式.</p>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5Cimg333.png" alt="" loading="lazy"></figure>
<p><strong>验证座机号码</strong></p>
<pre><code class="language-js">var reg = /^\d{3}-\d{8}|\d{4}-\d{7}$/;
var reg = /^\d{3,4}-\d{7,8}$/;
</code></pre>
<p><strong>表单验证案例</strong></p>
<pre><code class="language-js">//手机号验证:/^1[3|4|5|7|8][0-9]{9}$/;
//验证通过与不通过更换元素的类名与元素中的内容
 if (reg.test(this.value)) {
    // console.log('正确的');
    this.nextElementSibling.className = 'success';
    this.nextElementSibling.innerHTML = '&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确';
   } else {
       // console.log('不正确');
      this.nextElementSibling.className = 'error';
      this.nextElementSibling.innerHTML = '&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt;格式不正确,请从新输入 ';
 }
</code></pre>
<pre><code class="language-js">//QQ号验证: /^[1-9]\d{4,}$/; 
//昵称验证:/^[\u4e00-\u9fa5]{2,8}$/
//验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可
 function regexp(ele, reg) {
    ele.onblur = function() {
      if (reg.test(this.value)) {
        // console.log('正确的');
        this.nextElementSibling.className = 'success';
        this.nextElementSibling.innerHTML = '&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确';
   } else {
     // console.log('不正确');
     this.nextElementSibling.className = 'error';
     this.nextElementSibling.innerHTML = '&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确,请从新输入 ';
            }
        }
 };
</code></pre>
<pre><code class="language-js">//密码验证:/^[a-zA-Z0-9_-]{6,16}$/
//再次输入密码只需匹配与上次输入的密码值 是否一致
</code></pre>
<h3 id="正则替换replace">正则替换replace</h3>
<p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p>
<pre><code class="language-js">var str = 'andy和red';
var newStr = str.replace('andy', 'baby');
console.log(newStr)//baby和red
//等同于 此处的andy可以写在正则表达式内
var newStr2 = str.replace(/andy/, 'baby');
console.log(newStr2)//baby和red
//全部替换
var str = 'abcabc'
var nStr = str.replace(/a/,'哈哈')
console.log(nStr) //哈哈bcabc
//全部替换g
var nStr = str.replace(/a/a,'哈哈')
console.log(nStr) //哈哈bc哈哈bc
//忽略大小写i
var str = 'aAbcAba';
var newStr = str.replace(/a/gi,'哈哈')//&quot;哈哈哈哈bc哈哈b哈哈&quot;
</code></pre>
<p><strong>过滤敏感词汇</strong></p>
<pre><code class="language-js">&lt;textarea name=&quot;&quot; id=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
    var text = document.querySelector('textarea');
    var btn = document.querySelector('button');
    var div = document.querySelector('div');
    btn.onclick = function() {
    	div.innerHTML = text.value.replace(/激情|gay/g, '**');
    }
&lt;/script&gt;
</code></pre>
<h1 id="es6语法">ES6语法</h1>
<h2 id="目标">目标</h2>
<ul>
<li>能够说出使用let关键字声明变量的特点</li>
<li>能够使用解构赋值从数组中提取值</li>
<li>能够说出箭头函数拥有的特性</li>
<li>能够使用剩余参数接收剩余的函数参数</li>
<li>能够使用拓展运算符拆分数组</li>
<li>能够说出模板字符串拥有的特性</li>
</ul>
<h2 id="es6相关概念">ES6相关概念（★★）</h2>
<h3 id="什么是es6">什么是ES6</h3>
<p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。</p>
<h3 id="为什么使用-es6">为什么使用 ES6 ?</h3>
<p>每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。</p>
<ul>
<li>变量提升特性增加了程序运行时的不可预测性</li>
<li>语法过于松散，实现相同的功能，不同的人可能会写出不同的代码</li>
</ul>
<h2 id="es6新增语法">ES6新增语法</h2>
<h3 id="let">let（★★★）</h3>
<p>ES6中新增了用于声明变量的关键字</p>
<h4 id="let声明的变量只在所处于的块级有效">let声明的变量只在所处于的块级有效</h4>
<pre><code class="language-javascript"> if (true) { 
     let a = 10;
 }
console.log(a) // a is not defined
</code></pre>
<p>**注意：**使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p>
<h4 id="不存在变量提升">不存在变量提升</h4>
<pre><code class="language-javascript">console.log(a); // a is not defined 
let a = 20;
</code></pre>
<h4 id="暂时性死区">暂时性死区</h4>
<p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p>
<pre><code class="language-javascript"> var tmp = 123;
 if (true) { 
     tmp = 'abc';
     let tmp; 
 } 
</code></pre>
<h4 id="经典面试题">经典面试题</h4>
<pre><code class="language-javascript"> var arr = [];
 for (var i = 0; i &lt; 2; i++) {
     arr[i] = function () {
         console.log(i); 
     }
 }
 arr[0]();
 arr[1]();

</code></pre>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5Clet%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="" loading="lazy"></figure>
<p>**经典面试题图解：**此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p>
<pre><code class="language-javascript"> let arr = [];
 for (let i = 0; i &lt; 2; i++) {
     arr[i] = function () {
         console.log(i); 
     }
 }
 arr[0]();
 arr[1]();

</code></pre>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5Clet%E9%9D%A2%E8%AF%95%E9%A2%982.png" alt="" loading="lazy"></figure>
<p><strong>经典面试题图解：<strong>此题的关键点在于</strong>每次循环都会产生一个块级作用域</strong>，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p>
<h4 id="小结">小结</h4>
<ul>
<li>let关键字就是用来声明变量的</li>
<li>使用let关键字声明的变量具有块级作用域</li>
<li>在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的</li>
<li>防止循环变量变成全局变量</li>
<li>使用let关键字声明的变量没有变量提升</li>
<li>使用let关键字声明的变量具有暂时性死区特性</li>
</ul>
<h3 id="const">const（★★★）</h3>
<p>声明常量，常量就是值（内存地址）不能变化的量</p>
<h4 id="具有块级作用域">具有块级作用域</h4>
<pre><code class="language-javascript"> if (true) { 
     const a = 10;
 }
console.log(a) // a is not defined
</code></pre>
<h4 id="声明常量时必须赋值">声明常量时必须赋值</h4>
<pre><code class="language-javascript">const PI; // Missing initializer in const declaration
</code></pre>
<h4 id="常量赋值后值不能修改">常量赋值后，值不能修改</h4>
<pre><code class="language-javascript">const PI = 3.14;
PI = 100; // Assignment to constant variable.

const ary = [100, 200];
ary[0] = 'a';
ary[1] = 'b';
console.log(ary); // ['a', 'b']; 
ary = ['a', 'b']; // Assignment to constant variable.
</code></pre>
<h4 id="小结-2">小结</h4>
<ul>
<li>const声明的变量是一个常量</li>
<li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li>
<li>声明 const时候必须要给定值</li>
</ul>
<h3 id="let-const-var-的区别">let、const、var 的区别</h3>
<ul>
<li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</li>
<li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</li>
<li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</li>
</ul>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5Cvar&amp;let&amp;const%E5%8C%BA%E5%88%AB.png" alt="" loading="lazy"></figure>
<h3 id="解构赋值">解构赋值（★★★）</h3>
<p>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p>
<h4 id="数组解构">数组解构</h4>
<pre><code class="language-javascript"> let [a, b, c] = [1, 2, 3];
 console.log(a)//1
 console.log(b)//2
 console.log(c)//3
//如果解构不成功，变量的值为undefined
</code></pre>
<h4 id="对象解构">对象解构</h4>
<pre><code class="language-javascript"> let person = { name: 'zhangsan', age: 20 }; 
 let { name, age } = person;
 console.log(name); // 'zhangsan' 
 console.log(age); // 20

 let {name: myName, age: myAge} = person; // myName myAge 属于别名
 console.log(myName); // 'zhangsan' 
 console.log(myAge); // 20

</code></pre>
<h4 id="小结-3">小结</h4>
<ul>
<li>解构赋值就是把数据结构分解，然后给变量进行赋值</li>
<li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li>
<li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li>
<li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li>
</ul>
<h3 id="箭头函数">箭头函数（★★★）</h3>
<p>ES6中新增的定义函数的方式。</p>
<pre><code class="language-javascript">() =&gt; {} //()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；{}：函数体
const fn = () =&gt; {}//代表把一个函数赋值给fn
</code></pre>
<p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p>
<pre><code class="language-javascript"> function sum(num1, num2) { 
     return num1 + num2; 
 }
 //es6写法
 const sum = (num1, num2) =&gt; num1 + num2; 

</code></pre>
<p>如果形参只有一个，可以省略小括号</p>
<pre><code class="language-javascript"> function fn (v) {
     return v;
 } 
//es6写法
 const fn = v =&gt; v;

</code></pre>
<p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p>
<pre><code class="language-javascript">const obj = { name: '张三'} 
 function fn () { 
     console.log(this);//this 指向 是obj对象
     return () =&gt; { 
         console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象
     } 
 } 
 const resFn = fn.call(obj); 
 resFn();

</code></pre>
<h4 id="小结-4">小结</h4>
<ul>
<li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li>
<li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li>
</ul>
<h4 id="面试题">面试题</h4>
<pre><code class="language-javascript">var age = 100;

var obj = {
	age: 20,
	say: () =&gt; {
		alert(this.age)
	}
}

obj.say();//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域
</code></pre>
<h3 id="剩余参数">剩余参数（★★）</h3>
<p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p>
<pre><code class="language-javascript">function sum (first, ...args) {
     console.log(first); // 10
     console.log(args); // [20, 30] 
 }
 sum(10, 20, 30)

</code></pre>
<h4 id="剩余参数和解构配合使用">剩余参数和解构配合使用</h4>
<pre><code class="language-javascript">let students = ['wangwu', 'zhangsan', 'lisi'];
let [s1, ...s2] = students; 
console.log(s1);  // 'wangwu' 
console.log(s2);  // ['zhangsan', 'lisi']

</code></pre>
<h2 id="es6-的内置对象扩展">ES6 的内置对象扩展</h2>
<h3 id="array-的扩展方法">Array 的扩展方法（★★）</h3>
<h4 id="扩展运算符展开语法">扩展运算符（展开语法）</h4>
<p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p>
<pre><code class="language-javascript"> let ary = [1, 2, 3];
 ...ary  // 1, 2, 3
 console.log(...ary);    // 1 2 3,相当于下面的代码
 console.log(1,2,3);
</code></pre>
<h5 id="扩展运算符可以应用于合并数组">扩展运算符可以应用于合并数组</h5>
<pre><code class="language-javascript">// 方法一 
 let ary1 = [1, 2, 3];
 let ary2 = [3, 4, 5];
 let ary3 = [...ary1, ...ary2];
 // 方法二 
 ary1.push(...ary2);
</code></pre>
<h5 id="将类数组或可遍历对象转换为真正的数组">将类数组或可遍历对象转换为真正的数组</h5>
<pre><code class="language-javascript">let oDivs = document.getElementsByTagName('div'); 
oDivs = [...oDivs];
</code></pre>
<h4 id="构造函数方法arrayfrom">构造函数方法：Array.from()</h4>
<p>将伪数组或可遍历对象转换为真正的数组</p>
<pre><code class="language-javascript">//定义一个集合
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
}; 
//转成数组
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
</code></pre>
<p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<pre><code class="language-javascript"> let arrayLike = { 
     &quot;0&quot;: 1,
     &quot;1&quot;: 2,
     &quot;length&quot;: 2
 }
 let newAry = Array.from(arrayLike, item =&gt; item *2)//[2,4]

</code></pre>
<p>注意：如果是对象，那么属性需要写对应的索引</p>
<h4 id="实例方法find">实例方法：find()</h4>
<p>用于找出<strong>第一个符合条件</strong>的<strong>数组成员</strong>，如果没有找到返回undefined</p>
<pre><code class="language-javascript">let ary = [{
     id: 1,
     name: '张三'
 }, { 
     id: 2,
     name: '李四'
 }]; 
 let target = ary.find((item, index) =&gt; item.id == 2);//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个

</code></pre>
<h4 id="实例方法findindex">实例方法：findIndex()</h4>
<p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p>
<pre><code class="language-javascript">let ary = [1, 5, 10, 15];
let index = ary.findIndex((value, index) =&gt; value &gt; 9); 
console.log(index); // 2
</code></pre>
<h4 id="实例方法includes">实例方法：includes()</h4>
<p>判断某个数组是否包含给定的值，返回布尔值。</p>
<pre><code class="language-javascript">[1, 2, 3].includes(2) // true 
[1, 2, 3].includes(4) // false

</code></pre>
<h3 id="string-的扩展方法">String 的扩展方法</h3>
<h4 id="模板字符串">模板字符串（★★★）</h4>
<p>ES6新增的创建字符串的方式，使用反引号定义</p>
<pre><code class="language-javascript">let name = `zhangsan`;

</code></pre>
<h5 id="模板字符串中可以解析变量">模板字符串中可以解析变量</h5>
<pre><code class="language-javascript">let name = '张三'; 
let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan
</code></pre>
<h5 id="模板字符串中可以换行">模板字符串中可以换行</h5>
<pre><code class="language-javascript"> let result = { 
     name: 'zhangsan', 
     age: 20,
     sex: '男' 
 } 
 let html = ` &lt;div&gt;
     &lt;span&gt;${result.name}&lt;/span&gt;
     &lt;span&gt;${result.age}&lt;/span&gt;
     &lt;span&gt;${result.sex}&lt;/span&gt;
 &lt;/div&gt; `;

</code></pre>
<h5 id="在模板字符串中可以调用函数">在模板字符串中可以调用函数</h5>
<pre><code class="language-javascript">const sayHello = function () { 
    return '哈哈哈哈 追不到我吧 我就是这么强大';
 }; 
 let greet = `${sayHello()} 哈哈哈哈`;
 console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈

</code></pre>
<h4 id="实例方法startswith-和-endswith">实例方法：startsWith() 和 endsWith()</h4>
<ul>
<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li>
<li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li>
</ul>
<pre><code class="language-javascript">let str = 'Hello world!';
str.startsWith('Hello') // true 
str.endsWith('!')       // true

</code></pre>
<h4 id="实例方法repeat">实例方法：repeat()</h4>
<p>repeat方法表示将原字符串重复n次，返回一个新字符串</p>
<pre><code class="language-javascript">'x'.repeat(3)      // &quot;xxx&quot; 
'hello'.repeat(2)  // &quot;hellohello&quot;
</code></pre>
<h3 id="set-数据结构">Set 数据结构（★★）</h3>
<p>ES6 提供了新的数据结构  Set。它类似于数组，但是<strong>成员的值都是唯一的，没有重复的值。</strong></p>
<p>Set本身是一个构造函数，用来生成  Set  数据结构</p>
<pre><code class="language-javascript">const s = new Set();
</code></pre>
<p>Set函数可以接受一个数组作为参数，用来初始化。</p>
<pre><code class="language-javascript">const set = new Set([1, 2, 3, 4, 4]);//{1, 2, 3, 4}

</code></pre>
<h4 id="实例方法">实例方法</h4>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li>
<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li>
<li>clear()：清除所有成员，没有返回值</li>
</ul>
<pre><code class="language-javascript"> const s = new Set();
 s.add(1).add(2).add(3); // 向 set 结构中添加值 
 s.delete(2)             // 删除 set 结构中的2值   
 s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值 
 s.clear()               // 清除 set 结构中的所有值
 //注意：删除的是元素的值，不是代表的索引
</code></pre>
<h4 id="遍历">遍历</h4>
<p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="language-javascript">s.forEach(value =&gt; console.log(value))

</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>a-z0-9_- <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuerry]]></title>
        <id>https://xmweijh.github.io/post/jquerry/</id>
        <link href="https://xmweijh.github.io/post/jquerry/">
        </link>
        <updated>2021-02-19T12:06:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jquery">jQuery</h1>
<h2 id="jquery-介绍">jQuery 介绍</h2>
<h3 id="javascript-库">JavaScript 库</h3>
<p>​	JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</p>
<blockquote>
<p>简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</p>
<p>比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。</p>
</blockquote>
<p>​	常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</p>
<h3 id="jquery的概念">jQuery的概念</h3>
<p>​	jQuery总体概况如下 :</p>
<ul>
<li>
<p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p>
</li>
<li>
<p>j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</p>
</li>
<li>
<p>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</p>
</li>
<li>
<p>学习jQuery本质： 就是学习调用这些函数（方法）。</p>
</li>
<li>
<p>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</p>
</li>
</ul>
<h3 id="jquery的优点">jQuery的优点</h3>
<ol>
<li>轻量级。核心文件才几十kb，不会影响页面加载速度。</li>
<li>跨浏览器兼容，基本兼容了现在主流的浏览器。</li>
<li>链式编程、隐式迭代。</li>
<li>对事件、样式、动画支持，大大简化了DOM操作。</li>
<li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</li>
<li>免费、开源。</li>
</ol>
<h2 id="jquery-的基本使用">jQuery 的基本使用</h2>
<h3 id="jquery-的下载">jQuery 的下载</h3>
<p>​	jQuery的官网地址： https://jquery.com/，官网即可下载最新版本。</p>
<blockquote>
<p>各个版本的下载：https://code.jquery.com/</p>
</blockquote>
<p>​	版本介绍：</p>
<blockquote>
<p>1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</p>
<p>2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</p>
<p>3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</p>
</blockquote>
<h3 id="体验jquery">体验jQuery</h3>
<p>​	步骤：</p>
<ul>
<li>引入jQuery文件。</li>
<li>在文档最末尾插入 script 标签，书写体验代码。</li>
<li>$('div').hide() 可以隐藏盒子。</li>
</ul>
<h3 id="jquery的入口函数">jQuery的入口函数</h3>
<p>​	jQuery中常见的两种入口函数：</p>
<pre><code class="language-javascript">// 第一种: 简单易用。
$(function () {   
    ...  // 此处是页面 DOM 加载完成的入口
}) ; 

// 第二种: 繁琐，但是也可以实现
$(document).ready(function(){
   ...  //  此处是页面DOM加载完成的入口
});
</code></pre>
<p>​	总结：</p>
<ol>
<li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li>
<li>相当于原生 js 中的 DOMContentLoaded。</li>
<li>不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。</li>
<li>更推荐使用第一种方式。</li>
</ol>
<h3 id="jquery中的顶级对象">jQuery中的顶级对象$</h3>
<ol>
<li>$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</li>
<li>$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。</li>
</ol>
<h3 id="jquery-对象和-dom-对象">jQuery 对象和 DOM 对象</h3>
<p>​	使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 :</p>
<ol>
<li>用原生 JS 获取来的对象就是 DOM 对象</li>
<li>jQuery 方法获取的元素就是 jQuery 对象。</li>
<li>jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5CjQuery%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%AF%B9%E8%B1%A1.png" alt="jQuery对象和DOM对象" loading="lazy"></figure>
<h3 id="jquery-对象和-dom-对象转换">jQuery 对象和 DOM 对象转换</h3>
<p>​	DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p>
<pre><code class="language-javascript">// 1.DOM对象转换成jQuery对象，方法只有一种
var box = document.getElementById('box');  // 获取DOM对象
var jQueryObject = $(box);  // 把DOM对象转换为 jQuery 对象

// 2.jQuery 对象转换为 DOM 对象有两种方法：
//   2.1 jQuery对象[索引值]
var domObject1 = $('div')[0]

//   2.2 jQuery对象.get(索引值)
var domObject2 = $('div').get(0)
 
</code></pre>
<p>总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</p>
<h2 id="jquery-选择器">jQuery 选择器</h2>
<p>​	原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</p>
<h3 id="基础选择器">基础选择器</h3>
<pre><code class="language-js">$(&quot;选择器&quot;)   //  里面选择器直接写 CSS 选择器即可，但是要加引号 
</code></pre>
<p>​	<img src="E:%5CAPTX-4869%5Cmd%5C%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="基础选择器" loading="lazy"></p>
<h3 id="层级选择器">层级选择器</h3>
<p>​	层级选择器最常用的两个分别为：后代选择器和子代选择器。</p>
<p>​	<img src="E:%5CAPTX-4869%5Cmd%5C%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="层级选择器" loading="lazy"></p>
<p><strong>基础选择器和层级选择器案例代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;我是div&lt;/div&gt;
    &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt;
    &lt;p&gt;我是p&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;我是ul 的&lt;/li&gt;
        &lt;li&gt;我是ul 的&lt;/li&gt;        
        &lt;li&gt;我是ul 的&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        $(function() {
            console.log($(&quot;.nav&quot;));
            console.log($(&quot;ul li&quot;));
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="筛选选择器">筛选选择器</h3>
<p>​	筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="筛选选择器" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
        &lt;li&gt;多个里面筛选几个&lt;/li&gt;
    &lt;/ol&gt;
    &lt;script&gt;
        $(function() {
            $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;);
            $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;);
            $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;);
            $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;);
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</p>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5Crelation.png" alt="筛选方法" loading="lazy"></figure>
<h3 id="知识铺垫">知识铺垫</h3>
<ul>
<li>jQuery 设置样式</li>
</ul>
<pre><code class="language-javascript">$('div').css('属性', '值')    
</code></pre>
<ul>
<li>jQuery 里面的排他思想</li>
</ul>
<pre><code class="language-javascript">// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。
$(this).css(“color”,”red”);
$(this).siblings(). css(“color”,””);
</code></pre>
<ul>
<li>隐式迭代</li>
</ul>
<pre><code class="language-javascript">// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。
// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。
$('div').hide();  // 页面中所有的div全部隐藏，不用循环操作
</code></pre>
<ul>
<li>链式编程</li>
</ul>
<pre><code class="language-javascript">// 链式编程是为了节省代码量，看起来更优雅。
$(this).css('color', 'red').sibling().css('color', ''); 
</code></pre>
<h2 id="jquery-样式操作">jQuery 样式操作</h2>
<p>​	jQuery中常用的样式操作有两种：css() 和 设置类样式方法</p>
<h3 id="方法1-操作-css-方法">方法1: 操作 css 方法</h3>
<p>​	jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。</p>
<p>​	常用以下三种形式 :</p>
<pre><code class="language-javascript">// 1.参数只写属性名，则是返回属性值
var strColor = $(this).css('color');

// 2.  参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号
$(this).css(''color'', ''red'');

// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号
$(this).css({
    &quot;color&quot;:&quot;white&quot;,
    &quot;font-size&quot;:&quot;20px&quot;
});

</code></pre>
<p>​	注意：css() 多用于样式少时操作，多了则不太方便。</p>
<h3 id="方法2-设置类样式方法">方法2: 设置类样式方法</h3>
<p>​	作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。</p>
<p>​	常用的三种设置类样式方法：</p>
<pre><code class="language-javascript">// 1.添加类
$(&quot;div&quot;).addClass(&quot;current&quot;);

// 2.删除类
$(&quot;div&quot;).removeClass(&quot;current&quot;);

// 3.切换类
$(&quot;div&quot;).toggleClass(&quot;current&quot;);

</code></pre>
<p>​	注意：</p>
<ol>
<li>设置类样式方法比较适合样式多时操作，可以弥补css()的不足。</li>
<li>原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</li>
</ol>
<h3 id="tab-栏切换">tab 栏切换</h3>
<blockquote>
<p>思路分析:<br>
1.点击上部的li，当前li 添加current类，其余兄弟移除类。<br>
2.点击的同时，得到当前li 的索引号<br>
3.让下部里面相应索引号的item显示，其余的item隐藏</p>
</blockquote>
<p>​</p>
<pre><code class="language-js"> $(function() {
            // 1.点击上部的li，当前li 添加current类，其余兄弟移除类
            $(&quot;.tab_list li&quot;).click(function() {
                // 链式编程操作
                $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);
                // 2.点击的同时，得到当前li 的索引号
                var index = $(this).index();
                console.log(index);
                // 3.让下部里面相应索引号的item显示，其余的item隐藏
                $(&quot;.tab_con .item&quot;).eq(index).show().siblings().hide();
            });
        })
</code></pre>
<h2 id="jquery-效果">jQuery 效果</h2>
<p>​	jQuery 给我们封装了很多动画效果，最为常见的如下：</p>
<ul>
<li>显示隐藏：show() / hide() / toggle() ;</li>
<li>划入画出：slideDown() / slideUp() / slideToggle() ;</li>
<li>淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</li>
<li>自定义动画：animate() ;</li>
</ul>
<blockquote>
<p>注意：</p>
<p>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</p>
<p>jQuery为我们提供另一个方法，可以<strong>停止动画排队</strong>：stop() ;</p>
</blockquote>
<h3 id="显示隐藏">显示隐藏</h3>
<p>​	显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;</p>
<p>​	语法规范如下:</p>
<p><strong>1.显示语法规范</strong><br>
show ( [speed, [easing],[fn] ])</p>
<p><strong>2.显示参数</strong><br>
(1)参数都可以省略，无动画直接显示。<br>
(2) speed:三种预定速度之一的字符串(“slow”,“normal&quot;, or“fast”)或表示动画时长的毫秒数值(如:1000)。(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.隐藏语法规范</strong><br>
hide i [speed, [easing] , [fn]])</p>
<p><strong>2.隐藏参数</strong><br>
(1)参数都可以省略，无动画直接显示。</p>
<p>(2) speed:三种预定速度之一的字符串(“slow&quot;,&quot;normal”, or “fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.切换语法规范</strong><br>
togglei( [speed, [easing] , [fn] ])</p>
<p><strong>2.切换参数</strong><br>
(1）参数都可以省略，无动画直接显示。<br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”, or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear&quot;。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。<br>
建议:平时一般不带参数，直接显示隐藏即可。</p>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;button&gt;显示&lt;/button&gt;
    &lt;button&gt;隐藏&lt;/button&gt;
    &lt;button&gt;切换&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            $(&quot;button&quot;).eq(0).click(function() {
                $(&quot;div&quot;).show(1000, function() {
                    alert(1);
                });
            })
            $(&quot;button&quot;).eq(1).click(function() {
                $(&quot;div&quot;).hide(1000, function() {
                    alert(1);
                });
            })
            $(&quot;button&quot;).eq(2).click(function() {
              $(&quot;div&quot;).toggle(1000);
            })
            // 一般情况下，我们都不加参数直接显示隐藏就可以了
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="滑入滑出">滑入滑出</h3>
<p>​	滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ;</p>
<p>​	语法规范如下:</p>
<p><strong>1.下滑效果语法规范</strong><br>
slideDown ( [speed, [easing],[fn] ])</p>
<p><strong>2.下滑效果参数</strong><br>
(1)参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot; normal”,or “fast”)或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.上滑效果语法规范</strong><br>
slideUp i [ speed, [easing] , [fn] ])</p>
<p><strong>2.上滑效果参数</strong><br>
(1)参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串(“slow”,&quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”.<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.滑动切换效果语法规范</strong><br>
slideToggle i [speed, [easing], [fn]])</p>
<p><strong>⒉滑动切换效果参数</strong></p>
<p>(1）参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;button&gt;下拉滑动&lt;/button&gt;
    &lt;button&gt;上拉滑动&lt;/button&gt;
    &lt;button&gt;切换滑动&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            $(&quot;button&quot;).eq(0).click(function() {
                // 下滑动 slideDown()
                $(&quot;div&quot;).slideDown();
            })
            $(&quot;button&quot;).eq(1).click(function() {
                // 上滑动 slideUp()
                $(&quot;div&quot;).slideUp(500);
            })
            $(&quot;button&quot;).eq(2).click(function() {
                // 滑动切换 slideToggle()
                $(&quot;div&quot;).slideToggle(500);
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<blockquote>
<p>小案例：下拉菜单略（详情参看源码）。</p>
</blockquote>
<h3 id="淡入淡出">淡入淡出</h3>
<p>​	淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</p>
<p>​	语法规范如下:</p>
<p><strong>1.淡入效果语法规范</strong><br>
fadeIn ( [speed, [easing] ,[fn] ])</p>
<p><strong>2淡入效果参数</strong><br>
(1）参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串(“slow&quot;,&quot;normal”, or“fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”.<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.淡出效果语法规范</strong><br>
fadeout ( [speed, [easing] , [fn]])</p>
<p><strong>2.淡出效果参数</strong><br>
(1）参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or“fast”)或表示动画时长的毫秒数值(如:1000).(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.淡入淡出切换效果语法规范</strong><br>
fadeToggle ( [speed, [easing] ,[fn]])</p>
<p><strong>2.淡入淡出切换效果参数</strong><br>
(1）参数都可以省略。<br>
(2) speed:三种预定速度之一的字符串( “slow”,&quot;normal”, or“fast”)或表示动画时长的毫秒数值(如: 1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>1.渐进方式调整到指定的不透明度</strong><br>
fadeTo( [ [speed] , opacity, [easing] , [fn]])</p>
<p><strong>2效果参数</strong><br>
(1) opacity透明度必须写，取值0~1之间。<br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot; normal”,or“fast”)或表示动画时长的毫秒数值(如:1000)。必须写(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;button&gt;淡入效果&lt;/button&gt;
    &lt;button&gt;淡出效果&lt;/button&gt;
    &lt;button&gt;淡入淡出切换&lt;/button&gt;
    &lt;button&gt;修改透明度&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            $(&quot;button&quot;).eq(0).click(function() {
                // 淡入 fadeIn()
                $(&quot;div&quot;).fadeIn(1000);
            })
            $(&quot;button&quot;).eq(1).click(function() {
                // 淡出 fadeOut()
                $(&quot;div&quot;).fadeOut(1000);
            })
            $(&quot;button&quot;).eq(2).click(function() {
                // 淡入淡出切换 fadeToggle()
                $(&quot;div&quot;).fadeToggle(1000);
            });
            $(&quot;button&quot;).eq(3).click(function() {
                //  修改透明度 fadeTo() 这个速度和透明度要必须写
                $(&quot;div&quot;).fadeTo(1000, 0.5);
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="自定义动画">自定义动画</h3>
<p>​	自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;</p>
<p>​	语法规范如下:</p>
<p><strong>1.语法</strong><br>
animate (params, [speed] , [easing] , [fn] )<br>
<strong>2参数</strong><br>
<strong>(1) params:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采</strong><br>
<strong>取驼峰命名法borderLeft。其余参数都可以省略。</strong><br>
(2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。<br>
(4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。</p>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;button&gt;动起来&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            $(&quot;button&quot;).click(function() {
                $(&quot;div&quot;).animate({
                    left: 500,
                    top: 300,
                    opacity: .4,
                    width: 500
                }, 500);
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="停止动画排队">停止动画排队</h3>
<p>​	动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</p>
<p>​	停止动画排队的方法为：stop() ;</p>
<ul>
<li>stop() 方法用于停止动画或效果。</li>
<li>stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</li>
</ul>
<p>​        <strong>总结: 每次使用动画之前，先调用 stop() ,在调用动画。</strong></p>
<h3 id="事件切换">事件切换</h3>
<p>​	jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下</p>
<p><strong>语法</strong></p>
<pre><code class="language-javascript">hover([over,]out)     // 其中over和out为两个函数
</code></pre>
<ul>
<li>over:鼠标移到元素上要触发的函数（相当于mouseenter）</li>
<li>out:鼠标移出元素要触发的函数（相当于mouseleave）</li>
<li><strong>如果只写一个函数，则鼠标经过和离开都会触发它</strong></li>
</ul>
<p><strong>hover事件和停止动画排列案例</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;ul class=&quot;nav&quot;&gt;
        &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        $(function() {
            // 鼠标经过
            // $(&quot;.nav&gt;li&quot;).mouseover(function() {
            //     // $(this) jQuery 当前元素  this不要加引号
            //     // show() 显示元素  hide() 隐藏元素
            //     $(this).children(&quot;ul&quot;).slideDown(200);
            // });
            // // 鼠标离开
            // $(&quot;.nav&gt;li&quot;).mouseout(function() {
            //     $(this).children(&quot;ul&quot;).slideUp(200);
            // });
            // 1. 事件切换 hover 就是鼠标经过和离开的复合写法
            // $(&quot;.nav&gt;li&quot;).hover(function() {
            //     $(this).children(&quot;ul&quot;).slideDown(200);
            // }, function() {
            //     $(this).children(&quot;ul&quot;).slideUp(200);
            // });
            // 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数
            $(&quot;.nav&gt;li&quot;).hover(function() {
                // stop 方法必须写到动画的前面
                $(this).children(&quot;ul&quot;).stop().slideToggle();
            });
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="手风琴效果">手风琴效果</h3>
<blockquote>
<p>思路分析:<br>
1.鼠标经过某个小li 有两步操作：<br>
2.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入<br>
3.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出</p>
</blockquote>
<p>​</p>
<pre><code class="language-js">  $(function() {
            // 鼠标经过某个小li 有两步操作：
            $(&quot;.king li&quot;).mouseenter(function() {
                // 1.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入
                $(this).stop().animate({
                    width: 224
                }).find(&quot;.small&quot;).stop().fadeOut().siblings(&quot;.big&quot;).stop().fadeIn();
                // 2.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出
                $(this).siblings(&quot;li&quot;).stop().animate({
                    width: 69
                }).find(&quot;.small&quot;).stop().fadeIn().siblings(&quot;.big&quot;).stop().fadeOut();
            })
        });
</code></pre>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C%E6%80%BB%E7%BB%93.png" alt="总结" loading="lazy"></figure>
<hr>
<h2 id="jquery-属性操作">jQuery 属性操作</h2>
<p>​	jQuery 常用属性操作有三种：prop() / attr() / data() ;</p>
<h3 id="元素固有属性值-prop">元素固有属性值 prop()</h3>
<p>​	所谓元素固有属性就是元素本身自带的属性，比如 <a> 元素里面的 href ，比如 <input> 元素里面的 type。</p>
<p><strong>语法</strong></p>
<p><strong>1.获取属性语法</strong><br>
prop(&quot;属性&quot;&quot;)</p>
<p><strong>2.设置属性语法</strong><br>
prop(&quot;属性&quot;&quot;,&quot;属性值&quot;&quot;)</p>
<p>​	注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p>
<h3 id="元素自定义属性值-attr">元素自定义属性值 attr()</h3>
<p>​	用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。</p>
<p><strong>语法</strong></p>
<p><strong>1.获取属性语法</strong><br>
attr(&quot;届性&quot;)//类似原生getAttribute)</p>
<p><strong>2.设置属性语法</strong><br>
attr(&quot;&quot;属性&quot;&quot;，&quot;属性值&quot;&quot;1/类似原生setAttribute()<br>
该方法也可以获取H5自定义属性</p>
<p>​	注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</p>
<h3 id="数据缓存-data">数据缓存 data()</h3>
<p>​	data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。</p>
<p><strong>语法</strong></p>
<p>1.附加数据语法<br>
data(&quot;name&quot; ,&quot;value&quot;)!/向被选元素附加数据<br>
2获取数据语法<br>
date(&quot;name&quot;&quot;)<br>
//向被选元素获取数据</p>
<p>​	注意：同时，还可以读取 HTML5 自定义属性  data-index ，得到的是数字型。</p>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt;
    &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;
    &lt;span&gt;123&lt;/span&gt;
    &lt;script&gt;
        $(function() {
            //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值
            console.log($(&quot;a&quot;).prop(&quot;href&quot;));
            $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;);
            $(&quot;input&quot;).change(function() {
                console.log($(this).prop(&quot;checked&quot;));
            });
            // console.log($(&quot;div&quot;).prop(&quot;index&quot;));
            // 2. 元素的自定义属性 我们通过 attr()
            console.log($(&quot;div&quot;).attr(&quot;index&quot;));
            $(&quot;div&quot;).attr(&quot;index&quot;, 4);
            console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));
            // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面
            $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;);
            console.log($(&quot;span&quot;).data(&quot;uname&quot;));
            // 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型
            console.log($(&quot;div&quot;).data(&quot;index&quot;));
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="jquery-文本属性值">jQuery 文本属性值</h2>
<p>​	jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</p>
<h3 id="jquery内容文本值">jQuery内容文本值</h3>
<p>​	常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</p>
<p><strong>语法</strong></p>
<p><strong>1.普通元素内容html()（相当于原生innerHTML)</strong><br>
html()<br>
/获取元素的内容<br>
html(&quot;内容&quot;)/设置元素的内容<br>
<strong>2普通元素文本内容 text()(相当与原生innerText)</strong><br>
text()<br>
//获取元素的文本内容<br>
text(&quot;文本内容&quot;&quot;)//设置元素的文本内容<br>
<strong>3.表单的值val()(相当于原生value)</strong><br>
val()<br>
//获取表单的值<br>
val(&quot;内容&quot;)/设置表单的值</p>
<p>​	注意：html() 可识别标签，text() 不识别标签。</p>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;
        &lt;span&gt;我是内容&lt;/span&gt;
    &lt;/div&gt;
    &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt;
    &lt;script&gt;
        // 1. 获取设置元素内容 html()
        console.log($(&quot;div&quot;).html());
        // $(&quot;div&quot;).html(&quot;123&quot;);
        // 2. 获取设置元素文本内容 text()
        console.log($(&quot;div&quot;).text());
        $(&quot;div&quot;).text(&quot;123&quot;);
        // 3. 获取设置表单值 val()
        console.log($(&quot;input&quot;).val());
        $(&quot;input&quot;).val(&quot;123&quot;);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="jquery-元素操作">jQuery 元素操作</h2>
<p>​	jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</p>
<h3 id="遍历元素">遍历元素</h3>
<p>​	jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</p>
<p><strong>语法1</strong><br>
**<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mo>(</mo><mi mathvariant="normal">&quot;</mi><mi>d</mi><mi>i</mi><mi>v</mi><mi mathvariant="normal">&quot;</mi><mo>)</mo><mi mathvariant="normal">.</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mo>(</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mi>o</mi><mi>m</mi><mi>E</mi><mi>l</mi><mi>e</mi><mo>)</mo><mrow><mi>x</mi><mi>x</mi><mi>x</mi><mo separator="true">;</mo></mrow><mo>)</mo><mo>∗</mo><mo>∗</mo><mn>1.</mn><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">遍</mi><mi mathvariant="normal">历</mi><mi mathvariant="normal">匹</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">主</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">用</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">。</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mn>2.</mn><mi mathvariant="normal">里</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">有</mi><mn>2</mn><mi mathvariant="normal">个</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mo>:</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">号</mi><mo separator="true">;</mo><mi>d</mi><mi>e</mi><mi>m</mi><mi>E</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi>j</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mn>3.</mn><mi mathvariant="normal">所</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">想</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>j</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">为</mi><mi>j</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi></mrow><annotation encoding="application/x-tex">.( &quot;div&quot;).each (function (index, domEle) { xxx; })**
1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个
2.里面的回调函数有2个参数: index是每个元素的索引号; demEle是每个DOM元素对象，不是jquery对象
3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault">x</span><span class="mord mathdefault">x</span><span class="mpunct">;</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">遍</span><span class="mord cjk_fallback">历</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">。</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord">2</span><span class="mord">.</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">有</span><span class="mord">2</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord">3</span><span class="mord">.</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">想</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span></span></span></span>(domEle)</p>
<p>​	注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 <strong>DOM 对象</strong>，想要使用 jQuery 方法需要转换。</p>
<p><strong>语法2</strong></p>
<p>​								**<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mo>(</mo><mi>o</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">，</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo separator="true">,</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>)</mo><mrow><mi>x</mi><mi>x</mi><mi>x</mi><mo separator="true">;</mo></mrow><mo>)</mo><mo>∗</mo><mo>∗</mo><mn>1.</mn></mrow><annotation encoding="application/x-tex">.each (object， function (index, element) { xxx; })**
1.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault">x</span><span class="mord mathdefault">x</span><span class="mpunct">;</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord">1</span><span class="mord">.</span></span></span></span>.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象<br>
⒉里面的函数有2个参数: index是每个元素的索引号; element遍历内容</p>
<p>​	注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</p>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）
            var sum = 0;
            var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
            // 1. each() 方法遍历元素 
            $(&quot;div&quot;).each(function(i, domEle) {
                // 回调函数第一个参数一定是索引号  可以自己指定索引号号名称
                // console.log(i);
                // 回调函数第二个参数一定是 dom 元素对象，也是自己命名
                // console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)
                $(domEle).css(&quot;color&quot;, arr[i]);
                sum += parseInt($(domEle).text());
            })
            console.log(sum);
            // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据
            // $.each($(&quot;div&quot;), function(i, ele) {
            //     console.log(i);
            //     console.log(ele);
            // });
            // $.each(arr, function(i, ele) {
            //     console.log(i);
            //     console.log(ele);
            // })
            $.each({
                name: &quot;andy&quot;,
                age: 18
            }, function(i, ele) {
                console.log(i); // 输出的是 name age 属性名
                console.log(ele); // 输出的是 andy  18 属性值
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="创建-添加-删除">创建、添加、删除</h3>
<p>​	jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</p>
<p><strong>语法总和</strong></p>
<p><strong>1.创建</strong><br>
$(&quot;<li></li>&quot;&quot;);<br>
动态的创建了一个<li></p>
<p><strong>2.1.内部添加</strong><br>
element.append(&quot;内容&quot;&quot;)<br>
把内容放入匹配元素内部最后面，类似原生appendChild。<br>
element.prepend(&quot;内容&quot;&quot;)<br>
把内容放入匹配元素内部最前面。</p>
<p><strong>2.2.外部添加</strong><br>
element.after(&quot;内容&quot;&quot;)/把内容放入目标元素后面<br>
element.before(&quot;内容&quot;)l/把内容放入目标元素前面</p>
<p><strong>内部</strong>添加元素，生成之后，它们是<strong>父子</strong>关系。<br>
<strong>外部</strong>添加元素，生成之后，他们是<strong>兄弟</strong>关系。<br>
<strong>3.删除元素</strong><br>
element.remove0 //删除匹配的元素（<strong>本身</strong>)<br>
element.empty0//删除匹配的元素集合中所有的<strong>子节点</strong><br>
element.html(&quot;&quot;)//清空匹配的元素内容<br>
remove删除元素本身。<br>
empt()和htmI(&quot;&quot;)作用等价，都可以删除元素里面的内容，只不过 html还可以设置内容。</p>
<p>​	注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;原先的li&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            // 1. 创建元素
            var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;);
      
            // 2. 添加元素
            // 	2.1 内部添加
            // $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面 
            $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面
            //  2.2 外部添加
            var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;);
            // $(&quot;.test&quot;).after(div);
            $(&quot;.test&quot;).before(div);
      
            // 3. 删除元素
            // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀
            // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子
            $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="购物车">购物车</h2>
<pre><code class="language-js">$(function() {
    // 1. 全选 全不选功能模块
    // 就是把全选按钮（checkall）的状态赋值给 三个小的按钮（j-checkbox）就可以了
    // 事件可以使用change
    $(&quot;.checkall&quot;).change(function() {
        // console.log($(this).prop(&quot;checked&quot;));
        $(&quot;.j-checkbox, .checkall&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;));
        if ($(this).prop(&quot;checked&quot;)) {
            // 让所有的商品添加 check-cart-item 类名
            $(&quot;.cart-item&quot;).addClass(&quot;check-cart-item&quot;);
        } else {
            // check-cart-item 移除
            $(&quot;.cart-item&quot;).removeClass(&quot;check-cart-item&quot;);
        }
    });
    // 2. 如果小复选框被选中的个数等于3 就应该把全选按钮选上，否则全选按钮不选。
    $(&quot;.j-checkbox&quot;).change(function() {
        // if(被选中的小的复选框的个数 === 3) {
        //     就要选中全选按钮
        // } else {
        //     不要选中全选按钮
        // }
        // console.log($(&quot;.j-checkbox:checked&quot;).length);
        // $(&quot;.j-checkbox&quot;).length 这个是所有的小复选框的个数
        if ($(&quot;.j-checkbox:checked&quot;).length === $(&quot;.j-checkbox&quot;).length) {
            $(&quot;.checkall&quot;).prop(&quot;checked&quot;, true);
        } else {
            $(&quot;.checkall&quot;).prop(&quot;checked&quot;, false);
        }
        if ($(this).prop(&quot;checked&quot;)) {
            // 让当前的商品添加 check-cart-item 类名
            $(this).parents(&quot;.cart-item&quot;).addClass(&quot;check-cart-item&quot;);
        } else {
            // check-cart-item 移除
            $(this).parents(&quot;.cart-item&quot;).removeClass(&quot;check-cart-item&quot;);
        }
    });
    // 3. 增减商品数量模块 首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。
    $(&quot;.increment&quot;).click(function() {
        // 得到当前兄弟文本框的值
        var n = $(this).siblings(&quot;.itxt&quot;).val();
        // console.log(n);
        n++;
        $(this).siblings(&quot;.itxt&quot;).val(n);
        // 3. 计算小计模块 根据文本框的值 乘以 当前商品的价格  就是 商品的小计
        // 当前商品的价格 p  
        var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
        // console.log(p);
        p = p.substr(1);
        console.log(p);
        var price = (p * n).toFixed(2);
        // 小计模块 
        // toFixed(2) 可以让我们保留2位小数
        $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + price);
        getSum();
    });
    $(&quot;.decrement&quot;).click(function() {
        // 得到当前兄弟文本框的值
        var n = $(this).siblings(&quot;.itxt&quot;).val();
        if (n == 1) {
            return false;
        }
        // console.log(n);
        n--;
        $(this).siblings(&quot;.itxt&quot;).val(n);
        // var p = $(this).parent().parent().siblings(&quot;.p-price&quot;).html();
        // parents(&quot;.p-num&quot;) 返回指定的祖先元素
        var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
        // console.log(p);
        p = p.substr(1);
        console.log(p);
        // 小计模块 
        $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + (p * n).toFixed(2));
        getSum();
    });
    //  4. 用户修改文本框的值 计算 小计模块  
    $(&quot;.itxt&quot;).change(function() {
        // 先得到文本框的里面的值 乘以 当前商品的单价 
        var n = $(this).val();
        // 当前商品的单价
        var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html();
        // console.log(p);
        p = p.substr(1);
        $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + (p * n).toFixed(2));
        getSum();
    });
    // 5. 计算总计和总额模块
    getSum();

    function getSum() {
        var count = 0; // 计算总件数 
        var money = 0; // 计算总价钱
        $(&quot;.itxt&quot;).each(function(i, ele) {
            count += parseInt($(ele).val());
        });
        $(&quot;.amount-sum em&quot;).text(count);
        $(&quot;.p-sum&quot;).each(function(i, ele) {
            money += parseFloat($(ele).text().substr(1));
        });
        $(&quot;.price-sum em&quot;).text(&quot;￥&quot; + money.toFixed(2));
    }
    // 6. 删除商品模块
    // (1) 商品后面的删除按钮
    $(&quot;.p-action a&quot;).click(function() {
        // 删除的是当前的商品 
        $(this).parents(&quot;.cart-item&quot;).remove();
        getSum();
    });
    // (2) 删除选中的商品
    $(&quot;.remove-batch&quot;).click(function() {
        // 删除的是小的复选框选中的商品
        $(&quot;.j-checkbox:checked&quot;).parents(&quot;.cart-item&quot;).remove();
        getSum();
    });
    // (3) 清空购物车 删除全部商品
    $(&quot;.clear-all&quot;).click(function() {
        $(&quot;.cart-item&quot;).remove();
        getSum();
    })
})
</code></pre>
<h2 id="jquery-尺寸-位置操作">jQuery 尺寸、位置操作</h2>
<p>​	jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</p>
<h3 id="jquery-尺寸操作">jQuery 尺寸操作</h3>
<p>​	 jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5Csize.png" alt="size" loading="lazy"></figure>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            // 1. width() / height() 获取设置元素 width和height大小 
            console.log($(&quot;div&quot;).width());
            // $(&quot;div&quot;).width(300);

            // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小 
            console.log($(&quot;div&quot;).innerWidth());

            // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小 
            console.log($(&quot;div&quot;).outerWidth());

            // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin
            console.log($(&quot;div&quot;).outerWidth(true));
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>​	注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</p>
<h3 id="jquery-位置操作">jQuery 位置操作</h3>
<p>​	jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下:</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5Coffset.png" alt="offset" loading="lazy"></figure>
<p>![position](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\03-jQuery快速开发资料\jQuery_day02\4-笔记\images\position.png)</p>
<p>![scroll](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\03-jQuery快速开发资料\jQuery_day02\4-笔记\images\scroll.png)</p>
<p><strong>代码演示</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
        
    &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt;
    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;
   
    &lt;script&gt;
        $(function() {
            // 1. 获取设置距离文档的位置（偏移） offset
            console.log($(&quot;.son&quot;).offset());
            console.log($(&quot;.son&quot;).offset().top);
            // $(&quot;.son&quot;).offset({
            //     top: 200,
            //     left: 200
            // });
      
            // 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准
            // 这个方法只能获取不能设置偏移
            console.log($(&quot;.son&quot;).position());
            // $(&quot;.son&quot;).position({
            //     top: 200,
            //     left: 200
            // });
      
      		// 3. 被卷去的头部
      		$(document).scrollTop(100);
            // 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()
            // 页面滚动事件
            var boxTop = $(&quot;.container&quot;).offset().top;
            $(window).scroll(function() {
                // console.log(11);
                console.log($(document).scrollTop());
                if ($(document).scrollTop() &gt;= boxTop) {
                    $(&quot;.back&quot;).fadeIn();
                } else {
                    $(&quot;.back&quot;).fadeOut();
                }
            });
            // 返回顶部
            $(&quot;.back&quot;).click(function() {
                // $(document).scrollTop(0);
                $(&quot;body, html&quot;).stop().animate({
                    scrollTop: 0
                });
                // $(document).stop().animate({
                //     scrollTop: 0
                // }); 不能是文档而是 html和body元素做动画
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C%E6%80%BB%E7%BB%932.png" alt="总结" loading="lazy"></figure>
<hr>
<h2 id="jquery-事件注册">jQuery 事件注册</h2>
<p>​	jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</p>
<ul>
<li>优点: 操作简单，且不用担心事件覆盖等问题。</li>
<li>缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</li>
</ul>
<p><strong>语法</strong></p>
<p>语法:<br>
element.事件(function () { })<br>
$ ( &quot;div&quot; ).click (function (){事件处理程序})<br>
其他事件和原生基本一致。<br>
比如mouseover.mouseout、blur、focus、change.keydown、keyup.resize.scroll等</p>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        $(function() {
            // 1. 单个事件注册
            $(&quot;div&quot;).click(function() {
                $(this).css(&quot;background&quot;, &quot;purple&quot;);
            });
            $(&quot;div&quot;).mouseenter(function() {
                $(this).css(&quot;background&quot;, &quot;skyblue&quot;);
            });
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="jquery-事件处理">jQuery 事件处理</h2>
<p>​	因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：</p>
<ul>
<li>on(): 用于事件绑定，目前最好用的事件绑定方法</li>
<li>off(): 事件解绑</li>
<li>trigger() / triggerHandler(): 事件触发</li>
</ul>
<h3 id="事件处理-on-绑定事件">事件处理 on() 绑定事件</h3>
<p>​	因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5Con1.png" alt="on1" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5Con2.png" alt="on2" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5Con3.png" alt="on3" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;ul&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;&lt;/ol&gt;

    &lt;script&gt;
        $(function() {
            // (1) on可以绑定1个或者多个事件处理程序
            // $(&quot;div&quot;).on({
            //     mouseenter: function() {
            //         $(this).css(&quot;background&quot;, &quot;skyblue&quot;);
            //     },
            //     click: function() {
            //         $(this).css(&quot;background&quot;, &quot;purple&quot;);
            //     }
            // });
            $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() {
                $(this).toggleClass(&quot;current&quot;);
            });
  
            // (2) on可以实现事件委托（委派）
            // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li
            // $(&quot;ul li&quot;).click();
            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {
                alert(11);
            });

            // (3) on可以给未来动态创建的元素绑定事件
            $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {
                alert(11);
            })
            var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;);
            $(&quot;ol&quot;).append(li);
        })
    &lt;/script&gt;
&lt;/body&gt;

</code></pre>
<h3 id=""></h3>
<h3 id="事件处理-off-解绑事件">事件处理 off() 解绑事件</h3>
<p>​	当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5Coff.png" alt="off" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;ul&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
        &lt;li&gt;我们都是好孩子&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;我是一个P标签&lt;/p&gt;
	&lt;script&gt;
        $(function() {
  			// 事件绑定
            $(&quot;div&quot;).on({
                click: function() {
                    console.log(&quot;我点击了&quot;);
                },
                mouseover: function() {
                    console.log('我鼠标经过了');
                }
            });
            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() {
                alert(11);
            });
  
            // 1. 事件解绑 off 
            // $(&quot;div&quot;).off();  // 这个是解除了div身上的所有事件
            $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件
            $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;);
  
            // 2. one() 但是它只能触发事件一次
            $(&quot;p&quot;).one(&quot;click&quot;, function() {
                alert(11);
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="事件处理-trigger-自动触发事件">事件处理 trigger() 自动触发事件</h3>
<p>​	有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ;</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5Ct1.png" alt="t1" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5Ct2.png" alt="t2" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;input type=&quot;text&quot;&gt;
      
    &lt;script&gt;
    $(function() {
      // 绑定事件
      $(&quot;div&quot;).on(&quot;click&quot;, function() {
        alert(11);
      });

      // 自动触发事件
      // 1. 元素.事件()
      // $(&quot;div&quot;).click();会触发元素的默认行为
      
      // 2. 元素.trigger(&quot;事件&quot;)
      // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为
      $(&quot;input&quot;).trigger(&quot;focus&quot;);
      
      // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为
      $(&quot;input&quot;).on(&quot;focus&quot;, function() {
        $(this).val(&quot;你好吗&quot;);
      });
      // 一个会获取焦点，一个不会
      $(&quot;div&quot;).triggerHandler(&quot;click&quot;);
      // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);
    });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="jquery-事件对象">jQuery 事件对象</h2>
<p>​	jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5Cevent.png" alt="event" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;

	&lt;script&gt;
        $(function() {
            $(document).on(&quot;click&quot;, function() {
                console.log(&quot;点击了document&quot;);
            })
            $(&quot;div&quot;).on(&quot;click&quot;, function(event) {
                // console.log(event);
                console.log(&quot;点击了div&quot;);
                event.stopPropagation();
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</p>
<h2 id="jquery-拷贝对象">jQuery 拷贝对象</h2>
<p>​	jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5Cextend.png" alt="extend" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript"> &lt;script&gt;
        $(function() {
   			// 1.合并数据
            var targetObj = {};
            var obj = {
                id: 1,
                name: &quot;andy&quot;
            };
            // $.extend(target, obj);
            $.extend(targetObj, obj);
            console.log(targetObj);
   
   			// 2. 会覆盖 targetObj 里面原来的数据
            var targetObj = {
                id: 0
            };
            var obj = {
                id: 1,
                name: &quot;andy&quot;
            };
            // $.extend(target, obj);
            $.extend(targetObj, obj);
            console.log(targetObj); 
        })
    &lt;/script&gt;
</code></pre>
<h2 id="jquery-多库共存">jQuery 多库共存</h2>
<p>​	实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</p>
<p><strong>语法</strong></p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5Cnoconfig.png" alt="noconfig" loading="lazy"></figure>
<p><strong>演示代码</strong></p>
<pre><code class="language-javascript">&lt;script&gt;
	$(function() {
  		// 让jquery 释放对$ 控制权 让用自己决定
  		var suibian = jQuery.noConflict();
  		console.log(suibian(&quot;span&quot;));
	})
&lt;/script&gt;
</code></pre>
<h2 id="jquery-插件">jQuery 插件</h2>
<p>​	jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</p>
<p>jQuery文件，因此也称为 jQuery 插件。</p>
<p>​	jQuery 插件常用的网站：</p>
<ol>
<li>
<p>jQuery 插件库  http://www.jq22.com/</p>
</li>
<li>
<p>jQuery 之家   http://www.htmleaf.com/</p>
<p>jQuery 插件使用步骤：</p>
</li>
<li>
<p>引入相关文件。（jQuery 文件 和 插件文件）</p>
</li>
<li>
<p>复制相关html、css、js (调用插件)。</p>
</li>
</ol>
<h3 id="瀑布流插件重点">瀑布流插件（重点）</h3>
<p>​	我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</p>
<p><strong>代码演示</strong></p>
<p>​	插件的使用三点：   1. 引入css.           2.引入JS            3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js）</p>
<ul>
<li>1.引入css.</li>
</ul>
<pre><code class="language-javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt;
  
&lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;
&lt;style type=&quot;text/css&quot;&gt;
  #gallery-wrapper {
    position: relative;
    max-width: 75%;
    width: 75%;
    margin: 50px auto;
  }

  img.thumb {
    width: 100%;
    max-width: 100%;
    height: auto;
  }

  .white-panel {
    position: absolute;
    background: white;
    border-radius: 5px;
    box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);
    padding: 10px;
  }

  .white-panel h1 {
    font-size: 1em;
  }

  .white-panel h1 a {
    color: #A92733;
  }

  .white-panel:hover {
    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);
    margin-top: -5px;
    -webkit-transition: all 0.3s ease-in-out;
    -moz-transition: all 0.3s ease-in-out;
    -o-transition: all 0.3s ease-in-out;
    transition: all 0.3s ease-in-out;
  }
&lt;/style&gt;
</code></pre>
<ul>
<li>2.引入js.</li>
</ul>
<pre><code class="language-javascript">&lt;!-- 前两个必须引入 --&gt;
&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt;
&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	$(function() {
      $(&quot;#gallery-wrapper&quot;).pinterest_grid({
          no_columns: 5,
          padding_x: 15,
          padding_y: 10,
          margin_bottom: 50,
          single_column_breakpoint: 700
      });
	});
&lt;/script&gt;
</code></pre>
<ul>
<li>3.引入html.</li>
</ul>
<pre><code class="language-javascript">	&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;
	&lt;section id=&quot;gallery-wrapper&quot;&gt;
        &lt;article class=&quot;white-panel&quot;&gt;
            &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;
            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;
            &lt;p&gt;里面很精彩哦&lt;/p&gt;
        &lt;/article&gt;
        &lt;article class=&quot;white-panel&quot;&gt;
            &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;
            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;
            &lt;p&gt;里面很精彩哦&lt;/p&gt;
        &lt;/article&gt;
        &lt;article class=&quot;white-panel&quot;&gt;
            &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;
            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;
            &lt;p&gt;里面很精彩哦&lt;/p&gt;
        &lt;/article&gt;
        &lt;article class=&quot;white-panel&quot;&gt;
            &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;
            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;
            &lt;p&gt;里面很精彩哦&lt;/p&gt;
        &lt;/article&gt;
    &lt;/section&gt;
</code></pre>
<p>总结：jQuery插件就是引入别人写好的：html 、css、js  （有时也可以只引入一部分，读懂后也可以修改部分内容）</p>
<h3 id="图片懒加载插件">图片懒加载插件</h3>
<p>​	图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）</p>
<p><strong>代码演示</strong></p>
<p>​	懒加载只需引入html 和 js操作 即可，此插件不涉及css。</p>
<ul>
<li>1.引入js</li>
</ul>
<pre><code class="language-javascript">&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
   	lazyLoadInit({
   		showTime: 1100,
   		onLoadBackEnd: function(i, e) {
     		console.log(&quot;onLoadBackEnd:&quot; + i);
   		},
   		onLoadBackStart: function(i, e) {
     		console.log(&quot;onLoadBackStart:&quot; + i);
   		}
 	});
&lt;/script&gt;
</code></pre>
<ul>
<li>2.引入html</li>
</ul>
<pre><code class="language-javascript"> &lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt;
</code></pre>
<h3 id="全屏滚动插件">全屏滚动插件</h3>
<p>​	全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</p>
<p>http://www.dowebok.com/demo/2014/77/</p>
<p><strong>代码演示</strong></p>
<p>​	全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际</p>
<p>项目需要使用哪种风格引入对应的HTML和CSS。</p>
<pre><code class="language-javascript">&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  	$(function() {
  		$('#dowebok').fullpage({
    		sectionsColor: ['pink', '#4BBFC3', '#7BAABE', '#f90'],
    		navigation: true
  		});
	});
&lt;/script&gt;
</code></pre>
<p>注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</p>
<h3 id="bootstrap组件">bootstrap组件</h3>
<p>​	Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</p>
<p>布局，使得 Web 开发更加方便快捷。</p>
<p>​	<strong>凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</strong>。Bootstrap组件使</p>
<p>用非常方便:  1.引入bootstrap相关css和js        2.去官网复制html</p>
<p><strong>代码演示</strong></p>
<ol>
<li>引入bootstrap相关css和js</li>
</ol>
<pre><code class="language-javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;
&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>去官网复制html的功能模块</li>
</ol>
<pre><code class="language-javascript">    &lt;div class=&quot;container&quot;&gt;
        &lt;!-- Single button --&gt;
        &lt;div class=&quot;btn-group&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;
      		Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
    		&lt;/button&gt;
            &lt;ul class=&quot;dropdown-menu&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;
                &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
     	&lt;/div&gt;
	&lt;/div&gt;
</code></pre>
<h3 id="bootstrap插件js">bootstrap插件（JS）</h3>
<p>​	bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以</p>
<p>省略js，用属性实现）。</p>
<p>​	步骤： 1.引入bootstrap相关css和js        2.去官网复制html        3.复制js代码，启动js插件。</p>
<p><strong>代码演示</strong></p>
<ol>
<li>引入bootstrap相关css和js</li>
</ol>
<pre><code class="language-javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;
&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>去官网复制html的功能模块</li>
</ol>
<pre><code class="language-javascript">&lt;!-- 模态框 --&gt;
&lt;!-- Large modal --&gt;
&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt;
&lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt;
        &lt;div class=&quot;modal-content&quot;&gt;
            里面就是模态框
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ol start="3">
<li>复制js代码，启动js插件。</li>
</ol>
<pre><code class="language-javascript">&lt;script&gt;
	// 当我们点击了自己定义的按钮，就弹出模态框
	$(&quot;.myBtn&quot;).on(&quot;click&quot;, function() {
		// alert(11);
		$('#btn').modal()
	})
&lt;/script&gt;

</code></pre>
<h3 id="bootstrap案例-阿里百秀">bootstrap案例-阿里百秀</h3>
<blockquote>
<p>1.通过调用组件实现导航栏<br>
2.通过调用插件实现登录<br>
3.通过调用插件标签页实现 tab 栏</p>
</blockquote>
<p>​	代码实现略。(详情参考源代码)</p>
<h2 id="todolist案例分析">toDoList案例分析</h2>
<h3 id="案例介绍">案例介绍</h3>
<pre><code class="language-javascript">// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。
// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。
// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。
// 4. 但是本页面内容刷新页面不会丢失。
</code></pre>
<h3 id="todolist-分析">toDoList 分析</h3>
<pre><code class="language-javascript">// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage
// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据
// 3. 存储的数据格式：var todolist =  [{ title : ‘xxx’, done: false}]
// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。
// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。
</code></pre>
<h3 id="todolist-按下回车把新数据添加到本地存储里面">toDoList 按下回车把新数据添加到本地存储里面</h3>
<pre><code class="language-javascript">// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。
// 2.利用事件对象.keyCode判断用户按下回车键（13）。
// 3.声明一个数组，保存数据。
// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。
// 5.之后把最新从表单获取过来的数据，追加到数组里面。
// 6.最后把数组存储给本地存储 (声明函数 savaDate())
</code></pre>
<h3 id="todolist-本地存储数据渲染加载到页面">toDoList 本地存储数据渲染加载到页面</h3>
<pre><code class="language-javascript">// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用
// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）
// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。
// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。
</code></pre>
<h3 id="todolist-删除操作">toDoList 删除操作</h3>
<pre><code class="language-javascript">// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。
// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li
// 3.我们可以给链接自定义属性记录当前的索引号
// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法
// 5.存储修改后的数据，然后存储给本地存储
// 6.重新渲染加载数据列表
// 7.因为a是动态创建的，我们使用on方法绑定事件
</code></pre>
<h3 id="todolist-正在进行和已完成选项操作">toDoList  正在进行和已完成选项操作</h3>
<pre><code class="language-javascript">// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。
// 2.点击之后，获取本地存储数据。
// 3.修改对应数据属性 done 为当前复选框的checked状态。
// 4.之后保存数据到本地存储
// 5.重新渲染加载数据列表
// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面
// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面
</code></pre>
<h3 id="todolist-统计正在进行个数和已经完成个数">toDoList 统计正在进行个数和已经完成个数</h3>
<pre><code class="language-javascript">// 1.在我们load 函数里面操作
// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数   
// 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++
// 4.最后修改相应的元素 text() 
</code></pre>
<pre><code class="language-js">$(function() {
    // alert(11);
    // 1. 按下回车 把完整数据 存储到本地存储里面
    // 存储的数据格式  var todolist = [{title: &quot;xxx&quot;, done: false}]
    load();
    $(&quot;#title&quot;).on(&quot;keydown&quot;, function(event) {
        if (event.keyCode === 13) {
            if ($(this).val() === &quot;&quot;) {
                alert(&quot;请输入您要的操作&quot;);
            } else {
                // 先读取本地存储原来的数据
                var local = getDate();
                // console.log(local);
                // 把local数组进行更新数据 把最新的数据追加给local数组
                local.push({ title: $(this).val(), done: false });
                // 把这个数组local 存储给本地存储
                saveDate(local);
                // 2. toDoList 本地存储数据渲染加载到页面
                load();
                $(this).val(&quot;&quot;);
            }
        }
    });
    // 3. toDoList 删除操作
    $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function() {
        // alert(11);
        // 先获取本地存储
        var data = getDate();
        console.log(data);
        // 修改数据
        var index = $(this).attr(&quot;id&quot;);
        console.log(index);
        data.splice(index, 1);
        // 保存到本地存储
        saveDate(data);
        // 重新渲染页面
        load();
    });
    // 4. toDoList 正在进行和已完成选项操作
    $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;input&quot;, function() {
        // alert(11);
        // 先获取本地存储的数据
        var data = getDate();
        // 修改数据
        var index = $(this).siblings(&quot;a&quot;).attr(&quot;id&quot;);
        console.log(index);
        // data[?].done = ?
        data[index].done = $(this).prop(&quot;checked&quot;);
        console.log(data);

        // 保存到本地存储
        saveDate(data);
        // 重新渲染页面
        load();
    });
    // 读取本地存储的数据 
    function getDate() {
        var data = localStorage.getItem(&quot;todolist&quot;);
        if (data !== null) {
            // 本地存储里面的数据是字符串格式的 但是我们需要的是对象格式的
            return JSON.parse(data);
        } else {
            return [];
        }
    }
    // 保存本地存储数据
    function saveDate(data) {
        localStorage.setItem(&quot;todolist&quot;, JSON.stringify(data));
    }
    // 渲染加载数据
    function load() {
        // 读取本地存储的数据
        var data = getDate();
        console.log(data);
        // 遍历之前先要清空ol里面的元素内容
        $(&quot;ol, ul&quot;).empty();
        var todoCount = 0; // 正在进行的个数
        var doneCount = 0; // 已经完成的个数
        // 遍历这个数据
        $.each(data, function(i, n) {
            // console.log(n);
            if (n.done) {
                $(&quot;ul&quot;).prepend(&quot;&lt;li&gt;&lt;input type='checkbox' checked='checked' &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href='javascript:;' id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;);
                doneCount++;
            } else {
                $(&quot;ol&quot;).prepend(&quot;&lt;li&gt;&lt;input type='checkbox' &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href='javascript:;' id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;);
                todoCount++;
            }

        });
        $(&quot;#todocount&quot;).text(todoCount);
        $(&quot;#donecount&quot;).text(doneCount);

    }

})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebAPIs]]></title>
        <id>https://xmweijh.github.io/post/webapis/</id>
        <link href="https://xmweijh.github.io/post/webapis/">
        </link>
        <updated>2021-02-18T13:50:45.000Z</updated>
        <content type="html"><![CDATA[<p>Web API</p>
<p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</p>
<p>Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p>
<p>​	MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API</p>
<h2 id="dom">DOM</h2>
<p>文档对象模型（Document Object Model，简称DOM），是 <a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p>
<p>​	W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p>
<blockquote>
<p>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</p>
</blockquote>
<h3 id="获取元素">获取元素</h3>
<h3 id="根据id获取">根据ID获取</h3>
<pre><code class="language-js">语法：document.getElementById(id)
作用：根据ID获取元素对象
参数：id值，区分大小写的字符串
返回值：元素对象 或 null
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;
    &lt;script&gt;
        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
        var timer = document.getElementById('time');
        console.log(timer);
        console.log(typeof timer);
        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法
        console.dir(timer);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="根据标签名获取元素">根据标签名获取元素</h3>
<pre><code>语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') 
作用：根据标签名获取元素对象
参数：标签名
返回值：元素对象集合（伪数组，数组元素是元素对象）
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul id=&quot;nav&quot;&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的
        var lis = document.getElementsByTagName('li');
        console.log(lis);
        console.log(lis[0]);
        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式
        for (var i = 0; i &lt; lis.length; i++) {
            console.log(lis[i]);
        }
        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签
        var nav = document.getElementById('nav'); // 这个获得nav 元素
        var navLis = nav.getElementsByTagName('li');
        console.log(navLis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>注意:<br>
1．因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。<br>
2.得到元素对象是动态的</p>
<p>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</p>
<h3 id="h5新增获取元素方式">H5新增获取元素方式</h3>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C1550733518278.png" alt="1550733518278" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1550733734425.png" alt="1550733734425" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;首页&lt;/li&gt;
            &lt;li&gt;产品&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. getElementsByClassName 根据类名获得某些元素集合
        var boxs = document.getElementsByClassName('box');
        console.log(boxs);
        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav
        var firstBox = document.querySelector('.box');
        console.log(firstBox);
        var nav = document.querySelector('#nav');
        console.log(nav);
        var li = document.querySelector('li');
        console.log(li);
        // 3. querySelectorAll()返回指定选择器的所有元素对象集合
        var allBox = document.querySelectorAll('.box');
        console.log(allBox);
        var lis = document.querySelectorAll('li');
        console.log(lis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="获取特殊元素bodyhtml">获取特殊元素（body，html）</h3>
<p><strong>获取body元素</strong></p>
<p>doucumnet.body 	返回body元素对象</p>
<p><strong>获取html元素</strong></p>
<p>document.documentElement 		返回html元素对象</p>
<pre><code class="language-js">		// 1.获取body 元素
        var bodyEle = document.body;
        console.log(bodyEle);
        console.dir(bodyEle);
        // 2.获取html 元素
        var htmlEle = document.documentElement;
        console.log(htmlEle);
</code></pre>
<h2 id="事件基础">事件基础</h2>
<h3 id="事件概述">事件概述</h3>
<p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解： <strong>触发--- 响应机制</strong>。</p>
<p>​	网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>
<h3 id="事件三要素">事件三要素</h3>
<ul>
<li>事件源（谁）：触发事件的元素</li>
<li>事件类型（什么事件）： 例如 click 点击事件</li>
<li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li>
</ul>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;
    &lt;script&gt;
        // 点击一个按钮，弹出对话框
        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素
        //(1) 事件源 事件被触发的对象   谁  按钮
        var btn = document.getElementById('btn');
        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
        //(3) 事件处理程序  通过一个函数赋值的方式 完成
        btn.onclick = function() {
            alert('点秋香');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="执行事件的步骤">执行事件的步骤</h3>
<p>1.获取事件源<br>
2.注册事件（绑定事件)<br>
3.添加事件处理程序(采取函数赋值形式)</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        // 执行事件步骤
        // 点击div 控制台输出 我被选中了
        // 1. 获取事件源
        var div = document.querySelector('div');
        // 2.绑定事件 注册事件
        // div.onclick 
        // 3.添加事件处理程序 
        div.onclick = function() {
            console.log('我被选中了');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="常见的鼠标事件">常见的鼠标事件</h3>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5C1550734506084.png" alt="1550734506084" loading="lazy"></figure>
<h2 id="操作元素">操作元素</h2>
<p>​	JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p>
<h3 id="改变元素内容获取或设置">改变元素内容（获取或设置）</h3>
<p>element.innerText<br>
从起始位置到终止位置的内容,但它去除html标签，同时空格和换行也会去掉<br>
element.innerHTML<br>
起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p>
<p><strong>innerText改变元素内容</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;显示当前系统时间&lt;/button&gt;
    &lt;div&gt;某个时间&lt;/div&gt;
    &lt;p&gt;1123&lt;/p&gt;
    &lt;script&gt;
        // 当我们点击了按钮，  div里面的文字会发生变化
        // 1. 获取元素 
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function() {
            // div.innerText = '2019-6-6';
            div.innerHTML = getDate();
        }
        function getDate() {
            var date = new Date();
            // 我们写一个 2019年 5月 1日 星期三
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var dates = date.getDate();
            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            var day = date.getDay();
            return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day];
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><strong>innerText和innerHTML的区别</strong></p>
<ul>
<li>获取内容时的区别：</li>
</ul>
<p>​	innerText会去除空格和换行，而innerHTML会保留空格和换行</p>
<ul>
<li>设置内容时的区别：</li>
</ul>
<p>​	innerText不会识别html，而innerHTML会识别</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;p&gt;
        我是文字
        &lt;span&gt;123&lt;/span&gt;
    &lt;/p&gt;
    &lt;script&gt;
        // innerText 和 innerHTML的区别 
        // 1. innerText 不识别html标签 非标准  去除空格和换行
        var div = document.querySelector('div');
        // div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的
        div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 这两个属性是可读写的  可以获取元素里面的内容
        var p = document.querySelector('p');
        console.log(p.innerText);
        console.log(p.innerHTML);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="常用元素的属性操作">常用元素的属性操作</h3>
<ol>
<li>innerText、 innerHTML改变元素内容</li>
<li>src、href</li>
<li>id、 alt、 title</li>
</ol>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;
    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;
    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;
    &lt;script&gt;
        // 修改元素属性  src
        // 1. 获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');
        // 2. 注册事件  处理程序
        zxy.onclick = function() {
            img.src = 'images/zxy.jpg';
            img.title = '张学友思密达';
        }
        ldh.onclick = function() {
            img.src = 'images/ldh.jpg';
            img.title = '刘德华';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="表单元素的属性操作">表单元素的属性操作</h3>
<p>type、 value、 checked、 selected、 disabled</p>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
<p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;按钮&lt;/button&gt;
    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2. 注册事件 处理程序
        btn.onclick = function() {
            // 表单里面的值 文字内容是通过 value 来修改的
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 btn
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="样式属性操作">样式属性操作</h3>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<p><strong>常用方式</strong></p>
<ol>
<li>element.style<br>
行内样式操作</li>
<li>element.className类名样式操作</li>
</ol>
<h4 id="方式1通过操作style属性">方式1：通过操作style属性</h4>
<blockquote>
<p>元素对象的style属性也是一个对象！</p>
<p>元素对象.style.样式属性 = 值;</p>
</blockquote>
<p>注意:<br>
l.JS里面的样式采取驼峰命名法比如fontSize、backgroundcolor<br>
2.JS修改style样式操作，产生的是行内样式,css权重比较高</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素
        var div = document.querySelector('div');
        // 2. 注册事件 处理程序
        div.onclick = function() {
            // div.style里面的属性 采取驼峰命名法 
            this.style.backgroundColor = 'purple';
            this.style.width = '250px';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="方式2通过操作classname属性">方式2：通过操作className属性</h4>
<blockquote>
<p>元素对象.className = 值;</p>
<p>因为class是关键字，所有使用className。</p>
</blockquote>
<p>注意:<br>
1．如果样式修改较多，可以采取操作类名方式更改元素样式。</p>
<ol start="2">
<li>class因为是个保留字，因此使用className来操作元素类名属性</li>
<li>className会直接更改元素的类名，会覆盖原先的类名。</li>
</ol>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;
    &lt;script&gt;
        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
        var test = document.querySelector('div');
        test.onclick = function() {
            // this.style.backgroundColor = 'purple';
            // this.style.color = '#fff';
            // this.style.fontSize = '25px';
            // this.style.marginTop = '100px';

            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
            // this.className = 'change';
            this.className = 'first change';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C1550737354861.png" alt="1550737354861" loading="lazy"></figure>
<h2 id="排他操作">排他操作</h2>
<h3 id="排他思想">排他思想</h3>
<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：</p>
<ol>
<li>
<p>所有元素全部清除样式（干掉其他人）</p>
</li>
<li>
<p>给当前元素设置样式 （留下我自己）</p>
</li>
<li>
<p>注意顺序不能颠倒，首先干掉其他人，再设置自己</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;按钮1&lt;/button&gt;
    &lt;button&gt;按钮2&lt;/button&gt;
    &lt;button&gt;按钮3&lt;/button&gt;
    &lt;button&gt;按钮4&lt;/button&gt;
    &lt;button&gt;按钮5&lt;/button&gt;
    &lt;script&gt;
        // 1. 获取所有按钮元素
        var btns = document.getElementsByTagName('button');
        // btns得到的是伪数组  里面的每一个元素 btns[i]
        for (var i = 0; i &lt; btns.length; i++) {
            btns[i].onclick = function() {
                // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人
                for (var i = 0; i &lt; btns.length; i++) {
                    btns[i].style.backgroundColor = '';
                }
                // (2) 然后才让当前的元素背景颜色为pink 留下我自己
                this.style.backgroundColor = 'pink';

            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="换肤">换肤</h2>
<pre><code class="language-js">&lt;body&gt;
    &lt;ul class=&quot;baidu&quot;&gt;
        &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素 
        var imgs = document.querySelector('.baidu').querySelectorAll('img');
        // console.log(imgs);
        // 2. 循环注册事件 
        for (var i = 0; i &lt; imgs.length; i++) {
            imgs[i].onclick = function() {
                // this.src 就是我们点击图片的路径   images/2.jpg
                // console.log(this.src);
                // 把这个路径 this.src 给body 就可以了
                document.body.style.backgroundImage = 'url(' + this.src + ')';
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="表格隔行变色">表格隔行变色</h2>
<pre><code class="language-js">    &lt;script&gt;
        // 1.获取元素 获取的是 tbody 里面所有的行
        var trs = document.querySelector('tbody').querySelectorAll('tr');
        // 2. 利用循环绑定注册事件
        for (var i = 0; i &lt; trs.length; i++) {
            // 3. 鼠标经过事件 onmouseover
            trs[i].onmouseover = function() {
                    // console.log(11);
                    this.className = 'bg';
                }
                // 4. 鼠标离开事件 onmouseout
            trs[i].onmouseout = function() {
                this.className = '';
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="全选">全选</h2>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        
        var j_cbAll = document.getElementById('j_cbAll'); 
        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); 
        // 全选按钮注册事件
        j_cbAll.onclick = function() {
                // this.checked 当前复选框的选中状态
                console.log(this.checked);
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    j_tbs[i].checked = this.checked;
                }
         }
         // 给所有的子复选框注册单击事件
        for (var i = 0; i &lt; j_tbs.length; i++) {
            j_tbs[i].onclick = function() {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    if (!j_tbs[i].checked) {
                        flag = false;
                        break; 
                    }
                }
                // 设置全选按钮的状态
                j_cbAll.checked = flag;
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="自定义属性操作">自定义属性操作</h2>
<h3 id="获取属性值">获取属性值</h3>
<p>element.属性获取属性值。<br>
element.getAttribute(属性);<br>
区别:<br>
element.属性获取内置属性值(元素本身自带的属性)<br>
element.getAttribute ( '属性');主要获得自定义的属性(标准)我们程序员自定义的屋性</p>
<pre><code class="language-js">    &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
	&lt;/script&gt;
</code></pre>
<h3 id="设置属性值">设置属性值</h3>
<p>element.属性=‘值’设置内置属性值。<br>
element.setAttribute('属性'，&quot;值');<br>
区别:<br>
element.属性设置内置属性值<br>
element.setAttribute(属性');主要设置自定义的属性(标准)</p>
<pre><code class="language-js">        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是
</code></pre>
<h3 id="移出属性">移出属性</h3>
<p>element.removeAttribute ('属性');</p>
<pre><code class="language-js">		// class 不是className
        // 3 移除属性 removeAttribute(属性)    
        div.removeAttribute('index');
</code></pre>
<h3 id="tab栏">tab栏</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 获取元素
        var tab_list = document.querySelector('.tab_list');
        var lis = tab_list.querySelectorAll('li');
        var items = document.querySelectorAll('.item');
        // for循环，给选项卡绑定点击事件
        for (var i = 0; i &lt; lis.length; i++) {
            // 开始给5个小li 设置索引号 
            lis[i].setAttribute('index', i);
            lis[i].onclick = function() {
                // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）
                // 干掉所有人 其余的li清除 class 这个类
                for (var i = 0; i &lt; lis.length; i++) {
                    lis[i].className = '';
                }
                // 留下我自己 
                this.className = 'current';
                // 2. 下面的显示内容模块
                var index = this.getAttribute('index');
                console.log(index);
                // 干掉所有人 让其余的item 这些div 隐藏
                for (var i = 0; i &lt; items.length; i++) {
                    items[i].style.display = 'none';
                }
                // 留下我自己 让对应的item 显示出来
                items[index].style.display = 'block';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="h5自定义属性">H5自定义属性</h3>
<p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</p>
<p>自定义属性获取是通过getAttribute(‘属性’) 获取。</p>
<p>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</p>
<p>H5给我们新增了自定义属性：</p>
<p>1.设置H5自定义属性<br>
H5规定自定义属性data-开头做为属性名并且赋值。比如&lt;div data-index= &quot;1” &gt;</div><br>
或者使用JS设置<br>
element.setAttribute( 'data-index’,2)<br>
⒉获取H5自定义属性<br>
1．兼容性获取element.getAttribute( 'data-index');<br>
2、H5新增element.datasetindex或者element.dataset['index’ ] ie 11才开始支持</p>
<pre><code class="language-js">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // console.log(div.getTime);
        console.log(div.getAttribute('getTime'));
        div.setAttribute('data-time', 20);
        console.log(div.getAttribute('data-index'));
        console.log(div.getAttribute('data-list-name'));
        // h5新增的获取自定义属性的方法 它只能获取data-开头的
        // dataset 是一个集合里面存放了所有以data开头的自定义属性
        console.log(div.dataset);
        console.log(div.dataset.index);
        console.log(div.dataset['index']);
        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法
        console.log(div.dataset.listName);
        console.log(div.dataset['listName']);
    &lt;/script&gt;
</code></pre>
<h2 id="节点操作">节点操作</h2>
<h3 id="节点概述">节点概述</h3>
<p>​	网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p>
<p>​	HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5C1550970944363.png" alt="1550970944363" loading="lazy"></figure>
<p>​	一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p>
<p>元素节点nodeType 为1<br>
星性节点nodeType 为2<br>
文本节点nodeType 为3(文本节点包含文字、空格、换行等)<br>
我们在实际开发中，节点操作主要操作的是元素节点</p>
<h3 id="节点层级">节点层级</h3>
<p>​	利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p>
<p>​</p>
<h3 id="父级节点">父级节点</h3>
<p>node. parentNode<br>
parentNode属性可返回某节点的父节点，注意是最近的一个父节点<br>
如果指定的节点没有父节点则返回null</p>
<pre><code class="language-js">    &lt;div class=&quot;demo&quot;&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
        console.log(erweima.parentNode);
    &lt;/script&gt;
</code></pre>
<h3 id="子节点">子节点</h3>
<p><strong>所有子节点</strong></p>
<p>parentNode.childNodes(标准)<br>
parentNode.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。注意:返回值里面包含了所有的子节点，包括元素节点，文本节点等。<br>
如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</p>
<p><strong>子元素节点</strong></p>
<ol start="2">
<li>parentNode.children(非标准)<br>
parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(这个是我们重点掌握的)。<br>
虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用</li>
</ol>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // DOM 提供的方法（API）获取
        var ul = document.querySelector('ul');
        var lis = ul.querySelectorAll('li');
        // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
        console.log(ul.childNodes);
        console.log(ul.childNodes[0].nodeType);
        console.log(ul.childNodes[1].nodeType);
        // 2. children 获取所有的子元素节点 也是我们实际开发常用的
        console.log(ul.children);
    &lt;/script&gt;
</code></pre>
<p><strong>第1个子节点</strong></p>
<p>parentNode.firstChild<br>
firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<p><strong>最后1个子节点</strong></p>
<p>parentNode . lastChild<br>
lastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<p><strong>第1个子元素节点</strong></p>
<p>parentNode.firstElementChild<br>
firstElementchild返回第一个子元素节点，找不到则返回null。</p>
<p><strong>最后1个子元素节点</strong></p>
<p>parentNode . lastElementChild<br>
lastElementchild返回最后一个子元素节点，找不到则返回null。<br>
注意:这两个方法有兼容性问题，IE9以上才支持。</p>
<p>​	实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p>
<p>解决方案:<br>
1．如果想要第一个子元素节点，可以使用naxen太Nda.shildren.[0]<br>
2．如果想要最后一个子元素节点，可以使用parentModa.chi.ldrenlpaxentNode ..chil.dren.length - 1]</p>
<pre><code class="language-js">    &lt;ol&gt;
        &lt;li&gt;我是li1&lt;/li&gt;
        &lt;li&gt;我是li2&lt;/li&gt;
        &lt;li&gt;我是li3&lt;/li&gt;
        &lt;li&gt;我是li4&lt;/li&gt;
        &lt;li&gt;我是li5&lt;/li&gt;
    &lt;/ol&gt;
    &lt;script&gt;
        var ol = document.querySelector('ol');
        // 1. firstChild 第一个子节点 不管是文本节点还是元素节点
        console.log(ol.firstChild);
        console.log(ol.lastChild);
        // 2. firstElementChild 返回第一个子元素节点 ie9才支持
        console.log(ol.firstElementChild);
        console.log(ol.lastElementChild);
        // 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        console.log(ol.children[ol.children.length - 1]);
    &lt;/script&gt;
</code></pre>
<h3 id="下拉菜单">下拉菜单</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 获取元素
        var nav = document.querySelector('.nav');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i &lt; lis.length; i++) {
            lis[i].onmouseover = function() {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function() {
                this.children[1].style.display = 'none';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="兄弟节点">兄弟节点</h3>
<pre><code class="language-js">    &lt;div&gt;我是div&lt;/div&gt;
    &lt;span&gt;我是span&lt;/span&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
        console.log(div.nextSibling);
        console.log(div.previousSibling);
        // 2. nextElementSibling 得到下一个兄弟元素节点
        console.log(div.nextElementSibling);
        console.log(div.previousElementSibling);
    &lt;/script&gt;
</code></pre>
<pre><code class="language-js">   function getNextElementSibling(element) {
      var el = element;
      while (el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
      }
      return null;
    }  
</code></pre>
<h3 id="创建节点">创建节点</h3>
<p>document.createElement ( 'tagName &quot; )<br>
document.createElement()方法创建由tagName指定的HTMr元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。</p>
<h3 id="添加节点">添加节点</h3>
<p>node.appendchild(child)<br>
node.appendchild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于css里面的after伪元素。</p>
<p>node.insertBefore(child，指定元素)<br>
node.insertBefore()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的 before伪元素。</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;123&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 创建节点元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    &lt;/script&gt;
</code></pre>
<h3 id="简单版发布留言">简单版发布留言</h3>
<pre><code class="language-js">&lt;body&gt;
    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="节点操作-2">节点操作</h2>
<h3 id="删除节点">删除节点</h3>
<p>node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</p>
<pre><code class="language-js">    &lt;button&gt;删除&lt;/button&gt;
    &lt;ul&gt;
        &lt;li&gt;熊大&lt;/li&gt;
        &lt;li&gt;熊二&lt;/li&gt;
        &lt;li&gt;光头强&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素  node.removeChild(child)
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮依次删除里面的孩子
        btn.onclick = function() {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="删除留言">删除留言</h3>
<pre><code class="language-js">    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li  它的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i &lt; as.length; i++) {
                    as[i].onclick = function() {
                        // 删除的是 li 当前a所在的li  this.parentNode;
                        ul.removeChild(this.parentNode);
                    }
                }
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="复制克隆节点">复制（克隆）节点</h3>
<p>node.cloneNode ( )<br>
node.cloneNode()方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点<br>
注意:<br>
1.如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。<br>
⒉如果括号参数为true，则是深度拷贝，会复制节点本身以及里面所有的子节点。</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;1111&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
        var lili = ul.children[0].cloneNode(true);
        ul.appendChild(lili);
    &lt;/script&gt;
</code></pre>
<h3 id="动态生成表格">动态生成表格</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 1.先去准备好学生的数据
        var datas = [{
            name: '魏璎珞',
            subject: 'JavaScript',
            score: 100
        }, {
            name: '弘历',
            subject: 'JavaScript',
            score: 98
        }, {
            name: '傅恒',
            subject: 'JavaScript',
            score: 99
        }, {
            name: '明玉',
            subject: 'JavaScript',
            score: 88
        }, {
            name: '大猪蹄子',
            subject: 'JavaScript',
            score: 0
        }];
        // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
        var tbody = document.querySelector('tbody');
		// 遍历数组
        for (var i = 0; i &lt; datas.length; i++) { 
            // 1. 创建 tr行
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
            // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数  
            // 使用for in遍历学生对象
            for (var k in datas[i]) { 
                // 创建单元格 
                var td = document.createElement('td');
                // 把对象里面的属性值 datas[i][k] 给 td  
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 3. 创建有删除2个字的单元格 
            var td = document.createElement('td');
            td.innerHTML = '&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;';
            tr.appendChild(td);

        }
        // 4. 删除操作 开始 
        var as = document.querySelectorAll('a');
        for (var i = 0; i &lt; as.length; i++) {
            as[i].onclick = function() {
                // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  
                tbody.removeChild(this.parentNode.parentNode)
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="创建元素的三种方式">创建元素的三种方式</h3>
<p>document.write ()<br>
element.innerHTML<br>
document.createElement ()<br>
区别</p>
<ol>
<li>document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTMT，是将内容写入某个DOM节点，不会导致页面全部重绘</li>
<li>innerHTML创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂</li>
<li>createElement ()创建多个元素效率稍低一点点，但是结构更清晰<br>
总结:不同浏览器下， innerHTM效率要比creatElement 高</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 三种创建元素方式区别 
        // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘
         var btn = document.querySelector('button');
         btn.onclick = function() {
             document.write('&lt;div&gt;123&lt;/div&gt;');
         }

        // 2. innerHTML 创建元素
        var inner = document.querySelector('.inner');
         for (var i = 0; i &lt;= 100; i++) {
             inner.innerHTML += '&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;'
         }
        var arr = [];
        for (var i = 0; i &lt;= 100; i++) {
            arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');
        }
        inner.innerHTML = arr.join('');
        // 3. document.createElement() 创建元素
        var create = document.querySelector('.create');
        for (var i = 0; i &lt;= 100; i++) {
            var a = document.createElement('a');
            create.appendChild(a);
        }
    &lt;/script&gt;
</code></pre>
<h3 id="innerhtml和createelement效率对比">innerHTML和createElement效率对比</h3>
<p><strong>innerHTML字符串拼接方式（效率低）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var str = '';
        for (var i = 0; i &lt; 1000; i++) {
            document.body.innerHTML += '&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;';
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>createElement方式（效率一般）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();

        for (var i = 0; i &lt; 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>innerHTML数组方式（效率高）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var array = [];
        for (var i = 0; i &lt; 1000; i++) {
            array.push('&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;');
        }
        document.body.innerHTML = array.join('');
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<h2 id="dom的核心总结">DOM的核心总结</h2>
<p>关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</p>
<h3 id="创建">创建</h3>
<ol>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ol>
<h3 id="增加">增加</h3>
<ol>
<li>appendChild</li>
<li>insertBefore</li>
</ol>
<h3 id="删">删</h3>
<p>1.removeChild</p>
<h3 id="改">改</h3>
<p>主要修改dom的元素属性,dom元素的内容、属性,表单的值等<br>
1.修改元素属性:src、href、title等<br>
2.修改普通元素内容:innerHTML、 innerText<br>
3.修改表单元素: value、type、disabled等<br>
4.修改元素样式: style、className</p>
<h3 id="查">查</h3>
<p>主要获取查询dom的元素</p>
<ol>
<li>DOM提供的API方法: getElementByld、getElementsByTagName 古老用法不太推荐</li>
<li>H5提供的新方法: querySelector、querySelectorAll提倡</li>
<li>利用节点操作获取元素:父(parentNode)、子(children)、兄(previousElementSibling、<br>
nextElementSibling)提倡</li>
</ol>
<h3 id="属性操作">属性操作</h3>
<p>主要针对于自定义属性。<br>
1.setAttribute:设置dom的属性值<br>
2.getAttribute:得到dom的属性值<br>
3.removeAttribute移除属性</p>
<h3 id="事件操作重点">事件操作（重点）</h3>
<h2 id="事件高级">事件高级</h2>
<h3 id="注册事件2种方式">注册事件（2种方式）</h3>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5C1551165252019.png" alt="1551165252019" loading="lazy"></figure>
<h3 id="事件监听">事件监听</h3>
<h4 id="addeventlistener事件监听ie9以后支持">addEventListener()事件监听（IE9以后支持）</h4>
<pre><code class="language-js">eventTarget.addEventListener(type, listener[, useCapture])
</code></pre>
<p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>该方法接收三个参数:<br>
type:事件类型字符串，比如click、mouseover，注意这里不要带onlistener:事件处理函数，事件发生时，会调用该监听函数<br>
useCapture:可选参数，是一个布尔值，默认是false。</p>
<h4 id="attacheevent事件监听ie678支持">attacheEvent()事件监听（IE678支持）</h4>
<pre><code>eventTarget.attachEvent(eventNamewithon,callback)
</code></pre>
<p>​	eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>该方法接收两个参数:<br>
eventNameWithOn:事件类型字符串，比如onclick、onmouseover，这里要带oncallback:事件处理函数，当目标触发事件时回调函数被调用<br>
注意:IE8及早期版本支持</p>
<pre><code class="language-js">&lt;button&gt;传统注册事件&lt;/button&gt;
&lt;button&gt;方法监听注册事件&lt;/button&gt;
&lt;button&gt;ie9 attachEvent&lt;/button&gt;
&lt;script&gt;
    var btns = document.querySelectorAll('button');
    // 1. 传统方式注册事件
    btns[0].onclick = function() {
        alert('hi');
    }
    btns[0].onclick = function() {
            alert('hao a u');
        }
   // 2. 事件侦听注册事件 addEventListener 
   // (1) 里面的事件类型是字符串 必定加引号 而且不带on
   // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
    btns[1].addEventListener('click', function() {
        alert(22);
    })
    btns[1].addEventListener('click', function() {
            alert(33);
    })
    // 3. attachEvent ie9以前的版本支持
    btns[2].attachEvent('onclick', function() {
        alert(11);
    })
&lt;/script&gt;
</code></pre>
<h4 id="事件监听兼容性解决方案">事件监听兼容性解决方案</h4>
<p>封装一个函数，函数中判断浏览器的类型：</p>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C1551166023885.png" alt="1551166023885" loading="lazy"></figure>
<h3 id="删除事件解绑事件">删除事件（解绑事件）</h3>
<p><strong>1.传统注册方式</strong><br>
eventTarget.onclick=null;<br>
<strong>2.方法监听注册方式</strong><br>
eventTarget.removeEventListener(type，listener[, useCapture] ) ;eventTarget.detachEvent (eventNamewithon,callback) ;</p>
<pre><code class="language-js">    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;script&gt;
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号
        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    &lt;/script&gt;
</code></pre>
<p>**删除事件兼容性解决方案 **</p>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5C1551166332453.png" alt="1551166332453" loading="lazy"></figure>
<h3 id="dom事件流">DOM事件流</h3>
<blockquote>
<pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。
当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。

那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？
</code></pre>
</blockquote>
<p>事件流描述的是从页面中接收事件的顺序。<br>
事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p>
<blockquote>
<p>比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</p>
</blockquote>
<p>事件冒泡:IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点的过程。<br>
事件捕获:网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</p>
<p>DOM 事件流会经历3个阶段：</p>
<ol>
<li>
<p>捕获阶段</p>
</li>
<li>
<p>当前目标阶段</p>
</li>
<li>
<p>冒泡阶段</p>
</li>
</ol>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DoM事件流。<br>
注意</p>
<ol>
<li>Js代码中只能执行捕获或者冒泡其中的一个阶段。</li>
<li>onclick 和attachEvent只能得到冒泡阶段。</li>
<li>addEventListener(type，listener[，useCapture])第三个参数如果是true，表示在事件捕<br>
获阶段调用事件处理程序;如果是false (不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。</li>
<li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li>
<li>有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave</li>
<li>事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。</li>
</ol>
<p><strong>事件冒泡</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // onclick 和 attachEvent（ie） 在冒泡阶段触发
        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 
        // son -&gt; father -&gt;body -&gt; html -&gt; document
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function() {
            alert('son');
        }, false);
		// 给father注册单击事件
        var father = document.querySelector('.father');
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件，省略第3个参数
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>事件捕获</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发
        // document -&gt; html -&gt; body -&gt; father -&gt; son
         var son = document.querySelector('.son');
		// 给son注册单击事件，第3个参数为true
         son.addEventListener('click', function() {
             alert('son');
         }, true);
         var father = document.querySelector('.father');
		// 给father注册单击事件，第3个参数为true
         father.addEventListener('click', function() {
             alert('father');
         }, true);
		// 给document注册单击事件，第3个参数为true
        document.addEventListener('click', function() {
            alert('document');
        }, true)
    &lt;/script&gt;
</code></pre>
<h3 id="事件对象">事件对象</h3>
<h4 id="什么是事件对象">什么是事件对象</h4>
<p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</p>
<p>比如：</p>
<ol>
<li>
<p>谁绑定了这个事件。</p>
</li>
<li>
<p>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</p>
</li>
<li>
<p>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p>
</li>
</ol>
<h4 id="事件对象的使用">事件对象的使用</h4>
<p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</p>
<p>所以，在事件处理函数中声明1个形参用来接收事件对象。</p>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5C1551169537789.png" alt="1551169537789" loading="lazy"></figure>
<h4 id="事件对象的兼容性处理">事件对象的兼容性处理</h4>
<p>事件对象本身的获取存在兼容问题：</p>
<ol>
<li>
<p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p>
</li>
<li>
<p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</p>
</li>
</ol>
<pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。
只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。
</code></pre>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.onclick = function(e) {
                // 事件对象
                e = e || window.event;
                console.log(e);
        }
    &lt;/script&gt;
</code></pre>
<h4 id="事件对象的属性和方法">事件对象的属性和方法</h4>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5C1551169931778.png" alt="1551169931778" loading="lazy"></figure>
<h4 id="etarget-和-this-的区别">e.target 和 this 的区别</h4>
<ul>
<li>
<p>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</p>
</li>
<li>
<p>e.target 是事件触发的元素。</p>
</li>
</ul>
<blockquote>
<pre><code>常情况下terget 和 this是一致的，
但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），
	这时候this指向的是父元素，因为它是绑定事件的元素对象，
	而target指向的是子元素，因为他是触发事件的那个具体元素对象。
</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.addEventListener('click', function(e) {
            // e.target 和 this指向的都是div
            console.log(e.target);
            console.log(this);

        });
    &lt;/script&gt;
</code></pre>
<p>事件冒泡下的e.target和this</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
              // 我们给ul 绑定了事件  那么this 就指向ul  
              console.log(this); // ul

              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li
              console.log(e.target); // li
        });
    &lt;/script&gt;
</code></pre>
<h3 id="阻止默认行为">阻止默认行为</h3>
<blockquote>
<p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p>
</blockquote>
<pre><code class="language-js">    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;
    &lt;script&gt;
        // 2. 阻止默认行为 让链接不跳转 
        var a = document.querySelector('a');
        a.addEventListener('click', function(e) {
             e.preventDefault(); //  dom 标准写法
        });
        // 3. 传统的注册方式
        a.onclick = function(e) {
            // 普通浏览器 e.preventDefault();  方法
            e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            e.returnValue = false;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题
            return false;
        }
    &lt;/script&gt;
</code></pre>
<h3 id="阻止事件冒泡">阻止事件冒泡</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5C1551171467194.png" alt="1551171467194" loading="lazy"></figure>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function(e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
        }, false);

        var father = document.querySelector('.father');
		// 给father注册单击事件
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>阻止事件冒泡的兼容性处理</strong></p>
<p>![1551171657513](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551171657513.png)</p>
<h3 id="事件委托">事件委托</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<h4 id="什么是事件委托">什么是事件委托</h4>
<pre><code>把事情委托给别人，代为处理。
</code></pre>
<p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p>
<blockquote>
<p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p>
</blockquote>
<h4 id="事件委托的原理">事件委托的原理</h4>
<p>​	给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p>
<h4 id="事件委托的作用">事件委托的作用</h4>
<ul>
<li>
<p>我们只操作了一次 DOM ，提高了程序的性能。</p>
</li>
<li>
<p>动态新创建的子元素，也拥有事件。</p>
</li>
</ul>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
            // e.target 这个可以得到我们点击的对象
            e.target.style.backgroundColor = 'pink';
        })
    &lt;/script&gt;
</code></pre>
<h2 id="常用鼠标事件">常用鼠标事件</h2>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5C1551172699854.png" alt="1551172699854" loading="lazy"></figure>
<h3 id="禁止选中文字和禁止右键菜单">禁止选中文字和禁止右键菜单</h3>
<pre><code class="language-js">&lt;body&gt;
    我是一段不愿意分享的文字
    &lt;script&gt;
        // 1. contextmenu 我们可以禁用右键菜单
        document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
        })
        // 2. 禁止选中文字 selectstart
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="鼠标事件对象">鼠标事件对象</h3>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5C1551173103741.png" alt="1551173103741" loading="lazy"></figure>
<h3 id="获取鼠标在页面的坐标">获取鼠标在页面的坐标</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 鼠标事件对象 MouseEvent
        document.addEventListener('click', function(e) {
            // 1. client 鼠标在可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('---------------------');

            // 2. page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('---------------------');

            // 3. screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);

        })
    &lt;/script&gt;
</code></pre>
<h3 id="跟随鼠标">跟随鼠标</h3>
<pre><code class="language-js">    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;
    &lt;script&gt;
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function(e) {
        	// 1. mousemove只要我们鼠标移动1px 就会触发这个事件
        	// 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 
            // 把这个x和y坐标做为图片的top和left 值就可以移动图片
        	var x = e.pageX;
        	var y = e.pageY;
        	console.log('x坐标是' + x, 'y坐标是' + y);
        	//3 . 千万不要忘记给left 和top 添加px 单位
        	pic.style.left = x - 50 + 'px';
        	pic.style.top = y - 40 + 'px';
    	});
    &lt;/script&gt;
</code></pre>
<h2 id="常用的键盘事件">常用的键盘事件</h2>
<h3 id="键盘事件">键盘事件</h3>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5C1551318122855.png" alt="1551318122855" loading="lazy"></figure>
<p>注意:<br>
1.如果使用addEventListener 不需要加on</p>
<p>2.onkeypress和前面2个的区别是，它不识别功能键，比如左右箭头，shift等。</p>
<p>3.三个事件的执行顺序是: keydown -- keypress --- keyup</p>
<pre><code class="language-js">    &lt;script&gt;
        // 常用的键盘事件
        //1. keyup 按键弹起的时候触发 
        document.addEventListener('keyup', function() {
            console.log('我弹起了');
        })

        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keypress', function() {
                console.log('我按下了press');
        })
        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keydown', function() {
                console.log('我按下了down');
        })
        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup
    &lt;/script&gt;
</code></pre>
<h3 id="键盘事件对象">键盘事件对象</h3>
<p>注意:</p>
<ol>
<li>onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写。<br>
2)在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键（包括功能键)3) keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCIl值</li>
</ol>
<p><strong>使用keyCode属性判断用户按下哪个键</strong></p>
<pre><code class="language-js">    &lt;script&gt;
        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
        document.addEventListener('keyup', function(e) {
            console.log('up:' + e.keyCode);
            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键
            if (e.keyCode === 65) {
                alert('您按下的a键');
            } else {
                alert('您没有按下a键')
            }
        })
        document.addEventListener('keypress', function(e) {
            // console.log(e);
            console.log('press:' + e.keyCode);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="按键输入内容">按键输入内容</h3>
<p>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</p>
<blockquote>
<p>注意：触发获得焦点事件，可以使用 元素对象.focus()</p>
</blockquote>
<pre><code class="language-js">    &lt;input type=&quot;text&quot;&gt;
    &lt;script&gt;
        // 获取输入框
        var search = document.querySelector('input');
		// 给document注册keyup事件
        document.addEventListener('keyup', function(e) {
            // 判断keyCode的值
            if (e.keyCode === 83) {
                // 触发输入框的获得焦点事件
                search.focus();
            }
        })
    &lt;/script&gt;
</code></pre>
<h3 id="模拟京东快递单号查询">模拟京东快递单号查询</h3>
<p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</p>
<pre><code class="language-js">    &lt;div class=&quot;search&quot;&gt;
        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var con = document.querySelector('.con');
        var jd_input = document.querySelector('.jd');
		// 给输入框注册keyup事件
        jd_input.addEventListener('keyup', function() {
				// 判断输入框内容是否为空
                if (this.value == '') {
                    // 为空，隐藏放大提示盒子
                    con.style.display = 'none';
                } else {
                    // 不为空，显示放大提示盒子，设置盒子的内容
                    con.style.display = 'block';
                    con.innerText = this.value;
                }
            })
        // 给输入框注册失去焦点事件，隐藏放大提示盒子
        jd_input.addEventListener('blur', function() {
                con.style.display = 'none';
            })
        // 给输入框注册获得焦点事件
        jd_input.addEventListener('focus', function() {
            // 判断输入框内容是否为空
            if (this.value !== '') {
                // 不为空则显示提示盒子
                con.style.display = 'block';
            }
        })
    &lt;/script&gt;
</code></pre>
<h2 id="bom">BOM</h2>
<h3 id="什么是bom">什么是BOM</h3>
<p>​	BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p>
<p>​	BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p>
<p>​	BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5C1551319264407.png" alt="1551319264407" loading="lazy"></figure>
<h3 id="bom的构成">BOM的构成</h3>
<p>BOM 比 DOM 更大，它包含 DOM。</p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5C1551319344183.png" alt="1551319344183" loading="lazy"></figure>
<h3 id="顶级对象window">顶级对象window</h3>
<p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色。</p>
<p>1.它是S访问浏览器窗口的一个接口。<br>
2．它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。<br>
在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等。</p>
<p><strong>注意: window下的一个特殊属性window.name</strong></p>
<h3 id="window对象的常见事件">window对象的常见事件</h3>
<h4 id="页面窗口加载事件2种">页面（窗口）加载事件（2种）</h4>
<p><strong>第1种</strong></p>
<pre><code class="language-js">window .onload = function ( ) { }或者
window.addEventListener (&quot;load&quot; , function ( ) { });
</code></pre>
<p>window.onload 是窗口 (页面）加载事件，<strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p>
<p>注意:<br>
1.有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等面内容全部加载元毕，再去执行处理函数。</p>
<ol start="2">
<li>window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。</li>
<li>3.如果使用addEventListener则没有限制</li>
</ol>
<p><strong>第2种</strong></p>
<pre><code class="language-js">document.addEventListener ( ' DOMContentLoaded' , function() { })

</code></pre>
<p>​	DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p>
<p>​	IE9以上才支持！！！</p>
<p>​	如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p>
<pre><code class="language-js">    &lt;script&gt;
        window.addEventListener('load', function() {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function() {
                alert('点击我');
            })
        })
        window.addEventListener('load', function() {
            alert(22);
        })
        document.addEventListener('DOMContentLoaded', function() {
            alert(33);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="调整窗口大小事件">调整窗口大小事件</h4>
<pre><code class="language-js">window.onresize = function ( ) { }
window.addEventListener ( &quot;resize&quot; ,function() { } );
</code></pre>
<p>​	window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。</p>
<p>注意：</p>
<ol>
<li>
<p>只要窗口大小发生像素变化，就会触发这个事件。</p>
</li>
<li>
<p>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p>
</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 注册页面加载事件
        window.addEventListener('load', function() {
            var div = document.querySelector('div');
        	// 注册调整窗口大小事件
            window.addEventListener('resize', function() {
                // window.innerWidth 获取窗口大小
                console.log('变化了');
                if (window.innerWidth &lt;= 800) {
                    div.style.display = 'none';
                } else {
                    div.style.display = 'block';
                }
            })
        })
    &lt;/script&gt;
    &lt;div&gt;&lt;/div&gt;
</code></pre>
<h3 id="定时器两种">定时器（两种）</h3>
<p>window 对象给我们提供了 2 个非常好用的方法-定时器。</p>
<ul>
<li>
<p>setTimeout()</p>
</li>
<li>
<p>setInterval()</p>
</li>
</ul>
<h4 id="settimeout-炸弹定时器">setTimeout() 炸弹定时器</h4>
<h5 id="开启定时器">开启定时器</h5>
<p><strong>window.setTimeout(调用函数，[延迟的毫秒数]);</strong><br>
<strong>setTimeout()这个调用函数我们也称为回调函数callback</strong><br>
<strong>注意:</strong></p>
<ol>
<li>window可以省略。</li>
<li>这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐</li>
<li>延迟的毫秒数省略默认是0，如果写，必须是毫秒。</li>
<li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li>
</ol>
<blockquote>
<pre><code>普通函数是按照代码顺序直接调用。

简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。
例如：定时器中的调用函数，事件处理函数，也是回调函数。

以前我们讲的   element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。

</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;script&gt;
        // 回调函数是一个匿名函数
         setTimeout(function() {
             console.log('时间到了');

         }, 2000);
        function callback() {
            console.log('爆炸了');
        }
		// 回调函数是一个有名函数
        var timer1 = setTimeout(callback, 3000);
        var timer2 = setTimeout(callback, 5000);
    &lt;/script&gt;
</code></pre>
<h5 id="5秒后关闭广告">5秒后关闭广告</h5>
<pre><code class="language-js">&lt;body&gt;
    &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var ad = document.querySelector('.ad');
		// 开启定时器
        setTimeout(function() {
            ad.style.display = 'none';
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h5 id="停止定时器">停止定时器</h5>
<p><strong>window.clearTimeout (timeoutID)</strong><br>
<strong>clearTimeout()方法取消了先前通过调用setTimeout ()建立的定时器。</strong><br>
<strong>注意:</strong></p>
<ol>
<li>window可以省略。</li>
<li>里面的参数就是定时器的标识符。</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;点击停止定时器&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 开启定时器
        var timer = setTimeout(function() {
            console.log('爆炸了');
        }, 5000);
		// 给按钮注册单击事件
        btn.addEventListener('click', function() {
            // 停止定时器
            clearTimeout(timer);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="setinterval-闹钟定时器">setInterval() 闹钟定时器</h4>
<h5 id="开启定时器-2">开启定时器</h5>
<p><strong>window.setInterval(回调函数，[间隔的毫秒数]);</strong><br>
<strong>setInterval</strong>方法<strong>重复调用一个函数</strong>，每隔这个时间，就去调用一次回调函数。<br>
注意:</p>
<ol>
<li>window可以省略。<br>
2.这个调用函数可以直接写函数，或者写函数名或者采取字符串'函数名()’三种形式。<br>
3.间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。<br>
4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。<br>
5.第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行—次。</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 1. setInterval 
        setInterval(function() {
            console.log('继续输出');
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h5 id="倒计时">倒计时</h5>
<pre><code class="language-js">    &lt;div&gt;
        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素（时分秒盒子） 
        var hour = document.querySelector('.hour'); // 小时的黑色盒子
        var minute = document.querySelector('.minute'); // 分钟的黑色盒子
        var second = document.querySelector('.second'); // 秒数的黑色盒子
        var inputTime = +new Date('2021-5-1 18:00:00'); // 返回的是用户输入时间总的毫秒数

        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 

        // 2. 开启定时器
        setInterval(countDown, 1000);
		
        function countDown() {
            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 
            var h = parseInt(times / 60 / 60 % 24); //时
            h = h &lt; 10 ? '0' + h : h;
            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子
            var m = parseInt(times / 60 % 60); // 分
            m = m &lt; 10 ? '0' + m : m;
            minute.innerHTML = m;
            var s = parseInt(times % 60); // 当前的秒
            s = s &lt; 10 ? '0' + s : s;
            second.innerHTML = s;
        }
    &lt;/script&gt;
</code></pre>
<h5 id="停止定时器-2">停止定时器</h5>
<p>window.clearInterval (intervalID);<br>
clearInterval()方法取消了先前通过调用setInterval()建立的定时器。<br>
注意:<br>
1.window可以省略。<br>
2.里面的参数就是定时器的标识符。</p>
<h4 id="发送短信倒计时">发送短信倒计时</h4>
<p>​	点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。</p>
<pre><code class="language-js">    手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 全局变量，定义剩下的秒数
        var time = 3; 
		// 注册单击事件
        btn.addEventListener('click', function() {
            // 禁用按钮
            btn.disabled = true;
            // 开启定时器
            var timer = setInterval(function() {
                // 判断剩余秒数
                if (time == 0) {
                    // 清除定时器和复原按钮
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.innerHTML = '发送';
                } else {
                    btn.innerHTML = '还剩下' + time + '秒';
                    time--;
                }
            }, 1000);
        });
    &lt;/script&gt;
</code></pre>
<h3 id="this指向问题">this指向问题</h3>
<p>​	this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p>
<p>现阶段，我们先了解一下几个this指向</p>
<ol>
<li>
<p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p>
</li>
<li>
<p>方法调用中谁调用this指向谁</p>
</li>
<li>
<p>构造函数中this指向构造函数的实例</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        // this 指向问题 一般情况下this的最终指向的是那个调用它的对象
        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）
        console.log(this);
        function fn() {
            console.log(this);
        }
        window.fn();
        window.setTimeout(function() {
            console.log(this);
        }, 1000);
        // 2. 方法调用中谁调用this指向谁
        var o = {
            sayHi: function() {
                console.log(this); // this指向的是 o 这个对象
            }
        }
        o.sayHi();
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
                console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象
            })
        // 3. 构造函数中this指向构造函数的实例
        function Fun() {
            console.log(this); // this 指向的是fun 实例对象
        }
        var fun = new Fun();
    &lt;/script&gt;
</code></pre>
<h3 id="location对象">location对象</h3>
<h4 id="什么是-location-对象">什么是 location 对象</h4>
<p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析<br>
URL。因为<br>
这个属性返回的是一个对象，所以我们将这个属性也称为location对象。</p>
<h4 id="url">URL</h4>
<p>统一资源定位符(Uniform ResourceLocator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<br>
URL的一般语法格式为:<br>
protocol:// host [ :port] /path/ [?query]#fragment<br>
http : / / www.itcast.cn/index.html?name=andy&amp;age=18#link</p>
<figure data-type="image" tabindex="17"><img src="E:%5CAPTX-4869%5Cmd%5C1551322387201.png" alt="1551322387201" loading="lazy"></figure>
<h4 id="location-对象的属性">location 对象的属性</h4>
<figure data-type="image" tabindex="18"><img src="E:%5CAPTX-4869%5Cmd%5C1551322416716.png" alt="1551322416716" loading="lazy"></figure>
<p>![1551322438200](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551322438200.png)</p>
<h4 id="5s自动跳转页面">5s自动跳转页面</h4>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        btn.addEventListener('click', function() {
            // console.log(location.href);
            location.href = 'http://www.itcast.cn';
        })
        var timer = 5;
        setInterval(function() {
            if (timer == 0) {
                location.href = 'http://www.itcast.cn';
            } else {
                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';
                timer--;
            }
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h4 id="获取url参数">获取URL参数</h4>
<pre><code class="language-js">    &lt;div&gt;&lt;/div&gt;
	&lt;script&gt;
        console.log(location.search); // ?uname=andy
        // 1.先去掉？  substr('起始的位置'，截取几个字符);
        var params = location.search.substr(1); // uname=andy
        console.log(params);
        // 2. 利用=把字符串分割为数组 split('=');
        var arr = params.split('=');
        console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;]
        var div = document.querySelector('div');
        // 3.把数据写入div中
        div.innerHTML = arr[1] + '欢迎您';
    &lt;/script&gt;
</code></pre>
<h4 id="location对象的常见方法">location对象的常见方法</h4>
<figure data-type="image" tabindex="19"><img src="E:%5CAPTX-4869%5Cmd%5C1551322750241.png" alt="1551322750241" loading="lazy"></figure>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
            // 记录浏览历史，所以可以实现后退功能
            // location.assign('http://www.itcast.cn');
            // 不记录浏览历史，所以不可以实现后退功能
            // location.replace('http://www.itcast.cn');
            location.reload(true);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="navigator对象">navigator对象</h3>
<p>​	navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
<p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<pre><code class="language-js">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    window.location.href = &quot;&quot;;     //手机
 } else {
    window.location.href = &quot;&quot;;     //电脑
 }
</code></pre>
<h3 id="history对象">history对象</h3>
<p>​	window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p>
<p>![1551322885216](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551322885216.png)</p>
<p>history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p>
<h2 id="js执行机制">JS执行机制</h2>
<p>以下代码执行的结果是什么？</p>
<p>1 2 3</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 1000);
 
 console.log(2);
</code></pre>
<p>以下代码执行的结果是什么？</p>
<p>1 2 3</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 0);
 
 console.log(2);
</code></pre>
<h3 id="js-是单线程">JS 是单线程</h3>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p>
<pre><code class="language-js">	单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
	这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
</code></pre>
<h3 id="同步任务和异步任务">同步任务和异步任务</h3>
<p>​	单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</p>
<p>​	为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了<strong>同步任务</strong>和<strong>异步任务</strong>。</p>
<h4 id="同步">同步</h4>
<p>​	前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。</p>
<h4 id="异步">异步</h4>
<p>​	你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p>
<p><strong>他们的本质区别:这条流水线上各个流程的执行顺序不同。</strong></p>
<blockquote>
<pre><code class="language-js">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。

同步任务指的是：
	在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
异步任务指的是：
	不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。
</code></pre>
</blockquote>
<figure data-type="image" tabindex="20"><img src="E:%5CAPTX-4869%5Cmd%5C1551434972778.png" alt="1551434972778" loading="lazy"></figure>
<h3 id="js执行机制事件循环">JS执行机制（事件循环）</h3>
<figure data-type="image" tabindex="21"><img src="E:%5CAPTX-4869%5Cmd%5C1551435335464.png" alt="1551435335464" loading="lazy"></figure>
<p>![1551435398306](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551435398306.png)</p>
<p>![1551435449634](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551435449634.png)</p>
<h2 id="元素偏移量-offset-系列">元素偏移量 offset 系列</h2>
<h3 id="offset-概述">offset 概述</h3>
<p>offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p>
<ol>
<li>
<p>获得元素距离带有定位父元素的位置</p>
</li>
<li>
<p>获得元素自身的大小（宽度高度）</p>
</li>
<li>
<p>注意：返回的数值都不带单位</p>
<figure data-type="image" tabindex="22"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%871.png" alt="图片1" loading="lazy"></figure>
</li>
</ol>
<h3 id="offset-与-style-区别">offset 与 style 区别</h3>
<h4 id="offset">offset</h4>
<ul>
<li>
<p>offset 可以得到任意样式表中的样式值</p>
</li>
<li>
<p>offset 系列获得的数值是没有单位的</p>
</li>
<li>
<p>offsetWidth 包含padding+border+width</p>
</li>
<li>
<p>offsetWidth 等属性是<strong>只读属性</strong>，只能获取不能赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要获取元素大小位置，用offset更合适</p>
</blockquote>
</li>
</ul>
<h4 id="style">style</h4>
<ul>
<li>
<p>style 只能得到<strong>行内样式表中的样式值</strong></p>
</li>
<li>
<p>style.width 获得的是带有单位的字符串</p>
</li>
<li>
<p>style.width 获得不包含padding和border 的值</p>
</li>
<li>
<p>style.width 是可读写属性，可以获取也可以赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要给元素更改值，则需要用style改变</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="获取鼠标在盒子内的坐标">获取鼠标在盒子内的坐标</h3>
<ol>
<li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</li>
<li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li>
<li>其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop)</li>
<li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标</li>
<li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动</li>
</ol>
<pre><code class="language-javascript">var box = document.querySelector('.box');
box.addEventListener('mousemove', function(e) {
var x = e.pageX - this.offsetLeft;
var y = e.pageY - this.offsetTop;
this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
})
</code></pre>
<h3 id="模态框拖拽">模态框拖拽</h3>
<p>弹出框，我们也称为模态框。</p>
<p>​	1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。</p>
<p>​	2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。</p>
<p>​	3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。</p>
<p>​	4.鼠标松开，可以停止拖动模态框移动</p>
<ol>
<li>点击弹出层， 模态框和遮挡层就会显示出来 display:block;</li>
<li>点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</li>
<li>在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标</li>
<li>触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</li>
<li>拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</li>
<li>鼠标按下触发的事件源是最上面一行，就是  id 为 title</li>
<li>鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。</li>
<li>鼠标按下，我们要得到鼠标在盒子的坐标。</li>
<li>鼠标移动，就让模态框的坐标  设置为  ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。</li>
<li>鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除</li>
</ol>
<pre><code class="language-javascript"> // 1. 获取元素
        var login = document.querySelector('.login');
        var mask = document.querySelector('.login-bg');
        var link = document.querySelector('#link');
        var closeBtn = document.querySelector('#closeBtn');
        var title = document.querySelector('#title');
        // 2. 点击弹出层这个链接 link  让mask 和login 显示出来
        link.addEventListener('click', function() {
                mask.style.display = 'block';
                login.style.display = 'block';
            })
            // 3. 点击 closeBtn 就隐藏 mask 和 login 
        closeBtn.addEventListener('click', function() {
                mask.style.display = 'none';
                login.style.display = 'none';
            })
            // 4. 开始拖拽
            // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
        title.addEventListener('mousedown', function(e) {
            var x = e.pageX - login.offsetLeft;
            var y = e.pageY - login.offsetTop;
            // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
            document.addEventListener('mousemove', move)

            function move(e) {
                login.style.left = e.pageX - x + 'px';
                login.style.top = e.pageY - y + 'px';
            }
            // (3) 鼠标弹起，就让鼠标移动事件移除
            document.addEventListener('mouseup', function() {
                document.removeEventListener('mousemove', move);
            })
        })

</code></pre>
<h3 id="仿京东放大镜">仿京东放大镜</h3>
<ol>
<li>
<p>整个案例可以分为三个功能模块</p>
</li>
<li>
<p>鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能</p>
</li>
<li>
<p>黄色的遮挡层跟随鼠标功能。</p>
</li>
<li>
<p>移动黄色遮挡层，大图片跟随移动功能。</p>
</li>
<li>
<p>黄色的遮挡层跟随鼠标功能。</p>
</li>
<li>
<p>把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。</p>
</li>
<li>
<p>首先是获得鼠标在盒子的坐标。</p>
</li>
<li>
<p>之后把数值给遮挡层做为left 和top值。</p>
</li>
<li>
<p>此时用到鼠标移动事件，但是还是在小图片盒子内移动。</p>
</li>
<li>
<p>发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</p>
</li>
<li>
<p>遮挡层不能超出小图片盒子范围。</p>
</li>
<li>
<p>如果小于零，就把坐标设置为0</p>
</li>
<li>
<p>如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离</p>
</li>
<li>
<p>遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</p>
</li>
</ol>
<pre><code class="language-javascript">window.addEventListener('load', function() {
    var preview_img = document.querySelector('.preview_img');
    var mask = document.querySelector('.mask');
    var big = document.querySelector('.big');
    // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
    preview_img.addEventListener('mouseover', function() {
        mask.style.display = 'block';
        big.style.display = 'block';
    })
    preview_img.addEventListener('mouseout', function() {
            mask.style.display = 'none';
            big.style.display = 'none';
        })
        // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
    preview_img.addEventListener('mousemove', function(e) {
        // (1). 先计算出鼠标在盒子内的坐标
        var x = e.pageX - this.offsetLeft;
        var y = e.pageY - this.offsetTop;
        // console.log(x, y);
        // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了
        // (3) 我们mask 移动的距离
        var maskX = x - mask.offsetWidth / 2;
        var maskY = y - mask.offsetHeight / 2;
        // (4) 如果x 坐标小于了0 就让他停在0 的位置
        // 遮挡层的最大移动距离
        var maskMax = preview_img.offsetWidth - mask.offsetWidth;
        if (maskX &lt;= 0) {
            maskX = 0;
        } else if (maskX &gt;= maskMax) {
            maskX = maskMax;
        }
        if (maskY &lt;= 0) {
            maskY = 0;
        } else if (maskY &gt;= maskMax) {
            maskY = maskMax;
        }
        mask.style.left = maskX + 'px';
        mask.style.top = maskY + 'px';
        // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
        // 大图
        var bigIMg = document.querySelector('.bigImg');
        // 大图片最大移动距离
        var bigMax = bigIMg.offsetWidth - big.offsetWidth;
        // 大图片的移动距离 X Y
        var bigX = maskX * bigMax / maskMax;
        var bigY = maskY * bigMax / maskMax;
        bigIMg.style.left = -bigX + 'px';
        bigIMg.style.top = -bigY + 'px';

    })

})
</code></pre>
<h2 id="元素可视区-client-系列">元素可视区 client 系列</h2>
<h3 id="client概述">client概述</h3>
<p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>
系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p>
<figure data-type="image" tabindex="23"><img src="E:%5CAPTX-4869%5Cmd%5Cclient3.png" alt="图片3" loading="lazy"></figure>
<h3 id="淘宝-flexiblejs-源码分析">淘宝 flexible.js 源码分析</h3>
<p>立即执行函数 (function(){})()  或者 (function(){}())</p>
<p>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</p>
<p>下面三种情况都会刷新页面都会触发 load 事件。</p>
<p>1.a标签的超链接</p>
<p>2.F5或者刷新按钮（强制刷新）</p>
<p>3.前进后退按钮</p>
<p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</p>
<p>所以此时后退按钮不能刷新页面。</p>
<p>此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</p>
<p><code>注意这个事件给window添加。</code></p>
<h2 id="元素滚动-scroll-系列">元素滚动 scroll 系列</h2>
<h3 id="scroll-概述">scroll 概述</h3>
<p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<figure data-type="image" tabindex="24"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%875.png" alt="图片5" loading="lazy"></figure>
<h3 id="页面被卷去的头部">页面被卷去的头部</h3>
<p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</p>
<h3 id="仿淘宝固定右侧侧边栏">仿淘宝固定右侧侧边栏</h3>
<ol>
<li>
<p>原先侧边栏是绝对定位</p>
</li>
<li>
<p>当页面滚动到一定位置，侧边栏改为固定定位</p>
</li>
<li>
<p>页面继续滚动，会让 返回顶部显示出来</p>
</li>
<li>
<p>需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是document</p>
</li>
<li>
<p>滚动到某个位置，就是判断页面被卷去的上部值。</p>
</li>
<li>
<p><strong>页面被卷去的头部</strong>：可以通过window.pageYOffset 获得  如果是被卷去的左侧window.pageXOffset</p>
</li>
<li>
<p>注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset</p>
</li>
<li>
<p>其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了</p>
</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset);
            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
            if (window.pageYOffset &gt;= bannerTop) {
                sliderbar.style.position = 'fixed';
                sliderbar.style.top = sliderbarTop + 'px';
            } else {
                sliderbar.style.position = 'absolute';
                sliderbar.style.top = '300px';
            }
            // 4. 当我们页面滚动到main盒子，就显示 goback模块
            if (window.pageYOffset &gt;= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';
            }

        })
</code></pre>
<h3 id="页面被卷去的头部兼容性解决方案">页面被卷去的头部兼容性解决方案</h3>
<p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p>
<ol>
<li>声明了 DTD，使用 document.documentElement.scrollTop</li>
<li>未声明 DTD，使用  document.body.scrollTop</li>
<li>新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</li>
</ol>
<pre><code class="language-javascript">function getScroll() {
    return {
      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    };
 } 
使用的时候  getScroll().left

</code></pre>
<h2 id="三大系列总结">三大系列总结</h2>
<figure data-type="image" tabindex="25"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%877.png" alt="图片7" loading="lazy"></figure>
<p>他们主要用法：</p>
<p>1.offset系列 经常用于获得元素位置    offsetLeft  offsetTop</p>
<p>2.client经常用于获取元素大小  clientWidth clientHeight</p>
<p>3.scroll 经常用于获取滚动距离 scrollTop  scrollLeft</p>
<p>4.注意页面滚动的距离通过 window.pageXOffset  获得</p>
<h2 id="mouseenter-和mouseover的区别">mouseenter 和mouseover的区别</h2>
<ul>
<li>当鼠标移动到元素上时就会触发mouseenter 事件</li>
<li>类似 mouseover，它们两者之间的差别是</li>
<li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li>
<li>之所以这样，就是因为mouseenter不会冒泡</li>
<li>跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</li>
</ul>
<h2 id="动画函数封装">动画函数封装</h2>
<h3 id="动画实现原理">动画实现原理</h3>
<blockquote>
<p>核心原理：通过定时器 setInterval() 不断移动盒子位置。</p>
</blockquote>
<p>实现步骤：</p>
<ol>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上1个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>加一个结束定时器的条件</li>
<li>注意此元素需要添加定位，才能使用element.style.left</li>
</ol>
<h3 id="动画函数给不同元素记录不同定时器">动画函数给不同元素记录不同定时器</h3>
<p>如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p>
<blockquote>
<p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p>
</blockquote>
<pre><code class="language-javascript"> function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function() {
                if (obj.offsetLeft &gt;= target) {
                    // 停止动画 本质是停止定时器
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';

            }, 30);
        }

</code></pre>
<h3 id="缓动效果原理">缓动效果原理</h3>
<p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p>
<p>思路：</p>
<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li>
<li>核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</li>
<li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器</li>
<li>注意步长值需要取整</li>
</ol>
<h3 id="动画函数多个目标值之间移动">动画函数多个目标值之间移动</h3>
<p>可以让动画函数从 800 移动到 500。</p>
<p>当我们点击按钮时候，判断步长是正值还是负值（否则当为距离小于10时 步长取整始终为0 不在移动）</p>
<p>​	1.如果是正值，则步长往大了取整</p>
<p>​	2.如果是负值，则步长 向小了取整</p>
<h3 id="动函数添加回调函数">动函数添加回调函数</h3>
<p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当<strong>那个函数执行完之后，再执行传进去的这个函</strong>数，这个过程就叫做回调。</p>
<p>回调函数写的位置：定时器结束的位置。</p>
<h3 id="动画完整版代码">动画完整版代码:</h3>
<pre><code class="language-javascript">function animate(obj, target, callback) {
    // console.log(callback);  callback = function() {}  调用的时候 callback()

    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function() {
        // 步长值写到定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题
        // var step = Math.ceil((target - obj.offsetLeft) / 10);
        var step = (target - obj.offsetLeft) / 10;
        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft == target) {
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            // if (callback) {
            //     // 调用函数
            //     callback();
            // }
            callback &amp;&amp; callback();
        }
        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
        obj.style.left = obj.offsetLeft + step + 'px';

    }, 15);
}
</code></pre>
<h2 id="常见网页特效案例">常见网页特效案例</h2>
<h3 id="网页轮播图">网页轮播图</h3>
<p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p>
<p>功能需求：</p>
<p>​	1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</p>
<p>​	2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</p>
<p>​	3.图片播放的同时，下面小圆圈模块跟随一起变化。</p>
<p>​	4.点击小圆圈，可以播放相应图片。</p>
<p>​	5.鼠标不经过轮播图，轮播图也会自动播放图片。</p>
<p>​	6.鼠标经过，轮播图模块， 自动播放停止。</p>
<pre><code>window.addEventListener('load', function() {
    // 1. 获取元素
    var arrow_l = document.querySelector('.arrow-l');
    var arrow_r = document.querySelector('.arrow-r');
    var focus = document.querySelector('.focus');
    var focusWidth = focus.offsetWidth;
    // 2. 鼠标经过focus 就显示隐藏左右按钮
    focus.addEventListener('mouseenter', function() {
        arrow_l.style.display = 'block';
        arrow_r.style.display = 'block';
        clearInterval(timer);
        timer = null; // 清除定时器变量
    });
    focus.addEventListener('mouseleave', function() {
        arrow_l.style.display = 'none';
        arrow_r.style.display = 'none';
        timer = setInterval(function() {
            //手动调用点击事件
            arrow_r.click();
        }, 2000);
    });
    // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈
    var ul = focus.querySelector('ul');
    var ol = focus.querySelector('.circle');
    // console.log(ul.children.length);
    for (var i = 0; i &lt; ul.children.length; i++) {
        // 创建一个小li 
        var li = document.createElement('li');
        // 记录当前小圆圈的索引号 通过自定义属性来做 
        li.setAttribute('index', i);
        // 把小li插入到ol 里面
        ol.appendChild(li);
        // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件
        li.addEventListener('click', function() {
            // 干掉所有人 把所有的小li 清除 current 类名
            for (var i = 0; i &lt; ol.children.length; i++) {
                ol.children[i].className = '';
            }
            // 留下我自己  当前的小li 设置current 类名
            this.className = 'current';
            // 5. 点击小圆圈，移动图片 当然移动的是 ul 
            // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值
            // 当我们点击了某个小li 就拿到当前小li 的索引号
            var index = this.getAttribute('index');
            // 当我们点击了某个小li 就要把这个li 的索引号给 num  
            num = index;
            // 当我们点击了某个小li 就要把这个li 的索引号给 circle  
            circle = index;
            // num = circle = index;
            console.log(focusWidth);
            console.log(index);

            animate(ul, -index * focusWidth);
        })
    }
    // 把ol里面的第一个小li设置类名为 current
    ol.children[0].className = 'current';
    // 6. 克隆第一张图片(li)放到ul 最后面
    var first = ul.children[0].cloneNode(true);
    ul.appendChild(first);
    // 7. 点击右侧按钮， 图片滚动一张
    var num = 0;
    // circle 控制小圆圈的播放
    var circle = 0;
    // flag 节流阀
    var flag = true;
    arrow_r.addEventListener('click', function() {
        if (flag) {
            flag = false; // 关闭节流阀
            // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0
            if (num == ul.children.length - 1) {
                ul.style.left = 0;
                num = 0;
            }
            num++;
            animate(ul, -num * focusWidth, function() {
                flag = true; // 打开节流阀
            });
            // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle++;
            // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原
            if (circle == ol.children.length) {
                circle = 0;
            }
            // 调用函数
            circleChange();
        }
    });

    // 9. 左侧按钮做法
    arrow_l.addEventListener('click', function() {
        if (flag) {
            flag = false;
            if (num == 0) {
                num = ul.children.length - 1;
                ul.style.left = -num * focusWidth + 'px';

            }
            num--;
            animate(ul, -num * focusWidth, function() {
                flag = true;
            });
            // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle--;
            // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）
            // if (circle &lt; 0) {
            //     circle = ol.children.length - 1;
            // }
            circle = circle &lt; 0 ? ol.children.length - 1 : circle;
            // 调用函数
            circleChange();
        }
    });

    function circleChange() {
        // 先清除其余小圆圈的current类名
        for (var i = 0; i &lt; ol.children.length; i++) {
            ol.children[i].className = '';
        }
        // 留下当前的小圆圈的current类名
        ol.children[circle].className = 'current';
    }
    // 10. 自动播放轮播图
    var timer = setInterval(function() {
        //手动调用点击事件
        arrow_r.click();
    }, 2000);

})
</code></pre>
<h3 id="节流阀">节流阀</h3>
<p>防止轮播图按钮连续点击造成播放过快。</p>
<p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p>
<p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p>
<p>开始设置一个变量var flag= true;</p>
<p>If(flag){flag = false; do something}       关闭水龙头</p>
<p>利用回调函数动画执行完毕， flag = true     打开水龙头</p>
<h3 id="返回顶部">返回顶部</h3>
<ol>
<li>带有动画的返回顶部</li>
<li>此时可以继续使用我们封装的动画函数</li>
<li>只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了</li>
<li>页面滚动了多少，可以通过 window.pageYOffset 得到</li>
<li>最后是页面滚动，使用 window.scroll(x,y)</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
                // console.log(11);
                // window.pageYOffset 页面被卷去的头部
                // console.log(window.pageYOffset);
                // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
                if (window.pageYOffset &gt;= bannerTop) {
                    sliderbar.style.position = 'fixed';
                    sliderbar.style.top = sliderbarTop + 'px';
                } else {
                    sliderbar.style.position = 'absolute';
                    sliderbar.style.top = '300px';
                }
                // 4. 当我们页面滚动到main盒子，就显示 goback模块
                if (window.pageYOffset &gt;= mainTop) {
                    goBack.style.display = 'block';
                } else {
                    goBack.style.display = 'none';
                }

            })
            // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方
        goBack.addEventListener('click', function() {
            // 里面的x和y 不跟单位的 直接写数字即可
            // window.scroll(0, 0);
            // 因为是窗口滚动 所以对象是window
            animate(window, 0);
        });

</code></pre>
<h3 id="筋头云案例">筋头云案例</h3>
<ol>
<li>利用动画函数做动画效果</li>
<li>原先筋斗云的起始位置是0</li>
<li>鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可</li>
<li>鼠标离开某个小li，就把目标值设为 0</li>
<li>如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置</li>
</ol>
<pre><code class="language-javascript"> window.addEventListener('load', function() {
            // 1. 获取元素
            var cloud = document.querySelector('.cloud');
            var c_nav = document.querySelector('.c-nav');
            var lis = c_nav.querySelectorAll('li');
            // 2. 给所有的小li绑定事件 
            // 这个current 做为筋斗云的起始位置
            var current = 0;
            for (var i = 0; i &lt; lis.length; i++) {
                // (1) 鼠标经过把当前小li 的位置做为目标值
                lis[i].addEventListener('mouseenter', function() {
                    animate(cloud, this.offsetLeft);
                });
                // (2) 鼠标离开就回到起始的位置 
                lis[i].addEventListener('mouseleave', function() {
                    animate(cloud, current);
                });
                // (3) 当我们鼠标点击，就把当前位置做为目标值
                lis[i].addEventListener('click', function() {
                    current = this.offsetLeft;
                });
            }
        })

</code></pre>
<h2 id="触屏事件">触屏事件</h2>
<h3 id="触屏事件概述">触屏事件概述</h3>
<p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。</p>
<p>touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p>
<p>常见的触屏事件如下：</p>
<figure data-type="image" tabindex="26"><img src="E:%5CAPTX-4869%5Cmd%5Ctouch1.png" alt="图片1" loading="lazy"></figure>
<h3 id="触摸事件对象touchevent">触摸事件对象（TouchEvent）</h3>
<p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p>
<p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p>
<p>![图片2](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/图片2.png)</p>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="移动端拖动元素">移动端拖动元素</h3>
<ol>
<li>touchstart、touchmove、touchend 可以实现拖动元素</li>
<li>但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY</li>
<li>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li>
<li>手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</li>
</ol>
<p>拖动元素三步曲：</p>
<p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p>
<p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p>
<p>（3） 离开手指 touchend:</p>
<blockquote>
<p><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></p>
</blockquote>
<h2 id="移动端常见特效">移动端常见特效</h2>
<h3 id="案例-移动轮播图">案例: 移动轮播图</h3>
<p><code>移动端轮播图功能和基本PC端一致。</code></p>
<ol>
<li>可以自动播放图片</li>
<li>手指可以拖动播放轮播图</li>
</ol>
<h3 id="案例分析">案例分析:</h3>
<ol>
<li>
<p>自动播放功能</p>
</li>
<li>
<p>开启定时器</p>
</li>
<li>
<p>移动端移动，可以使用translate 移动</p>
</li>
<li>
<p>想要图片优雅的移动，请添加过渡效果</p>
<pre><code class="language-js"> // 1. 获取元素 
    var focus = document.querySelector('.focus');
    var ul = focus.children[0];
    // 获得focus 的宽度
    var w = focus.offsetWidth;
    var ol = focus.children[1];
    // 2. 利用定时器自动轮播图图片
    var index = 0;
    var timer = setInterval(function() {
        index++;
        var translatex = -index * w;
        ul.style.transition = 'all .3s';
        ul.style.transform = 'translateX(' + translatex + 'px)';
    }, 2000);
</code></pre>
</li>
<li>
<p>自动播放功能-无缝滚动</p>
</li>
<li>
<p>注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断</p>
</li>
<li>
<p>此时需要添加检测过渡完成事件  transitionend</p>
</li>
<li>
<p>判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
</li>
<li>
<p>如果索引号小于0， 说明是倒着走， 索引号等于2</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
<pre><code class="language-js">// 等着我们过渡完成之后，再去判断 监听过渡完成的事件 transitionend 
    ul.addEventListener('transitionend', function() {
        // 无缝滚动
        if (index &gt;= 3) {
            index = 0;
            // console.log(index);
            // 去掉过渡效果 这样让我们的ul 快速的跳到目标位置
            ul.style.transition = 'none';
            // 利用最新的索引号乘以宽度 去滚动图片
            var translatex = -index * w;
            ul.style.transform = 'translateX(' + translatex + 'px)';
        } else if (index &lt; 0) {
            index = 2;
            ul.style.transition = 'none';
            // 利用最新的索引号乘以宽度 去滚动图片
            var translatex = -index * w;
            ul.style.transform = 'translateX(' + translatex + 'px)';
        }
</code></pre>
</li>
</ol>
<h2 id="classlist-属性">classList 属性</h2>
<p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p>
<p>该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p>
<p><strong>添加类：</strong></p>
<p>element.classList.add（’类名’）；</p>
<pre><code class="language-javascript">focus.classList.add('current');
</code></pre>
<p><strong>移除类：</strong></p>
<p>element.classList.remove（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.remove('current');
</code></pre>
<p><strong>切换类：</strong></p>
<p>element.classList.toggle（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.toggle('current');
</code></pre>
<p><code>注意:以上方法里面，所有类名都不带点</code></p>
<h3 id="案例分析-2">案例分析</h3>
<ol>
<li>
<p>小圆点跟随变化效果</p>
</li>
<li>
<p>把ol里面li带有current类名的选出来去掉类名 remove</p>
</li>
<li>
<p>让当前索引号的小li 加上 current   add</p>
</li>
<li>
<p>但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面</p>
<pre><code class="language-js">// 3. 小圆点跟随变化
        // 把ol里面li带有current类名的选出来去掉类名 remove
        ol.querySelector('.current').classList.remove('current');
        // 让当前索引号 的小li 加上 current   add
        ol.children[index].classList.add('current');
</code></pre>
</li>
<li>
<p>手指滑动轮播图</p>
</li>
<li>
<p>本质就是ul跟随手指移动，简单说就是移动端拖动元素</p>
</li>
<li>
<p>触摸元素touchstart：  获取手指初始坐标</p>
</li>
<li>
<p>移动手指touchmove：  计算手指的滑动距离，并且移动盒子</p>
</li>
<li>
<p>离开手指touchend:   根据滑动的距离分不同的情况</p>
</li>
<li>
<p>如果移动距离小于某个像素  就回弹原来位置</p>
</li>
<li>
<p>如果移动距离大于某个像素就上一张下一张滑动。</p>
</li>
<li>
<p>滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑</p>
</li>
<li>
<p>如果是左滑就播放下一张 （index++）</p>
</li>
<li>
<p>如果是右滑就播放上一张  (index--)</p>
</li>
</ol>
<pre><code class="language-js">    // 4. 手指滑动轮播图 
    // 触摸元素 touchstart： 获取手指初始坐标
    var startX = 0;
    var moveX = 0; // 后面我们会使用这个移动距离所以要定义一个全局变量
    var flag = false;
    ul.addEventListener('touchstart', function(e) {
        startX = e.targetTouches[0].pageX;
        // 手指触摸的时候就停止定时器
        clearInterval(timer);
    });
    // 移动手指 touchmove： 计算手指的滑动距离， 并且移动盒子
    ul.addEventListener('touchmove', function(e) {
        // 计算移动距离
        moveX = e.targetTouches[0].pageX - startX;
        // 移动盒子：  盒子原来的位置 + 手指移动的距离 
        var translatex = -index * w + moveX;
        // 手指拖动的时候，不需要动画效果所以要取消过渡效果
        ul.style.transition = 'none';
        ul.style.transform = 'translateX(' + translatex + 'px)';
        flag = true; // 如果用户手指移动过我们再去判断否则不做判断效果
        e.preventDefault(); // 阻止滚动屏幕的行为
    });
    // 手指离开 根据移动距离去判断是回弹还是播放上一张下一张
    ul.addEventListener('touchend', function(e) {
        if (flag) {
            // (1) 如果移动距离大于50像素我们就播放上一张或者下一张
            if (Math.abs(moveX) &gt; 50) {
                // 如果是右滑就是 播放上一张 moveX 是正值
                if (moveX &gt; 0) {
                    index--;
                } else {
                    // 如果是左滑就是 播放下一张 moveX 是负值
                    index++;
                }
                var translatex = -index * w;
                ul.style.transition = 'all .3s';
                ul.style.transform = 'translateX(' + translatex + 'px)';
            } else {
                // (2) 如果移动距离小于50像素我们就回弹
                var translatex = -index * w;
                ul.style.transition = 'all .1s';
                ul.style.transform = 'translateX(' + translatex + 'px)';
            }
        }
        // 手指离开的时候就重新开启定时器
        clearInterval(timer);
        timer = setInterval(function() {
            index++;
            var translatex = -index * w;
            ul.style.transition = 'all .3s';
            ul.style.transform = 'translateX(' + translatex + 'px)';
        }, 2000);
</code></pre>
<h3 id="案例返回顶部">案例：返回顶部</h3>
<p>当页面滚动某个地方，就显示，否则隐藏</p>
<p>点击可以返回顶部</p>
<h3 id="案例分析-3">案例分析</h3>
<ol>
<li>滚动某个地方显示</li>
<li>事件：scroll页面滚动事件</li>
<li>如果被卷去的头部（window.pageYOffset ）大于某个数值</li>
<li>点击，window.scroll(0,0) 返回顶部</li>
</ol>
<pre><code class="language-js"> var goBack = document.querySelector('.goBack');
    var nav = document.querySelector('nav');
    window.addEventListener('scroll', function() {
        if (window.pageYOffset &gt;= nav.offsetTop) {
            goBack.style.display = 'block';
        } else {
            goBack.style.display = 'none';
        }
    });
    goBack.addEventListener('click', function() {
        window.scroll(0, 0);
    })
</code></pre>
<h2 id="click-延时解决方案">click 延时解决方案</h2>
<p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。</p>
<p>解决方案：</p>
<p>​	1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。</p>
<pre><code class="language-html">  &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<p>​	2.利用touch事件自己封装这个事件解决300ms 延迟。</p>
<p>​	原理就是：</p>
<ol>
<li>当我们手指触摸屏幕，记录当前触摸时间</li>
<li>当我们手指离开屏幕， 用离开的时间减去触摸的时间</li>
<li>如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击</li>
</ol>
<p>代码如下:</p>
<pre><code class="language-javascript">//封装tap，解决click 300ms 延时
function tap (obj, callback) {
        var isMove = false;
        var startTime = 0; // 记录触摸时候的时间变量
        obj.addEventListener('touchstart', function (e) {
            startTime = Date.now(); // 记录触摸时间
        });
        obj.addEventListener('touchmove', function (e) {
            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击
        });
        obj.addEventListener('touchend', function (e) {
            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) {  // 如果手指触摸和离开时间小于150ms 算点击
                callback &amp;&amp; callback(); // 执行回调函数
            }
            isMove = false;  //  取反 重置
            startTime = 0;
        });
}
//调用  
  tap(div, function(){   // 执行代码  });

</code></pre>
<ol start="3">
<li>
<p>使用插件。fastclick 插件解决300ms 延迟。</p>
<pre><code class="language-js">  &lt;script&gt;
        if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                FastClick.attach(document.body);
            }, false);
        }
        var div = document.querySelector('div');
        div.addEventListener('click', function() {
            alert(11);
        })
    &lt;/script&gt;
</code></pre>
</li>
</ol>
<h2 id="移动端常用开发插件">移动端常用开发插件</h2>
<h3 id="什么是插件">什么是插件</h3>
<p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？</p>
<p>JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。</p>
<p>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>我们以前写的animate.js 也算一个最简单的插件</p>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
<p>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://</a><a href="https://github.com/ftlabs/fastclick">github.com/ftlabs/fastclick</a></p>
<h3 id="插件的使用">插件的使用</h3>
<ol>
<li>
<p>引入 js 插件文件。</p>
</li>
<li>
<p>按照规定语法使用。</p>
</li>
<li>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
</li>
<li>
<p>GitHub官网地址： https://github.com/ftlabs/fastclick</p>
<pre><code class="language-javascript">if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                       FastClick.attach(document.body);
            }, false);
}
</code></pre>
</li>
</ol>
<h3 id="swiper-插件的使用">Swiper 插件的使用</h3>
<p>中文官网地址： https://www.swiper.com.cn/</p>
<ol>
<li>引入插件相关文件。</li>
<li>按照规定语法使用</li>
</ol>
<h3 id="其他移动端常见插件">其他移动端常见插件</h3>
<p>lsuperslide： http://www.superslide2.com/</p>
<p>l iscroll： https://github.com/cubiq/iscroll</p>
<h3 id="插件的使用总结">插件的使用总结</h3>
<p>1.确认插件实现的功能</p>
<p>2.去官网查看使用说明</p>
<p>3.下载插件</p>
<p>4.打开demo实例文件，查看需要引入的相关文件，并且引入</p>
<p>5.复制demo实例文件中的结构html，样式css以及js代码</p>
<h3 id="移动端视频插件-zymediajs">移动端视频插件 zy.media.js</h3>
<p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。</p>
<p>不同的视频格式文件，我们可以通过source解决。</p>
<p>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。</p>
<p>这个时候我们可以使用插件方式来制作。</p>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<h2 id="移动端常用开发框架">移动端常用开发框架</h2>
<h3 id="移动端视频插件-zymediajs-2">移动端视频插件 zy.media.js</h3>
<p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p>
<p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端</p>
<p>前端常用的移动端插件有 swiper、superslide、iscroll等。</p>
<p>框架： 大而全，一整套解决方案</p>
<p>插件： 小而专一，某个功能的解决方案</p>
<h3 id="bootstrap">Bootstrap</h3>
<p>Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。</p>
<p>它能开发PC端，也能开发移动端</p>
<p>Bootstrap JS插件使用步骤：</p>
<p>1.引入相关js 文件</p>
<p>2.复制HTML 结构</p>
<p>3.修改对应样式</p>
<p>4.修改相应JS 参数</p>
<h2 id="本地存储">本地存储</h2>
<p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p>
<h3 id="本地存储特性">本地存储特性</h3>
<p>1、数据存储在用户浏览器中</p>
<p>2、设置、读取方便、甚至页面刷新不丢失数据</p>
<p>3、容量较大，sessionStorage约5M、localStorage约20M</p>
<p>4、只能存储字符串，可以将对象JSON.stringify() 编码后存储</p>
<h3 id="windowsessionstorage">window.sessionStorage</h3>
<p>1、生命周期为关闭浏览器窗口</p>
<p>2、在同一个窗口(页面)下数据可以共享</p>
<p>3、以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">sessionStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">sessionStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">sessionStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">sessionStorage.clear()
</code></pre>
<h3 id="windowlocalstorage">window.localStorage</h3>
<p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3.  以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">localStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">localStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">localStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">localStorage.clear()
</code></pre>
<h3 id="记住用户名">记住用户名</h3>
<p>如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名</p>
<h4 id="案例分析-4">案例分析</h4>
<ol>
<li>
<p>把数据存起来，用到本地存储</p>
</li>
<li>
<p>关闭页面，也可以显示用户名，所以用到localStorage</p>
</li>
<li>
<p>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</p>
</li>
<li>
<p>当复选框发生改变的时候change事件</p>
</li>
<li>
<p>如果勾选，就存储，否则就移除</p>
</li>
</ol>
<pre><code class="language-js">&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;remember&quot;&gt; 记住用户名
    &lt;script&gt;
        var username = document.querySelector('#username');
        var remember = document.querySelector('#remember');
        if (localStorage.getItem('username')) {
            username.value = localStorage.getItem('username');
            remember.checked = true;
        }
        remember.addEventListener('change', function() {
            if (this.checked) {
                localStorage.setItem('username', username.value)
            } else {
                localStorage.removeItem('username');
            }
        })
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS基础]]></title>
        <id>https://xmweijh.github.io/post/js-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/js-ji-chu/">
        </link>
        <updated>2021-02-17T05:14:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="javascript基础">JavaScript基础</h1>
<h3 id="js-的组成">JS 的组成</h3>
<ol>
<li>
<h4 id="ecmascript"><strong>ECMAScript</strong></h4>
<p>ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>
<p>​		ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
<p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p>
</li>
<li>
<h4 id="dom文档对象模型"><strong>DOM——文档对象模型</strong></h4>
<p><strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p>
</li>
<li>
<h4 id="bom浏览器对象模型"><strong>BOM——浏览器对象模型</strong></h4>
<p><strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>
</li>
</ol>
<h3 id="js-书写位置">JS 书写位置</h3>
<pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。
</code></pre>
<ol>
<li>
<p>行内式</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert('Hello World')&quot; /&gt;
</code></pre>
<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>
<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
</li>
<li>
<p>内嵌式</p>
<pre><code class="language-html">&lt;script&gt;
    alert('Hello  World~!');
&lt;/script&gt;
</code></pre>
<ul>
<li>可以将多行JS代码写到 script 标签中</li>
<li>内嵌 JS 是学习时常用的方式</li>
</ul>
</li>
<li>
<p>外部JS文件</p>
<pre><code class="language-html">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
</li>
</ol>
<h3 id="javascript注释">JavaScript注释</h3>
<ul>
<li>flex子项目占的份数</li>
<li>align-self控制子项自己在侧轴的排列方式</li>
<li>order属性定义子项的排列顺序（前后顺序）</li>
</ul>
<h4 id="单行注释">单行注释</h4>
<pre><code>为了提高代码的可读性，JS与CSS一样，也提供了注释功能。
JS中的注释主要有两种，分别是 单行注释 和 多行注释。
</code></pre>
<p>单行注释的注释方式如下：</p>
<pre><code class="language-html">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来	
</code></pre>
<pre><code>// 用来注释单行文字（  快捷键   ctrl  +  /   ）
</code></pre>
<h4 id="多行注释">多行注释</h4>
<p>多行注释的注释方式如下：</p>
<pre><code class="language-html">/*
  获取用户年龄和姓名
  并通过提示框显示出来
*/
</code></pre>
<pre><code>/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） 
</code></pre>
<p>快捷键修改为：   ctrl + shift  +  /</p>
<p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p>
<h3 id="javascript输入输出语句">JavaScript输入输出语句</h3>
<p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li>
</ul>
<h3 id="变量的概念">变量的概念</h3>
<p>白话：变量就是一个装东西的盒子。</p>
<p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。</p>
<p>变量在内存中的存储</p>
<pre><code>	本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。  
</code></pre>
<h3 id="变量的使用">变量的使用</h3>
<ul>
<li>变量的声明</li>
<li>变量的赋值</li>
</ul>
<h4 id="声明变量">声明变量</h4>
<pre><code class="language-javascript">//  声明变量  
var age; //  声明一个 名称为age 的变量     
</code></pre>
<ul>
<li>
<p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p>
</li>
<li>
<p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p>
</li>
</ul>
<h4 id="赋值">赋值</h4>
<pre><code class="language-javascript">age = 10; // 给 age  这个变量赋值为 10          
</code></pre>
<ul>
<li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<h4 id="变量的初始化">变量的初始化</h4>
<pre><code class="language-js">var age  = 18;  // 声明变量同时赋值为 18
// 声明一个变量并赋值， 我们称之为变量的初始化。
</code></pre>
<h4 id="变量语法扩展">变量语法扩展</h4>
<ul>
<li>
<p>更新变量</p>
<p>​		一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<pre><code class="language-js">var age = 18;

age = 81;   // 最后的结果就是81因为18 被覆盖掉了          
</code></pre>
</li>
<li>
<p>同时声明多个变量</p>
<p>​		同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p>
<pre><code class="language-js">var age = 10,  name = 'zs', sex = 2;       
</code></pre>
</li>
<li>
<p>声明变量特殊情况</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>var  age ; console.log (age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值  直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age   = 10; console.log (age);</td>
<td>不声明   只赋值</td>
<td>10</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="变量命名规范">变量命名规范</h4>
<p>规则：</p>
<ul>
<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li>
<li>严格区分大小写。var app; 和 var App; 是两个变量</li>
<li>不能 以数字开头。  18age   是错误的</li>
<li>不能 是关键字、保留字。例如：var、for、while</li>
<li>变量名必须有意义。 MMD   BBD        nl   →     age</li>
<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>
<p>变量的数据类型</p>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定：</p>
<pre><code class="language-js">var age = 10;        // 这是一个数字型
var areYouOk = '是的';   // 这是一个字符串     
</code></pre>
<p>​		在<strong>代码运行</strong>时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着<strong>相同的变量可用作不同的类型</strong>：</p>
<pre><code class="language-js">var x = 6;           // x 为数字
var x = &quot;Bill&quot;;      // x 为字符串    
</code></pre>
</li>
<li>
<p>数据类型的分类</p>
<p>JS 把数据类型分为两类：</p>
<ul>
<li>
<p>简单数据类型 （Number,String,Boolean,Undefined,Null）</p>
</li>
<li>
<p>复杂数据类型 （object)</p>
</li>
</ul>
</li>
</ul>
<h4 id="简单数据类型">简单数据类型</h4>
<p>简单数据类型（基本数据类型）</p>
<p>JavaScript 中的简单数据类型及其说明如下：</p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8716.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>数字型 Number</p>
<p>​		JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p>
<pre><code class="language-js">var age = 21;       // 整数
var Age = 21.3747;  // 小数     
</code></pre>
<ol>
<li>
<p>数字型进制</p>
<p>最常见的进制有二进制、八进制、十进制、十六进制。</p>
<pre><code class="language-js">  // 1.八进制数字序列范围：0~7
 var num1 = 07;   // 对应十进制的7
 var num2 = 019;  // 对应十进制的19
 var num3 = 08;   // 对应十进制的8
  // 2.十六进制数字序列范围：0~9以及A~F
 var num = 0xA;   
</code></pre>
<p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x</p>
</li>
<li>
<p>数字型范围</p>
<p>JavaScript中数值的最大和最小值</p>
<ul>
<li>
<p>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</p>
</li>
<li>
<p>最小值：Number.MIN_VALUE，这个值为：5e-32</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>
<p>数字型三个特殊值</p>
<ul>
<li>
<p>Infinity ，代表无穷大，大于任何数值</p>
</li>
<li>
<p>-Infinity ，代表无穷小，小于任何数值</p>
</li>
<li>
<p>NaN ，Not a number，代表一个非数值</p>
</li>
</ul>
</li>
<li>
<p>isNaN</p>
<p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p>
</li>
</ol>
<pre><code class="language-js">  var usrAge = 21;
var isOk = isNaN(userAge);
  console.log(isNum);          // false ，21 不是一个非数字
var usrName = &quot;andy&quot;;
  console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字
</code></pre>
<ul>
<li>
<p>字符串型 String</p>
<p>​		字符串型可以是引号中的任意文本，其语法为 双引号 &quot;&quot; 和 单引号''</p>
<pre><code class="language-js">var strMsg = &quot;我爱北京天安门~&quot;;  // 使用双引号表示字符串
var strMsg2 = '我爱吃猪蹄~';    // 使用单引号表示字符串
// 常见错误
var strMsg3 = 我爱大肘子;       // 报错，没使用引号，会被认为是js代码，但js没有这些语法
</code></pre>
<p>​		因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</p>
<ol>
<li>
<p>字符串引号嵌套</p>
<p>​		JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p>
<pre><code class="language-js">var strMsg = '我是&quot;高帅富&quot;程序猿';   // 可以用''包含&quot;&quot;
var strMsg2 = &quot;我是'高帅富'程序猿&quot;;  // 也可以用&quot;&quot; 包含''
//  常见错误
var badQuotes = 'What on earth?&quot;; // 报错，不能 单双引号搭配
</code></pre>
</li>
<li>
<p>字符串转义符</p>
<p>​		类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p>
<p>​		转义符都是 \ 开头的，常用的转义符及其说明如下：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符，n   是   newline   的意思</td>
</tr>
<tr>
<td>\ \</td>
<td>斜杠   \</td>
</tr>
<tr>
<td>'</td>
<td>'   单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>”双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab  缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格 ，b   是   blank  的意思</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>字符串长度</p>
<p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p>
<pre><code class="language-js">var strMsg = &quot;我是帅气多金的程序猿！&quot;;
alert(strMsg.length); // 显示 11
</code></pre>
</li>
<li>
<p>字符串拼接</p>
<ul>
<li>
<p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p>
</li>
<li>
<p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p>
<pre><code class="language-js">//1.1 字符串 &quot;相加&quot;
alert('hello' + ' ' + 'world'); // hello world
//1.2 数值字符串 &quot;相加&quot;
alert('100' + '100'); // 100100
//1.3 数值字符串 + 数值
alert('11' + 12);     // 1112 
</code></pre>
<ul>
<li><em><strong>+ 号总结口诀：数值相加 ，字符相连</strong></em></li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串拼接加强</p>
<pre><code class="language-js">console.log('pink老师' + 18);        // 只要有字符就会相连 
var age = 18;
console.log('pink老师age岁啦');      // 这样不行哦
console.log('pink老师' + age);         // pink老师18
console.log('pink老师' + age + '岁啦'); // pink老师18岁啦
</code></pre>
<ul>
<li>经常会将字符串和变量来拼接，变量可以很方便地修改里面的值</li>
<li>变量是不能添加引号的，因为加引号的变量会变成字符串</li>
<li>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</li>
</ul>
</li>
</ol>
</li>
<li>
<p>布尔型Boolean</p>
<p>​		布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p>
<p>​		布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p>
<pre><code class="language-js">console.log(true + 1);  // 2
console.log(false + 1); // 1
</code></pre>
</li>
<li>
<p>Undefined和 Null</p>
<p>​		一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</p>
<pre><code class="language-js">var variable;
console.log(variable);           // undefined
console.log('你好' + variable);  // 你好undefined
console.log(11 + variable);     // NaN
console.log(true + variable);   //  NaN
</code></pre>
<p>​		一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p>
<pre><code class="language-js">var vari = null;
console.log('你好' + vari);  // 你好null
console.log(11 + vari);     // 11
console.log(true + vari);   //  1
</code></pre>
</li>
</ul>
<h4 id="获取变量数据类型">获取变量数据类型</h4>
<ul>
<li>
<p>获取检测变量的数据类型</p>
<p>​		typeof 可用来获取检测变量的数据类型</p>
<pre><code class="language-js">var num = 18;
console.log(typeof num) // 结果 number      
</code></pre>
</li>
<li>
<p>字面量</p>
<p>​		字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。</p>
</li>
</ul>
<h4 id="数据类型转换">数据类型转换</h4>
<p>​		什么是数据类型转换？</p>
<p>​		使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</p>
<pre><code>转换为字符串类型
转换为数字型
转换为布尔型
</code></pre>
<ul>
<li>
<p>转换为字符串</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8719.png" alt="" loading="lazy"></figure>
<ul>
<li>toString() 和 String()  使用方式不一样。</li>
<li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li>
</ul>
</li>
<li>
<p>转换为数字型（重点）</p>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8720.png" alt="" loading="lazy"></figure>
<ul>
<li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li>
<li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li>
</ul>
</li>
<li>
<p>转换为布尔型</p>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8721.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>代表空、否定的值会被转换为 false  ，如 ''、0、NaN、null、undefined</p>
</li>
<li>
<p>其余值都会被转换为 true</p>
<pre><code class="language-js">console.log(Boolean('')); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean('小白')); // true
console.log(Boolean(12)); // true
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="解释型语言和编译型语言">解释型语言和编译型语言</h3>
<pre><code>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。
</code></pre>
<ul>
<li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li>
<li>编译器是在代码执行之前进行编译，生成中间代码文件</li>
<li>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</li>
</ul>
<h4 id="执行过程">执行过程</h4>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8723.png" alt="" loading="lazy"></figure>
<pre><code>类似于请客吃饭：

	编译语言：首先把所有菜做好，才能上桌吃饭

	解释语言：好比吃火锅，边吃边涮，同时进行
</code></pre>
<h3 id="关键字和保留字">关键字和保留字</h3>
<h4 id="标识符">标识符</h4>
<pre><code>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。

标识符不能是关键字或保留字。
</code></pre>
<h4 id="关键字">关键字</h4>
<pre><code>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。

包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。
</code></pre>
<h4 id="保留字">保留字</h4>
<pre><code>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。

注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。
</code></pre>
<h3 id="运算符操作符">运算符（操作符）</h3>
<h4 id="运算符的分类">运算符的分类</h4>
<p><strong>运算符</strong>（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p>
<pre><code>JavaScript中常用的运算符有：
</code></pre>
<ul>
<li>算数运算符</li>
<li>递增和递减运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ul>
<h4 id="算数运算符">算数运算符</h4>
<ul>
<li>
<p>算术运算符概述</p>
<p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。</p>
</li>
<li>
<p>浮点数的精度问题</p>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p>
<pre><code class="language-js">var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004
console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001
</code></pre>
<p>所以：不要直接判断两个浮点数是否相等 !</p>
</li>
<li>
<p>表达式和返回值</p>
<p>表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合</p>
<p>简单理解：是由数字、运算符、变量等组成的式子</p>
<p>表达式最终都会有一个结果，返回给开发者，称为返回值</p>
</li>
</ul>
<h4 id="递增和递减运算符">递增和递减运算符</h4>
<ul>
<li>
<p>递增和递减运算符概述</p>
<p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。</p>
<p>在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。</p>
<p>注意：递增和递减运算符必须和变量配合使用。</p>
</li>
<li>
<p>递增运算符</p>
<ul>
<li>
<p>前置递增运算符</p>
<p>++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。</p>
<p>使用口诀：先自加，后返回值</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(++num + 10);   // 21
</code></pre>
<ul>
<li>
<p>后置递增运算符</p>
<p>num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。</p>
<p>使用口诀：先返回原值，后自加</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(10 + num++);  // 20
</code></pre>
</li>
</ul>
<h4 id="比较运算符">比较运算符</h4>
<ul>
<li>
<p>比较运算符概述</p>
<p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。</p>
</li>
<li>
<p>等号比较</p>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%873.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">console.log(18 == '18');
console.log(18 === '18'); 
</code></pre>
</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ul>
<li>
<p>逻辑运算符概述</p>
<p>概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p>
</li>
<li>
<p>逻辑与&amp;&amp;</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑或 ||</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑非 ！</p>
<p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p>
<pre><code class="language-js">var isOk = !true;
console.log(isOk);  // false
</code></pre>
</li>
<li>
<p>短路运算（逻辑中断）</p>
<p>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p>
<ul>
<li>
<p>逻辑与</p>
<p>语法： 表达式1 &amp;&amp; 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式2

- 如果第一个表达式的值为假，则返回表达式1
</code></pre>
<pre><code class="language-js">console.log( 123 &amp;&amp; 456 );        // 456
console.log( 0 &amp;&amp; 456 );          // 0
console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789
</code></pre>
</li>
<li>
<p>逻辑或</p>
<p>语法： 表达式1 || 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式1

- 如果第一个表达式的值为假，则返回表达式2
</code></pre>
<pre><code class="language-js">console.log( 123 || 456 );         //  123
console.log( 0 ||  456 );          //  456
console.log( 123 || 456 || 789 );  //  123
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<pre><code>概念：用来把数据赋值给变量的运算符。
</code></pre>
<pre><code class="language-js">var age = 10;
age += 5;  // 相当于 age = age + 5;
age -= 5;  // 相当于 age = age - 5;
age *= 10; // 相当于 age = age * 10;
</code></pre>
<h4 id="运算符优先级">运算符优先级</h4>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8710.png" alt="" loading="lazy"></figure>
<ul>
<li>一元运算符里面的逻辑非优先级很高</li>
<li>逻辑与比逻辑或优先级高</li>
</ul>
<h3 id="流程控制">流程控制</h3>
<h4 id="流程控制概念">流程控制概念</h4>
<pre><code>在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解：**流程控制就是来控制代码按照一定结构顺序来执行**

流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。
</code></pre>
<ul>
<li>
<p>switch 语句和 if else if 语句的区别</p>
<ul>
<li>一般情况下，它们两个语句可以相互替换</li>
<li>switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)</li>
<li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。</li>
<li>当分支比较少时，if… else语句的执行效率比 switch语句高。</li>
<li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。</li>
</ul>
</li>
</ul>
<p>断点调试：</p>
<pre><code>	断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程
</code></pre>
<pre><code class="language-html">断点调试的流程：
1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点
2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。
3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
</code></pre>
<h3 id="标识符命名规范">标识符命名规范</h3>
<ul>
<li>变量、函数的命名必须要有意义</li>
<li>变量的名称一般用名词</li>
<li>函数的名称一般用动词</li>
</ul>
<h4 id="操作符规范">操作符规范</h4>
<pre><code class="language-js">// 操作符的左右两侧各保留一个空格
for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 直接退出整个 for 循环，跳到整个for循环下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="单行注释规范">单行注释规范</h4>
<pre><code class="language-js">for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 单行注释前面注意有个空格
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="其他规范">其他规范</h4>
<pre><code>关键词、操作符之间后加空格
</code></pre>
<h3 id="创建数组">创建数组</h3>
<p>JS 中创建数组有两种方式：</p>
<ul>
<li>
<p>利用  new 创建数组</p>
<pre><code class="language-js">var 数组名 = new Array() ；
var arr = new Array();   // 创建一个新的空数组
</code></pre>
<p>注意 Array () ，A 要大写</p>
</li>
<li>
<p>利用数组字面量创建数组</p>
<pre><code class="language-js">//1. 使用数组字面量方式创建空的数组
var  数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var  数组名 = ['小白','小黑','大黄','瑞奇'];
</code></pre>
<ul>
<li>数组的字面量是方括号 [ ]</li>
<li>声明数组并赋值称为数组的初始化</li>
<li>这种字面量方式也是我们以后最多使用的方式</li>
</ul>
</li>
<li>
<p>数组元素的类型</p>
<p>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p>
<pre><code class="language-js">var arrStus = ['小白',12,true,28.9];
</code></pre>
</li>
</ul>
<h3 id="获取数组中的元素">获取数组中的元素</h3>
<p>​		索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</p>
<p>​		数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</p>
<pre><code class="language-js">// 定义数组
var arrStus = [1,2,3];
// 获取数组中的第2个元素
alert(arrStus[1]);    
</code></pre>
<p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</p>
<h3 id="遍历数组">遍历数组</h3>
<ul>
<li>
<p>数组遍历</p>
<p>​		把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</p>
</li>
</ul>
<pre><code class="language-js">var arr = ['red','green', 'blue'];
for(var i = 0; i &lt; arr.length; i++){
    console.log(arrStus[i]);
}
</code></pre>
<ul>
<li>
<p>数组的长度</p>
<p>数组的长度：默认情况下表示数组中元素的个数</p>
<p>使用“数组名.length”可以访问数组元素的数量（数组长度）。</p>
<pre><code class="language-js">var arrStus = [1,2,3];
alert(arrStus.length);  // 3
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</li>
</ul>
</li>
<li>
<p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p>
<ul>
<li>数组的length属性可以被修改：</li>
</ul>
</li>
<li>
<p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p>
<ul>
<li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li>
</ul>
</li>
</ul>
<h3 id="数组中新增元素">数组中新增元素</h3>
<p>​		数组中可以通过以下方式在数组的末尾插入新元素：</p>
<pre><code class="language-js">  数组[ 数组.length ] = 新数据;
</code></pre>
<h2 id="函数">函数</h2>
<h3 id="函数的概念">函数的概念</h3>
<p>​		在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。</p>
<p>​		函数：就是<strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以<strong>实现大量代码的重复使用</strong>。</p>
<h3 id="函数的使用">函数的使用</h3>
<h4 id="声明函数">声明函数</h4>
<pre><code class="language-js">// 声明函数
function 函数名() {
    //函数体代码
}
</code></pre>
<ul>
<li>
<p>function 是声明函数的关键字,必须小写</p>
</li>
<li>
<p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p>
</li>
</ul>
<h4 id="调用函数">调用函数</h4>
<pre><code class="language-js">// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
</code></pre>
<ul>
<li>
<p>调用的时候千万不要忘记添加小括号</p>
</li>
<li>
<p>口诀：函数不调用，自己不执行</p>
<p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p>
</li>
</ul>
<h4 id="函数的封装">函数的封装</h4>
<ul>
<li>
<p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</p>
</li>
<li>
<p>简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）</p>
<p>例子：封装计算1-100累加和</p>
<pre><code class="language-js">/* 
   计算1-100之间值的函数
*/
// 声明函数
function getSum(){
  var sumNum = 0;// 准备一个变量，保存数字和
  for (var i = 1; i &lt;= 100; i++) {
    sumNum += i;// 把每个数值 都累加 到变量中
  }
  alert(sumNum);
}
// 调用函数
getSum();
</code></pre>
</li>
</ul>
<h3 id="函数的参数">函数的参数</h3>
<h4 id="函数参数语法">函数参数语法</h4>
<ul>
<li>
<p>形参：函数定义时设置接收调用时传入</p>
</li>
<li>
<p>实参：函数调用时传入小括号内的真实数据</p>
<p>​	参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</p>
<p>函数参数的运用：</p>
<pre><code class="language-js">// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
</code></pre>
<ol>
<li>调用的时候实参值是传递给形参的</li>
<li>形参简单理解为：不用声明的变量</li>
<li>实参和形参的多个参数之间用逗号（,）分隔</li>
</ol>
</li>
</ul>
<h4 id="函数形参和实参数量不匹配时">函数形参和实参数量不匹配时</h4>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%874.png" alt="" loading="lazy"></figure>
<pre><code>注意：在JavaScript中，形参的默认值是undefined。
</code></pre>
<p>小结：</p>
<ul>
<li>函数可以带参数也可以不带参数</li>
<li>声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined</li>
<li>调用函数的时候，函数名括号里面的是实参</li>
<li>多个参数中间用逗号分隔</li>
<li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li>
</ul>
<h3 id="函数的返回值">函数的返回值</h3>
<h4 id="return-语句">return 语句</h4>
<pre><code>返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。
</code></pre>
<pre><code class="language-js">// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
</code></pre>
<ul>
<li>在使用 return 语句时，函数会停止执行，并返回指定的值</li>
<li>如果函数没有 return ，返回的值是 undefined</li>
</ul>
<h4 id="break-continue-return-的区别">break ,continue ,return 的区别</h4>
<ul>
<li>break ：结束当前的循环体（如 for、while）</li>
<li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li>
<li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li>
</ul>
<h3 id="arguments的使用">arguments的使用</h3>
<p>​		当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>
<p>具有 length 属性</p>
</li>
<li>
<p>按索引方式储存数据</p>
</li>
<li>
<p>不具有数组的 push , pop 等方法</p>
<p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p>
<pre><code class="language-javascript">    &lt;script&gt;
        // 利用函数求任意个数的最大值
        function getMax() { // arguments = [1,2,3]
            var max = arguments[0];
            for (var i = 1; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) {
                    max = arguments[i];
                }
            }
            return max;
        }
        console.log(getMax(1, 2, 3));
        console.log(getMax(1, 2, 3, 4, 5));
        console.log(getMax(11, 2, 34, 444, 5, 100));
    &lt;/script&gt;
</code></pre>
</li>
</ul>
<h3 id="函数案例">函数案例</h3>
<pre><code>	函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。
</code></pre>
<h3 id="函数的两种声明方式">函数的两种声明方式</h3>
<ul>
<li>
<p>自定义函数方式(命名函数)</p>
<p>利用函数关键字 function 自定义函数方式</p>
<pre><code class="language-js">// 声明定义方式
function fn() {...}
// 调用  
fn();  
</code></pre>
<ul>
<li>因为有名字，所以也被称为命名函数</li>
<li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li>
</ul>
</li>
<li>
<p>函数表达式方式(匿名函数）</p>
<p>利用函数表达式方式的写法如下：</p>
<pre><code class="language-js">// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
</code></pre>
<ul>
<li>因为函数没有名字，所以也被称为匿名函数</li>
<li>这个fn 里面存储的是一个函数</li>
<li>函数表达式方式原理跟声明变量方式是一致的</li>
<li>函数调用的代码必须写到函数体后面</li>
</ul>
</li>
</ul>
<p>​    <strong>1. 我们js引擎运行js 分为两步： 预解析 代码执行</strong></p>
<p>​    (1). 预解析 js引擎会把js 里面所有的 var 还有 function 提升到当前作用域的最前面</p>
<p>​    (2). 代码执行 按照代码书写的顺序从上往下执行</p>
<p>​    <strong>2. 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）</strong></p>
<p>​    (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作</p>
<p>​    (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数</p>
<h3 id="创建对象的三种方式">创建对象的三种方式</h3>
<ul>
<li>
<p>利用字面量创建对象</p>
<h5 id="使用对象字面量创建对象"><strong>使用对象字面量创建对象</strong>：</h5>
<pre><code>  就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 
</code></pre>
<ul>
<li>
<p>键：相当于属性名</p>
</li>
<li>
<p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p>
<p>代码如下：</p>
<pre><code class="language-js">var star = {
    name : 'pink',
    age : 18,
    sex : '男',
    sayHi : function(){
        alert('大家好啊~');
    }
};
</code></pre>
<p>对象[‘属性名’]，注意方括号里面的属性必须加引号</p>
</li>
<li>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">console.log(star.name)     // 调用名字属性
console.log(star['name'])  // 调用名字属性
</code></pre>
</li>
</ul>
</li>
<li>
<p>调用对象的方法</p>
<ul>
<li>
<p>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号</p>
<p>示例代码如下：</p>
<pre><code class="language-js">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号
</code></pre>
</li>
</ul>
</li>
<li>
<p>变量、属性、函数、方法总结</p>
<pre><code>属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器
</code></pre>
<ul>
<li>
<p>变量：单独声明赋值，单独存在</p>
</li>
<li>
<p>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</p>
<p>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</p>
</li>
<li>
<p>函数：单独存在的，通过“函数名()”的方式就可以调用</p>
</li>
<li>
<p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用 new Object 创建对象</p>
<ul>
<li>
<p>创建空对象</p>
<pre><code class="language-js">var andy = new Obect();
</code></pre>
<p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p>
</li>
<li>
<p>给空对象添加属性和方法</p>
<ul>
<li>
<p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p>
<p>示例代码如下：</p>
</li>
</ul>
<pre><code class="language-js">andy.name = 'pink';
andy.age = 18;
andy.sex = '男';
andy.sayHi = function(){
    alert('大家好啊~');
}
</code></pre>
<p>注意：</p>
<ul>
<li>Object() ：第一个字母大写</li>
<li>new Object() ：需要 new 关键字</li>
<li>使用的格式：对象.属性 =  值;</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用构造函数创建对象</p>
<ul>
<li>
<p>构造函数</p>
<ul>
<li>
<p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
</li>
<li>
<p>构造函数的封装格式：</p>
<pre><code class="language-js">function 构造函数名(形参1,形参2,形参3) {
     this.属性名1 = 参数1;
     this.属性名2 = 参数2;
     this.属性名3 = 参数3;
     this.方法名 = 函数体;
}
</code></pre>
</li>
<li>
<p>构造函数的调用格式</p>
<pre><code>var obj = new 构造函数名(实参1，实参2，实参3)
</code></pre>
<p>以上代码中，obj即接收到构造函数创建出来的对象。</p>
</li>
<li>
<p>注意事项</p>
<ol>
<li>构造函数约定<strong>首字母大写</strong>。</li>
<li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li>
<li>构造函数中<strong>不需要 return 返回结果</strong>。</li>
<li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li>
</ol>
</li>
<li>
<p>其他</p>
<p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>
创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>new关键字的作用</p>
<ol>
<li>在构造函数代码开始执行之前，创建一个空对象；</li>
<li>修改this的指向，把this指向创建出来的空对象；</li>
<li>执行函数的代码</li>
<li>在函数完成之后，返回this---即创建出来的对象</li>
</ol>
<h3 id="遍历对象">遍历对象</h3>
<p>for...in 语句用于对数组或者对象的属性进行循环操作。</p>
<p>其语法如下：</p>
<pre><code class="language-js">for (变量 in 对象名字) {
    // 在此执行代码
}
</code></pre>
<p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p>
<pre><code class="language-js">for (var k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
</code></pre>
</li>
</ul>
<h3 id="预解析的相关概念">预解析的相关概念</h3>
<pre><code>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。
</code></pre>
<ul>
<li>
<p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中<strong>进行提前声明或者定义。</strong></p>
</li>
<li>
<p>代码执行： 从上到下执行JS语句。</p>
<p><strong>预解析会把变量和函数的声明在代码执行之前执行完成。</strong></p>
</li>
</ul>
<p>变量预解析</p>
<pre><code>预解析也叫做变量、函数提升。
变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。
</code></pre>
<pre><code class="language-js">console.log(num);  // 结果是多少？
var num = 10;      // ？
</code></pre>
<pre><code>结果：undefined

注意：**变量提升只提升声明，不提升赋值**
</code></pre>
<p>函数预解析</p>
<pre><code>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。
</code></pre>
<pre><code class="language-js">fn();
function fn() {
    console.log('打印');
}
</code></pre>
<pre><code>结果：控制台打印字符串 --- ”打印“ 

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	
</code></pre>
<p>函数表达式声明函数问题</p>
<pre><code>函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：
</code></pre>
<pre><code class="language-js">fn();
var  fn = function() {
    console.log('想不到吧');
}
</code></pre>
<pre><code>结果：报错提示 ”fn is not a function&quot;

解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
</code></pre>
<pre><code class="language-javascript">//函数的预解析
		var num=1;
		function demo(){
			console.log(num);
			function demoSon(){
				num=3;
			}
			var num=2;
			demoSon();
		}
		demo();

//相当于
var num;//作用域在全局
		function demo();
		num=1;
		function demo(){
			var num;
			function demoSon();
			console.log(num);
			function demoSon(){
				num=3;
			}
			num=2;//num在函数作用域
			demoSon();
		}
		demo();
//var num = 2，声明会提前，但不会赋值 num会变为undefined 所以不会输出1 
</code></pre>
<p>JavaScript 中的对象分为3种：<strong>自定义对象 、内置对象、 浏览器对象</strong><br>
​		前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是<strong>最基本而必要的功能</strong>（属性和方法），内置对象最大的优点就是帮助我们快速开发</p>
<p>​	 	JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</p>
<h3 id="math对象">Math对象</h3>
<p>​		Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p>
<table>
<thead>
<tr>
<th>属性、方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.round()</td>
<td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td>
</tr>
<tr>
<td>Math.abs()</td>
<td>绝对值</td>
</tr>
<tr>
<td>Math.max()/Math.min()</td>
<td>求最大和最小值</td>
</tr>
<tr>
<td>Math.random()</td>
<td>获取范围在[0,1)内的随机值</td>
</tr>
</tbody>
</table>
<p>​	注意：上面的方法使用时必须带括号</p>
<pre><code class="language-js">console.log(Math.round(1.5)); // 2
console.log(Math.round(-1.5)); // 这个结果是 -1
</code></pre>
<p>​	<strong>获取指定范围内的随机整数</strong>：</p>
<pre><code class="language-javascript"> function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min; 
}
</code></pre>
<h3 id="日期对象">日期对象</h3>
<p>​	 	Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p>
<ul>
<li>
<p>使用Date实例化日期对象</p>
<ul>
<li>获取当前时间必须实例化：</li>
</ul>
<pre><code class="language-js">var now = new Date();
</code></pre>
<ul>
<li>获取指定时间的日期对象</li>
</ul>
<pre><code class="language-js">var future = new Date('2010/5/1');
</code></pre>
<p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p>
</li>
<li>
<p>使用Date实例的方法和属性</p>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5Ctime1.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>通过Date实例获取总毫米数</p>
<ul>
<li>
<p>总毫秒数的含义</p>
<p>​	基于1970年1月1日（世界标准时间）起的毫秒数</p>
</li>
<li>
<p>获取总毫秒数</p>
<pre><code class="language-js">// 实例化Date对象
var now = new Date();
// 1. 用于获取对象的原始值
console.log(date.valueOf())	
console.log(date.getTime())	
// 2. 简单写可以这么做
var now = + new Date();			
// 3. HTML5中提供的方法，有兼容性问题
var now = Date.now();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="数组对象">数组对象</h3>
<h4 id="创建数组的两种方式">创建数组的两种方式</h4>
<ul>
<li>
<p>字面量方式</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">var arr = [1,&quot;test&quot;,true];
</code></pre>
</li>
</ul>
</li>
<li>
<p>new Array()</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code>var arr = new Array();
</code></pre>
<p>​	注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p>
<p>​	参数传递规则如下：</p>
<ul>
<li>
<p>如果只传入一个参数，则参数规定了数组的长度</p>
</li>
<li>
<p>如果传入了多个参数，则参数称为数组的元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="检测是否为数组">检测是否为数组</h4>
<ul>
<li>
<p>instanceof 运算符</p>
<ul>
<li>
<p>instanceof 可以判断一个对象是否是某个构造函数的实例</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
</code></pre>
</li>
</ul>
</li>
<li>
<p>Array.isArray()</p>
<ul>
<li>
<p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(Array.isArray(arr));   // true
console.log(Array.isArray(obj));   // false
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="添加删除数组元素的方法">添加删除数组元素的方法</h4>
<ul>
<li>
<p>数组中有进行增加、删除元素的方法，部分方法如下表</p>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5Cp%E5%9B%BE%E7%89%872.png" alt="" loading="lazy"></figure>
<p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p>
</li>
</ul>
<h4 id="数组排序">数组排序</h4>
<ul>
<li>
<p>数组中有对数组本身排序的方法，部分方法如下表</p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5Carray3.png" alt="" loading="lazy"></figure>
<p>注意：sort方法需要传入参数来设置升序、降序排序</p>
<ul>
<li>如果传入“function(a,b){ return a-b;}”，则为升序</li>
<li>如果传入“function(a,b){ return b-a;}”，则为降序</li>
</ul>
</li>
</ul>
<h4 id="数组索引方法">数组索引方法</h4>
<ul>
<li>
<p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5Carray4.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h4 id="数组转换为字符串">数组转换为字符串</h4>
<ul>
<li>
<p>数组中有把数组转化为字符串的方法，部分方法如下表</p>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5Carray5.png" alt="" loading="lazy"></figure>
<p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p>
</li>
</ul>
<h4 id="其他方法">其他方法</h4>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5Carray6.png" alt="" loading="lazy"></figure>
<h3 id="字符串对象">字符串对象</h3>
<h4 id="基本包装类型">基本包装类型</h4>
<p>​		为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p>
<p>​		基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<pre><code class="language-js">// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
</code></pre>
<p>​		按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为</p>
<p>​		js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p>
<pre><code class="language-js">// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
</code></pre>
<h4 id="字符串的不可变">字符串的不可变</h4>
<p>​		指的是里面的值不可变，虽然看上去可以改变内容，但其实是<strong>地址变了</strong>，内存中新开辟了一个内存空间。</p>
<p>​		当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>
​		由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</p>
<h4 id="根据字符返回位置">根据字符返回位置</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5Carray7.png" alt="" loading="lazy"></figure>
<p>​		案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数</p>
<ol>
<li>先查找第一个o出现的位置</li>
<li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li>
<li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</li>
</ol>
<h4 id="根据位置返回字符">根据位置返回字符</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5Carray8.png" alt="" loading="lazy"></figure>
<p>​		在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码</p>
<p>​		案例：判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数</p>
<ol>
<li>
<p>核心算法：利用 charAt(） 遍历这个字符串</p>
</li>
<li>
<p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p>
</li>
<li>
<p>遍历对象，得到最大值和该字符</p>
<p>​	注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数</p>
</li>
</ol>
<h4 id="字符串操作方法">字符串操作方法</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</p>
<figure data-type="image" tabindex="17"><img src="E:%5CAPTX-4869%5Cmd%5Cstring10.png" alt="" loading="lazy"></figure>
<h4 id="replace方法">replace()方法</h4>
<p>​		replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</p>
<pre><code>字符串.replace(被替换的字符串， 要替换为的字符串)；
</code></pre>
<h4 id="split方法">split()方法</h4>
<p>​		split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<p>​		其使用格式如下：</p>
<pre><code>字符串.split(&quot;分割字符&quot;)
</code></pre>
<h2 id="简单数据类型和复杂数据类型">简单数据类型和复杂数据类型</h2>
<h3 id="简单数据类型-2">简单数据类型</h3>
<p>​		<strong>简单类型</strong>（<strong>基本数据类型</strong>、<strong>值类型</strong>）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</p>
<h3 id="复杂数据类型">复杂数据类型</h3>
<p>​		<strong>复杂数据类型（引用类型）</strong>：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</p>
<h3 id="堆栈">堆栈</h3>
<ul>
<li>堆栈空间分配区别：</li>
</ul>
<p>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>简单数据类型存放到栈里面</p>
<p>2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
<ul>
<li>
<p>简单数据类型的存储方式</p>
<p>​		值类型变量的数据直接存放在变量（栈空间）中</p>
</li>
<li>
<p>复杂数据类型的存储方式</p>
<p>​		引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</p>
</li>
</ul>
<h3 id="简单类型传参">简单类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<h3 id="复杂数据类型传参">复杂数据类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xmweijh.github.io/</id>
    <title>小虾米的记录</title>
    <updated>2021-02-17T05:15:43.314Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xmweijh.github.io/"/>
    <link rel="self" href="https://xmweijh.github.io/atom.xml"/>
    <subtitle>努力成就自我</subtitle>
    <logo>https://xmweijh.github.io/images/avatar.png</logo>
    <icon>https://xmweijh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小虾米的记录</rights>
    <entry>
        <title type="html"><![CDATA[JS基础]]></title>
        <id>https://xmweijh.github.io/post/js-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/js-ji-chu/">
        </link>
        <updated>2021-02-17T05:14:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="javascript基础">JavaScript基础</h1>
<h3 id="js-的组成">JS 的组成</h3>
<ol>
<li>
<h4 id="ecmascript"><strong>ECMAScript</strong></h4>
<p>ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>
<p>​		ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
<p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p>
</li>
<li>
<h4 id="dom文档对象模型"><strong>DOM——文档对象模型</strong></h4>
<p><strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p>
</li>
<li>
<h4 id="bom浏览器对象模型"><strong>BOM——浏览器对象模型</strong></h4>
<p><strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>
</li>
</ol>
<h3 id="js-书写位置">JS 书写位置</h3>
<pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。
</code></pre>
<ol>
<li>
<p>行内式</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert('Hello World')&quot; /&gt;
</code></pre>
<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>
<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
</li>
<li>
<p>内嵌式</p>
<pre><code class="language-html">&lt;script&gt;
    alert('Hello  World~!');
&lt;/script&gt;
</code></pre>
<ul>
<li>可以将多行JS代码写到 script 标签中</li>
<li>内嵌 JS 是学习时常用的方式</li>
</ul>
</li>
<li>
<p>外部JS文件</p>
<pre><code class="language-html">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
</li>
</ol>
<h3 id="javascript注释">JavaScript注释</h3>
<ul>
<li>flex子项目占的份数</li>
<li>align-self控制子项自己在侧轴的排列方式</li>
<li>order属性定义子项的排列顺序（前后顺序）</li>
</ul>
<h4 id="单行注释">单行注释</h4>
<pre><code>为了提高代码的可读性，JS与CSS一样，也提供了注释功能。
JS中的注释主要有两种，分别是 单行注释 和 多行注释。
</code></pre>
<p>单行注释的注释方式如下：</p>
<pre><code class="language-html">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来	
</code></pre>
<pre><code>// 用来注释单行文字（  快捷键   ctrl  +  /   ）
</code></pre>
<h4 id="多行注释">多行注释</h4>
<p>多行注释的注释方式如下：</p>
<pre><code class="language-html">/*
  获取用户年龄和姓名
  并通过提示框显示出来
*/
</code></pre>
<pre><code>/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） 
</code></pre>
<p>快捷键修改为：   ctrl + shift  +  /</p>
<p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p>
<h3 id="javascript输入输出语句">JavaScript输入输出语句</h3>
<p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li>
</ul>
<h3 id="变量的概念">变量的概念</h3>
<p>白话：变量就是一个装东西的盒子。</p>
<p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。</p>
<p>变量在内存中的存储</p>
<pre><code>	本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。  
</code></pre>
<h3 id="变量的使用">变量的使用</h3>
<ul>
<li>变量的声明</li>
<li>变量的赋值</li>
</ul>
<h4 id="声明变量">声明变量</h4>
<pre><code class="language-javascript">//  声明变量  
var age; //  声明一个 名称为age 的变量     
</code></pre>
<ul>
<li>
<p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p>
</li>
<li>
<p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p>
</li>
</ul>
<h4 id="赋值">赋值</h4>
<pre><code class="language-javascript">age = 10; // 给 age  这个变量赋值为 10          
</code></pre>
<ul>
<li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<h4 id="变量的初始化">变量的初始化</h4>
<pre><code class="language-js">var age  = 18;  // 声明变量同时赋值为 18
// 声明一个变量并赋值， 我们称之为变量的初始化。
</code></pre>
<h4 id="变量语法扩展">变量语法扩展</h4>
<ul>
<li>
<p>更新变量</p>
<p>​		一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<pre><code class="language-js">var age = 18;

age = 81;   // 最后的结果就是81因为18 被覆盖掉了          
</code></pre>
</li>
<li>
<p>同时声明多个变量</p>
<p>​		同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p>
<pre><code class="language-js">var age = 10,  name = 'zs', sex = 2;       
</code></pre>
</li>
<li>
<p>声明变量特殊情况</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>var  age ; console.log (age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值  直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age   = 10; console.log (age);</td>
<td>不声明   只赋值</td>
<td>10</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="变量命名规范">变量命名规范</h4>
<p>规则：</p>
<ul>
<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li>
<li>严格区分大小写。var app; 和 var App; 是两个变量</li>
<li>不能 以数字开头。  18age   是错误的</li>
<li>不能 是关键字、保留字。例如：var、for、while</li>
<li>变量名必须有意义。 MMD   BBD        nl   →     age</li>
<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>
<p>变量的数据类型</p>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定：</p>
<pre><code class="language-js">var age = 10;        // 这是一个数字型
var areYouOk = '是的';   // 这是一个字符串     
</code></pre>
<p>​		在<strong>代码运行</strong>时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着<strong>相同的变量可用作不同的类型</strong>：</p>
<pre><code class="language-js">var x = 6;           // x 为数字
var x = &quot;Bill&quot;;      // x 为字符串    
</code></pre>
</li>
<li>
<p>数据类型的分类</p>
<p>JS 把数据类型分为两类：</p>
<ul>
<li>
<p>简单数据类型 （Number,String,Boolean,Undefined,Null）</p>
</li>
<li>
<p>复杂数据类型 （object)</p>
</li>
</ul>
</li>
</ul>
<h4 id="简单数据类型">简单数据类型</h4>
<p>简单数据类型（基本数据类型）</p>
<p>JavaScript 中的简单数据类型及其说明如下：</p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8716.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>数字型 Number</p>
<p>​		JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p>
<pre><code class="language-js">var age = 21;       // 整数
var Age = 21.3747;  // 小数     
</code></pre>
<ol>
<li>
<p>数字型进制</p>
<p>最常见的进制有二进制、八进制、十进制、十六进制。</p>
<pre><code class="language-js">  // 1.八进制数字序列范围：0~7
 var num1 = 07;   // 对应十进制的7
 var num2 = 019;  // 对应十进制的19
 var num3 = 08;   // 对应十进制的8
  // 2.十六进制数字序列范围：0~9以及A~F
 var num = 0xA;   
</code></pre>
<p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x</p>
</li>
<li>
<p>数字型范围</p>
<p>JavaScript中数值的最大和最小值</p>
<ul>
<li>
<p>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</p>
</li>
<li>
<p>最小值：Number.MIN_VALUE，这个值为：5e-32</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>
<p>数字型三个特殊值</p>
<ul>
<li>
<p>Infinity ，代表无穷大，大于任何数值</p>
</li>
<li>
<p>-Infinity ，代表无穷小，小于任何数值</p>
</li>
<li>
<p>NaN ，Not a number，代表一个非数值</p>
</li>
</ul>
</li>
<li>
<p>isNaN</p>
<p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p>
</li>
</ol>
<pre><code class="language-js">  var usrAge = 21;
var isOk = isNaN(userAge);
  console.log(isNum);          // false ，21 不是一个非数字
var usrName = &quot;andy&quot;;
  console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字
</code></pre>
<ul>
<li>
<p>字符串型 String</p>
<p>​		字符串型可以是引号中的任意文本，其语法为 双引号 &quot;&quot; 和 单引号''</p>
<pre><code class="language-js">var strMsg = &quot;我爱北京天安门~&quot;;  // 使用双引号表示字符串
var strMsg2 = '我爱吃猪蹄~';    // 使用单引号表示字符串
// 常见错误
var strMsg3 = 我爱大肘子;       // 报错，没使用引号，会被认为是js代码，但js没有这些语法
</code></pre>
<p>​		因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</p>
<ol>
<li>
<p>字符串引号嵌套</p>
<p>​		JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p>
<pre><code class="language-js">var strMsg = '我是&quot;高帅富&quot;程序猿';   // 可以用''包含&quot;&quot;
var strMsg2 = &quot;我是'高帅富'程序猿&quot;;  // 也可以用&quot;&quot; 包含''
//  常见错误
var badQuotes = 'What on earth?&quot;; // 报错，不能 单双引号搭配
</code></pre>
</li>
<li>
<p>字符串转义符</p>
<p>​		类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p>
<p>​		转义符都是 \ 开头的，常用的转义符及其说明如下：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符，n   是   newline   的意思</td>
</tr>
<tr>
<td>\ \</td>
<td>斜杠   \</td>
</tr>
<tr>
<td>'</td>
<td>'   单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>”双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab  缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格 ，b   是   blank  的意思</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>字符串长度</p>
<p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p>
<pre><code class="language-js">var strMsg = &quot;我是帅气多金的程序猿！&quot;;
alert(strMsg.length); // 显示 11
</code></pre>
</li>
<li>
<p>字符串拼接</p>
<ul>
<li>
<p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p>
</li>
<li>
<p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p>
<pre><code class="language-js">//1.1 字符串 &quot;相加&quot;
alert('hello' + ' ' + 'world'); // hello world
//1.2 数值字符串 &quot;相加&quot;
alert('100' + '100'); // 100100
//1.3 数值字符串 + 数值
alert('11' + 12);     // 1112 
</code></pre>
<ul>
<li><em><strong>+ 号总结口诀：数值相加 ，字符相连</strong></em></li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串拼接加强</p>
<pre><code class="language-js">console.log('pink老师' + 18);        // 只要有字符就会相连 
var age = 18;
console.log('pink老师age岁啦');      // 这样不行哦
console.log('pink老师' + age);         // pink老师18
console.log('pink老师' + age + '岁啦'); // pink老师18岁啦
</code></pre>
<ul>
<li>经常会将字符串和变量来拼接，变量可以很方便地修改里面的值</li>
<li>变量是不能添加引号的，因为加引号的变量会变成字符串</li>
<li>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</li>
</ul>
</li>
</ol>
</li>
<li>
<p>布尔型Boolean</p>
<p>​		布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p>
<p>​		布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p>
<pre><code class="language-js">console.log(true + 1);  // 2
console.log(false + 1); // 1
</code></pre>
</li>
<li>
<p>Undefined和 Null</p>
<p>​		一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</p>
<pre><code class="language-js">var variable;
console.log(variable);           // undefined
console.log('你好' + variable);  // 你好undefined
console.log(11 + variable);     // NaN
console.log(true + variable);   //  NaN
</code></pre>
<p>​		一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p>
<pre><code class="language-js">var vari = null;
console.log('你好' + vari);  // 你好null
console.log(11 + vari);     // 11
console.log(true + vari);   //  1
</code></pre>
</li>
</ul>
<h4 id="获取变量数据类型">获取变量数据类型</h4>
<ul>
<li>
<p>获取检测变量的数据类型</p>
<p>​		typeof 可用来获取检测变量的数据类型</p>
<pre><code class="language-js">var num = 18;
console.log(typeof num) // 结果 number      
</code></pre>
</li>
<li>
<p>字面量</p>
<p>​		字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。</p>
</li>
</ul>
<h4 id="数据类型转换">数据类型转换</h4>
<p>​		什么是数据类型转换？</p>
<p>​		使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</p>
<pre><code>转换为字符串类型
转换为数字型
转换为布尔型
</code></pre>
<ul>
<li>
<p>转换为字符串</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8719.png" alt="" loading="lazy"></figure>
<ul>
<li>toString() 和 String()  使用方式不一样。</li>
<li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li>
</ul>
</li>
<li>
<p>转换为数字型（重点）</p>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8720.png" alt="" loading="lazy"></figure>
<ul>
<li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li>
<li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li>
</ul>
</li>
<li>
<p>转换为布尔型</p>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8721.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>代表空、否定的值会被转换为 false  ，如 ''、0、NaN、null、undefined</p>
</li>
<li>
<p>其余值都会被转换为 true</p>
<pre><code class="language-js">console.log(Boolean('')); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean('小白')); // true
console.log(Boolean(12)); // true
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="解释型语言和编译型语言">解释型语言和编译型语言</h3>
<pre><code>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。
</code></pre>
<ul>
<li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li>
<li>编译器是在代码执行之前进行编译，生成中间代码文件</li>
<li>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</li>
</ul>
<h4 id="执行过程">执行过程</h4>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8723.png" alt="" loading="lazy"></figure>
<pre><code>类似于请客吃饭：

	编译语言：首先把所有菜做好，才能上桌吃饭

	解释语言：好比吃火锅，边吃边涮，同时进行
</code></pre>
<h3 id="关键字和保留字">关键字和保留字</h3>
<h4 id="标识符">标识符</h4>
<pre><code>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。

标识符不能是关键字或保留字。
</code></pre>
<h4 id="关键字">关键字</h4>
<pre><code>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。

包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。
</code></pre>
<h4 id="保留字">保留字</h4>
<pre><code>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。

注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。
</code></pre>
<h3 id="运算符操作符">运算符（操作符）</h3>
<h4 id="运算符的分类">运算符的分类</h4>
<p><strong>运算符</strong>（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p>
<pre><code>JavaScript中常用的运算符有：
</code></pre>
<ul>
<li>算数运算符</li>
<li>递增和递减运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ul>
<h4 id="算数运算符">算数运算符</h4>
<ul>
<li>
<p>算术运算符概述</p>
<p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。</p>
</li>
<li>
<p>浮点数的精度问题</p>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p>
<pre><code class="language-js">var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004
console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001
</code></pre>
<p>所以：不要直接判断两个浮点数是否相等 !</p>
</li>
<li>
<p>表达式和返回值</p>
<p>表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合</p>
<p>简单理解：是由数字、运算符、变量等组成的式子</p>
<p>表达式最终都会有一个结果，返回给开发者，称为返回值</p>
</li>
</ul>
<h4 id="递增和递减运算符">递增和递减运算符</h4>
<ul>
<li>
<p>递增和递减运算符概述</p>
<p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。</p>
<p>在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。</p>
<p>注意：递增和递减运算符必须和变量配合使用。</p>
</li>
<li>
<p>递增运算符</p>
<ul>
<li>
<p>前置递增运算符</p>
<p>++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。</p>
<p>使用口诀：先自加，后返回值</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(++num + 10);   // 21
</code></pre>
<ul>
<li>
<p>后置递增运算符</p>
<p>num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。</p>
<p>使用口诀：先返回原值，后自加</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(10 + num++);  // 20
</code></pre>
</li>
</ul>
<h4 id="比较运算符">比较运算符</h4>
<ul>
<li>
<p>比较运算符概述</p>
<p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。</p>
</li>
<li>
<p>等号比较</p>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%873.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">console.log(18 == '18');
console.log(18 === '18'); 
</code></pre>
</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ul>
<li>
<p>逻辑运算符概述</p>
<p>概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p>
</li>
<li>
<p>逻辑与&amp;&amp;</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑或 ||</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑非 ！</p>
<p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p>
<pre><code class="language-js">var isOk = !true;
console.log(isOk);  // false
</code></pre>
</li>
<li>
<p>短路运算（逻辑中断）</p>
<p>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p>
<ul>
<li>
<p>逻辑与</p>
<p>语法： 表达式1 &amp;&amp; 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式2

- 如果第一个表达式的值为假，则返回表达式1
</code></pre>
<pre><code class="language-js">console.log( 123 &amp;&amp; 456 );        // 456
console.log( 0 &amp;&amp; 456 );          // 0
console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789
</code></pre>
</li>
<li>
<p>逻辑或</p>
<p>语法： 表达式1 || 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式1

- 如果第一个表达式的值为假，则返回表达式2
</code></pre>
<pre><code class="language-js">console.log( 123 || 456 );         //  123
console.log( 0 ||  456 );          //  456
console.log( 123 || 456 || 789 );  //  123
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<pre><code>概念：用来把数据赋值给变量的运算符。
</code></pre>
<pre><code class="language-js">var age = 10;
age += 5;  // 相当于 age = age + 5;
age -= 5;  // 相当于 age = age - 5;
age *= 10; // 相当于 age = age * 10;
</code></pre>
<h4 id="运算符优先级">运算符优先级</h4>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8710.png" alt="" loading="lazy"></figure>
<ul>
<li>一元运算符里面的逻辑非优先级很高</li>
<li>逻辑与比逻辑或优先级高</li>
</ul>
<h3 id="流程控制">流程控制</h3>
<h4 id="流程控制概念">流程控制概念</h4>
<pre><code>在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解：**流程控制就是来控制代码按照一定结构顺序来执行**

流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。
</code></pre>
<ul>
<li>
<p>switch 语句和 if else if 语句的区别</p>
<ul>
<li>一般情况下，它们两个语句可以相互替换</li>
<li>switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)</li>
<li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。</li>
<li>当分支比较少时，if… else语句的执行效率比 switch语句高。</li>
<li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。</li>
</ul>
</li>
</ul>
<p>断点调试：</p>
<pre><code>	断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程
</code></pre>
<pre><code class="language-html">断点调试的流程：
1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点
2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。
3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
</code></pre>
<h3 id="标识符命名规范">标识符命名规范</h3>
<ul>
<li>变量、函数的命名必须要有意义</li>
<li>变量的名称一般用名词</li>
<li>函数的名称一般用动词</li>
</ul>
<h4 id="操作符规范">操作符规范</h4>
<pre><code class="language-js">// 操作符的左右两侧各保留一个空格
for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 直接退出整个 for 循环，跳到整个for循环下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="单行注释规范">单行注释规范</h4>
<pre><code class="language-js">for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 单行注释前面注意有个空格
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="其他规范">其他规范</h4>
<pre><code>关键词、操作符之间后加空格
</code></pre>
<h3 id="创建数组">创建数组</h3>
<p>JS 中创建数组有两种方式：</p>
<ul>
<li>
<p>利用  new 创建数组</p>
<pre><code class="language-js">var 数组名 = new Array() ；
var arr = new Array();   // 创建一个新的空数组
</code></pre>
<p>注意 Array () ，A 要大写</p>
</li>
<li>
<p>利用数组字面量创建数组</p>
<pre><code class="language-js">//1. 使用数组字面量方式创建空的数组
var  数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var  数组名 = ['小白','小黑','大黄','瑞奇'];
</code></pre>
<ul>
<li>数组的字面量是方括号 [ ]</li>
<li>声明数组并赋值称为数组的初始化</li>
<li>这种字面量方式也是我们以后最多使用的方式</li>
</ul>
</li>
<li>
<p>数组元素的类型</p>
<p>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p>
<pre><code class="language-js">var arrStus = ['小白',12,true,28.9];
</code></pre>
</li>
</ul>
<h3 id="获取数组中的元素">获取数组中的元素</h3>
<p>​		索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</p>
<p>​		数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</p>
<pre><code class="language-js">// 定义数组
var arrStus = [1,2,3];
// 获取数组中的第2个元素
alert(arrStus[1]);    
</code></pre>
<p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</p>
<h3 id="遍历数组">遍历数组</h3>
<ul>
<li>
<p>数组遍历</p>
<p>​		把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</p>
</li>
</ul>
<pre><code class="language-js">var arr = ['red','green', 'blue'];
for(var i = 0; i &lt; arr.length; i++){
    console.log(arrStus[i]);
}
</code></pre>
<ul>
<li>
<p>数组的长度</p>
<p>数组的长度：默认情况下表示数组中元素的个数</p>
<p>使用“数组名.length”可以访问数组元素的数量（数组长度）。</p>
<pre><code class="language-js">var arrStus = [1,2,3];
alert(arrStus.length);  // 3
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</li>
</ul>
</li>
<li>
<p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p>
<ul>
<li>数组的length属性可以被修改：</li>
</ul>
</li>
<li>
<p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p>
<ul>
<li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li>
</ul>
</li>
</ul>
<h3 id="数组中新增元素">数组中新增元素</h3>
<p>​		数组中可以通过以下方式在数组的末尾插入新元素：</p>
<pre><code class="language-js">  数组[ 数组.length ] = 新数据;
</code></pre>
<h2 id="函数">函数</h2>
<h3 id="函数的概念">函数的概念</h3>
<p>​		在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。</p>
<p>​		函数：就是<strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以<strong>实现大量代码的重复使用</strong>。</p>
<h3 id="函数的使用">函数的使用</h3>
<h4 id="声明函数">声明函数</h4>
<pre><code class="language-js">// 声明函数
function 函数名() {
    //函数体代码
}
</code></pre>
<ul>
<li>
<p>function 是声明函数的关键字,必须小写</p>
</li>
<li>
<p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p>
</li>
</ul>
<h4 id="调用函数">调用函数</h4>
<pre><code class="language-js">// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
</code></pre>
<ul>
<li>
<p>调用的时候千万不要忘记添加小括号</p>
</li>
<li>
<p>口诀：函数不调用，自己不执行</p>
<p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p>
</li>
</ul>
<h4 id="函数的封装">函数的封装</h4>
<ul>
<li>
<p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</p>
</li>
<li>
<p>简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）</p>
<p>例子：封装计算1-100累加和</p>
<pre><code class="language-js">/* 
   计算1-100之间值的函数
*/
// 声明函数
function getSum(){
  var sumNum = 0;// 准备一个变量，保存数字和
  for (var i = 1; i &lt;= 100; i++) {
    sumNum += i;// 把每个数值 都累加 到变量中
  }
  alert(sumNum);
}
// 调用函数
getSum();
</code></pre>
</li>
</ul>
<h3 id="函数的参数">函数的参数</h3>
<h4 id="函数参数语法">函数参数语法</h4>
<ul>
<li>
<p>形参：函数定义时设置接收调用时传入</p>
</li>
<li>
<p>实参：函数调用时传入小括号内的真实数据</p>
<p>​	参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</p>
<p>函数参数的运用：</p>
<pre><code class="language-js">// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
</code></pre>
<ol>
<li>调用的时候实参值是传递给形参的</li>
<li>形参简单理解为：不用声明的变量</li>
<li>实参和形参的多个参数之间用逗号（,）分隔</li>
</ol>
</li>
</ul>
<h4 id="函数形参和实参数量不匹配时">函数形参和实参数量不匹配时</h4>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%874.png" alt="" loading="lazy"></figure>
<pre><code>注意：在JavaScript中，形参的默认值是undefined。
</code></pre>
<p>小结：</p>
<ul>
<li>函数可以带参数也可以不带参数</li>
<li>声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined</li>
<li>调用函数的时候，函数名括号里面的是实参</li>
<li>多个参数中间用逗号分隔</li>
<li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li>
</ul>
<h3 id="函数的返回值">函数的返回值</h3>
<h4 id="return-语句">return 语句</h4>
<pre><code>返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。
</code></pre>
<pre><code class="language-js">// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
</code></pre>
<ul>
<li>在使用 return 语句时，函数会停止执行，并返回指定的值</li>
<li>如果函数没有 return ，返回的值是 undefined</li>
</ul>
<h4 id="break-continue-return-的区别">break ,continue ,return 的区别</h4>
<ul>
<li>break ：结束当前的循环体（如 for、while）</li>
<li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li>
<li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li>
</ul>
<h3 id="arguments的使用">arguments的使用</h3>
<p>​		当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>
<p>具有 length 属性</p>
</li>
<li>
<p>按索引方式储存数据</p>
</li>
<li>
<p>不具有数组的 push , pop 等方法</p>
<p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p>
<pre><code class="language-javascript">    &lt;script&gt;
        // 利用函数求任意个数的最大值
        function getMax() { // arguments = [1,2,3]
            var max = arguments[0];
            for (var i = 1; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) {
                    max = arguments[i];
                }
            }
            return max;
        }
        console.log(getMax(1, 2, 3));
        console.log(getMax(1, 2, 3, 4, 5));
        console.log(getMax(11, 2, 34, 444, 5, 100));
    &lt;/script&gt;
</code></pre>
</li>
</ul>
<h3 id="函数案例">函数案例</h3>
<pre><code>	函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。
</code></pre>
<h3 id="函数的两种声明方式">函数的两种声明方式</h3>
<ul>
<li>
<p>自定义函数方式(命名函数)</p>
<p>利用函数关键字 function 自定义函数方式</p>
<pre><code class="language-js">// 声明定义方式
function fn() {...}
// 调用  
fn();  
</code></pre>
<ul>
<li>因为有名字，所以也被称为命名函数</li>
<li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li>
</ul>
</li>
<li>
<p>函数表达式方式(匿名函数）</p>
<p>利用函数表达式方式的写法如下：</p>
<pre><code class="language-js">// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
</code></pre>
<ul>
<li>因为函数没有名字，所以也被称为匿名函数</li>
<li>这个fn 里面存储的是一个函数</li>
<li>函数表达式方式原理跟声明变量方式是一致的</li>
<li>函数调用的代码必须写到函数体后面</li>
</ul>
</li>
</ul>
<p>​    <strong>1. 我们js引擎运行js 分为两步： 预解析 代码执行</strong></p>
<p>​    (1). 预解析 js引擎会把js 里面所有的 var 还有 function 提升到当前作用域的最前面</p>
<p>​    (2). 代码执行 按照代码书写的顺序从上往下执行</p>
<p>​    <strong>2. 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）</strong></p>
<p>​    (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作</p>
<p>​    (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数</p>
<h3 id="创建对象的三种方式">创建对象的三种方式</h3>
<ul>
<li>
<p>利用字面量创建对象</p>
<h5 id="使用对象字面量创建对象"><strong>使用对象字面量创建对象</strong>：</h5>
<pre><code>  就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 
</code></pre>
<ul>
<li>
<p>键：相当于属性名</p>
</li>
<li>
<p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p>
<p>代码如下：</p>
<pre><code class="language-js">var star = {
    name : 'pink',
    age : 18,
    sex : '男',
    sayHi : function(){
        alert('大家好啊~');
    }
};
</code></pre>
<p>对象[‘属性名’]，注意方括号里面的属性必须加引号</p>
</li>
<li>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">console.log(star.name)     // 调用名字属性
console.log(star['name'])  // 调用名字属性
</code></pre>
</li>
</ul>
</li>
<li>
<p>调用对象的方法</p>
<ul>
<li>
<p>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号</p>
<p>示例代码如下：</p>
<pre><code class="language-js">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号
</code></pre>
</li>
</ul>
</li>
<li>
<p>变量、属性、函数、方法总结</p>
<pre><code>属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器
</code></pre>
<ul>
<li>
<p>变量：单独声明赋值，单独存在</p>
</li>
<li>
<p>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</p>
<p>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</p>
</li>
<li>
<p>函数：单独存在的，通过“函数名()”的方式就可以调用</p>
</li>
<li>
<p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用 new Object 创建对象</p>
<ul>
<li>
<p>创建空对象</p>
<pre><code class="language-js">var andy = new Obect();
</code></pre>
<p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p>
</li>
<li>
<p>给空对象添加属性和方法</p>
<ul>
<li>
<p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p>
<p>示例代码如下：</p>
</li>
</ul>
<pre><code class="language-js">andy.name = 'pink';
andy.age = 18;
andy.sex = '男';
andy.sayHi = function(){
    alert('大家好啊~');
}
</code></pre>
<p>注意：</p>
<ul>
<li>Object() ：第一个字母大写</li>
<li>new Object() ：需要 new 关键字</li>
<li>使用的格式：对象.属性 =  值;</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用构造函数创建对象</p>
<ul>
<li>
<p>构造函数</p>
<ul>
<li>
<p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
</li>
<li>
<p>构造函数的封装格式：</p>
<pre><code class="language-js">function 构造函数名(形参1,形参2,形参3) {
     this.属性名1 = 参数1;
     this.属性名2 = 参数2;
     this.属性名3 = 参数3;
     this.方法名 = 函数体;
}
</code></pre>
</li>
<li>
<p>构造函数的调用格式</p>
<pre><code>var obj = new 构造函数名(实参1，实参2，实参3)
</code></pre>
<p>以上代码中，obj即接收到构造函数创建出来的对象。</p>
</li>
<li>
<p>注意事项</p>
<ol>
<li>构造函数约定<strong>首字母大写</strong>。</li>
<li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li>
<li>构造函数中<strong>不需要 return 返回结果</strong>。</li>
<li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li>
</ol>
</li>
<li>
<p>其他</p>
<p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>
创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>new关键字的作用</p>
<ol>
<li>在构造函数代码开始执行之前，创建一个空对象；</li>
<li>修改this的指向，把this指向创建出来的空对象；</li>
<li>执行函数的代码</li>
<li>在函数完成之后，返回this---即创建出来的对象</li>
</ol>
<h3 id="遍历对象">遍历对象</h3>
<p>for...in 语句用于对数组或者对象的属性进行循环操作。</p>
<p>其语法如下：</p>
<pre><code class="language-js">for (变量 in 对象名字) {
    // 在此执行代码
}
</code></pre>
<p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p>
<pre><code class="language-js">for (var k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
</code></pre>
</li>
</ul>
<h3 id="预解析的相关概念">预解析的相关概念</h3>
<pre><code>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。
</code></pre>
<ul>
<li>
<p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中<strong>进行提前声明或者定义。</strong></p>
</li>
<li>
<p>代码执行： 从上到下执行JS语句。</p>
<p><strong>预解析会把变量和函数的声明在代码执行之前执行完成。</strong></p>
</li>
</ul>
<p>变量预解析</p>
<pre><code>预解析也叫做变量、函数提升。
变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。
</code></pre>
<pre><code class="language-js">console.log(num);  // 结果是多少？
var num = 10;      // ？
</code></pre>
<pre><code>结果：undefined

注意：**变量提升只提升声明，不提升赋值**
</code></pre>
<p>函数预解析</p>
<pre><code>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。
</code></pre>
<pre><code class="language-js">fn();
function fn() {
    console.log('打印');
}
</code></pre>
<pre><code>结果：控制台打印字符串 --- ”打印“ 

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	
</code></pre>
<p>函数表达式声明函数问题</p>
<pre><code>函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：
</code></pre>
<pre><code class="language-js">fn();
var  fn = function() {
    console.log('想不到吧');
}
</code></pre>
<pre><code>结果：报错提示 ”fn is not a function&quot;

解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
</code></pre>
<pre><code class="language-javascript">//函数的预解析
		var num=1;
		function demo(){
			console.log(num);
			function demoSon(){
				num=3;
			}
			var num=2;
			demoSon();
		}
		demo();

//相当于
var num;//作用域在全局
		function demo();
		num=1;
		function demo(){
			var num;
			function demoSon();
			console.log(num);
			function demoSon(){
				num=3;
			}
			num=2;//num在函数作用域
			demoSon();
		}
		demo();
//var num = 2，声明会提前，但不会赋值 num会变为undefined 所以不会输出1 
</code></pre>
<p>JavaScript 中的对象分为3种：<strong>自定义对象 、内置对象、 浏览器对象</strong><br>
​		前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是<strong>最基本而必要的功能</strong>（属性和方法），内置对象最大的优点就是帮助我们快速开发</p>
<p>​	 	JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</p>
<h3 id="math对象">Math对象</h3>
<p>​		Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p>
<table>
<thead>
<tr>
<th>属性、方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.round()</td>
<td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td>
</tr>
<tr>
<td>Math.abs()</td>
<td>绝对值</td>
</tr>
<tr>
<td>Math.max()/Math.min()</td>
<td>求最大和最小值</td>
</tr>
<tr>
<td>Math.random()</td>
<td>获取范围在[0,1)内的随机值</td>
</tr>
</tbody>
</table>
<p>​	注意：上面的方法使用时必须带括号</p>
<pre><code class="language-js">console.log(Math.round(1.5)); // 2
console.log(Math.round(-1.5)); // 这个结果是 -1
</code></pre>
<p>​	<strong>获取指定范围内的随机整数</strong>：</p>
<pre><code class="language-javascript"> function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min; 
}
</code></pre>
<h3 id="日期对象">日期对象</h3>
<p>​	 	Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p>
<ul>
<li>
<p>使用Date实例化日期对象</p>
<ul>
<li>获取当前时间必须实例化：</li>
</ul>
<pre><code class="language-js">var now = new Date();
</code></pre>
<ul>
<li>获取指定时间的日期对象</li>
</ul>
<pre><code class="language-js">var future = new Date('2010/5/1');
</code></pre>
<p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p>
</li>
<li>
<p>使用Date实例的方法和属性</p>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5Ctime1.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>通过Date实例获取总毫米数</p>
<ul>
<li>
<p>总毫秒数的含义</p>
<p>​	基于1970年1月1日（世界标准时间）起的毫秒数</p>
</li>
<li>
<p>获取总毫秒数</p>
<pre><code class="language-js">// 实例化Date对象
var now = new Date();
// 1. 用于获取对象的原始值
console.log(date.valueOf())	
console.log(date.getTime())	
// 2. 简单写可以这么做
var now = + new Date();			
// 3. HTML5中提供的方法，有兼容性问题
var now = Date.now();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="数组对象">数组对象</h3>
<h4 id="创建数组的两种方式">创建数组的两种方式</h4>
<ul>
<li>
<p>字面量方式</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">var arr = [1,&quot;test&quot;,true];
</code></pre>
</li>
</ul>
</li>
<li>
<p>new Array()</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code>var arr = new Array();
</code></pre>
<p>​	注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p>
<p>​	参数传递规则如下：</p>
<ul>
<li>
<p>如果只传入一个参数，则参数规定了数组的长度</p>
</li>
<li>
<p>如果传入了多个参数，则参数称为数组的元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="检测是否为数组">检测是否为数组</h4>
<ul>
<li>
<p>instanceof 运算符</p>
<ul>
<li>
<p>instanceof 可以判断一个对象是否是某个构造函数的实例</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
</code></pre>
</li>
</ul>
</li>
<li>
<p>Array.isArray()</p>
<ul>
<li>
<p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(Array.isArray(arr));   // true
console.log(Array.isArray(obj));   // false
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="添加删除数组元素的方法">添加删除数组元素的方法</h4>
<ul>
<li>
<p>数组中有进行增加、删除元素的方法，部分方法如下表</p>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5Cp%E5%9B%BE%E7%89%872.png" alt="" loading="lazy"></figure>
<p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p>
</li>
</ul>
<h4 id="数组排序">数组排序</h4>
<ul>
<li>
<p>数组中有对数组本身排序的方法，部分方法如下表</p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5Carray3.png" alt="" loading="lazy"></figure>
<p>注意：sort方法需要传入参数来设置升序、降序排序</p>
<ul>
<li>如果传入“function(a,b){ return a-b;}”，则为升序</li>
<li>如果传入“function(a,b){ return b-a;}”，则为降序</li>
</ul>
</li>
</ul>
<h4 id="数组索引方法">数组索引方法</h4>
<ul>
<li>
<p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5Carray4.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h4 id="数组转换为字符串">数组转换为字符串</h4>
<ul>
<li>
<p>数组中有把数组转化为字符串的方法，部分方法如下表</p>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5Carray5.png" alt="" loading="lazy"></figure>
<p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p>
</li>
</ul>
<h4 id="其他方法">其他方法</h4>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5Carray6.png" alt="" loading="lazy"></figure>
<h3 id="字符串对象">字符串对象</h3>
<h4 id="基本包装类型">基本包装类型</h4>
<p>​		为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p>
<p>​		基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<pre><code class="language-js">// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
</code></pre>
<p>​		按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为</p>
<p>​		js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p>
<pre><code class="language-js">// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
</code></pre>
<h4 id="字符串的不可变">字符串的不可变</h4>
<p>​		指的是里面的值不可变，虽然看上去可以改变内容，但其实是<strong>地址变了</strong>，内存中新开辟了一个内存空间。</p>
<p>​		当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>
​		由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</p>
<h4 id="根据字符返回位置">根据字符返回位置</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5Carray7.png" alt="" loading="lazy"></figure>
<p>​		案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数</p>
<ol>
<li>先查找第一个o出现的位置</li>
<li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li>
<li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</li>
</ol>
<h4 id="根据位置返回字符">根据位置返回字符</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5Carray8.png" alt="" loading="lazy"></figure>
<p>​		在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码</p>
<p>​		案例：判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数</p>
<ol>
<li>
<p>核心算法：利用 charAt(） 遍历这个字符串</p>
</li>
<li>
<p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p>
</li>
<li>
<p>遍历对象，得到最大值和该字符</p>
<p>​	注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数</p>
</li>
</ol>
<h4 id="字符串操作方法">字符串操作方法</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</p>
<figure data-type="image" tabindex="17"><img src="E:%5CAPTX-4869%5Cmd%5Cstring10.png" alt="" loading="lazy"></figure>
<h4 id="replace方法">replace()方法</h4>
<p>​		replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</p>
<pre><code>字符串.replace(被替换的字符串， 要替换为的字符串)；
</code></pre>
<h4 id="split方法">split()方法</h4>
<p>​		split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<p>​		其使用格式如下：</p>
<pre><code>字符串.split(&quot;分割字符&quot;)
</code></pre>
<h2 id="简单数据类型和复杂数据类型">简单数据类型和复杂数据类型</h2>
<h3 id="简单数据类型-2">简单数据类型</h3>
<p>​		<strong>简单类型</strong>（<strong>基本数据类型</strong>、<strong>值类型</strong>）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</p>
<h3 id="复杂数据类型">复杂数据类型</h3>
<p>​		<strong>复杂数据类型（引用类型）</strong>：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</p>
<h3 id="堆栈">堆栈</h3>
<ul>
<li>堆栈空间分配区别：</li>
</ul>
<p>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>简单数据类型存放到栈里面</p>
<p>2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
<ul>
<li>
<p>简单数据类型的存储方式</p>
<p>​		值类型变量的数据直接存放在变量（栈空间）中</p>
</li>
<li>
<p>复杂数据类型的存储方式</p>
<p>​		引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</p>
</li>
</ul>
<h3 id="简单类型传参">简单类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<h3 id="复杂数据类型传参">复杂数据类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL]]></title>
        <id>https://xmweijh.github.io/post/stl/</id>
        <link href="https://xmweijh.github.io/post/stl/">
        </link>
        <updated>2021-02-17T05:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="stl">STL</h1>
<h3 id="stl六大组件">STL六大组件</h3>
<p>容器、算法、迭代器、仿函数、适配器、空间配置器</p>
<p>STL优点</p>
<p>内建在C++编译器中，不需要安装额外内容</p>
<p>不需要了解具体实现内容，只要熟练运用即可</p>
<p>高复用，可移植，高性能</p>
<p>容器划分</p>
<p>序列式容器</p>
<p>关联式容器  有个key起到索引作用</p>
<p>算法</p>
<p>变算法</p>
<p>非质变算法</p>
<h3 id="vector容器-vectorintv">vector容器 vector<int>v</h3>
<p>vector<int>::iterator itBegin = v.begin(); //v.begin() 起始迭代器，指向容器中第一个数据</p>
<p>vector<int>::iterator itEnd = v.end(); //v.end()；结束迭代器，指向的是容器中最后一个元素的下一个位置</p>
<p>利用算法遍历容器</p>
<p>for_each(v.begin(),v.end() , myPrint ) 头文件  algorithm</p>
<p>容器中存放自定义数据类型</p>
<p>容器中存放自定义数据类型指针</p>
<p>容器嵌套容器</p>
<pre><code class="language-c++">	vector&lt;vector&lt;int&gt;&gt;v;

	vector&lt;int&gt;v1;
	vector&lt;int&gt;v2;
	vector&lt;int&gt;v3;

	for (int i = 0; i &lt; 5; i++)
	{
		v1.push_back(i + 1);
		v2.push_back(i + 10);
		v3.push_back(i + 100);
	}

	//将小容器放入到大容器中
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);


	//遍历大容器
	for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end();it++)
	{
		// *it ==== vector&lt;int&gt;
		for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end();vit++)
		{
			cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
</code></pre>
<h3 id="string">string</h3>
<p>构造、赋值</p>
<p>[]、at 字符存取</p>
<p>[] 和 at区别 []访问越界 直接挂掉，at抛出out_of_range异常</p>
<pre><code class="language-c++">string str = &quot;hello world&quot;;

	//for (int i = 0; i &lt; str.size();i++)
	//{
	//	//cout &lt;&lt; str[i] &lt;&lt; endl;
	//	cout &lt;&lt; str.at(i) &lt;&lt; endl;
	//}

	//[]和at区别，[]访问越界 直接挂掉 ， at访问越界  抛出out_of_range异常
	try
	{
		//cout &lt;&lt; str[100] &lt;&lt; endl;
		cout &lt;&lt; str.at(100) &lt;&lt; endl;
	}
	catch (out_of_range &amp; e)
	{
		cout &lt;&lt; e.what() &lt;&lt; endl;
	}
	catch (...)
	{
		cout &lt;&lt; &quot;异常捕获&quot; &lt;&lt; endl;
	}
</code></pre>
<p>字符串拼接  += append</p>
<p>查找  find  rfind(从右往左查找)</p>
<p>替换  replace</p>
<pre><code class="language-c++">	//替换
	//string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str
	str.replace(1, 3, &quot;11111&quot;);//不是只替换三个1，而是将三个替换为五个
	//a11111efgde
	cout &lt;&lt; str &lt;&lt; endl;
</code></pre>
<p>比较  compare</p>
<p>子串  substr</p>
<pre><code class="language-c++">	string email = &quot;zhangtao@sina.com&quot;;

	int pos = email.find(&quot;@&quot;); // 8

	string userName = email.substr(0, pos);//pos任然是8而非加减，因为截取几个是从1开始的

	cout &lt;&lt; userName &lt;&lt; endl;
</code></pre>
<pre><code class="language-c++">	string str = &quot;www.itcast.com.cn&quot;;

	vector&lt;string&gt; v; //将 www  itcast  com  cn 单词截取到 vector容器中

	int start = 0;
	int pos = -1;

	while (true)
	{
		//www.itcast.com.cn
		pos = str.find(&quot;.&quot;, start);

		if (pos == -1)
		{
			//将cn截取出来
			string tempStr = str.substr(start,str.size() - start);
			v.push_back(tempStr);
			break;
		}

		string tempStr = str.substr(start, pos - start);

		v.push_back(tempStr);

		start = pos + 1;
	}

	for (vector&lt;string&gt;::iterator it = v.begin(); it != v.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; endl;
	}
</code></pre>
<p>插入 insert</p>
<p>删除 erase</p>
<p>string和const char* 转换</p>
<p>string 转 const char *   .c_str();</p>
<p>const char * 转string  利用string 有参构造</p>
<p>const char *可以隐式转换为 string 反之不可以</p>
<p>小写转大写 toupper</p>
<p>大写转小写 tolower</p>
<h3 id="vector容器">vector容器</h3>
<p>单端数组</p>
<p>动态数组，自动扩展内存，所谓动态扩展内存，并不是在原有空间后续进行扩展，而是找一个更大的内存空间，将原有数据拷贝到新空间下，并且释放原有空间</p>
<p>接口</p>
<p>构造、赋值</p>
<p>交换 swap</p>
<p>大小 size</p>
<p>是否为空 empty</p>
<p>重置大小 resize</p>
<p>如果重置的比原来大，有默认值填充新位置</p>
<p>如果重置的比原来小，超出的部分删除掉</p>
<p>front 返回容器中第一个元素</p>
<p>back 返回容器中最后一个元素</p>
<p>插入 insert （迭代器）</p>
<p>删除 erase  （迭代器）</p>
<p>尾插 push_back</p>
<p>尾删 pop_back</p>
<p>清空 clear</p>
<p>案例1 ：巧用swap收缩内存</p>
<pre><code class="language-c++">vector&lt;int&gt;v;
	for (int i = 0; i &lt; 100000;i++)
	{
		v.push_back(i);
	}
	cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl;

	v.resize(3);

	cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl;

	//巧用swap收缩内存
	vector&lt;int&gt;(v).swap(v);//vector&lt;int&gt;(v) 以v的size创造匿名对象，再与v交换（实际是地址的交换），匿名对象运行后会被释放。

	cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl;
</code></pre>
<p>案例2: ： 巧用reserve 预留内存</p>
<pre><code class="language-c++">vector&lt;int&gt;v;
	v.reserve(100000);
	int * p = NULL;
	int num = 0;
	for (int i = 0; i &lt; 100000; i++)
	{
		v.push_back(i);
		if (p != &amp;v[0])
		{
			p = &amp;v[0];
			num++;
		}
	}

	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
</code></pre>
<p>逆序遍历 reverse_iterator  非质变</p>
<p>判断容器的迭代器是否支持随机访问</p>
<h3 id="deque容器">deque容器</h3>
<p>双端数组</p>
<p>可以对头部进行插入和删除操作，内部有中控器控制数据</p>
<p>接口</p>
<p>构造、赋值</p>
<p>交换 swap</p>
<p>大小 size</p>
<p>是否为空 empty</p>
<p>重置大小 resize</p>
<p>front 返回容器中第一个元素</p>
<p>back 返回容器中最后一个元素</p>
<p>插入 insert （迭代器）</p>
<p>删除 erase  （迭代器）</p>
<p>头部插入 push_front</p>
<p>头部删除 pop_front</p>
<p>尾插 push_back</p>
<p>尾删 pop_back</p>
<p>清空 clear</p>
<p>​    sort排序 sort(v.begin(),v.end(), 回调函数)</p>
<h3 id="栈容器-stack">栈容器 Stack</h3>
<p>符合先进后出的数据结构</p>
<p>对外接口</p>
<p>入栈 push</p>
<p>出栈 pop</p>
<p>栈顶 top</p>
<p>是否为空 empty</p>
<p>栈大小  size</p>
<h3 id="队列容器-queue">队列容器 Queue</h3>
<p>符合先进先出的数据结构</p>
<p>对外接口</p>
<p>入队 push</p>
<p>出队 pop</p>
<p>队头元素 front</p>
<p>队尾元素 back</p>
<p>是否为空 empty</p>
<p>队列大小 size</p>
<p>list容器</p>
<p>双向循环链表</p>
<p>对外接口</p>
<p>构造、赋值、大小、重置大小、是否为空</p>
<p>反转 reverse</p>
<p>排序 sort</p>
<p>//如果容器的迭代器支持随机访问，可以使用系统提供的标志算法</p>
<p>//不支持随机访问的迭代器的容器，内部会提供对应的算法接口</p>
<p>对于自定义数据类型，必须要指定排序规则</p>
<p>对自定义数据类型做了高级排序</p>
<p>如果利用remove删除自定义数据类型，需要重载 ==</p>
<h3 id="set-容器">set 容器</h3>
<p>关联式容器 key就是value</p>
<p>默认排好序 从小到大</p>
<p>插入 insert  大小 size 是否为空 empty</p>
<p>查找 find 返回值 迭代器</p>
<p>统计 count  对于set的结果 要么是0 要么是1</p>
<p>lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</p>
<p>upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</p>
<p>equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</p>
<h3 id="pair对组">pair对组</h3>
<p>创建方式</p>
<p><em>pair</em>&lt;<em>string</em>, int&gt; p(&quot;Tom&quot;, 10);</p>
<p><em>pair</em>&lt;<em>string</em>, int&gt; p2 = <em>make_pair</em>(&quot;Jerry&quot;, 18);</p>
<p>set.insert的返回值是个对组 pair&lt;iterator, bool&gt; bool代表插入是否成功</p>
<p>multiset可以插入重复的key值</p>
<p>可以指定set容器的排序规则，但是必须在插入前指定，利用仿函数的技术</p>
<p>对于自定义数据类型，set通常都会指定出排序规则</p>
<h3 id="map容器">map容器</h3>
<p>关联式容器</p>
<p>默认按照key从小到大排序</p>
<p>插入</p>
<p>m.insert(pair&lt;int, int&gt;(1, 10));</p>
<p>m.insert(make_pair(2, 20));</p>
<p>m.insert(map&lt;int, int&gt;::value_type(3, 30));</p>
<p>m[4] = 40;</p>
<p>查找 find 返回值 是迭代器</p>
<p>统计 count</p>
<p>lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</p>
<p>upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</p>
<p>equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</p>
<p>利用仿函数 实现指定排序规则</p>
<p>STL容器使用时机</p>
<h3 id="函数对象">函数对象</h3>
<p>本质是一个类的对象，因此称为函数对象，也叫仿函数</p>
<p>函数对象 超出了普通函数的概念，可以拥有自己状态</p>
<p>函数对象可以作为函数参数</p>
<h3 id="谓词">谓词</h3>
<p>普通函数或者仿函数的返回值是bool类型，称为谓词</p>
<p>一元谓词</p>
<p>查找容器中大于20的数字  find_if</p>
<p>二元谓词</p>
<p>对容器进行排序 sort</p>
<p>lambda表达式  <a href=""></a>{}</p>
<pre><code class="language-c++">	//lambda表达式  匿名函数  []代表lambda表达式标志  [](){}
	for_each(v.begin(), v.end(), [](int val){ cout &lt;&lt; val &lt;&lt; &quot; &quot;; });
</code></pre>
<h3 id="内建函数对象">内建函数对象</h3>
<p>引入头文件 #include&lt; functional&gt;</p>
<p>取反 negate<int></p>
<p>加法 plus<int></p>
<p>大于 greater<int></p>
<pre><code class="language-c++">//从大到小排序
	sort(v.begin(), v.end(), greater&lt;int&gt;());
</code></pre>
<h3 id="适配器">适配器</h3>
<p>函数对象适配器</p>
<p>//1、利用bind2nd 进行绑定</p>
<p>//2、继承 public binary_function&lt;参数1 类型,参数2类型,返回值类型&gt;</p>
<p>//3、加const<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<pre><code class="language-c++">class MyPrint :public binary_function&lt;int,int,void&gt;
{
public:
	void operator()(int val , int start)const 
	{
		cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; &quot; start = &quot; &lt;&lt; start &lt;&lt;  &quot; sum = &quot; &lt;&lt;val +  start &lt;&lt; endl;
	}
};
	for_each(v.begin(), v.end(), bind2nd( MyPrint(), num ) );
</code></pre>
<p>取反适配器</p>
<p>一元取反 not1</p>
<p>//1、利用not1进行取反</p>
<p>//2、继承 public unary_function&lt;int,bool&gt;</p>
<p>//3、加const</p>
<pre><code class="language-c++">class GreaterThanFive:public unary_function&lt;int,bool&gt;
{
public:
	bool operator()(int val) const
	{
		return val &gt; 5;
	}
};
	//一元取反
	//vector&lt;int&gt;::iterator pos = find_if(v.begin(), v.end(), not1( GreaterThanFive()));
</code></pre>
<p>​	二元取反 not2</p>
<p>函数指针适配器</p>
<p>ptr_fun将普通函数指针 适配成函数对象</p>
<p>​     成员函数适配器<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<pre><code class="language-c++">//利用 mem_fun_ref
	for_each(v.begin(), v.end(),  mem_fun_ref(&amp;Person::showPerson));
</code></pre>
<p>如果存放的是对象实体  mem_fun_ref</p>
<p>如果存放的是对象指针  mem_fun</p>
<h3 id="常用遍历算法">常用遍历算法</h3>
<p><strong>for_each</strong></p>
<p>用于遍历</p>
<p>有返回值</p>
<pre><code class="language-c++">class MyPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; endl;
		m_Count++;
	}

	int m_Count = 0;
};
	MyPrint print = for_each(v.begin(), v.end(), MyPrint());

	cout &lt;&lt; &quot;print.count = &quot; &lt;&lt; print.m_Count &lt;&lt; endl;
</code></pre>
<p>可以绑定参数进行输出</p>
<pre><code class="language-c++">class MyPrint2 :public binary_function&lt;int,int,void&gt;
{
public:
	void operator()(int val , int start) const
	{
		cout &lt;&lt; val &lt;&lt; endl;
		
	}

};
</code></pre>
<p><strong>transform</strong></p>
<p>搬运</p>
<p>注意：目标容器要有容量</p>
<pre><code class="language-c++">class MyTransform
{
public:
	int operator()(int val)
	{	
		return val + 10000;
	}
};
void test()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	vector&lt;int&gt;v2;
	v2.resize(v.size());//如果不rize把v1向空的v2搬运会报错，v2会动态的扩充内存

	transform(v.begin(), v.end(), v2.begin(), MyTransform());

	for_each(v2.begin(), v2.end(), [](int val){cout &lt;&lt; val &lt;&lt; &quot; &quot;; });

}
</code></pre>
<p>常用查找算法</p>
<p><strong>find</strong> <strong>查找</strong></p>
<p><strong>find_if</strong> <strong>按条件查找</strong></p>
<p>adjacent_find算法 查找相邻重复元素</p>
<p>binary_search算法 二分查找法	注意: 在无序序列中不可用</p>
<p>**count算法 **统计元素出现次数</p>
<p><strong>count_if</strong> <strong>按条件进行统计</strong></p>
<h3 id="常用排序算法">常用排序算法</h3>
<p>merge 合并</p>
<p>将两个容器合并到 目标容器中</p>
<p>注意： 两个容器必须是有序序列</p>
<p>目标容器必须有容量</p>
<p><strong>sort</strong> <strong>排序</strong></p>
<p><strong>random_shuffle</strong> <strong>洗牌</strong></p>
<p>reverse 反转</p>
<h3 id="常用的拷贝和替换算法">常用的拷贝和替换算法</h3>
<p>copy 拷贝</p>
<p>实现打印 copy(v.begin(),v.end() , ostream_iterator<int>(cout , “ ”));</p>
<p><code>ostream_iterator需要#include &lt;iterator&gt;</code></p>
<p>replace 替换</p>
<p>replace_if 按条件替换</p>
<p>​    swap 交换</p>
<h3 id="常用的算数生成算法">常用的算数生成算法</h3>
<p>头文件 #include <numeric></p>
<p><strong>accumulate</strong>算法 计算容器元素累计总和</p>
<p>fill算法 向容器中添加元素</p>
<h3 id="常用集合算法">常用集合算法</h3>
<p>set_intersection算法 求两个set集合的交集</p>
<p>set_union算法 求两个set集合的并集</p>
<p>set_difference算法 求两个set集合的差集</p>
<p>注意:两个集合必须是有序序列</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这个const 修饰的是this指针，表示this指针指向的内存空间不能修改 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>成员函数与成员函数是分开存储的，可不创造对象，找到函数地址调用 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS]]></title>
        <id>https://xmweijh.github.io/post/css/</id>
        <link href="https://xmweijh.github.io/post/css/">
        </link>
        <updated>2021-02-07T11:39:17.000Z</updated>
        <content type="html"><![CDATA[<p>CSS</p>
<p>结构(html)与样式(css)相分离</p>
<p>主要用于<strong>设置</strong> HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及<strong>版面的布局和外观显示样式。</strong></p>
<h3 id="引入css样式表">引入CSS样式表</h3>
<h4 id="行内式">行内式</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称行内样式、行间样式.</p>
<p>​	是通过标签的style属性来设置元素的样式</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;
</code></pre>
<p>实际上任何HTML标签都拥有style属性，用来设置行内式。</p>
<ul>
<li>案例：</li>
</ul>
<pre><code class="language-css">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt;
</code></pre>
<ul>
<li>注意：
<ul>
<li>style其实就是标签的属性</li>
<li>样式属性和值中间是<code>:</code></li>
<li>多组属性值之间用<code>;</code>隔开。</li>
<li>只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余</li>
</ul>
</li>
<li>缺点：
<ul>
<li>没有实现样式和结构相分离</li>
</ul>
</li>
</ul>
<h4 id="内部样式表内嵌样式表">内部样式表（内嵌样式表）</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称内嵌式</p>
<p>​	是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
&lt;style type=&quot;text/CSS&quot;&gt;
    选择器（选择的标签） { 
      属性1: 属性值1;
      属性2: 属性值2; 
      属性3: 属性值3;
    }
&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<pre><code class="language-css">&lt;style&gt;
	 div {
	 	color: red;
	 	font-size: 12px;
	 }
&lt;/style&gt;
</code></pre>
<ul>
<li>
<p>注意：</p>
<ul>
<li>style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。</li>
<li>type=&quot;text/css&quot;  在html5中可以省略。</li>
<li>只能控制当前的页面</li>
</ul>
</li>
<li>
<p>缺点：</p>
<p>没有彻底分离</p>
</li>
</ul>
<h4 id="外部样式表外链式">外部样式表（外链式）</h4>
<ul>
<li>
<p>概念：</p>
<p>​	称链入式</p>
<p>​	是将所有的样式放在一个或多个以**.CSS**为扩展名的外部样式表文件中，</p>
<p>​	通过link标签将外部样式表文件链接到HTML文档中</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot;&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>注意：
<ul>
<li>link 是个单标签</li>
<li>link标签需要放在head头部标签中，并且指定link标签的三个属性</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rel</td>
<td style="text-align:left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</td>
</tr>
<tr>
<td>href</td>
<td style="text-align:left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</td>
</tr>
</tbody>
</table>
<h3 id="三种样式表总结位置">三种样式表总结（位置）</h3>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少）</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h3 id="css选择器重点">CSS选择器（重点）</h3>
<h4 id="css选择器作用重点">CSS选择器作用（重点）</h4>
<p>找到特定的HTML页面元素      选择标签用的， 把我们想要的标签选择出来</p>
<h4 id="css基础选择器">CSS基础选择器</h4>
<h5 id="标签选择器">标签选择器</h5>
<ul>
<li>
<p>概念：</p>
<p>标签选择器（元素选择器）是指用<strong>HTML标签名</strong>称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<pre><code>标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 
</code></pre>
<ul>
<li>
<p>作用：</p>
<p>标签选择器 可以把某一类标签<strong>全部</strong>选择出来  比如所有的div标签  和 所有的 span标签</p>
</li>
<li>
<p>优点：</p>
<p>是能快速为页面中同类型的标签统一样式</p>
</li>
<li>
<p>缺点：</p>
<p>不能设计差异化样式。</p>
</li>
</ul>
<h5 id="类选择器">类选择器</h5>
<p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名.</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>类名选择器</li>
</ul>
<pre><code>.类名  {   
    属性1:属性值1; 
    属性2:属性值2; 
    属性3:属性值3;     
}
</code></pre>
<ul>
<li>标签</li>
</ul>
<pre><code>&lt;p class='类名'&gt;&lt;/p&gt;
</code></pre>
</li>
<li>
<p>优点：</p>
<ul>
<li>可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的)</li>
<li>长名称或词组可以使用中横线来为选择器命名。</li>
<li>不要纯数字、中文等命名， 尽量使用英文字母来表示。</li>
</ul>
</li>
</ul>
<h5 id="类选择器特殊用法-多类名">类选择器特殊用法- 多类名</h5>
<p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p>
<p>注意：</p>
<ul>
<li>各个类名中间用空格隔开。</li>
<li>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</li>
</ul>
<h5 id="id选择器">id选择器</h5>
<p>id选择器使用<code>#</code>进行标识，后面紧跟id名</p>
<ul>
<li>
<p>其基本语法格式如下：</p>
<ul>
<li>
<p>id选择器</p>
<pre><code>#id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
</code></pre>
</li>
<li>
<p>标签</p>
<pre><code>&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p>
</li>
<li>
<p>用法基本和类选择器相同。</p>
</li>
</ul>
<h5 id="id选择器和类选择器区别">id选择器和类选择器区别</h5>
<ul>
<li>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。
<ul>
<li>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</li>
<li>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</li>
</ul>
</li>
</ul>
<p><em><strong>id选择器和类选择器最大的不同在于 使用次数上。</strong></em></p>
<ul>
<li>类选择器我们在修改样式中，用的最多。</li>
<li>id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。</li>
</ul>
<h5 id="通配符选择器">通配符选择器</h5>
<ul>
<li>
<p>概念</p>
<p>通配符选择器用<code>*</code>号表示，  *   就是 选择所有的标签      他是所有选择器中作用范围最广的，能匹配页面中所有的元素。</p>
</li>
<li>
<p>其基本语法格式如下：</p>
</li>
</ul>
<pre><code>* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
</code></pre>
<p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p>
<pre><code class="language-css">* {
  margin: 0;                    /* 定义外边距*/
  padding: 0;                   /* 定义内边距*/
}
</code></pre>
<ul>
<li>
<p>注意：</p>
<p>会匹配页面所有的元素，降低页面响应速度，不建议随便使用</p>
</li>
</ul>
<h3 id="基础选择器总结">基础选择器总结</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>缺点</th>
<th>使用情况</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签选择器</td>
<td>可以选出所有相同的标签，比如p</td>
<td>不能差异化选择</td>
<td>较多</td>
<td>p { color：red;}</td>
</tr>
<tr>
<td>类选择器</td>
<td>可以选出1个或者多个标签</td>
<td>可以根据需求选择</td>
<td>非常多</td>
<td>.nav { color: red; }</td>
</tr>
<tr>
<td>id选择器</td>
<td>一次只能选择器1个标签</td>
<td>只能使用一次</td>
<td>不推荐使用</td>
<td>#nav {color: red;}</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>选择所有的标签</td>
<td>选择的太多，有部分不需要</td>
<td>不推荐使用</td>
<td>* {color: red;}</td>
</tr>
</tbody>
</table>
<h3 id="css字体样式属性调试工具">CSS字体样式属性调试工具</h3>
<h4 id="font字体">font字体</h4>
<h5 id="font-size大小">font-size:大小</h5>
<ul>
<li>
<p>作用：</p>
<p>font-size属性用于设置字号</p>
</li>
</ul>
<pre><code class="language-css">p {  
    font-size:20px; 
}
</code></pre>
<ul>
<li>
<p>单位：</p>
<ul>
<li>可以使用相对长度单位，也可以使用绝对长度单位。</li>
<li>相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。</li>
</ul>
</li>
</ul>
<ul>
<li>谷歌浏览器默认的文字大小为16px</li>
<li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小</li>
</ul>
<h5 id="font-family字体">font-family:字体</h5>
<ul>
<li>
<p>作用：</p>
<p>font-family属性用于设置哪一种字体。</p>
</li>
</ul>
<pre><code>p{ font-family:&quot;微软雅黑&quot;;}
</code></pre>
<ul>
<li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li>
<li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li>
</ul>
<pre><code>p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;}
</code></pre>
<pre><code>1. 各种字体之间必须使用英文状态下的逗号隔开。
2. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。
3. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。
4. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。
</code></pre>
<h5 id="font-weight字体粗细">font-weight:字体粗细</h5>
<ul>
<li>在html中如何将字体加粗我们可以用标签来实现
<ul>
<li>使用 b  和 strong 标签是文本加粗。</li>
</ul>
</li>
<li>可以使用CSS 来实现，但是CSS 是没有语义的。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td style="text-align:left">默认值（不加粗的）</td>
</tr>
<tr>
<td>bold</td>
<td style="text-align:left">定义粗体（加粗的）</td>
</tr>
<tr>
<td>100~900</td>
<td style="text-align:left">400 等同于 normal，而 700 等同于 bold  我们重点记住这句话</td>
</tr>
</tbody>
</table>
<p>提倡：</p>
<p>我们平时更喜欢用数字来表示加粗和不加粗</p>
<h5 id="font-style字体风格">font-style:字体风格</h5>
<ul>
<li>在html中如何将字体倾斜我们可以用标签来实现
<ul>
<li>字体倾斜除了用 i  和 em 标签，</li>
</ul>
</li>
<li>可以使用CSS 来实现，但是CSS 是没有语义的</li>
</ul>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td style="text-align:left">默认值，浏览器会显示标准的字体样式  font-style: normal;</td>
</tr>
<tr>
<td>italic</td>
<td style="text-align:left">浏览器会显示斜体的字体样式。</td>
</tr>
</tbody>
</table>
<h5 id="font综合设置字体样式-重点">font:综合设置字体样式 (重点)</h5>
<p>font属性用于对字体样式进行综合设置</p>
<ul>
<li>基本语法格式如下：</li>
</ul>
<pre><code class="language-css">选择器 { font: font-style  font-weight  font-size/line-height  font-family;}
</code></pre>
<ul>
<li>注意：
<ul>
<li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li>
<li>其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</li>
</ul>
</li>
</ul>
<h4 id="font总结">font总结</h4>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
<th style="text-align:left">注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">font-size</td>
<td style="text-align:left">字号</td>
<td style="text-align:left">我们通常用的单位是px 像素，一定要跟上单位</td>
</tr>
<tr>
<td style="text-align:left">font-family</td>
<td style="text-align:left">字体</td>
<td style="text-align:left">实际工作中按照团队约定来写字体</td>
</tr>
<tr>
<td style="text-align:left">font-weight</td>
<td style="text-align:left">字体粗细</td>
<td style="text-align:left">记住加粗是 700 或者 bold  不加粗 是 normal 或者  400  记住数字不要跟单位</td>
</tr>
<tr>
<td style="text-align:left">font-style</td>
<td style="text-align:left">字体样式</td>
<td style="text-align:left">记住倾斜是 italic     不倾斜 是 normal  工作中我们最常用 normal</td>
</tr>
<tr>
<td style="text-align:left">font</td>
<td style="text-align:left">字体连写</td>
<td style="text-align:left">1. 字体连写是有顺序的  不能随意换位置 2. 其中字号 和 字体 必须同时出现</td>
</tr>
</tbody>
</table>
<h3 id="css外观属性">CSS外观属性</h3>
<h4 id="color文本颜色">color:文本颜色</h4>
<ul>
<li>
<p>作用：</p>
<p>color属性用于定义文本的颜色，</p>
</li>
<li>
<p>其取值方式有如下3种：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">表示表示</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">预定义的颜色值</td>
<td style="text-align:left">red，green，blue，还有我们的御用色 pink</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">#FF0000，#FF6600，#29D794</td>
</tr>
<tr>
<td style="text-align:left">RGB代码</td>
<td style="text-align:left">rgb(255,0,0)或rgb(100%,0%,0%)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>注意</p>
<p>我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如  #f00 代表红色</p>
</li>
</ul>
<h4 id="text-align文本水平对齐方式">text-align:文本水平对齐方式</h4>
<ul>
<li>
<p>作用：</p>
<p>text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性</p>
</li>
<li>
<p>其可用属性值如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td style="text-align:center">左对齐（默认值）</td>
</tr>
<tr>
<td>right</td>
<td style="text-align:center">右对齐</td>
</tr>
<tr>
<td>center</td>
<td style="text-align:center">居中对齐</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>注意：</p>
<p>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</p>
</li>
</ul>
<h4 id="line-height行间距">line-height:行间距</h4>
<ul>
<li>
<p>作用：</p>
<p>line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p>
</li>
<li>
<p>单位：</p>
<ul>
<li>line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</li>
</ul>
</li>
<li>
<p>技巧：</p>
</li>
</ul>
<pre><code>一般情况下，行距比字号大7.8像素左右就可以了。
line-height: 24px;
</code></pre>
<h4 id="text-indent首行缩进">text-indent:首行缩进</h4>
<ul>
<li>
<p>作用：</p>
<p>text-indent属性用于设置首行文本的缩进，</p>
</li>
<li>
<p>属性值</p>
<ul>
<li>其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</li>
<li>建议使用em作为设置单位。</li>
</ul>
</li>
</ul>
<p><strong>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p>
<pre><code class="language-css">p {
      /*行间距*/
      line-height: 25px;
      /*首行缩进2个字  em  1个em 就是1个字的大小*/
      text-indent: 2em;  
 }
</code></pre>
<h4 id="text-decoration-文本的装饰">text-decoration 文本的装饰</h4>
<p>text-decoration   通常我们用于给链接修改装饰效果</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认。定义标准的文本。 取消下划线（最常用）</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线。（不用）</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线。（不常用）</td>
</tr>
</tbody>
</table>
<h4 id="css外观属性总结">CSS外观属性总结</h4>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">表示</th>
<th style="text-align:left">注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">颜色</td>
<td style="text-align:left">我们通常用  十六进制   比如 而且是简写形式 #fff</td>
</tr>
<tr>
<td style="text-align:left">line-height</td>
<td style="text-align:left">行高</td>
<td style="text-align:left">控制行与行之间的距离</td>
</tr>
<tr>
<td style="text-align:left">text-align</td>
<td style="text-align:left">水平对齐</td>
<td style="text-align:left">可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td style="text-align:left">text-indent</td>
<td style="text-align:left">首行缩进</td>
<td style="text-align:left">通常我们用于段落首行缩进2个字的距离   text-indent: 2em;</td>
</tr>
<tr>
<td style="text-align:left">text-decoration</td>
<td style="text-align:left">文本修饰</td>
<td style="text-align:left">记住 添加 下划线  underline  取消下划线  none</td>
</tr>
</tbody>
</table>
<p>Emmet的前身是Zen coding,它使用缩写,来提高html/css的编写速度。</p>
<ol>
<li>
<p>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 <div></div></p>
</li>
<li>
<p>如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div</p>
</li>
<li>
<p>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</p>
</li>
<li>
<p>如果有兄弟关系的标签，用  +  就可以了 比如 div+p</p>
</li>
<li>
<p>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</p>
</li>
<li>
<p>如果生成的div 类名是有顺序的， 可以用 自增符号  $</p>
<pre><code>.demo$*3        
&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
</ol>
<h4 id="后代选择器重点">后代选择器（重点）</h4>
<ul>
<li>
<p>概念：</p>
<p>后代选择器又称为包含选择器</p>
</li>
<li>
<p>作用：</p>
<p>用来选择元素或元素组的<strong>子孙后代</strong></p>
</li>
<li>
<p>其写法就是把外层标签写在前面，内层标签写在后面，中间用<strong>空格</strong>分隔，先写父亲爷爷，在写儿子孙子。</p>
</li>
</ul>
<pre><code>父级 子级{属性:属性值;属性:属性值;}
</code></pre>
<ul>
<li>语法：</li>
</ul>
<pre><code>.class h3{color:red;font-size:16px;}
</code></pre>
<ul>
<li>当标签发生嵌套时，内层标签就成为外层标签的后代。</li>
<li>子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。</li>
</ul>
<h4 id="子元素选择器">子元素选择器</h4>
<ul>
<li>
<p>作用：</p>
<p>子元素选择器只能选择作为某元素**子元素(亲儿子)**的元素。</p>
</li>
<li>
<p>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 <code>&gt;</code> 进行连接</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<pre><code>.class&gt;h3{color:red;font-size:14px;}
</code></pre>
<pre><code> 比如：  .demo &gt; h3 {color: red;}   说明  h3 一定是demo 亲儿子。  demo 元素包含着h3。
</code></pre>
<h4 id="交集选择器">交集选择器</h4>
<ul>
<li>
<p>条件</p>
<p>交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。</p>
</li>
<li>
<p>其中第一个为标签选择器，第二个为class选择器，两个选择器之间<strong>不能有空格</strong>，如h3.special。</p>
</li>
</ul>
<p><strong>记忆技巧：</strong></p>
<p>交集选择器 是 并且的意思。  即...又...的意思</p>
<pre><code>比如：   p.one   选择的是： 类名为 .one  的 段落标签。  
</code></pre>
<p>用的相对来说比较少，不太建议使用</p>
<h4 id="并集选择器重点">并集选择器（重点）</h4>
<ul>
<li>
<p>应用：</p>
<ul>
<li>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。</li>
</ul>
</li>
<li>
<p>并集选择器（CSS选择器分组）是各个选择器通过<code>,</code>连接而成的，通常用于集体声明。</p>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。</p>
</li>
<li>
<p>记忆技巧：</p>
<p>并集选择器通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。</p>
</li>
</ul>
<pre><code>比如  .one, p , #test {color: #F00;}  
表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。 
通常用于集体声明。  
</code></pre>
<h4 id="链接伪类选择器重点">链接伪类选择器（重点）</h4>
<p>伪类选择器：</p>
<p>为了和我们刚才学的类选择器相区别<br>
类选择器是一个点 比如 .demo {}<br>
而我们的伪类 用 2个点 就是 冒号  比如  :link{}    伪娘</p>
<p>作用：</p>
<p>用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p>
<p>因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。</p>
<pre><code class="language-css">
</code></pre>
<ul>
<li>
<p>a:link      /* 未访问的链接 */</p>
</li>
<li>
<p>a:visited   /* 已访问的链接 */</p>
</li>
<li>
<p>a:hover     /* 鼠标移动到链接上 */</p>
</li>
<li>
<p>a:active    /* 选定的链接 */</p>
<p><strong>注意</strong></p>
</li>
</ul>
<ul>
<li>写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。</li>
<li>记忆法
<ul>
<li><strong>l</strong>o<strong>v</strong>e   <strong>ha</strong>te     爱上了讨厌</li>
<li>**lv **包包   非常 <strong>ha</strong>o</li>
</ul>
</li>
<li>因为叫链接伪类，所以都是 利用交集选择器  a:link    a:hover</li>
<li>因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li>
<li>实际工作开发中，我们很少写全四个状态，一般我们写法如下：</li>
</ul>
<pre><code class="language-css">a {   /* a是标签选择器  所有的链接 */
			font-weight: 700;
			font-size: 16px;
			color: gray;
}
a:hover {   /* :hover 是链接伪类选择器 鼠标经过 */
			color: red; /*  鼠标经过的时候，由原来的 灰色 变成了红色 */
}
</code></pre>
<h3 id="复合选择器总结">复合选择器总结</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>作用</th>
<th>特征</th>
<th>使用情况</th>
<th>隔开符号及用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>后代选择器</td>
<td>用来选择元素后代</td>
<td>是选择所有的子孙后代</td>
<td>较多</td>
<td>符号是<strong>空格</strong> .nav a</td>
</tr>
<tr>
<td>子代选择器</td>
<td>选择 最近一级元素</td>
<td>只选亲儿子</td>
<td>较少</td>
<td>符号是**&gt;**   .nav&gt;p</td>
</tr>
<tr>
<td>交集选择器</td>
<td>选择两个标签交集的部分</td>
<td>既是 又是</td>
<td>较少</td>
<td><strong>没有符号</strong>  p.one</td>
</tr>
<tr>
<td>并集选择器</td>
<td>选择某些相同样式的选择器</td>
<td>可以用于集体声明</td>
<td>较多</td>
<td>符号是<strong>逗号</strong> .nav, .header</td>
</tr>
<tr>
<td>链接伪类选择器</td>
<td>给链接更改状态</td>
<td></td>
<td>较多</td>
<td>重点记住 a{} 和 a:hover  实际开发的写法</td>
</tr>
</tbody>
</table>
<h3 id="标签显示模式display重点">标签显示模式（display）重点</h3>
<ul>
<li>
<p>什么是标签的显示模式？</p>
<p>标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个</p>
</li>
<li>
<p>作用：</p>
<p>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p>
</li>
<li>
<p>标签的类型(分类)</p>
<p>HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p>
</li>
</ul>
<h4 id="块级元素block-level">块级元素(block-level)</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。
</code></pre>
<ul>
<li>块级元素的特点</li>
</ul>
<p>（1）比较霸道，自己独占一行</p>
<p>（2）高度，宽度、外边距以及内边距都可以控制。</p>
<p>（3）宽度默认是容器（父级宽度）的100%</p>
<p>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p>
<ul>
<li>注意：
<ul>
<li>只有 文字才 能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div</li>
<li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
</li>
</ul>
<h4 id="行内元素inline-level">行内元素(inline-level)</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素
</code></pre>
<ul>
<li>行内元素的特点：</li>
</ul>
<p>（1）相邻行内元素在一行上，一行可以显示多个。</p>
<p>（2）高、宽直接设置是无效的。</p>
<p>（3）默认宽度就是它本身内容的宽度。</p>
<p>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p>
<p>​     注意：</p>
<ul>
<li>链接里面不能再放链接。</li>
<li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li>
</ul>
<h4 id="行内块元素inline-block">行内块元素（inline-block）</h4>
<ul>
<li>例：</li>
</ul>
<pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。
</code></pre>
<ul>
<li>
<p>行内块元素的特点：</p>
<p>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>
（2）默认宽度就是它本身内容的宽度。<br>
（3）高度，行高、外边距以及内边距都可以控制。</p>
</li>
</ul>
<h3 id="三种模式总结区别">三种模式总结区别</h3>
<table>
<thead>
<tr>
<th>元素模式</th>
<th>元素排列</th>
<th>设置样式</th>
<th>默认宽度</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>块级元素</td>
<td>一行只能放一个块级元素</td>
<td>可以设置宽度高度</td>
<td>容器的100%</td>
<td>容器级可以包含任何标签</td>
</tr>
<tr>
<td>行内元素</td>
<td>一行可以放多个行内元素</td>
<td>不可以直接设置宽度高度</td>
<td>它本身内容的宽度</td>
<td>容纳文本或则其他行内元素</td>
</tr>
<tr>
<td>行内块元素</td>
<td>一行放多个行内块元素</td>
<td>可以设置宽度和高度</td>
<td>它本身内容的宽度</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="标签显示模式转换-display">标签显示模式转换 display</h4>
<ul>
<li>块转行内：display:inline;</li>
<li>行内转块：display:block;</li>
<li><strong>块、行内元素转换为行内块： display: inline-block;</strong></li>
</ul>
<p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p>
<h4 id="行高那些事line-height">行高那些事（line-height）</h4>
<h4 id="单行文本垂直居中">单行文本垂直居中</h4>
<p>行高   =  上距离 +  内容高度  + 下距离</p>
<p>上距离和下距离总是相等的，因此文字看上去是垂直居中的。</p>
<p><strong>行高和高度的三种关系</strong></p>
<ul>
<li>如果 行高 等 高度  文字会 垂直居中</li>
<li>如果行高 大于 高度   文字会 偏下</li>
<li>如果行高小于高度   文字会  偏上</li>
</ul>
<h3 id="css-背景background">CSS 背景(background)</h3>
<h4 id="背景颜色color">背景颜色(color)</h4>
<ul>
<li>
<p>语法：</p>
<pre><code>background-color:颜色值;   默认的值是 transparent  透明的
</code></pre>
</li>
</ul>
<h4 id="背景图片image">背景图片(image)</h4>
<ul>
<li>语法：</li>
<li></li>
</ul>
<pre><code class="language-css">background-image : none | url (url) 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td style="text-align:center">无背景图（默认的）</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">使用绝对或相对地址指定背景图像</td>
</tr>
</tbody>
</table>
<pre><code class="language-css">background-image : url(images/demo.png);
</code></pre>
<ul>
<li>小技巧：  我们提倡 背景图片后面的地址，<strong>url不要加引号。</strong></li>
</ul>
<h4 id="背景平铺repeat">背景平铺（repeat）</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background-repeat : repeat | no-repeat | repeat-x | repeat-y 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td style="text-align:center">背景图像在纵向和横向上平铺（默认的）</td>
</tr>
<tr>
<td>no-repeat</td>
<td style="text-align:center">背景图像不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td style="text-align:center">背景图像在横向上平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td style="text-align:center">背景图像在纵向平铺</td>
</tr>
</tbody>
</table>
<h4 id="背景位置position-重点">背景位置(position) 重点</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background-position : length || length

background-position : position || position 
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td style="text-align:center">百分数 | 由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td style="text-align:center">top | center | bottom | left | center | right   方位名词</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：
<ul>
<li>必须先指定background-image属性</li>
<li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致</li>
<li>如果只指定了一个方位名词，另一个值默认居中对齐。</li>
<li>如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y</li>
<li>如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中</li>
<li>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
</li>
</ul>
<p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p>
<p>练习1：</p>
<p>背景大图</p>
<p>练习2：</p>
<p>小图片在盒子左侧垂直居中</p>
<h4 id="背景附着">背景附着</h4>
<ul>
<li>
<p>背景附着就是解释背景是滚动的还是固定的</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-】">background-attachment : scroll | fixed 
</code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scroll</td>
<td style="text-align:center">背景图像是随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td style="text-align:center">背景图像固定</td>
</tr>
</tbody>
</table>
<h4 id="背景简写">背景简写</h4>
<ul>
<li>background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</li>
<li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li>
<li>语法：</li>
</ul>
<pre><code class="language-css">background: transparent url(image.jpg) repeat-y  scroll center top ;
</code></pre>
<p>案例：</p>
<p>导航栏案例</p>
<h4 id="背景透明css3">背景透明(CSS3)</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">background: rgba(0, 0, 0, 0.3);
</code></pre>
<ul>
<li>最后一个参数是alpha 透明度  取值范围 0~1之间</li>
<li>我们习惯把0.3 的 0 省略掉  这样写  background: rgba(0, 0, 0, .3);</li>
<li>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li>
<li>因为是CSS3 ，所以 低于 ie9 的版本是不支持的。</li>
</ul>
<h4 id="背景总结">背景总结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-color</td>
<td style="text-align:left">背景颜色</td>
<td style="text-align:left">预定义的颜色值/十六进制/RGB代码</td>
</tr>
<tr>
<td>background-image</td>
<td style="text-align:left">背景图片</td>
<td style="text-align:left">url(图片路径)</td>
</tr>
<tr>
<td>background-repeat</td>
<td style="text-align:left">是否平铺</td>
<td style="text-align:left">repeat/no-repeat/repeat-x/repeat-y</td>
</tr>
<tr>
<td>background-position</td>
<td style="text-align:left">背景位置</td>
<td style="text-align:left">length/position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法</td>
</tr>
<tr>
<td>background-attachment</td>
<td style="text-align:left">背景固定还是滚动</td>
<td style="text-align:left">scroll/fixed</td>
</tr>
<tr>
<td>背景简写</td>
<td style="text-align:left">更简单</td>
<td style="text-align:left">背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序</td>
</tr>
<tr>
<td>背景透明</td>
<td style="text-align:left">让盒子半透明</td>
<td style="text-align:left">background: rgba(0,0,0,0.3);   后面必须是 4个值</td>
</tr>
</tbody>
</table>
<h3 id="css-三大特性">CSS 三大特性</h3>
<h4 id="css层叠性">CSS层叠性</h4>
<ul>
<li>
<p>概念：</p>
<p>所谓层叠性是指多种CSS样式的叠加。</p>
<p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p>
</li>
<li>
<p>原则：</p>
<ul>
<li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li>
<li>样式不冲突，不会层叠</li>
</ul>
</li>
</ul>
<pre><code>CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。
</code></pre>
<h4 id="css继承性">CSS继承性</h4>
<ul>
<li>
<p>概念：</p>
<p>子标签会继承父标签的某些样式，如文本颜色和字号。</p>
<p>想要设置一个可继承的属性，只需将它应用于父元素即可。</p>
</li>
</ul>
<p>简单的理解就是：  子承父业。</p>
<ul>
<li><strong>注意</strong>：
<ul>
<li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li>
<li>子元素可以继承父元素的样式（<strong>text-，font-，line-这些元素开头的可以继承，以及color属性</strong>）</li>
</ul>
</li>
</ul>
<pre><code>CSS继承性口诀：  龙生龙，凤生凤，老鼠生的孩子会打洞。
</code></pre>
<h4 id="css优先级重点">CSS优先级（重点）</h4>
<ul>
<li>
<p>概念：</p>
<p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，就会出现优先级的问题。</li>
</ul>
</li>
</ul>
<h5 id="1-权重计算公式">1). 权重计算公式</h5>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p>
<table>
<thead>
<tr>
<th>标签选择器</th>
<th>计算权重公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承或者 *</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>每个元素（标签选择器）</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类，伪类</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>每个行内样式 style=&quot;&quot;</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important  重要的</td>
<td>∞ 无穷大</td>
</tr>
</tbody>
</table>
<ul>
<li>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</li>
<li>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li>
<li>div {<br>
color: pink!important;<br>
}</li>
</ul>
<h5 id="2-权重叠加">2). 权重叠加</h5>
<p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p>
<p>就是一个简单的加法计算</p>
<ul>
<li>
<p>div ul  li   ------&gt;      0,0,0,3</p>
</li>
<li>
<p>.nav ul li   ------&gt;      0,0,1,2</p>
</li>
<li>
<p>a:hover      -----—&gt;   0,0,1,1</p>
</li>
<li>
<p>.nav a       ------&gt;      0,0,1,1</p>
<p>注意：</p>
</li>
</ul>
<ol>
<li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</li>
</ol>
<h5 id="3-继承的权重是0">3). 继承的权重是0</h5>
<p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p>
<p>1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>
2） 如果没有选中，那么权重是0，因为继承的权重为0.</p>
<h3 id="css注释">CSS注释</h3>
<p><strong>CSS注释规则：</strong></p>
<pre><code>/*  需要注释的内容  */  进行注释的，即在需要注释的内容前使用 &quot;/*&quot; 标记开始注释，在内容的结尾使用 &quot;*/&quot;结束。
</code></pre>
<p>例如：</p>
<pre><code class="language-css">p {
 /* 所有的字体是14像素大小*/
  font-size: 14px;                 
}
</code></pre>
<h3 id="盒子模型css重点">盒子模型（CSS重点）</h3>
<p>所谓盒子模型：</p>
<ul>
<li>就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</li>
</ul>
<ul>
<li>盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。</li>
<li>盒子里面的文字和图片等元素是 内容区域</li>
<li>盒子的厚度 我们成为 盒子的边框</li>
<li>盒子内容与边框的距离是内边距（类似单元格的 cellpadding)</li>
<li>盒子与盒子之间的距离是外边距（类似单元格的 cellspacing）</li>
</ul>
<h4 id="盒子边框border">盒子边框（border）</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">border : border-width || border-style || border-color 
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-width</td>
<td style="text-align:center">定义边框粗细，单位是px</td>
</tr>
<tr>
<td>border-style</td>
<td style="text-align:center">边框的样式</td>
</tr>
<tr>
<td>border-color</td>
<td style="text-align:center">边框颜色</td>
</tr>
</tbody>
</table>
<ul>
<li>边框的样式：
<ul>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线</li>
<li>dotted：边框为点线</li>
</ul>
</li>
</ul>
<h5 id="边框综合设置">边框综合设置</h5>
<pre><code>border : border-width || border-style || border-color 
</code></pre>
<p>例如：</p>
<pre><code class="language-css"> border: 1px solid red;  没有顺序  
</code></pre>
<h5 id="盒子边框写法总结表">盒子边框写法总结表</h5>
<p>很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">上边框</th>
<th style="text-align:left">下边框</th>
<th style="text-align:left">左边框</th>
<th style="text-align:left">右边框</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">border-top-style:样式;</td>
<td style="text-align:left">border-bottom-style:样式;</td>
<td style="text-align:left">border-left-style:样式;</td>
<td style="text-align:left">border-right-style:样式;</td>
</tr>
<tr>
<td style="text-align:left">border-top-width:宽度;</td>
<td style="text-align:left">border- bottom-width:宽度;</td>
<td style="text-align:left">border-left-width:宽度;</td>
<td style="text-align:left">border-right-width:宽度;</td>
</tr>
<tr>
<td style="text-align:left">border-top-color:颜色;</td>
<td style="text-align:left">border- bottom-color:颜色;</td>
<td style="text-align:left">border-left-color:颜色;</td>
<td style="text-align:left">border-right-color:颜色;</td>
</tr>
<tr>
<td style="text-align:left">border-top:宽度 样式 颜色;</td>
<td style="text-align:left">border-bottom:宽度 样式 颜色;</td>
<td style="text-align:left">border-left:宽度 样式 颜色;</td>
<td style="text-align:left">border-right:宽度 样式 颜色;</td>
</tr>
</tbody>
</table>
<h5 id="表格的细线边框">表格的细线边框</h5>
<ul>
<li>
<p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为0，</p>
</li>
<li>
<p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li>
<p>通过css属性：</p>
<pre><code>table{ border-collapse:collapse; }  
</code></pre>
<ul>
<li>collapse 单词是合并的意思</li>
<li>border-collapse:collapse; 表示相邻边框合并在一起。</li>
</ul>
</li>
</ul>
<pre><code class="language-css">&lt;style&gt;
	table {
		width: 500px;
		height: 300px;
		border: 1px solid red;
	}
	td {
		border: 1px solid red;
		text-align: center;
	}
	table, td {
		border-collapse: collapse;  /*合并相邻边框*/
	}
&lt;/style&gt;
</code></pre>
<h4 id="内边距padding">内边距（padding）</h4>
<p>内边距：</p>
<p>​	padding属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p>
<p>设置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>padding-left</td>
<td style="text-align:left">左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td style="text-align:left">右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td style="text-align:left">上内边距</td>
</tr>
<tr>
<td>padding-bottom</td>
<td style="text-align:left">下内边距</td>
</tr>
</tbody>
</table>
<p>当我们给盒子指定padding值之后， 发生了2件事情：</p>
<ol>
<li>内容和边框 有了距离，添加了内边距。</li>
<li>盒子会变大了。</li>
</ol>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个值</td>
<td>padding：上下左右内边距;</td>
</tr>
<tr>
<td>2个值</td>
<td>padding: 上下内边距    左右内边距 ；</td>
</tr>
<tr>
<td>3个值</td>
<td>padding：上内边距   左右内边距   下内边距；</td>
</tr>
<tr>
<td>4个值</td>
<td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td>
</tr>
</tbody>
</table>
<h4 id="内盒尺寸计算元素实际大小">内盒尺寸计算（元素实际大小）</h4>
<ul>
<li>
<p>宽度</p>
<p>Element Height = content height + padding + border （Height为内容高度）</p>
</li>
<li>
<p>高度</p>
<p>Element Width = content width + padding + border （Width为内容宽度）</p>
</li>
<li>
<p>盒子的实际的大小 =   内容的宽度和高度 +  内边距   +  边框</p>
</li>
</ul>
<p>padding不影响盒子大小情况</p>
<blockquote>
<p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p>
</blockquote>
<h4 id="外边距margin">外边距（margin）</h4>
<p>​	margin属性用于设置外边距。  margin就是控制<strong>盒子和盒子之间的距离</strong></p>
<p>设置：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-left</td>
<td style="text-align:left">左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td style="text-align:left">右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td style="text-align:left">上外边距</td>
</tr>
<tr>
<td>margin-bottom</td>
<td style="text-align:left">下外边距</td>
</tr>
</tbody>
</table>
<p>margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p>
<h4 id="块级盒子水平居中">块级盒子水平居中</h4>
<ul>
<li>可以让一个块级盒子实现水平居中必须：
<ul>
<li>盒子必须指定了宽度（width）</li>
<li>然后就给<strong>左右的外边距都设置为auto</strong>，</li>
</ul>
</li>
</ul>
<p>实际工作中常用这种方式进行网页布局，示例代码如下：</p>
<pre><code class="language-css">.header{ width:960px; margin:0 auto;}
</code></pre>
<p>常见的写法，以下下三种都可以。</p>
<ul>
<li>margin-left: auto;   margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<h4 id="文字居中和盒子居中区别">文字居中和盒子居中区别</h4>
<ol>
<li>盒子内的文字水平居中是  text-align: center,  而且还可以让 行内元素和行内块居中对齐</li>
<li>块级盒子水平居中  左右margin 改为 auto</li>
</ol>
<pre><code class="language-css">text-align: center; /*  文字 行内元素 行内块元素水平居中 */
margin: 10px auto;  /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */
</code></pre>
<h4 id="插入图片和背景图片区别">插入图片和背景图片区别</h4>
<ol>
<li>插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</li>
<li>背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</li>
</ol>
<pre><code class="language-css"> img {  
		width: 200px;/* 插入图片更改大小 width 和 height */
		height: 210px;
		margin-top: 30px;  /* 插入图片更改位置 可以用margin 或padding  盒模型 */
		margin-left: 50px; /* 插入当图片也是一个盒子 */
	}

 div {
		width: 400px;
		height: 400px;
		border: 1px solid purple;
		background: #fff url(images/sun.jpg) no-repeat;
		background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */
	}
</code></pre>
<h4 id="清除元素的默认内外边距重要">清除元素的默认内外边距(重要)</h4>
<p>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</p>
<p>代码：</p>
<pre><code class="language-css">* {
   padding:0;         /* 清除内边距 */
   margin:0;          /* 清除外边距 */
}
</code></pre>
<p>注意：</p>
<ul>
<li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li>
</ul>
<h4 id="外边距合并">外边距合并</h4>
<p>使用margin定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p>
<p><strong>(1). 相邻块元素垂直外边距的合并</strong></p>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li>
</ul>
<p><strong>解决方案：尽量给只给一个盒子添加margin值</strong>。</p>
<p><strong>(2). 嵌套块元素垂直外边距的合并（塌陷）</strong></p>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow:hidden。</li>
</ol>
<p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p>
<h4 id="盒子模型布局稳定性">盒子模型布局稳定性</h4>
<ul>
<li>
<p>学习完盒子模型，内边距和外边距，什么情况下用内边距，什么情况下用外边距？</p>
<ul>
<li>大部分情况下是可以混用的。  就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。</li>
</ul>
</li>
</ul>
<p>我们根据稳定性来分，建议如下：</p>
<p>按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。</p>
<pre><code>  width &gt;  padding  &gt;   margin   
</code></pre>
<ul>
<li>原因：
<ul>
<li>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</li>
<li>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li>
<li>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</li>
</ul>
</li>
</ul>
<h3 id="ps基本操作以及常用快捷键">ps基本操作以及常用快捷键：</h3>
<p>因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。</p>
<ul>
<li>文件--打开 --  可以打开 我们要测量的图片</li>
<li>ctrl+r 可以打开标尺  或者  视图 --  标尺</li>
<li>右击标尺，  把里面的单位改为  像素</li>
<li>ctrl+ 加号 键  可以 放大  视图  ctrl+ 减号 缩小视图</li>
<li>按住空格键，  鼠标可以 变成小手 ，拖动 ps 视图</li>
<li>用选区 拖动  可以 测量 大小</li>
<li>ctrl+ d  可以取消选区  或者旁边空白处点击一下也可以取消选区</li>
</ul>
<h3 id="圆角边框css3">圆角边框(CSS3)</h3>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-css">border-radius:length;  
</code></pre>
<ul>
<li>
<p>其中每一个值可以为 数值或百分比的形式。</p>
</li>
<li>
<p>技巧： 让一个正方形  变成圆圈</p>
<pre><code>border-radius: 50%;
</code></pre>
</li>
</ul>
<ul>
<li>效果图矩形的圆角， 就不要用 百分比了，因为百分比会是表示高度和宽度的一半。</li>
<li>而我们这里矩形就只用 用 高度的一半就好了。精确单位。</li>
</ul>
<h3 id="盒子阴影css3">盒子阴影(CSS3)</h3>
<ul>
<li>语法:</li>
</ul>
<pre><code class="language-css">box-shadow:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；
</code></pre>
<ul>
<li>前两个属性是必须写的。其余的可以省略。</li>
<li>外阴影 (outset) 是默认的 但是不能写           想要内阴影可以写  inset</li>
</ul>
<pre><code class="language-css">div {
			width: 200px;
			height: 200px;
			border: 10px solid red;
			/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */
			/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */
			box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);
			
}
</code></pre>
<h3 id="css书写规范">CSS书写规范</h3>
<h4 id="空格规范">空格规范</h4>
<p>【强制】 选择器 与 { 之间必须包含空格。</p>
<p>示例：</p>
<pre><code class="language-css">.selector {
}
</code></pre>
<p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</p>
<p>示例：</p>
<pre><code class="language-css">font-size: 12px;
</code></pre>
<h4 id="选择器规范">选择器规范</h4>
<p>【强制】 并集选择器，每个选择器声明必须独占一行。</p>
<p>示例：</p>
<pre><code>/* good */
.post,
.page,
.comment {
    line-height: 1.5;
}


/* bad */
.post, .page, .comment {
    line-height: 1.5;
}
</code></pre>
<p>【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
#username input {}
.comment .avatar {}

/* bad */
.page .header .login  input {}
.comment div * {}
</code></pre>
<h4 id="属性规范">属性规范</h4>
<p>【强制】 属性定义必须另起一行。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
.selector {
    margin: 0;
    padding: 0;
}

/* bad */
.selector { margin: 0; padding: 0; }
</code></pre>
<p>【强制】 属性定义后必须以分号结尾。</p>
<p>示例：</p>
<pre><code class="language-css">/* good */
.selector {
    margin: 0;
}

/* bad */
.selector {
    margin: 0
}
</code></pre>
<h3 id="浮动float">浮动(float)</h3>
<p><strong>CSS 布局的三种机制</strong></p>
<p>分别是<strong>普通流</strong>（标准流）、<strong>浮动</strong>和<strong>定位</strong></p>
<p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p>
<ol>
<li>脱离标准普通流的控制</li>
<li>移动到指定位置。</li>
</ol>
<p><strong>作用</strong></p>
<ol>
<li><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</li>
<li>可以实现盒子的左右对齐等等..</li>
<li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</li>
</ol>
<p><strong>语法</strong></p>
<p>在 CSS 中，通过 <code>float</code>  中文，  浮 漏 特    属性定义浮动，语法如下：</p>
<pre><code>选择器 { float: 属性值; }
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>none</strong></td>
<td>元素不浮动（<strong>默认值</strong>）</td>
</tr>
<tr>
<td><strong>left</strong></td>
<td>元素向<strong>左</strong>浮动</td>
</tr>
<tr>
<td><strong>right</strong></td>
<td>元素向<strong>右</strong>浮动</td>
</tr>
</tbody>
</table>
<p><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</p>
<p>浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p>
<p>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似。</p>
<p><strong>float</strong> —— <strong>浮漏特</strong></p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>浮</td>
<td>加了浮动的盒子<strong>是浮起来</strong>的，漂浮在其他标准流盒子的上面。</td>
</tr>
<tr>
<td>漏</td>
<td>加了浮动的盒子<strong>是不占位置的</strong>，它原来的位置<strong>漏给了标准流的盒子</strong>。</td>
</tr>
<tr>
<td>特</td>
<td><strong>特别注意</strong>：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙</td>
</tr>
</tbody>
</table>
<h4 id="浮动float的应用重要">浮动(float)的应用（重要）</h4>
<p>注意，实际重要的导航栏中，我们不会直接用链接a 而是用 li  包含链接(li+a)的做法。</p>
<ol>
<li>li+a 语义更清晰，一看这就是有条理的列表型内容。</li>
<li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名</li>
</ol>
<h4 id="浮动float的扩展">浮动(float)的扩展</h4>
<p>浮动元素与父盒子的关系</p>
<ul>
<li>子盒子的浮动参照父盒子对齐</li>
<li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li>
</ul>
<p>浮动元素与兄弟盒子的关系</p>
<p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p>
<ul>
<li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li>
<li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。</li>
</ul>
<h4 id="清除浮动">清除浮动</h4>
<p><strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p>
<h4 id="清除浮动的方法">清除浮动的方法</h4>
<p>在CSS中，clear属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完css会再回头分析。</p>
<ul>
<li>语法：</li>
</ul>
<pre><code>选择器{clear:属性值;}   clear 清除  
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
<p>但是我们实际工作中， 几乎只用 clear: both;</p>
<h5 id="1额外标签法隔墙法">1).额外标签法(隔墙法)</h5>
<pre><code class="language-html">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。
</code></pre>
<ul>
<li>优点： 通俗易懂，书写方便</li>
<li>缺点： 添加许多无意义的标签，结构化较差。</li>
</ul>
<h5 id="2父级添加overflow属性方法">2).父级添加overflow属性方法</h5>
<pre><code class="language-css">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。
</code></pre>
<p>优点：  代码简洁</p>
<p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<h5 id="3使用after伪元素清除浮动">3).使用after伪元素清除浮动</h5>
<p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p>
<p>使用方法：</p>
<pre><code class="language-css"> .clearfix:after {  content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;  }   

 .clearfix {*zoom: 1;}   /* IE6、7 专有 */
</code></pre>
<ul>
<li>优点： 符合闭合浮动思想  结构语义化正确</li>
<li>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li>
</ul>
<h5 id="4用双伪元素清除浮动">4).用双伪元素清除浮动</h5>
<p>使用方法：</p>
<pre><code class="language-css">.clearfix:before,.clearfix:after { 
  content:&quot;&quot;;
  display:table; 
}
.clearfix:after {
 clear:both;
}
.clearfix {
  *zoom:1;
}
</code></pre>
<ul>
<li>
<p>优点：  代码更简洁</p>
</li>
<li>
<p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
</li>
</ul>
<ol>
<li>父级没高度</li>
<li>子盒子浮动了</li>
<li>影响下面布局了，我们就应该清除浮动了。</li>
</ol>
<table>
<thead>
<tr>
<th>清除浮动的方式</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>额外标签法（隔墙法）</td>
<td style="text-align:left">通俗易懂，书写方便</td>
<td style="text-align:left">添加许多无意义的标签，结构化较差。</td>
</tr>
<tr>
<td>父级overflow:hidden;</td>
<td style="text-align:left">书写简单</td>
<td style="text-align:left">溢出隐藏</td>
</tr>
<tr>
<td>父级after伪元素</td>
<td style="text-align:left">结构语义化正确</td>
<td style="text-align:left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
<tr>
<td>父级双伪元素</td>
<td style="text-align:left">结构语义化正确</td>
<td style="text-align:left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
</tbody>
</table>
<p><strong>常见的图片格式</strong></p>
<pre><code>1. jpg图像格式： 
JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的
2. gif图像格式：
GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果
3. png图像格式
是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景
4. PSD图像格式
PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。 
</code></pre>
<p>PS切图   可以 分为   利用切片工具切图 以及   利用PS的插件快速切图。</p>
<h3 id="css属性书写顺序重点">CSS属性书写顺序(重点)</h3>
<p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li>
</ol>
<pre><code class="language-css">.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre>
<h3 id="布局流程">布局流程</h3>
<p>为了提高网页制作的效率，布局时通常有以下的布局流程，具体如下：</p>
<p>1、必须确定页面的版心（可视区）， 我们测量可得知。</p>
<p>2、分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成</p>
<p>3、制作HTML结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</p>
<p>4、然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</p>
<h3 id="定位position">定位(position)</h3>
<p>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>、<strong>浮动</strong>和<strong>定位</strong>，其中：</p>
<ol>
<li>
<p><strong>普通流</strong>（<strong>标准流</strong>）</p>
</li>
<li>
<p><strong>浮动</strong></p>
<ul>
<li>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</li>
</ul>
</li>
<li>
<p><strong>定位</strong></p>
<ul>
<li>将盒子<strong>定</strong>在某一个<strong>位</strong>置  自由的漂浮在其他盒子的上面  —— CSS 离不开定位，特别是后面的 js 特效。</li>
</ul>
</li>
</ol>
<h4 id="边偏移">边偏移</h4>
<p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。</p>
<p>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th style="text-align:left">示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top</code></td>
<td style="text-align:left"><code>top: 80px</code></td>
<td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td style="text-align:left"><code>bottom: 80px</code></td>
<td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td>
</tr>
<tr>
<td><code>left</code></td>
<td style="text-align:left"><code>left: 80px</code></td>
<td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td>
</tr>
<tr>
<td><code>right</code></td>
<td style="text-align:left"><code>right: 80px</code></td>
<td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td>
</tr>
</tbody>
</table>
<p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p>
<h4 id="定位模式-position">定位模式 (position)</h4>
<p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p>
<pre><code class="language-css">选择器 { position: 属性值; }
</code></pre>
<p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th style="text-align:center">语义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static</code></td>
<td style="text-align:center"><strong>静态</strong>定位</td>
</tr>
<tr>
<td><code>relative</code></td>
<td style="text-align:center"><strong>相对</strong>定位</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td style="text-align:center"><strong>绝对</strong>定位</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td style="text-align:center"><strong>固定</strong>定位</td>
</tr>
</tbody>
</table>
<p>静态定位(static) - 了解</p>
<ul>
<li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。</li>
<li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li>
<li>静态定位在布局时我们几乎不用的</li>
</ul>
<h4 id="相对定位relative-重要">相对定位(relative) - 重要</h4>
<ul>
<li><strong>相对定位</strong>是元素<strong>相对</strong>于它  原来在标准流中的位置 来说的。（自恋型）</li>
</ul>
<p>相对定位的特点：（务必记住）</p>
<ul>
<li>相对于 自己原来在标准流中位置来移动的</li>
<li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li>
</ul>
<h4 id="绝对定位absolute-重要">绝对定位(absolute) - 重要</h4>
<p><strong>绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p>
<ol>
<li>
<p><strong>完全脱标</strong> —— 完全不占位置；</p>
</li>
<li>
<p><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）。</p>
</li>
</ol>
<p><strong>父元素要有定位</strong></p>
<ul>
<li>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li>
</ul>
<p>绝对定位的特点：（务必记住）</p>
<ul>
<li>绝对是以带有定位的父级元素来移动位置 （拼爹型） 如果父级都没有定位，则以浏览器文档为准移动位置</li>
<li>不保留原来的位置，完全是脱标的。</li>
</ul>
<p><strong>定位口诀 —— 子绝父相</strong></p>
<p>刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢？</p>
<p><strong>子绝父相</strong> —— <strong>子级</strong>是<strong>绝对</strong>定位，<strong>父级</strong>要用<strong>相对</strong>定位。</p>
<blockquote>
<p><strong>子绝父相</strong>是使用绝对定位的口诀，要牢牢记住！</p>
</blockquote>
<p><strong>疑问</strong>：为什么在布局时，<strong>子级元素</strong>使用<strong>绝对定位</strong>时，<strong>父级元素</strong>就要用<strong>相对定位</strong>呢？</p>
<h4 id="固定定位fixed-重要">固定定位(fixed) - 重要</h4>
<p><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）   如果说绝对定位是一个矩形 那么 固定定位就类似于正方形</p>
<ol>
<li><strong>完全脱标</strong> —— 完全不占位置；</li>
<li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；
<ul>
<li>跟父元素没有任何关系；单独使用的</li>
<li>不随滚动条滚动。</li>
</ul>
</li>
</ol>
<h4 id="定位position的扩展">定位(position)的扩展</h4>
<p><strong>绝对定位的盒子居中</strong></p>
<blockquote>
<p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p>
</blockquote>
<ol>
<li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li>
<li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li>
</ol>
<p><strong>堆叠顺序（z-index）</strong></p>
<ol>
<li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li>
<li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li>
<li><strong>数字后面不能加单位</strong>。</li>
</ol>
<p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p>
<p><strong>定位改变display属性</strong></p>
<p>前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式:</p>
<ul>
<li>可以用inline-block  转换为行内块</li>
<li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li>
</ul>
<p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<blockquote>
<p>完善新浪导航案例</p>
</blockquote>
<p><strong>同时注意：</strong></p>
<p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</p>
<p>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
<h4 id="圆角矩形设置4个角">圆角矩形设置4个角</h4>
<p>圆角矩形可以为4个角分别设置圆度， 但是是有顺序的</p>
<pre><code>border-top-left-radius:20px;
border-top-right-radius:20px;
border-bottom-right-radius:20px;
border-bottom-left-radius:20px;
</code></pre>
<ul>
<li>
<p>如果4个角，数值相同</p>
<pre><code class="language-css">border-radius: 15px;
</code></pre>
</li>
<li>
<p>里面数值不同，我们也可以按照简写的形式，具体格式如下:</p>
</li>
</ul>
<pre><code class="language-css">border-radius: 左上角 右上角  右下角  左下角;
</code></pre>
<p>还是遵循的顺时针。</p>
<h3 id="定位小结">定位小结</h3>
<table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标占有位置</th>
<th style="text-align:left">移动位置基准</th>
<th>模式转换（行内块）</th>
<th>使用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态static</td>
<td>不脱标，正常模式</td>
<td style="text-align:left">正常模式</td>
<td>不能</td>
<td>几乎不用</td>
</tr>
<tr>
<td>相对定位relative</td>
<td>不脱标，占有位置</td>
<td style="text-align:left">相对自身位置移动</td>
<td>不能</td>
<td>基本单独使用</td>
</tr>
<tr>
<td>绝对定位absolute</td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于定位父级移动位置</td>
<td>能</td>
<td>要和定位父级元素搭配使用</td>
</tr>
<tr>
<td>固定定位fixed</td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于浏览器移动位置</td>
<td>能</td>
<td>单独使用，不需要父级</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<ol>
<li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li>
<li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li>
<li><code>left</code> 和 <code>right</code> 不要同时使用。</li>
</ol>
<h3 id="元素的显示与隐藏">元素的显示与隐藏</h3>
<h4 id="display-显示重点">display 显示（重点）</h4>
<ul>
<li>
<p>display 设置或检索对象是否及如何显示。</p>
<pre><code>display: none 隐藏对象

display：block 除了转换为块级元素之外，同时还有显示元素的意思。
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，不再保留位置。</p>
</li>
</ul>
<p>实际开发场景：</p>
<blockquote>
<p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
</blockquote>
<h4 id="visibility-可见性-了解">visibility 可见性 (了解)</h4>
<ul>
<li>
<p>设置或检索是否显示对象。</p>
<pre><code>visibility：visible ; 　对象可视

visibility：hidden; 　  对象隐藏
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，继续保留原有位置。</p>
</li>
</ul>
<h4 id="overflow-溢出重点">overflow 溢出(重点)</h4>
<ul>
<li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>visible</strong></td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td><strong>hidden</strong></td>
<td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td><strong>scroll</strong></td>
<td>不管超出内容否，总是显示滚动条</td>
</tr>
<tr>
<td><strong>auto</strong></td>
<td>超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody>
</table>
<p>实际开发场景：</p>
<ol>
<li>清除浮动</li>
<li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li>
</ol>
<h3 id="显示与隐藏总结">显示与隐藏总结</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>区别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>display</strong></td>
<td>隐藏对象，不保留位置</td>
<td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td>
</tr>
<tr>
<td><strong>visibility</strong></td>
<td>隐藏对象，保留位置</td>
<td>使用较少</td>
</tr>
<tr>
<td><strong>overflow</strong></td>
<td>只是隐藏超出大小的部分</td>
<td>1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody>
</table>
<h3 id="css用户界面样式">CSS用户界面样式</h3>
<p>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。</p>
<ul>
<li>更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究)</li>
<li>表单轮廓等。</li>
<li>防止表单域拖拽</li>
</ul>
<h4 id="鼠标样式cursor">鼠标样式cursor</h4>
<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>default</strong></td>
<td>小白  默认</td>
</tr>
<tr>
<td><strong>pointer</strong></td>
<td>小手</td>
</tr>
<tr>
<td><strong>move</strong></td>
<td>移动</td>
</tr>
<tr>
<td><strong>text</strong></td>
<td>文本</td>
</tr>
<tr>
<td><strong>not-allowed</strong></td>
<td>禁止</td>
</tr>
</tbody>
</table>
<h4 id="轮廓线-outline">轮廓线 outline</h4>
<p>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<pre><code class="language-css"> outline : outline-color ||outline-style || outline-width 
</code></pre>
<p>但是我们都不关心可以设置多少，我们平时都是去掉的。 li</p>
<p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p>
<pre><code class="language-html"> &lt;input  type=&quot;text&quot;  style=&quot;outline: 0;&quot;/&gt;
</code></pre>
<h4 id="防止拖拽文本域resize">防止拖拽文本域resize</h4>
<p>实际开发中，我们文本域右下角是不可以拖拽：</p>
<pre><code class="language-html">&lt;textarea  style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h3 id="用户界面样式总结">用户界面样式总结</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>用途</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>鼠标样式</strong></td>
<td>更改鼠标样式cursor</td>
<td>样式很多，重点记住 pointer</td>
</tr>
<tr>
<td><strong>轮廓线</strong></td>
<td>表单默认outline</td>
<td>outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用</td>
</tr>
<tr>
<td>防止拖拽</td>
<td>主要针对文本域resize</td>
<td>防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none</td>
</tr>
</tbody>
</table>
<h3 id="vertical-align-垂直对齐">vertical-align 垂直对齐</h3>
<ul>
<li>有宽度的块级元素居中对齐，是margin: 0 auto;</li>
<li>让文字居中对齐，是 text-align: center;</li>
</ul>
<p>但是我们从来没有讲过有垂直居中的属性。</p>
<p>vertical-align 垂直对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p>
<pre><code class="language-css">vertical-align : baseline |top |middle |bottom 
</code></pre>
<p>设置或检索对象内容的垂直对其方式。</p>
<ul>
<li>
<p>注意：</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p>
<p>特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p>
</li>
</ul>
<h4 id="图片-表单和文字对齐">图片、表单和文字对齐</h4>
<figure data-type="image" tabindex="1"><img src="F:%5CAPEX-4869%5Cmd%5C1498467742995.png" alt="" loading="lazy"></figure>
<h4 id="去除图片底侧空白缝隙">去除图片底侧空白缝隙</h4>
<ul>
<li>
<p>原因：</p>
<p>图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p>
<p>就是图片底侧会有一个空白缝隙。</p>
</li>
<li>
<p>解决的方法就是：</p>
<ul>
<li>
<p>给img vertical-align:middle | top| bottom等等。  让图片不要和基线对齐。</p>
</li>
<li>
<p>给img 添加 display：block; 转换为块级元素就不会存在问题了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="溢出的文字省略号显示">溢出的文字省略号显示</h3>
<h4 id="white-space">white-space</h4>
<ul>
<li>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</li>
</ul>
<pre><code>white-space:normal ；默认处理方式

white-space:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。
</code></pre>
<h4 id="text-overflow-文字溢出">text-overflow 文字溢出</h4>
<ul>
<li>设置或检索是否使用一个省略标记（...）标示对象内文本的溢出</li>
</ul>
<pre><code>text-overflow : clip ；不显示省略标记（...），而是简单的裁切 

text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）
</code></pre>
<p><strong>注意</strong>：</p>
<p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<h4 id="总结三步曲">总结三步曲</h4>
<pre><code class="language-css">  /*1. 先强制一行内显示文本*/
      white-space: nowrap;
  /*2. 超出的部分隐藏*/
      overflow: hidden;
  /*3. 文字用省略号替代超出的部分*/
      text-overflow: ellipsis;
</code></pre>
<h3 id="css精灵技术sprite-重点">CSS精灵技术（sprite) 重点</h3>
<blockquote>
<p><strong>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</strong></p>
</blockquote>
<p>出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p>
<h4 id="精灵技术讲解">精灵技术讲解</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</p>
<p>这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</p>
<p>我们需要使用CSS的</p>
<ul>
<li>background-image、</li>
<li>background-repeat</li>
<li>background-position属性进行背景定位，</li>
<li>其中最关键的是使用background-position 属性精确地定位。</li>
</ul>
<h4 id="精灵技术使用的核心总结">精灵技术使用的核心总结</h4>
<p>首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</p>
<ol>
<li>精确测量，每个小背景图片的大小和 位置。</li>
<li>给盒子指定小背景图片时， 背景定位基本都是 负值。</li>
</ol>
<h4 id="制作精灵图了解">制作精灵图(了解)</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p>
<p>大部分情况下，精灵图都是网页美工做。</p>
<pre><code>我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。
我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙
在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。
</code></pre>
<p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p>
<h3 id="滑动门">滑动门</h3>
<h3 id="核心技术">核心技术</h3>
<p>核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p>
<p>一般的经典布局都是这样的：</p>
<pre><code class="language-html">&lt;li&gt;
  &lt;a href=&quot;#&quot;&gt;
    &lt;span&gt;导航栏内容&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;
</code></pre>
<p>css样式</p>
<pre><code class="language-css">* {
      padding:0;
      margin:0;

    }
    body{
      background: url(images/wx.jpg) repeat-x;
    }
    .father {
      padding-top:20px;
    }
    li {
      padding-left: 16px;
      height: 33px;
      float: left;
      line-height: 33px;
      margin:0  10px;
      background: url(./images/to.png) no-repeat left ;
    }
    a {
      padding-right: 16px;
      height: 33px;
      display: inline-block;
      color:#fff;
      background: url(./images/to.png) no-repeat right ;
      text-decoration: none;
    }
    li:hover,
     li:hover a {
      background-image:url(./images/ao.png);
    }
</code></pre>
<p>总结：</p>
<ol>
<li>a 设置 背景左侧，padding撑开合适宽度。</li>
<li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li>
<li>之所以a包含span就是因为 整个导航都是可以点击的。</li>
</ol>
<h3 id="margin负值之美">margin负值之美</h3>
<p><strong>1). 负边距+定位：水平垂直居中</strong></p>
<p>咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</p>
<p><strong>2). 压住盒子相邻边框</strong></p>
<h3 id="css三角形之美">CSS三角形之美</h3>
<pre><code class="language-css"> div {

 	width: 0; 

    height: 0;
    line-height:0；
    font-size: 0;
	border-top: 10px solid red;

	border-right: 10px solid green;

	border-bottom: 10px solid blue;

	border-left: 10px soli #000; 

 }

</code></pre>
<h3 id="网站ico图标">网站ico图标</h3>
<h3 id="1-使用ico图标">1). 使用ico图标</h3>
<ul>
<li>
<p>首先把favicon.ico 这个图标放到根目录下。</p>
</li>
<li>
<p>再html里面，  head 之间 引入 代码。</p>
<blockquote>
<link rel="shortcut icon" href="favicon.ico"  type="image/x-icon"/>     
</blockquote>
</li>
</ul>
<h3 id="2-制作ico图标">2). 制作ico图标</h3>
<p>我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。</p>
<p>方法步骤：</p>
<ul>
<li>首先把我们想要的切成图片。</li>
<li>要把图片转换为 ico 图标，我们借助于第三方转换网站：   http://www.bitbug.net/。  比特虫</li>
</ul>
<p>总结：</p>
<pre><code>代码：  &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;  type=&quot;image/x-icon&quot;/&gt;     
</code></pre>
<p>注意：</p>
<ol>
<li>她（它）是显示在浏览器中的网页图标。</li>
<li>它是图标形式，不是一个图片</li>
<li>位置是放到 head 标签中间。</li>
<li>后面的type=&quot;image/x-icon&quot;  属性可以省略。（我相信你也愿意省略。）</li>
<li>为了兼容性，请将favicon.ico 这个图标放到根目录下。</li>
</ol>
<h3 id="网站优化三大标签">网站优化三大标签</h3>
<h4 id="1-网页title-标题">1. 网页title 标题</h4>
<p>title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。</p>
<p>建议：</p>
<p>首页标题：网站名（产品名）- 网站的介绍</p>
<p>例如：</p>
<p>品优购-综合网购首选-正品低价、品质保障、配送及时、轻松购物！</p>
<p>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</p>
<h4 id="2-description-网站说明">2. Description  网站说明</h4>
<p>对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。<br>
我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。</p>
<p>品优购网：</p>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;品优购JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt;
</code></pre>
<p>注意点：</p>
<ol>
<li>描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。</li>
<li>同样遵循简短原则，字符数含空格在内不要超过 120  个汉字。</li>
<li>补充在 title  和 keywords  中未能充分表述的说明.</li>
<li>用英文逗号 关键词1,关键词2</li>
</ol>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt;
</code></pre>
<h4 id="3-keywords-关键字">3. Keywords 关键字</h4>
<p>Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。</p>
<p>品优购网：</p>
<pre><code>&lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,品优购&quot; /&gt;
</code></pre>
<p>小米网：</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt;
</code></pre>
<h4 id="4-总结">4. 总结</h4>
<ol>
<li>我们的网页要做的优秀，符合搜索引擎的要求，才可以让搜索引擎优先显示我们的网页。</li>
</ol>
<p>所以我们的网站要做很多的优化， 其中就有这三大标签。</p>
<ol start="2">
<li>一般情况下，三大标签里面的优化词，都是专门的优化人员写的，我们大概了解一下规范就可以了。</li>
<li>我们的主要任务是，能写出这三大标签， 然后把优化人员给我们的内容，添加到里面。</li>
</ol>
<h3 id="字体图标">字体图标</h3>
<p>​    推荐网站： http://icomoon.io</p>
<ul>
<li>
<p>icomoon字库</p>
</li>
<li>
<p>阿里icon font字库</p>
</li>
</ul>
<p>http://www.iconfont.cn/</p>
<p>在样式里面声明字体： 告诉别人我们自己定义的字体(一定注意字体文件路径的问题)</p>
<pre><code class="language-css">@font-face {
  font-family: 'icomoon';
  src:  url('fonts/icomoon.eot?7kkyc2');
  src:  url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
    url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
    url('fonts/icomoon.woff?7kkyc2') format('woff'),
    url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
  font-weight: normal;
  font-style: normal;
}
</code></pre>
<p>给盒子使用字体</p>
<pre><code class="language-css">span {
		font-family: &quot;icomoon&quot;;
	}
</code></pre>
<h3 id=""></h3>
<h3 id="过渡css3">过渡(CSS3)</h3>
<p>过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>过渡动画：   是从一个状态 渐渐的过渡到另外一个状态</p>
<p>可以让我们页面更好看，更动感十足，虽然 低版本浏览器不支持（ie9以下版本） 但是不会影响页面布局。</p>
<p>我们现在经常和 :hover 一起 搭配使用。</p>
<p>语法格式:</p>
<pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
<td>3</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称。</td>
<td>3</td>
</tr>
<tr>
<td>transition-duration</td>
<td>定义过渡效果花费的时间。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线。默认是 &quot;ease&quot;。</td>
<td>3</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始。默认是 0。</td>
<td>3</td>
</tr>
</tbody>
</table>
<ul>
<li>属性</li>
</ul>
<p>​    属性就是你想要变化的 css 属性，  宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。</p>
<ul>
<li>
<p>花费时间</p>
<p>transition-duration  花费时间  单位是  秒（必须写单位）     s   ms      比如 0.5s    这个s单位必须写      ms 毫秒</p>
</li>
<li>
<p>运动曲线   默认是 ease</p>
</li>
</ul>
<p>运动曲线示意图：</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1498445454760.png" alt="" loading="lazy"></figure>
<p><strong>案例：</strong></p>
<pre><code class="language-css">div {
			width: 200px;
			height: 100px;
			background-color: pink;
			/* transition: 要过渡的属性  花费时间  运动曲线  何时开始; */
			transition: width 0.6s ease 0s, height 0.3s ease-in 1s;
			/* transtion 过渡的意思  这句话写到div里面而不是 hover里面 */
  
			
}
div:hover {  /* 鼠标经过盒子，我们的宽度变为400 */

			width: 600px;
			height: 300px
}

transition: all 0.6s;  /* 所有属性都变化用all 就可以了  后面俩个属性可以省略 */
</code></pre>
<p>transition: all 0.5s;</p>
<h3 id="获得焦点元素">获得焦点元素</h3>
<p>:focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素</p>
<p>:hover</p>
<p>语法：</p>
<pre><code class="language-css">.total input {
  border: 1px solid #ccc;
  height: 30px;
  width: 40px;
  transition: all .5s;
}
/*这个input 获得了焦点*/
.total input:focus {
  width: 80px;
  border: 1px solid skyblue;
}
</code></pre>
<p>border: 1px solid #ccc;<br>
height: 30px;<br>
width: 40px;<br>
transition: all .5s;<br>
}<br>
/<em>这个input 获得了焦点</em>/<br>
.total input:focus {<br>
width: 80px;<br>
border: 1px solid skyblue;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[H5,C3]]></title>
        <id>https://xmweijh.github.io/post/h5c3/</id>
        <link href="https://xmweijh.github.io/post/h5c3/">
        </link>
        <updated>2021-02-07T11:38:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html5css3">HTML5+CSS3</h1>
<p><code>HTML5</code> 拓展了哪些内容</p>
<ul>
<li>语义化标签</li>
<li>本地存储</li>
<li>兼容特性</li>
<li><code>2D</code>、<code>3D</code></li>
<li>动画、过渡</li>
<li><code>CSS3</code> 特性</li>
<li>性能与集成</li>
</ul>
<h3 id="html5-新增标签"><code>HTML5</code> 新增标签</h3>
<ol>
<li>
<p>什么是语义化</p>
</li>
<li>
<p>新增了那些语义化标签</p>
<ul>
<li><code>header</code>   ---  头部标签</li>
<li><code>nav</code>        ---  导航标签</li>
<li><code>article</code> ---   内容标签</li>
<li><code>section</code> ---   块级标签</li>
<li><code>aside</code>     ---   侧边栏标签</li>
<li><code>footer</code>   ---   尾部标签</li>
</ul>
</li>
</ol>
<h4 id="多媒体音频标签">多媒体音频标签</h4>
<ol>
<li>
<p>多媒体标签有两个，分别是</p>
<ul>
<li>音频  -- <code>audio</code></li>
<li>视频  -- <code>video</code></li>
</ul>
</li>
<li>
<p><code>audio</code> 标签说明</p>
<ul>
<li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li>
<li>但是：播放格式是有限的</li>
</ul>
</li>
<li>
<p>audio 支持的音频格式</p>
<ul>
<li>audio 目前支持三种格式</li>
</ul>
</li>
</ol>
<p><strong>audio 的参数</strong></p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5Caudiocanshu.png" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;
  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;

  &lt;!-- 
    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件
   --&gt;
  &lt;audio controls&gt;
    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
  &lt;/audio&gt;
&lt;/body&gt;
</code></pre>
<h4 id="多媒体视频标签">多媒体视频标签</h4>
<p>语法格式</p>
<pre><code class="language-html">&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;
</code></pre>
<p>video 参数</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5Cvideocanshu.png" alt="" loading="lazy"></figure>
<p>video 代码演示</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;

  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;
  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;
    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;
    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;
  &lt;/video&gt;
&lt;/body&gt;
</code></pre>
<p>多媒体标签总结</p>
<ul>
<li>音频标签与视频标签使用基本一致</li>
<li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li>
<li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li>
<li>谷歌浏览器中视频添加 muted 标签可以自己播放</li>
<li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li>
</ul>
<h4 id="新增-input-标签">新增 input 标签</h4>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5Ch5input.png" alt="" loading="lazy"></figure>
<h4 id="新增表单属性">新增表单属性</h4>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5Cnewinput.png" alt="" loading="lazy"></figure>
<h3 id="css3-属性选择器"><code>CSS3</code> 属性选择器</h3>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5Cattrcanshu.png" alt="" loading="lazy"></figure>
<p>属性选择器代码演示</p>
<pre><code class="language-css">button {
  cursor: pointer;
}
button[disabled] {
  cursor: default
}
</code></pre>
<pre><code class="language-css">input[type=search] {
  color: skyblue;
}

span[class^=black] {
  color: lightgreen;
}

span[class$=black] {
  color: lightsalmon;
}

span[class*=black] {
  color: lightseagreen;
}
</code></pre>
<h4 id="结构伪类选择器">结构伪类选择器</h4>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5Cjiegouweilei.png" alt="" loading="lazy"></figure>
<pre><code class="language-css">ul li:first-child {
  background-color: lightseagreen;
}

ul li:last-child {
  background-color: lightcoral;
}

ul li:nth-child(3) {
  background-color: aqua;
}
</code></pre>
<p>nth-child 详解</p>
<ul>
<li>
<p>注意：本质上就是选中第几个子元素</p>
</li>
<li>
<p>n 可以是数字、关键字、公式</p>
</li>
<li>
<p>n 如果是数字，就是选中第几个</p>
</li>
<li>
<p>常见的关键字有 <code>even</code> 偶数、<code>odd</code> 奇数</p>
</li>
<li>
<p>常见的公式如下(如果 n 是公式，则从 0 开始计算)</p>
</li>
<li>
<p>但是第 0 个元素或者超出了元素的个数会被忽略</p>
</li>
<li>
<p><code>nth-child</code>  选择父元素里面的第几个子元素，不管是第几个类型</p>
</li>
<li>
<p><code>nt-of-type</code>  选择指定类型的元素</p>
</li>
</ul>
<h4 id="伪元素选择器">伪元素选择器</h4>
<p>伪类选择器注意事项</p>
<ul>
<li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li>
<li><code>before</code> 在内容前面，after 在内容后面</li>
<li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li>
<li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li>
<li>伪元素和标签选择器一样，权重为 1</li>
</ul>
<pre><code class="language-css">&lt;style&gt;
    div {
      width: 100px;
      height: 100px;
      border: 1px solid lightcoral;
    }

    div::after,
    div::before {
      width: 20px;
      height: 50px;
      text-align: center;
      display: inline-block;
    }
    div::after {
      content: '德';
      background-color: lightskyblue;
    }

    div::before {
      content: '道';
      background-color: mediumaquamarine;
    }
  &lt;/style&gt;
</code></pre>
<h4 id="2d-转换之-translate"><code>2D</code> 转换之 <code>translate</code></h4>
<p>2D转换</p>
<ul>
<li>
<p><code>2D</code> 转换是改变标签在二维平面上的位置和形状</p>
</li>
<li>
<p>移动： <code>translate</code></p>
</li>
<li>
<p>旋转： <code>rotate</code></p>
</li>
<li>
<p>缩放： <code>scale</code></p>
</li>
</ul>
<p>translate语法</p>
<ul>
<li>x 就是 x 轴上水平移动</li>
<li>y 就是 y 轴上水平移动</li>
</ul>
<pre><code class="language-css">transform: translate(x, y)
transform: translateX(n)
transfrom: translateY(n)
</code></pre>
<p>重点知识点</p>
<ul>
<li><code>2D</code> 的移动主要是指 水平、垂直方向上的移动</li>
<li><code>translate</code> 最大的优点就是不影响其他元素的位置</li>
<li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li>
<li>行内标签没有效果</li>
</ul>
<p>代码演示</p>
<pre><code class="language-css">div {
  background-color: lightseagreen;
  width: 200px;
  height: 100px;
  /* 平移 */
  /* 水平垂直移动 100px */
  /* transform: translate(100px, 100px); */

  /* 水平移动 100px */
  /* transform: translate(100px, 0) */

  /* 垂直移动 100px */
  /* transform: translate(0, 100px) */

  /* 水平移动 100px */
  /* transform: translateX(100px); */

  /* 垂直移动 100px */
  transform: translateY(100px)
}
</code></pre>
<p>让一个盒子水平垂直居中</p>
<pre><code>p {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            background-color: purple;
            /* margin-top: -100px;
            margin-left: -100px; */
            /* translate(-50%, -50%)  盒子往上走自己高度的一半   */
            transform: translate(-50%, -50%);
        }
        
        span {
            /* translate 对于行内元素是无效的 */
            transform: translate(300px, 300px);
        }
</code></pre>
<p>2D 转换 rotate</p>
<p>rotate 旋转</p>
<p>2D旋转指的是让元素在二维平面内顺时针或者逆时针旋转rotate</p>
<p>语法</p>
<pre><code class="language-css">/* 单位是：deg */
transform: rotate(度数) 
</code></pre>
<p>重点知识点</p>
<ul>
<li><code>rotate</code> 里面跟度数，单位是 <code>deg</code></li>
<li>角度为正时，顺时针，角度为负时，逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
<p>代码演示</p>
<pre><code class="language-css">img:hover {
  transform: rotate(360deg)
}
</code></pre>
<h6 id="rotate">rotate</h6>
<blockquote>
<p>2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</p>
</blockquote>
<p>使用步骤：</p>
<ol>
<li>给元素添加转换属性 <code>transform</code></li>
<li>属性值为 <code>rotate(角度)</code>  如 <code>transform:rotate(30deg)</code>  顺时针方向旋转<strong>30度</strong></li>
</ol>
<pre><code class="language-css">div{
      transform: rotate(0deg);
}
</code></pre>
<h6 id="三角">三角</h6>
<pre><code class="language-css">div::after {
            content: &quot;&quot;;
            position: absolute;
            top: 8px;
            right: 15px;
            width: 10px;
            height: 10px;
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            transform: rotate(45deg);
            transition: all 0.2s;
        }
        /* 鼠标经过div  里面的三角旋转 */
        
        div:hover::after {
            transform: rotate(225deg);
        }
</code></pre>
<h6 id="设置元素旋转中心点transform-origin">设置元素旋转中心点(transform-origin)</h6>
<ol>
<li>
<p><code>transform-origin</code> 基础语法</p>
<pre><code class="language-css">transform-origin: x y;
</code></pre>
</li>
<li>
<p>重要知识点</p>
<ul>
<li>注意后面的参数 x 和 y 用空格隔开</li>
<li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code></li>
<li>还可以给 x y 设置像素或者方位名词(<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>)</li>
</ul>
</li>
</ol>
<h6 id="旋转中心案例">旋转中心案例</h6>
<ul>
<li>代码演示</li>
</ul>
<h6 id="2d-转换之-scale"><code>2D</code> 转换之 <code>scale</code></h6>
<ol>
<li>
<p><code>scale</code> 的作用</p>
<ul>
<li>用来控制元素的放大与缩小</li>
</ul>
</li>
<li>
<p>语法</p>
<pre><code class="language-css">transform: scale(x, y)
</code></pre>
</li>
<li>
<p>知识要点</p>
<ul>
<li>注意，x 与 y 之间使用逗号进行分隔</li>
<li><code>transform: scale(1, 1)</code>: 宽高都放大一倍，相当于没有放大</li>
<li><code>transform: scale(2, 2)</code>: 宽和高都放大了二倍</li>
<li><code>transform: scale(2)</code>: 如果只写了一个参数，第二个参数就和第一个参数一致</li>
<li><code>transform:scale(0.5, 0.5)</code>: 缩小</li>
<li><code>scale</code> 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">   div:hover {
	   /* 注意，数字是倍数的含义，所以不需要加单位 */
	   /* transform: scale(2, 2) */
   
	   /* 实现等比缩放，同时修改宽与高 */
	   /* transform: scale(2) */
   
	   /* 小于 1 就等于缩放*/
	   transform: scale(0.5, 0.5)
   }
</code></pre>
</li>
</ol>
<h6 id="2d-转换综合写法以及顺序问题"><code>2D</code> 转换综合写法以及顺序问题</h6>
<ol>
<li>
<p>知识要点</p>
<ul>
<li>同时使用多个转换，其格式为 <code>transform: translate() rotate() scale()</code></li>
<li>顺序会影响到转换的效果(先旋转会改变坐标轴方向)</li>
<li>但我们同时有位置或者其他属性的时候，要将位移放到最前面</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div:hover {
  transform: translate(200px, 0) rotate(360deg) scale(1.2)
}
</code></pre>
</li>
</ol>
<h6 id="动画animation">动画(animation)</h6>
<ol>
<li>
<p>什么是动画</p>
<ul>
<li>动画是 <code>CSS3</code> 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果</li>
</ul>
</li>
<li>
<p>动画的基本使用</p>
<ul>
<li>先定义动画</li>
<li>在调用定义好的动画</li>
</ul>
</li>
<li>
<p>语法格式(定义动画)</p>
<pre><code class="language-css">@keyframes 动画名称 {
    0% {
        width: 100px;
    }
    100% {
        width: 200px
    }
}
</code></pre>
</li>
<li>
<p>语法格式(使用动画)</p>
<pre><code>div {
	/* 调用动画 */
    animation-name: 动画名称;
 	/* 持续时间 */
 	animation-duration: 持续时间；
}
</code></pre>
</li>
<li>
<p>动画序列</p>
<ul>
<li>0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</li>
<li>在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</li>
<li>用百分比来规定变化发生的时间，或用 <code>from</code> 和 <code>to</code>，等同于 0% 和 100%</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">&lt;style&gt;
    div {
      width: 100px;
      height: 100px;
      background-color: aquamarine;
      animation-name: move;
      animation-duration: 0.5s;
    }

    @keyframes move{
      0% {
        transform: translate(0px)
      }
      100% {
        transform: translate(500px, 0)
      }
    }
  &lt;/style&gt;
</code></pre>
</li>
</ol>
<h6 id="动画常见属性">动画常见属性</h6>
<ol>
<li>
<p>常见的属性</p>
<img src="E:\APTX-4869\md\animationcanshu.png">
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  width: 100px;
  height: 100px;
  background-color: aquamarine;
  /* 动画名称 */
  animation-name: move;
  /* 动画花费时长 */
  animation-duration: 2s;
  /* 动画速度曲线 */
  animation-timing-function: ease-in-out;
  /* 动画等待多长时间执行 */
  animation-delay: 2s;
  /* 规定动画播放次数 infinite: 无限循环 */
  animation-iteration-count: infinite;
  /* 是否逆行播放 */
  animation-direction: alternate;
  /* 动画结束之后的状态 */
  animation-fill-mode: forwards;
}

div:hover {
  /* 规定动画是否暂停或者播放 */
  animation-play-state: paused;
}
</code></pre>
</li>
</ol>
<h6 id="动画简写方式">动画简写方式</h6>
<ol>
<li>
<p>动画简写方式</p>
<pre><code class="language-css">/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */
animation: name duration timing-function delay iteration-count direction fill-mode
</code></pre>
</li>
<li>
<p>知识要点</p>
<ul>
<li>简写属性里面不包含 <code>animation-paly-state</code></li>
<li>暂停动画 <code>animation-paly-state: paused</code>; 经常和鼠标经过等其他配合使用</li>
<li>要想动画走回来，而不是直接调回来：<code>animation-direction: alternate</code></li>
<li>盒子动画结束后，停在结束位置：<code>animation-fill-mode: forwards</code></li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">animation: move 2s linear 1s infinite alternate forwards;
</code></pre>
</li>
</ol>
<h6 id="速度曲线细节">速度曲线细节</h6>
<ol>
<li>速度曲线细节
<ul>
<li><code>animation-timing-function</code>: 规定动画的速度曲线，默认是<code>ease</code></li>
</ul>
</li>
</ol>
<img src="E:\APTX-4869\md\steps.png">
<ol start="2">
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  width: 0px;
  height: 50px;
  line-height: 50px;
  white-space: nowrap;
  overflow: hidden;
  background-color: aquamarine;
  animation: move 4s steps(24) forwards;
}

@keyframes move {
  0% {
    width: 0px;
  }

  100% {
    width: 480px;
  }
}
</code></pre>
</li>
</ol>
<h6 id="奔跑的熊大">奔跑的熊大</h6>
<ol>
<li>代码演示</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body {
            background-color: #ccc;
        }      
        div {
            position: absolute;
            width: 200px;
            height: 100px;
            background: url(media/bear.png) no-repeat;
            /* 我们元素可以添加多个动画， 用逗号分隔 */
            animation: bear .4s steps(8) infinite, move 3s forwards;
        }
        
        @keyframes bear {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: -1600px 0;
            }
        }
        
        @keyframes move {
            0% {
                left: 0;
            }
            100% {
                left: 50%;
                /* margin-left: -100px; */
                transform: translateX(-50%);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>​</p>
<h6 id="3d-转换"><code>3D</code> 转换</h6>
<ol>
<li>
<p><code>3D</code> 转换知识要点</p>
<ul>
<li><code>3D</code> 位移：<code>translate3d(x, y, z)</code></li>
<li><code>3D</code> 旋转：<code>rotate3d(x, y, z)</code></li>
<li>透视：<code>perspctive</code></li>
<li><code>3D</code>呈现 <code>transfrom-style</code></li>
</ul>
</li>
<li>
<p><code>3D</code> 移动 <code>translate3d</code></p>
<ul>
<li><code>3D</code> 移动就是在 <code>2D</code> 移动的基础上多加了一个可以移动的方向，就是 z 轴方向</li>
<li><code>transform: translateX(100px)</code>：仅仅是在 x 轴上移动</li>
<li><code>transform: translateY(100px)</code>：仅仅是在 y 轴上移动</li>
<li><code>transform: translateZ(100px)</code>：仅仅是在 z 轴上移动</li>
<li><code>transform: translate3d(x, y, z)</code>：其中x、y、z 分别指要移动的轴的方向的距离</li>
<li><strong>注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充</strong></li>
</ul>
</li>
<li>
<p>语法</p>
<pre><code class="language-css"> transform: translate3d(x, y, z)
</code></pre>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">transform: translate3d(100px, 100px, 100px)
/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */
transform: translate3d(100px, 100px, 0)
</code></pre>
</li>
</ol>
<h6 id="透视-perspective">透视 <code>perspective</code></h6>
<ol>
<li>
<p>知识点讲解</p>
<ul>
<li>如果想要网页产生 <code>3D</code> 效果需要透视(理解成 <code>3D</code> 物体投影的 <code>2D</code> 平面上)</li>
<li>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</li>
<li>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li>
<li>透视的单位是像素</li>
</ul>
</li>
<li>
<p>知识要点</p>
<ul>
<li>
<p><strong>透视需要写在被视察元素的父盒子上面</strong></p>
</li>
<li>
<p>注意下方图片</p>
<ul>
<li>
<p>d：就是视距，视距就是指人的眼睛到屏幕的距离</p>
</li>
<li>
<p>z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</p>
<img src="E:\APTX-4869\md\perspective.png">
</li>
</ul>
</li>
</ul>
<p>​</p>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">body {
  perspective: 1000px;
}
</code></pre>
</li>
</ol>
<h6 id="translatez"><code>translateZ</code></h6>
<ol>
<li><code>translateZ</code> 与 <code>perspecitve</code> 的区别
<ul>
<li><code>perspecitve</code> 给父级进行设置，<code>translateZ</code> 给 子元素进行设置不同的大小</li>
</ul>
</li>
</ol>
<h6 id="3d-旋转rotatex"><code>3D</code> 旋转<code>rotateX</code></h6>
<blockquote>
<p>3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</p>
</blockquote>
<ol>
<li>
<p>语法</p>
<ul>
<li><code>transform: rotateX(45deg)</code> -- 沿着 x 轴正方向旋转 45 度</li>
<li><code>transform: rotateY(45deg)</code> -- 沿着 y 轴正方向旋转 45 度</li>
<li><code>transform: rotateZ(45deg)</code> -- 沿着 z 轴正方向旋转 45 度</li>
<li><code>transform: rotate3d(x, y, z, 45deg)</code> -- 沿着自定义轴旋转 45 deg 为角度</li>
</ul>
</li>
<li>
<p>代码案例</p>
<pre><code class="language-css">div {
  perspective: 300px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateX(-45deg)
}
</code></pre>
</li>
</ol>
<p>​</p>
<h6 id="3d-旋转-rotatey"><code>3D</code> 旋转 <code>rotateY</code></h6>
<ol>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateY(180deg)
}
</code></pre>
</li>
</ol>
<h6 id="3d-旋转-rotatez"><code>3D</code> 旋转 <code>rotateZ</code></h6>
<ol>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotateZ(180deg)
}
</code></pre>
</li>
<li>
<p><code>rotate3d</code></p>
<ul>
<li><code>transform: rotate3d(x, y, z, deg)</code> -- 沿着自定义轴旋转 deg 为角度</li>
<li>x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度
<ul>
<li><code>transform: rotate3d(1, 1, 0, 180deg)</code> -- 沿着对角线旋转 45deg</li>
<li><code>transform: rotate3d(1, 0, 0, 180deg)</code> -- 沿着 x 轴旋转 45deg</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码演示</p>
<pre><code class="language-css">div {
  perspective: 500px;
}

img {
  display: block;
  margin: 100px auto;
  transition: all 1s;
}

img:hover {
  transform: rotate3d(1, 1, 0, 180deg)
}
</code></pre>
<h6 id="3d-呈现-transform-style"><code>3D</code> 呈现 <code>transform-style</code></h6>
<ol>
<li>
<p><code>transform-style</code></p>
<ul>
<li>
<p>☆☆☆☆☆</p>
</li>
<li>
<p>控制子元素是否开启三维立体环境</p>
</li>
<li>
<p><code>transform-style: flat</code>  代表子元素不开启 <code>3D</code> 立体空间，默认的</p>
</li>
<li>
<p><code>transform-style: preserve-3d</code> 子元素开启立体空间</p>
</li>
<li>
<p>代码写给父级，但是影响的是子盒子</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="移动web">移动web</h3>
<h4 id="meta标签">meta标签</h4>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C4.png" alt="" loading="lazy"></figure>
<h4 id="背景缩放background-size">背景缩放background-size</h4>
<p>background-size 属性规定背景图像的尺寸</p>
<pre><code>background-size: 背景图片宽度 背景图片高度;
</code></pre>
<p>单位： 长度|百分比|cover|contain;</p>
<p>cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</p>
<p>contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</p>
<h4 id="移动端大量使用-css3盒子模型box-sizin">移动端大量使用 CSS3盒子模型box-sizin</h4>
<p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</p>
<p>CSS3盒子模型：     盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</p>
<p>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</p>
<pre><code>/*CSS3盒子模型*/
box-sizing: border-box;
/*传统盒子模型*/
box-sizing: content-box;

</code></pre>
<p>移动端可以全部CSS3 盒子模型</p>
<p>PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</p>
<h4 id="移动端特殊样式">移动端特殊样式</h4>
<pre><code>    /*CSS3盒子模型*/
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    /*点击高亮我们需要清除清除  设置为transparent 完成透明*/
    -webkit-tap-highlight-color: transparent;
    /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
    -webkit-appearance: none;
    /*禁用长按页面时的弹出菜单*/
    img,a { -webkit-touch-callout: none; }

</code></pre>
<h4 id="移动端常见布局">移动端常见布局</h4>
<p>移动端单独制作</p>
<ul>
<li>流式布局（百分比布局）</li>
<li>flex 弹性布局（强烈推荐）</li>
<li>less+rem+媒体查询布局</li>
<li>混合布局</li>
</ul>
<p>响应式</p>
<ul>
<li>媒体查询</li>
<li>bootstarp</li>
</ul>
<p>流式布局：</p>
<p>流式布局，就是百分比布局，也称非固定像素布局。</p>
<p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p>
<p>流式布局方式是移动web开发使用的比较常见的布局方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++记录]]></title>
        <id>https://xmweijh.github.io/post/cji-lu/</id>
        <link href="https://xmweijh.github.io/post/cji-lu/">
        </link>
        <updated>2021-02-07T11:36:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c">C++</h1>
<p>c++语言在c语言的基础上添加了<strong>面向对象编程</strong>和<strong>泛型编程</strong>的支持。c++继承了c语言高效，简洁，快速和可移植的传统。</p>
<h3 id="作用域运算符">::作用域运算符</h3>
<p>​         在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p>
<p>​     ::代表作用域 如果前面什么都不添加 代表全局作用域</p>
<p>namespace命名空间</p>
<h3 id="c命名空间namespace">C++命名空间(namespace)</h3>
<p>命名空间用途：解决名称冲突</p>
<p>​       可以存放 ： 变量、函数、结构体、类…</p>
<p>​	   命名空间必须要声明在全局作用域</p>
<pre><code>命名空间可以嵌套命名空

命名空间是开放的，可以随时将新成员添加到命名空间下
</code></pre>
<p>​       命名空间可以匿名的</p>
<pre><code>命名空间可以起别名
</code></pre>
<p>using声明</p>
<p>using KingGlory::sunwukongId；</p>
<p>当using声明与 就近原则同时出现，出错，尽量避免</p>
<p>using编译指令</p>
<p>using namespace KingGlory;</p>
<p>当using编译指令 与 就近原则同时出现，优先使用就近</p>
<p>当using编译指令有多个，需要加作用域 区分</p>
<h3 id="c对c语言增强以及扩展">C++对C语言增强以及扩展</h3>
<p><strong>全局变量检测增强</strong></p>
<p>int a ;</p>
<p>int a = 10; C下可以，C++重定义</p>
<p><strong>函数检测增强</strong></p>
<p>函数的返回值</p>
<p>形参类型</p>
<p>函数调用参数个数</p>
<p><strong>类型转换检测增强</strong></p>
<p>char * p = (char *)malloc(64) C++下必须等号左右一致类型</p>
<p><strong>struct 增强</strong></p>
<p>C++可以在结构体中放函数</p>
<p>创建结构体变量  可以简化关键字struct</p>
<p><strong>bool数据类型扩展</strong></p>
<p>C++才有bool类型</p>
<p>代表真 --- 1 true 假 ---- 0 false</p>
<p>sizeof = 1</p>
<p><strong>三目运算符增强</strong></p>
<p>C语言下返回的是值</p>
<p>C++语言下返回的是变量</p>
<p>a &gt; b ? a : b = 100;            结果b变为100  执行的是b=100这个式子 若是小于  a，b都不变（不要想成(a &gt; b ? a : b) = 100;   b=100是个整体式子 前面条件满足才执行这个赋值语句）</p>
<p><strong>const增强</strong></p>
<p>C语言下</p>
<p>全局const  直接修改 失败 间接修改 语法通过，运行失败</p>
<p>局部 const 直接修改 失败 间接修改 成功</p>
<p>C++语言下</p>
<p>全局 const 和C结论一样</p>
<p>局部 const 直接修改失败  间接修改 失败</p>
<p>C++const可以称为常量</p>
<p>const 链接属性</p>
<p>C语言下const修饰的全局变量默认是外部链接属性</p>
<p>C++下const修饰的全局变量默认是内部链接属性，可以加extern 提高作用域</p>
<p>const分配内存情况</p>
<p>对const变量 取地址 ，会分配临时内存</p>
<p>使用普通变量 初始化 const变量</p>
<p>对于自定义数据类型</p>
<p>尽量用const代替define</p>
<p>define出的宏常量，没有数据类型、不重视作用域</p>
<h3 id="引用"><strong>引用</strong></h3>
<p>目的：起别名</p>
<p>语法： 类型（与原名类型必须一致）  &amp;别名 = 原名</p>
<p>引用必须要初始化</p>
<p>引用一旦初始化后，就不可以引向其他变量</p>
<p>建立对数组引用</p>
<p>直接建立引用</p>
<p>int arr[10];</p>
<p>int(&amp;pArr)[10] = arr;</p>
<p>先定义出数组类型，再通过类型 定义引用</p>
<p>typedef int(ARRAY_TYPE)[10];</p>
<p>ARRAY_TYPE &amp; pArr2 = arr;</p>
<p><strong>参数的传递方式</strong></p>
<p>值传递</p>
<p>地址传递</p>
<p>引用传递</p>
<p>注意事项</p>
<p>引用必须引一块合法内存空间</p>
<p>不要返回局部变量的引用</p>
<p>当函数返回值是引用时候，那么函数的调用可以作为左值进行运算</p>
<p>指针的引用</p>
<p>利用引用可以简化指针</p>
<p>可以直接用同级指针的 引用 给同级指针分配空间</p>
<p>常量的引用</p>
<p>const int &amp;ref = 10;</p>
<p>/ 加了const之后， 相当于写成  int temp = 10; const int &amp;ref = temp;</p>
<p>常量引用的使用场景 修饰函数中的形参，防止误操作</p>
<h3 id="设计类-抽象类">设计类 抽象类</h3>
<p>class 类名{</p>
<p>public 公共权限</p>
<p>​	 设置 成员属性</p>
<p>​	设置 成员函数</p>
<p>}</p>
<p>使用类 创建对象 实例化对象</p>
<p>类名 对象名</p>
<p>通过对象 来设置属性 调用成员函数</p>
<p>类和对象 关系</p>
<p>类是对对象的抽象</p>
<p>对象是对类的实例</p>
<h3 id="内联函数-解决宏缺陷问题">内联函数 解决宏缺陷问题</h3>
<p>给编译器一个建议，加上关键字，编译器不一定按照内联处理</p>
<p>不加关键字，也许编译器还偷摸的给你加inline</p>
<p>成员函数 默认加上关键字</p>
<p>函数声明加了关键字，函数实现也要加inline关键字</p>
<p><strong>函数默认参数</strong></p>
<p>参数可以有默认值</p>
<p>如果有一个位置有了默认值，那么从这个位置开始，从左往右都必须有默认值</p>
<p>函数声明和实现 只能有一个有默认值</p>
<p><strong>函数占位参数</strong></p>
<p>void func(int) 占位参数 调用时候必须要提供这个参数</p>
<p>占位参数也可以有默认值</p>
<p>c语言中没有默认参数 和占位参数</p>
<p><strong>函数重载的基本语法</strong></p>
<p>函数名称相同 又在同一个作用域下</p>
<p>函数参数个数不同、类型不同、顺序不同都可以满足重载条件</p>
<p>函数的返回值可以作为函数重载条件吗？ 不可以</p>
<p>当函数重载碰到了函数默认参数 要注意避免二义性</p>
<h3 id="extern-c浅析"><strong>extern C浅析</strong></h3>
<p>解决了C++文件中调用C语言的代码</p>
<p>方法1:+<br>
在C++代码中加入<br>
告诉编译器show函数用C语言方式做链接/ /extern &quot;C&quot; void show() ;<br>
方法2:<br>
在c语言的头文件中加入6行代码<br>
#ifdef__cplusplus       //两个下划线</p>
<p>extern &quot;C&quot; {</p>
<p>#endif<br>
#ifdef  __cplusplus       //两个下划线</p>
<p>｝</p>
<p>#endif</p>
<h3 id="c语言的封装">C++语言的封装</h3>
<p>将属性和行为作为一个整体，来表示生活中具体的事物</p>
<p>有访问权限</p>
<p>class 和struct唯一区别 默认权限不同</p>
<p>class默认是private</p>
<p>struct 默认是public</p>
<p>public 是类内类外都可以访问到</p>
<p>protected 类内可以，类外不可以</p>
<p>private 类内可以，类外不可以</p>
<p>建议将所有成员属性设置为私有</p>
<p>自己提供公共的对外接口来进行 set或者get方法访问</p>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<p>构造函数</p>
<p>//没有返回值 不用写void</p>
<p>//函数名 与 类名相同</p>
<p>//可以有参数 ，可以发生重载</p>
<p>//构造函数 由编译器自动调用一次 无须手动调用</p>
<p>析构函数</p>
<p>//没有返回值  不用写void</p>
<p>函数名 与类名相同 函数名前 加 ~</p>
<p>不可以有参数 ，不可以发生重载</p>
<p>析构函数 也是由编译器自动调用一次，无须手动调用</p>
<p>构造函数的分类和调用</p>
<p>分类</p>
<p>按照参数分类： 有参 无参（默认）</p>
<p>按照类型分类： 普通 拷贝构造 ( const Person &amp; p )</p>
<p>调用</p>
<p>括号法</p>
<p>显示法</p>
<p>隐式法</p>
<p>注意事项</p>
<p>不要用括号法 调用无参构造函数 Person p3(); 编译器认为代码是函数的声明</p>
<p>不要用拷贝构造函数 初始化 匿名对象 Person(p3); 编译器认为 Person p3对象实例化 如果已经有p3 p3就重定义</p>
<p>匿名对象 特点： 当前行执行完后 立即释放</p>
<p>拷贝构造函数的调用时机</p>
<p>用已经创建好的对象来初始化新的对象</p>
<p>值传递的方式 给函数参数传值</p>
<p>以值方式 返回局部对象</p>
<p>构造函数的调用规则</p>
<p>//1、编译器会给一个类 至少添加3个函数  默认构造（空实现）  析构函数（空实现）  拷贝构造（值拷贝）</p>
<p>//2、如果我们自己提供了 有参构造函数，编译器就不会提供默认构造函数，但是依然会提供拷贝构造函数</p>
<p>//3、如果我们自己提供了 拷贝构造函数，编译器就不会提供其他构造函数</p>
<h3 id="深拷贝与浅拷贝的问题以及解决">深拷贝与浅拷贝的问题以及解决</h3>
<p>如果有属性开辟到堆区，利用编译器提供拷贝构造函数会调用浅拷贝带来的析构重复释放堆区内存的问题</p>
<p>利用深拷贝解决浅拷贝问题</p>
<p>自己提供拷贝构造函数，实现深拷贝</p>
<p>初始化列表</p>
<p>可以利用初始化列表语法 对类中属性进行初始化</p>
<p>语法：构造函数名称后 ： 属性(值), 属性（值）...</p>
<p>Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c)</p>
<h3 id="类对象作为类中成员">类对象作为类中成员</h3>
<p>当其他类对象 作为本类成员，先构造其他类对象，再构造自身，析构的顺序和构造相反</p>
<p>explicit关键字</p>
<p>explicit用途： 防止利用隐式类型转换方式来构造对象</p>
<p>new和delete</p>
<p>malloc 和 new 区别</p>
<p>malloc 和 free 属于 库函数   new 和delete属于 运算符</p>
<p>malloc不会调用构造函数  new会调用构造函数</p>
<p>malloc返回void* C++下要强转   new 返回创建的对象的指针</p>
<p>事项 不要用void<em>去接受new出来的对象,利用void</em>无法调用析构函数</p>
<p>利用new创建数组</p>
<p>Person * pPerson = new Person[10];</p>
<p>释放数组时候 需要加[]</p>
<p>delete [] pPerson;</p>
<p>堆区开辟数组，一定会调用默认构造函数</p>
<p>栈上开辟数组，可不可以没有默认构造,可以没有默认构造</p>
<h3 id="静态成员">静态成员</h3>
<p><strong>静态成员变量</strong></p>
<p>所有对象都共享同一份数据</p>
<p>编译阶段就分配内存</p>
<p>类内声明、类外初始化</p>
<p>访问方式有两种：通过对象访问、通过类名访问</p>
<p>静态成员变量也是有访问权限</p>
<p><strong>静态成员函数</strong></p>
<p>所有对象都共享同一份函数</p>
<p>静态成员函数 只可以访问 静态成员变量，不可以访问非静态成员变量</p>
<p>静态成员函数 也是有访问权限的</p>
<p>静态成员函数 有两种访问方式：通过对象 、通过类名</p>
<p>单例模式 – 主席类案例</p>
<p>通过一个类 只能实例化唯一的一个对象</p>
<p>私有化</p>
<p>默认构造</p>
<p>拷贝构造</p>
<p>唯一实例指针</p>
<p>对外提供 getInstance 接口，将指针返回</p>
<p>单例模式 – 打印机案例</p>
<p>和主席类案例一样设计单例模式</p>
<p>提供打印功能并且统计打印次数</p>
<p>C++对象模型初探</p>
<p>类中的成员变量 和 成员函数 是分开存储的</p>
<p>只有非静态成员变量 属于类对象上</p>
<p>空类的sizeof结果 1</p>
<p>this指针</p>
<p>this指针 指向 被调用的成员函数 所属的对象</p>
<p>this指针可以解决名称冲突</p>
<p>this指针 隐式加在每个成员函数中</p>
<p>*this 就是本体</p>
<p>​     p1.personAddPerson(p2).personAddPerson(p2).personAddPerson(p2); //链式编程</p>
<p>空指针访问成员函数</p>
<p>如果成员函数中没有用到this指针，可以用空指针调用成员函数</p>
<p>如果成员函数中用到了this，那么这个this需要加判断，防止代码down掉</p>
<p>常对象和常函数</p>
<p>常函数</p>
<p>成员函数 声明后面加const</p>
<p>void showPerson() <strong>const</strong></p>
<p>const目的是为了修饰成员函数中的this指针，让指针指向的值不可以修改</p>
<p>有些属性比较特殊，依然在常函数或者常对象中可以修改，需要加入关键字 mutable</p>
<p>常对象</p>
<p>const Person p</p>
<p>常对象也不许修改成员属性</p>
<p>常对象只能调用常函数</p>
<p>对于成员函数 ，可不可以 用static 和 const同时修饰 ，不可以</p>
<p>友元</p>
<p>全局函数作为友元函数</p>
<p>利用friend关键字让全局函数 goodGay作为本类好朋友，可以访问私有成员</p>
<p>friend  void goodGay(Building * buliding);</p>
<p>类作为友元类</p>
<p>让goodGay类作为 Building的好朋友，可以访问私有成员</p>
<p>friend class GoodGay;</p>
<p>​    类中的成员函数作为友元函数</p>
<p>​    //让GoodGay类中的 visit成员函数作为友元</p>
<p>friend void GoodGay::visit();</p>
<h3 id="加号运算符重载">加号运算符重载</h3>
<p>对于内置的数据类型，编译器知道如何进行运算</p>
<p>但是对于自定义数据类型，编译器不知道如何运算</p>
<p>利用运算符重载 可以让符号有新的含义</p>
<p>利用加号重载 实现p1 + p2 Person数据类型相加操作</p>
<p>利用成员函数 和 全局函数 都可以实现重载</p>
<p>关键字 operator +</p>
<p>成员本质 p1.operator+(p2)</p>
<p>全局本质 operator+(p1,p2)</p>
<p>简化  p1 + p2</p>
<p>运算符重载 也可以发生函数重载</p>
<p>左移运算符重载</p>
<p>不要滥用运算符重载，除非有需求</p>
<p>不能对内置数据类型进行重载</p>
<p>对于自定义数据类型，不可以直接用 cout &lt;&lt; 输出</p>
<p>需要重载 左移运算符</p>
<p>如果利用成员 函数重载 ，无法实现让cout 在左侧，因此不用成员重载</p>
<p>利用全局函数 实现左移运算符重载</p>
<p><em>ostream</em>&amp; operator&lt;&lt;(<em>ostream</em> &amp;cout, Person &amp; p1)</p>
<p>如果想访问类中私有内存，可以配置友元实现</p>
<h3 id="递增运算符重载">递增运算符重载</h3>
<p>前置递增</p>
<p>MyInter&amp; operator++()</p>
<p>后置递增</p>
<p>MyInter operator++(<strong>int</strong>)</p>
<p>前置++ 效率高于 后置++ 效率 ，因为后置++会调用拷贝构造，创建新的数据</p>
<h3 id="指针运算符重载">指针运算符重载</h3>
<p>智能指针</p>
<p>用途： 托管new出来的对象的释放</p>
<p>设计smartPoint智能指针类，内部维护 Person * ，在析构时候释放堆区new出来的person对象</p>
<p>重载 -&gt;  * 让 sp智能指针用起来向真正的指针</p>
<p>赋值运算符重载</p>
<p>编译器会默认个一个类添加4个函数</p>
<p>默认构造、析构 、 拷贝构造（值拷贝） 、 operator=（值拷贝）</p>
<p>出现 堆区内存重复释放的问题</p>
<p>解决方案：利用深拷贝 重载 =运算符</p>
<p>Person&amp; operator=( const Person &amp;p)</p>
<p>[]运算符重载</p>
<p>int&amp; operator[](int index);</p>
<p>实现访问数组时候利用[] 访问元素</p>
<h3 id="关系运算符重载">关系运算符重载</h3>
<p>对于自定义数据类型，编译器不知道如果进行比较</p>
<p>重载 ==  ！=号</p>
<p>bool operator==( Person &amp; p)</p>
<p>bool operator!=(Person &amp; p)</p>
<h3 id="函数调用运算符重载">函数调用运算符重载</h3>
<p>重载 （）</p>
<p>使用时候很像函数调用，因此称为仿函数</p>
<p>void operator()(<em>string</em> text)</p>
<p>int operator()(int a,int b)</p>
<p>仿函数写法不固定，比较灵活</p>
<p><em>cout</em> &lt;&lt; MyAdd()(1, 1) &lt;&lt; <em>endl</em>; // 匿名函数对象 特点：当前行执行完立即释放</p>
<p><strong>不要重载 &amp;&amp; 和 ||</strong></p>
<p>原因是无法实现短路特性</p>
<p>建议：将&lt;&lt; 和 &gt;&gt;写成全局函数，其他可重载的符号写到成员即可</p>
<p>强化训练-字符串类封装</p>
<p>myString类 实现自定义的字符串类</p>
<h3 id="继承基本语法">继承基本语法</h3>
<p>继承优点：减少重复的代码，提高代码复用性</p>
<p>// 语法： class 子类 ： 继承方式  父类</p>
<p>// News     子类  派生类</p>
<p>// BasePage 父类  基类</p>
<h3 id="继承方式">继承方式</h3>
<p>公共继承</p>
<p>父类中公共权限，子类中变为公共权限</p>
<p>父类中保护权限，子类中变为保护权限</p>
<p>父类中私有权限，子类访问不到</p>
<p>保护继承</p>
<p>父类中公共权限，子类中变为保护权限</p>
<p>父类中保护权限，子类中变为保护权限</p>
<p>父类中私有权限，子类访问不到</p>
<p>私有继承</p>
<p>父类中公共权限，子类中变为私有权限</p>
<p>父类中保护权限，子类中变为私有权限</p>
<p>父类中私有权限，子类访问不到</p>
<p><strong>继承中的对象模型</strong>**</p>
<p>父类中的私有属性，子类是继承下去了，只不过由编译器给隐藏了，访问不到</p>
<p>可以利用开发人员工具查看对象模型</p>
<p>C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts</p>
<p>打开开发人员命令工具</p>
<p>跳转盘符 E:</p>
<p>跳转文件路径 cd到文件路径下</p>
<p>c<strong>l</strong> /d<strong>1</strong> reportSingleClassLayout类名 文件名</p>
<h3 id="继承中的构造和析构">继承中的构造和析构</h3>
<p>先调用父类构造，再调用其他成员构造， 再调用自身构造 ，析构的顺序与构造相反</p>
<p>利用初始化列表语法 显示调用父类中的其他构造函数</p>
<p>父类中 构造、析构、拷贝构造 、operator= 是不会被子类继承下去的</p>
<p>继承中的同名成员处理</p>
<p>​     我们可以利用作用域 访问父类中的同名成员</p>
<p>当子类重新定义了父类中的同名成员函数，子类的成员函数会 隐藏掉父类中所有重载版本的同名成员，可以利用作用域显示指定调用</p>
<p>继承中的同名 静态成员处理</p>
<p>结论和 非静态成员 一致</p>
<p>只不过调用方式有两种</p>
<p>通过对象</p>
<p>通过类名</p>
<p>通过类名的方式 访问 父类作用域下的m_A静态成员变量</p>
<p>Son::Base::m_A</p>
<p>​    多继承基本语法</p>
<p>class 子类 ： 继承方式 父类1 ， 继承方式 父类2</p>
<p>当多继承的两个父类中有同名成员，需要加作用域区分</p>
<p>菱形继承</p>
<p>两个类有公共的父类 和共同的子类 ，发生菱形继承</p>
<p>​    菱形继承导致数据有两份，浪费资源</p>
<p>解决方案：利用虚继承可以解决菱形继承问题</p>
<p>class Sheep : <strong>virtual</strong> public Animal{};</p>
<p>//当发生虚继承后，sheep和tuo类中 继承了一个 vbptr指针  虚基类指针  指向的是一个 虚基类表 vbtable</p>
<p>​    //虚基类表中记录了 偏移量 ，通过偏移量 可以找到唯一的一个m_Age</p>
<p>​    利用地址偏移找到 vbtable中的偏移量 并且访问数据</p>
<p>静态联编动态联编</p>
<p><strong>静态多态和动态多态</strong></p>
<p>静态多态：函数重载，运算符重载</p>
<h3 id="动态多态">动态多态：</h3>
<p>//先有继承关系</p>
<p>//父类中有虚函数，子类重写父类中的虚函数</p>
<p>//父类的指针或引用 指向子类的对象</p>
<p>静态多态在编译阶段绑定地址，地址早绑定，静态联编</p>
<p>动态多次在运行阶段绑定地址，地址晚绑定，动态联编</p>
<h3 id="多态原理">多态原理</h3>
<p>当父类写了虚函数后，类内部结构发生改变，多了一个vfptr</p>
<p>vfptr 虚函数表指针 ---- &gt; vftable 虚函数表</p>
<p>虚函数表内部记录着 虚函数的入口地址</p>
<p>当父类指针或引用指向子类对象，发生多态，调用是时候从虚函数中找函数入口地址</p>
<p>虚函数 关键字 virtual</p>
<p>利用指针的偏移调用 函数</p>
<p>((void(<em>)()) (</em>(int <em>)</em>(int *)animal)) ();</p>
<p>typedef void( __stdcall *FUNPOINT)(int);</p>
<p>(FUNPOINT (<em>((int</em>)<em>(int</em>)animal + 1)))(10);</p>
<p>多态的好处</p>
<p>代码可读性强</p>
<p>组织结构清晰</p>
<p>扩展性强</p>
<p>开闭原则： 对扩展进行开放 对修改进行关闭</p>
<p>纯虚函数和抽象类</p>
<p>语法： virtual int getResult() = 0;</p>
<p>//如果一个类中包含了纯虚函数，那么这个类就无法实例化对象了,这个类通常我们称为 抽象类</p>
<p>//抽象类的子类 必须要重写 父类中的纯虚函数，否则也属于抽象类</p>
<p>虚析构和纯虚析构</p>
<p>虚析构语法：</p>
<p>virtual ~Animal(){}</p>
<p>如果子类中有指向堆区的属性，那么要利用虚析构技术 在delete的时候 调用子类的析构函数</p>
<p>纯虚析构语法：</p>
<p>virtual ~Animal() = 0;</p>
<p>Animal::~Animal(){ .. }</p>
<p>​     //纯虚析构 需要有声明 也需要有实现</p>
<p>​    //如果一个类中 有了 纯虚析构函数，那么这个类也属于抽象类，无法实例化对象了</p>
<p>向上类型转换和向下类型转换</p>
<p>父转子  向下类型转换  不安全</p>
<p>子转父  向上类型转换  安全</p>
<p>如果发生多态，那么转换永远都是安全的</p>
<p>重载、重写、重定义</p>
<p>重载</p>
<p>函数重载</p>
<p>同一个作用域下，函数名称相同，参数个数、顺序、类型不同</p>
<p>重写</p>
<p>子类重写父类中的虚函数，函数返回值、函数名、形参列表完全一致称为重写</p>
<p>重定义</p>
<p>子类重新定义父类中的同名成员函数，隐藏掉父类中同名成员函数，如果想调用加作用域</p>
<h3 id="函数模板">函数模板</h3>
<p><strong>泛型编程 – 模板技术 特点：类型参数化</strong></p>
<p>template&lt; typename T &gt; 告诉编译器后面紧跟着的函数或者类中出现T，不要报错，T是一个通用的数据类型</p>
<p>实现通用两个数进行交换函数</p>
<p>使用</p>
<p>1.自动类型推导  必须要推导出一致的T才可以使用</p>
<p>2.显示指定类型    mySwap<int>(a,b);</p>
<p><strong>函数模板和普通函数的区别以及调用规则</strong></p>
<p>区别</p>
<p>如果使用自动类型推导，是不可以发生隐式类型转换的</p>
<p>普通函数 可以发生隐式类型转换</p>
<p>调用规则</p>
<p>如果函数模板和普通函数都可以调用，那么优先调用普通函数</p>
<p>如果想强制调用函数模板，可以使用空模板参数列表</p>
<p>myPrint&lt;&gt;(a, b);</p>
<p>函数模板也可以发生函数重载</p>
<p>如果函数模板能产生更好的匹配，那么优先使用函数模板</p>
<p><strong>模板的实现机制</strong></p>
<p>编译器并不是把函数模板处理成能够处理任何类型的函数</p>
<p>函数模板通过具体类型产生不同的函数 --- 通过函数模板产生的函数 称为模板函数</p>
<p>编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<p><strong>模板局限性</strong></p>
<p>模板并不是真实的通用，对于自定义数据类型，可以使用具体化技术，实现对自定义数据类型特殊使用</p>
<p>template&lt;&gt;bool myCompare(<strong>Person</strong> &amp;a, <strong>Person</strong> &amp;b)</p>
<h3 id="类模板">类模板</h3>
<p>​    //类模板和函数模板区别：</p>
<p>​     //1、类模板不可以使用自动类型推导，只能用显示指定类型</p>
<p>​        //2、类模板中 可以有默认参数</p>
<p>类模板中成员函数创建时机</p>
<p>类模板中的成员函数 并不是一开始创建的，而是在运行阶段确定出T的数据类型才去创建</p>
<p><strong>类模板做函数参数</strong></p>
<p>1、指定传入类型</p>
<p>void doWork(Person &lt;string, int&gt;&amp;p)</p>
<p>2、参数模板化</p>
<p>template&lt;class T1, class T2&gt;</p>
<p>void doWork2(Person &lt;T1, T2&gt;&amp;p)</p>
<p>3、整个类 模板化</p>
<p>template<class T></p>
<p>void doWork3( T &amp;p)</p>
<p>查看T数据类型</p>
<p>typeid(T).name()</p>
<p>​     <strong>类模板碰到继承的问题以及解决</strong></p>
<p>必须要指定出父类中的T数据类型，才能给子类分配内存</p>
<p>​    template&lt;class T1 ,class T2&gt;</p>
<p>class Son2 :public Base2<T2></p>
<p>类模板中的成员函数类外实现</p>
<p>void Person&lt;T1, T2&gt;::showPerson()</p>
<p><strong>类模板的分文件编写问题以及解决</strong></p>
<p>类模板中的成员函数，不会一开始创建，因此导致分文件编写时连接不到函数的实现，出现无法解析的外部命令错误</p>
<p>解决方式1：</p>
<p>直接包含.cpp文件 （不推荐）</p>
<p>解决方式2：</p>
<p>将类声明和实现写到同一个文件中，将文件的后缀名改为 .hpp 即可</p>
<p><strong>类模板碰到友元的问题以及解决</strong></p>
<p>友元类内实现</p>
<p>friend void printPerson(Person&lt;T1, T2&gt; &amp;p)</p>
<p>友元类外实现</p>
<p>声明：</p>
<p>friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</p>
<p>实现：</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>void printPerson2(Person&lt;T1, T2&gt; &amp;p){ 。。。}</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>class Person;</p>
<p>template&lt;class T1,class T2&gt;</p>
<p>void printPerson2(Person&lt;T1, T2&gt; &amp;p);</p>
<h3 id="类型转换">类型转换</h3>
<p>静态类型转换 static_cast</p>
<p>允许内置数据类型转换</p>
<p>允许父子之间的指针或者引用的转换</p>
<p>语法 static_cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>动态类型转换 dynamic_cast</p>
<p>不允许内置数据类型转换</p>
<p>允许父子之间指针或者引用的转换</p>
<p>父转子 不安全的 转换失败</p>
<p>子转父 安全  转换成功</p>
<p>如果发生多态，总是安全，可以成功</p>
<p>语法 dynamic_cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>常量转换  const_cast</p>
<p>只允许 指针或者引用 之间转换</p>
<p>语法 const _cast&lt;目标类型&gt;(原变量/原对象)</p>
<p>重新解释转换</p>
<p>reinterpret_cast 最不安全一种转换，不建议使用</p>
<h3 id="异常的基本语法">异常的基本语法</h3>
<p>C++异常的处理关键字</p>
<p>try throw catch</p>
<p>可以出现异常的代码 放到 try块</p>
<p>利用throw抛出异常</p>
<p>利用catch捕获异常</p>
<p>catch( 类型) 如果想捕获其他类型 catch(…)</p>
<p>如果捕获到的异常不想处理，而继续向上抛出，利用 throw</p>
<p>异常必须有函数进行处理，如果都不去处理，程序自动调用 terminate函数，中断掉</p>
<p>异常可以是自定义数据类型</p>
<p><strong>栈解旋</strong></p>
<p>从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉，</p>
<p>释放的顺序和创建顺序相反的，这个过程我们称为栈解旋</p>
<p><strong>异常的接口声明</strong></p>
<p>在函数中 如果限定抛出异常的类型，可以用异常的接口声明</p>
<p>语法： void func()throw(int ,double)</p>
<p>throw(空)代表 不允许抛出异常</p>
<p><strong>异常变量的生命周期</strong></p>
<p>//抛出的是 throw MyException(); catch (MyException e) 调用拷贝构造函数 效率低</p>
<p>//抛出的是 throw MyException(); catch (MyException &amp;e) 只调用默认构造函数 效率高 <strong>推荐</strong></p>
<p>//抛出的是 throw &amp;MyException(); catch (MyException *e) 对象会提前释放掉，不能在非法操作</p>
<p>//抛出的是 new MyException();  catch (MyException *e) 只调用默认构造函数 自己要管理释放</p>
<p>异常的多态使用</p>
<p>提供基类异常类</p>
<p>class BaseException</p>
<p>纯虚函数 virtual void printError() = 0;</p>
<p>子类空指针异常 和 越界异常 继承 BaseException</p>
<p>重写virtual void printError()</p>
<p>测试 利用父类引用指向子类对象</p>
<p><strong>系统标准异常</strong></p>
<p>引入头文件 #include <stdexcept></p>
<p>抛出越界异常 throw out_of_range(“…”)</p>
<p>获取错误信息 catch( exception &amp; e )   e.what();</p>
<p><strong>编写自己的异常类</strong></p>
<p>编写myOutofRange 继承 Exception类</p>
<p>重写 virtual const char * what() const</p>
<p>将sting 转为 const char *</p>
<p>.c_str()</p>
<p>​    const char * 可以隐式类型转换为 string 反之不可以</p>
<p>​     测试，利用多态打印出错误提示信息</p>
<h3 id="标准输入流">标准输入流</h3>
<p>cin.get() 获取一个字符</p>
<p>cin.get(两个参数) 获取字符串</p>
<p>利用cin.get获取字符串时候，换行符遗留在缓冲区中</p>
<p>cin.getline() 获取字符串</p>
<p>利用cin.getline获取字符串时候，换行符不会被取走，也不在缓冲区中，而是直接扔掉</p>
<p>cin.ignore() 忽略 默认忽略1个字符， 如果填入参数X，代表忽略X个字符</p>
<p>cin.peek() 偷窥</p>
<p>cin.putback() 放回 放回原位置</p>
<h3 id="标准输出流">标准输出流</h3>
<p>cout.put() //向缓冲区写字符</p>
<p>cout.write() //从buffer中写num个字节到当前输出流中。</p>
<p>通过 流成员函数 格式化输出</p>
<p>int number = 99;</p>
<p>cout.width(20); //指定宽度为20</p>
<p>cout.fill('*'); //填充</p>
<p>cout.setf(ios::left); //左对齐</p>
<p>cout.unsetf(ios::dec); //卸载十进制</p>
<p>cout.setf(ios::hex); //安装十六进制</p>
<p>cout.setf(ios::showbase); //显示基数</p>
<p>cout.unsetf(ios::hex); //卸载十六进制</p>
<p>cout.setf(ios::oct);  //安装八进制</p>
<p>​    cout &lt;&lt; number &lt;&lt; endl;</p>
<p><strong>通过控制符 格式化输出</strong></p>
<p>int number = 99;</p>
<p>cout &lt;&lt; setw(20)   //设置宽度</p>
<p>​    &lt;&lt; setfill('~') //设置填充</p>
<p>&lt;&lt; setiosflags(ios::showbase) //显示基数</p>
<p>&lt;&lt; setiosflags(ios::left) //设置左对齐</p>
<p>&lt;&lt; hex  //显示十六进制</p>
<p>&lt;&lt; number</p>
<p>&lt;&lt; endl;</p>
<p>​	引入头文件 #include&lt; iomanip&gt;</p>
<h3 id="文件读写">文件读写</h3>
<p>头文件 #inlcude &lt; fstream&gt;</p>
<p>写文件</p>
<p>ofstream ofs (文件路径，打开方式 ios::out )</p>
<p>判断文件是否打开成功 ofs.is_open</p>
<p>ofs &lt;&lt; “…”</p>
<p>关闭文件 ofs.close();</p>
<p>读文件</p>
<p>ifstream ifs(文件路径，打开方式 ios::in)</p>
<p>判断文件是否打开成功 ofs.is_open</p>
<p>利用4种方式 对文件进行读取</p>
<p>关闭文件 ifs.close();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言续]]></title>
        <id>https://xmweijh.github.io/post/c-yu-yan-xu/</id>
        <link href="https://xmweijh.github.io/post/c-yu-yan-xu/">
        </link>
        <updated>2021-02-07T11:35:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c语言续">c语言续</h2>
<p>char *p1,p2       p1指针，p2字符         可用  typedef char * PCHAR    或   char *p1 ,  *p2解决</p>
<p>数据类型  编译器指定出的数据类型，为了更好地管理内存</p>
<p><code>sizeof</code>  只是一个操作符类似于+-*/，非函数。对于数据类型，必须用（），但对于变量不用。   其返回值类型为 unsigned int  无符号整型。</p>
<p>当unsigned int 和 int 做运算，编译器会把数据类型都转换为unsigned int</p>
<p>无符号打印%u</p>
<p>sizeof 可以统计数组长度，当数组名作为函数参数时，会退化为指针，指向数组的第一个元素</p>
<p>变量，可以读写的内存对象</p>
<p>data初始化全局变量，静态变量，常量     bss未初始化</p>
<p>栈区          堆区</p>
<p>栈，注意不要返回局部变量的地址（函数结束内存会被释放）</p>
<p>堆区，手动开辟的记得手动回收</p>
<p>如果主调函数中没有给指针分配内存，被调函数用同级指针是修饰不到主调函数中的指针的</p>
<p>static 静态变量 只初始化一次，在编译阶段就分配内存属于内部链接属性，只能在当前文件中使用</p>
<p>const 修饰的局部变量通过间接修改 成功</p>
<p>宏函数一定程度上比普通效率（入栈，出栈）高 ，频繁短小函数可写为宏函数           以空间换时间</p>
<p>调用惯例       出栈放、参数的传入顺序、函数名称的修饰    c和c++ 为cdecl</p>
<p>栈的生成方向 以及 内存存储方式</p>
<p>栈底   高地址      栈顶   低地址  （从高地址到低地址使用）</p>
<p>存储方式     高位字节数据  高地址  低位 低地址  （小端对齐）</p>
<p>空指针   不允许向NULL和非法地址拷贝内存</p>
<p>野指针  未初始化指针 ， malloc后free了，但没将指针置空  ， 指针操作超越作用域</p>
<p>指针的步长</p>
<p>指针变量+1后，跳跃的字节数量</p>
<p>解引用的时候，取得字节数</p>
<p>获取结构体中属性的偏移： offsetof(结构体,属性)   头文件 #include&lt;stddef.h&gt;</p>
<p>字符串是有结束标志 \0</p>
<p>三种方式拷贝字符串：利用[]  利用指针  利用while （*dest++ =  *source++）</p>
<p>char*str 字符串常量不能改变  char str[]可以改</p>
<p>calloc 分配的内存会初始化为0</p>
<p>sscanf  将已知的字符串格式化匹配出有效信息</p>
<p>指针易错点</p>
<p>越界操作  指针叠加会不断改变指针指向  返回局部变量地址  不可以释放野指针</p>
<p>将文件光标置为文件首 fseek( file, 0 ,SEEK_SET)</p>
<p>按位取反 ~</p>
<pre><code> int num =2; 
 printf(&quot;~num = %d\n&quot;,~num);//结果为-3
</code></pre>
<p>2  -&gt;  010    按位取反（符号位也取反） 101  源码      101  补码 （取反+1）  110+1（此时符号位不取反）    111   = -3</p>
<p>两数交换的其他方法</p>
<pre><code>num1 = num1 ^ num2;
num2 = num1 ^ num2;
num1 = num1 ^ num2;

num1 = num1 + num2;
num2 = num1 - num2;
num1 = num1 - num2;
</code></pre>
<p>左移&lt;&lt;  右移&gt;&gt;</p>
<p>一维数组  本质并不是一个指针</p>
<p>​		有两种特殊情况：1.对数组进行sizeof   2.对数组名称取地址 ，获取的指针步长为整个数组的长度</p>
<p>其他情况都是指向数组首元素的地址的指针</p>
<p>数组名  -- 指针常量 ，指针的指向不可以修改  int * const p</p>
<p>访问数组元素的时候下标可以为负数</p>
<p>结构体偏移量 offsetof计算 或 地址相减</p>
<p>cpu按块读取内存，块的大小为2的n次方 有了内存对齐，更好读取</p>
<p>#pragma pack(show) 查看对齐模数， 默认对齐为8 可改为2的n次方</p>
<p>对于自定义数据类型 内存对齐规则如下:</p>
<p>1、从第一个属性开始 偏移为0</p>
<p>2、从第二个属性开始，地址要放在 该类型整数倍 与 对齐模数比 取小的值的 整数倍</p>
<p>3、所有的属性都计算后，整体再做二次对齐 整体需要放在属性中最大类型与 对齐模数比 取小的值的整数倍上。</p>
<p>结构体嵌套结构体时，只需要看子结构体中最大数据类型就可以了</p>
<p>文件结尾 EOF</p>
<p>fseek(文件指针，偏移，起始位置 SEEK_SET SEEK_END SEEK_CUR)</p>
<p>rewind(文件指正) 将文件光标置首</p>
<p>error宏 全局变量 perror 打印宏提示错误信息</p>
<p>数组缺陷，静态空间，一旦分配内存就不可以动态扩展  对属于数组头进行插入和删除效率低</p>
<p>头结点 好处在于头结点永远都是固定的</p>
<p>静态链表  栈区  动态链表 堆区</p>
<p>带头节点链表好处在于头节点永远都是固定的<br>
初始化链表struct LinkNode*pHeader= init_LinkList(u<br>
遍历链表void	foreach_LinkList( struct LinkNode  pHeader )u</p>
<p>函数指针的定义<br>
先定义出函数类型，再通过类型定义出函数指针<br>
typedef void(FUNC_TYPE)();<br>
FUNC_TYPE pEunc = func</p>
<p>先定义出函躞指针类型，再定义函数指针÷<br>
typedef void(*FUNC_TYPE)();'<br>
FUNC_TYPE pFunc- func;</p>
<p>直接定义函数指针变量<br>
void(* pEunc )()= fung;<br>
函数指针和指针函数的区别<br>
函数指针是指向函数的指针<br>
指针函数―丞|数的返回值是一个指针的函数+<br>
函数指针的数组定义↓<br>
void(*pFunc[3])();.</p>
<p>本题要求实现一个函数，判断任一给定整数<code>N</code>是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int IsTheNumber(const int N);

int main()
{
    int n1, n2, i, cnt;

    scanf(&quot;%d %d&quot;, &amp;n1, &amp;n2);
    cnt = 0;
    for (i = n1; i &lt;= n2; i++) {
        if (IsTheNumber(i))
            cnt++;
    }
    printf(&quot;cnt = %d\n&quot;, cnt);
    
    return 0;

}

int IsTheNumber(const int N) {
    int n = N;
    int b;
    int p[10] = { 0 };
    int m = sqrt(n);
    if (m * m == n) {
        while (n) {
            b = n % 10;
            p[b]++;
            n /= 10;
        }
        for (int i = 0;i &lt;= 9;i++) {
            if (p[i] &gt; 1)
                return 1;
        }
    }
    return 0;
}
</code></pre>
<p>声明和定义区别</p>
<p>l 声明变量不需要建立存储空间，如：extern int a;</p>
<p>l 定义变量需要建立存储空间，如：int b;</p>
<p>从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：</p>
<p>l int b 它既是声明，同时又是定义</p>
<p>l 对于 extern b来讲它只是声明不是定义</p>
<p>​         不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型</p>
<p><strong>在计算机系统中，数值一律用补码来存储</strong>，主要原因是：</p>
<p>l 统一了零的编码</p>
<p>l 将符号位和其它位统一处理</p>
<p>l 将减法运算转变为加法运算</p>
<p>l 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃</p>
<p>斯特林(Stirling)公式 求大数阶乘的位数</p>
<pre><code>我们知道整数n的位数的计算方法为：log10(n)+1n!=10^m故n!的位数为 m = log10(n!)+1
</code></pre>
<p><strong>#pragmaonce这个宏有什么作用？</strong></p>
<p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p>
<p>在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。</p>
<p>如果我们要在一个函数内改变一个指针的值，我们就需要将形参定义了二级指针</p>
<p><strong>中缀转后缀算法∶</strong><br>
遍历中缀表达式中的数字和符号∶<br>
**对于数字︰**直接输出.<br>
<strong>对于符号∶</strong><br>
左括号∶进栈<br>
运算符号∶与栈顶符号进行优先级比较若栈顶符号优先级低∶此符号进栈<br>
(默认栈顶若是左括号，左括号优先级最低)&gt;<br>
若栈顶符号优先级不低∶将栈顶符号弹出并输出，之后进栈<br>
右括号∶将栈顶符号弹出并输出，直到匹配左括号,将左括号和右括号同时舍弃<br>
遍历结束∶将栈中的所有符号弹出并输出</p>
<p>计算规则·<br>
遍历后缀表达式中的数字和符号<br>
对于数字∶进栈<br>
对于符号:<br>
从栈中弹出右操作数<br>
从栈中弹出左操作数<br>
根据符号进行运算<br>
将运算结果压入栈中<br>
遍历结束:栈中的唯—数字为计算结果</p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C1337526379_6285.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1337526423_9040.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cc">List Reverse( List L )
{
    List head,next,prev;
    prev = NULL;
    head = L;
    while(head != NULL)
    {
        next = head-&gt;Next;
        head-&gt;Next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML]]></title>
        <id>https://xmweijh.github.io/post/html/</id>
        <link href="https://xmweijh.github.io/post/html/">
        </link>
        <updated>2021-02-07T11:35:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html">HTML</h1>
<h3 id="web-标准构成">Web 标准构成</h3>
<p><strong>构成：</strong> 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p>
<p>VSCode常用快捷键</p>
<p>1） ！+enter : 快速生称html代码框架</p>
<p>2） shift+alt+向下的方向键： 向下复制当前行</p>
<p>3） shift+alt+向上的方向键： 向上复制当前行</p>
<p>4） ctrl+S： 保存</p>
<p>5）shift+alt+F: 格式化代码</p>
<p>6） ctrl+F: 查找和替换</p>
<h3 id="文档类型doctype">文档类型&lt;!DOCTYPE&gt;</h3>
<p><strong>用法：</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt; 
</code></pre>
<p><strong>作用：</strong></p>
<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。
<h3 id="页面语言lang">页面语言lang</h3>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;  指定html 语言种类
</code></pre>
<p>最常见的2个：</p>
<ol>
<li><code>en</code>定义语言为英语</li>
<li><code>zh-CN</code>定义语言为中文</li>
</ol>
<h3 id="字符集">字符集</h3>
<pre><code class="language-html">&lt;meta charset=&quot;UTF-8&quot; /&gt;
</code></pre>
<pre><code>字符集(Character set)是多个字符的集合。

计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。
</code></pre>
<p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p>
<ul>
<li>gb2312 简单中文  包括6763个汉字  GUO BIAO</li>
<li>BIG5   繁体中文 港澳台等用</li>
<li>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</li>
<li>UTF-8则基本包含全世界所有国家需要用到的字符</li>
<li><strong>这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。</strong></li>
</ul>
<h2 id="html常用标签">HTML常用标签</h2>
<h3 id="排版标签">排版标签</h3>
<h4 id="标题标签h-熟记">标题标签h (熟记)</h4>
<p>单词缩写：  head</p>
<p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p>
<p><strong>标题标签语义：</strong>  作为标题使用，并且依据重要性递减</p>
<p>其基本语法格式如下：</p>
<pre><code class="language-html">&lt;h1&gt;   标题文本   &lt;/h1&gt;
&lt;h2&gt;   标题文本   &lt;/h2&gt;
&lt;h3&gt;   标题文本   &lt;/h3&gt;
&lt;h4&gt;   标题文本   &lt;/h4&gt;
&lt;h5&gt;   标题文本   &lt;/h5&gt;
&lt;h6&gt;   标题文本   &lt;/h6&gt;
</code></pre>
<ul>
<li>加了标题的文字会变的加粗，字号也会依次变大</li>
<li>一行是只能放一个标题的</li>
</ul>
<h4 id="段落标签p-熟记">段落标签p ( 熟记)</h4>
<p>单词缩写：  paragraph</p>
<p><strong>作用语义：</strong></p>
<p>可以把 HTML 文档分割为若干段落</p>
<p>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<pre><code class="language-html">&lt;p&gt;  文本内容  &lt;/p&gt;
</code></pre>
<p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<h4 id="水平线标签hr认识">水平线标签hr(认识)</h4>
<p>单词缩写：  horizontal</p>
<p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，<hr />就是创建横跨网页水平线的标签。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;hr /&gt;是单标签
</code></pre>
<p>在网页中显示默认样式的水平线。</p>
<h4 id="换行标签br-熟记">换行标签br (熟记)</h4>
<p>单词缩写：  break</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p>
<pre><code class="language-html">&lt;br /&gt;
</code></pre>
<p>这时如果还像在word中直接敲回车键换行就不起作用了。</p>
<h4 id="div-和-span标签重点">div 和  span标签(重点)</h4>
<p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p>
<p>span   跨度，跨距；范围</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;div&gt; 这是头部 &lt;/div&gt;    &lt;span&gt;今日价格&lt;/span&gt;
</code></pre>
<p>他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们主要记住使用方法和特点就好了</p>
<ul>
<li>div标签  用来布局的，但是现在一行只能放一个div</li>
<li>span标签  用来布局的，一行上可以放好多个span</li>
</ul>
<h4 id="排版标签总结">排版标签总结</h4>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><hx></hx></td>
<td style="text-align:left">标题标签</td>
<td style="text-align:left">作为标题使用，并且依据重要性递减</td>
</tr>
<tr>
<td><p></p></td>
<td style="text-align:left">段落标签</td>
<td style="text-align:left">可以把 HTML 文档分割为若干段落</td>
</tr>
<tr>
<td><hr /></td>
<td style="text-align:left">水平线标签</td>
<td style="text-align:left">没啥可说的，就是一条线</td>
</tr>
<tr>
<td><br /></td>
<td style="text-align:left">换行标签</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><div></div></td>
<td style="text-align:left">div标签</td>
<td style="text-align:left">用来布局的，但是现在一行只能放一个div</td>
</tr>
<tr>
<td><span></span></td>
<td style="text-align:left">span标签</td>
<td style="text-align:left">用来布局的，一行上可以放好多个span</td>
</tr>
</tbody>
</table>
<h3 id="文本格式化标签熟记">文本格式化标签(熟记)</h3>
<p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p>
<img src="D:/BaiduNetdiskDownload/web/【27】源码+课件+软件/01-03 前端开发基础/01-HTML资料/01.HTML-Day01/笔记/media/tab.png" />
<p><strong>区别：</strong></p>
<p>b  只是加粗          strong  除了可以加粗还有 强调的意思，  语义更强烈。</p>
<h3 id="标签属性">标签属性</h3>
<p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;
</code></pre>
<h3 id="图像标签img-重点">图像标签img (重点)</h3>
<p>单词缩写：   image</p>
<p>要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<img />以及和他相关的属性。</p>
<p>语法如下：</p>
<pre><code class="language-html">&lt;img src=&quot;图像URL&quot; /&gt;
</code></pre>
<p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p>
<img src="D:/BaiduNetdiskDownload/web/【27】源码+课件+软件/01-03 前端开发基础/01-HTML资料/01.HTML-Day01/笔记/media/img.png" />
<p>border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了</p>
<p>**注意: **</p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>采取  键值对 的格式   key=&quot;value&quot;  的格式</li>
</ol>
<p>比如:</p>
<pre><code class="language-html">	正常的&lt;br /&gt;
    &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;&lt;br /&gt;
     带有边框的&lt;br /&gt;
    &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; /&gt;&lt;br /&gt;
	有提示文本的&lt;br /&gt;
	&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&gt;&lt;br /&gt;
	有替换文本的&lt;br /&gt;
	&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;图片不存在&quot; /&gt;
</code></pre>
<h3 id="链接标签重点">链接标签(重点)</h3>
<p>单词缩写：  anchor 的缩写</p>
<p>在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>href</td>
<td style="text-align:left">用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td>target</td>
<td style="text-align:left">用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，__blank为在新窗口中打开方式。</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ol>
<li>外部链接 需要添加 http:// www.baidu.com</li>
<li>内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 </a ></li>
<li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。</li>
<li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</li>
</ol>
<h3 id="注释标签">注释标签</h3>
<p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p>
<p>简单解释：</p>
<p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p>
<p>语法格式：</p>
<pre><code class="language-html">    &lt;!-- 注释语句 --&gt;     快捷键是：    ctrl + /       或者 ctrl +shift + / 
</code></pre>
<h2 id="路径重点-难点">路径(重点、难点)</h2>
<p>实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。</p>
<p>**目录文件夹： **</p>
<p>就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。</p>
<p>**根目录 **</p>
<p>打开目录文件夹的第一层  就是 根目录</p>
<p>页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径</p>
<h3 id="相对路径">相对路径</h3>
<p>以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。</p>
<table>
<thead>
<tr>
<th>路径分类</th>
<th style="text-align:center">符号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一级路径</td>
<td style="text-align:center"></td>
<td style="text-align:left">只需输入图像文件的名称即可，如&lt;img src=&quot;baidu.gif&quot; /&gt;。</td>
</tr>
<tr>
<td>下一级路径</td>
<td style="text-align:center">“/”</td>
<td style="text-align:left">图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images）                         如&lt;img src=&quot;images/baidu.gif&quot; /&gt;。</td>
</tr>
<tr>
<td>上一级路径</td>
<td style="text-align:center">“../”</td>
<td style="text-align:left">在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，                    如&lt;img src=&quot;../baidu.gif&quot; /&gt;。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级  简单说，就是 图片 位于 HTML 页面的位置</p>
</blockquote>
<h3 id="绝对路径">绝对路径</h3>
<p>绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。</p>
<p>“D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。</p>
<p><strong>注意：</strong></p>
<p>绝对路径用的较少，我们理解下就可以了。  但是要注意，它的写法 特别是符号  \  并不是 相对路径的   /</p>
<h4 id="锚点定位-难点">锚点定位 （难点）</h4>
<p>通过创建锚点链接，用户能够快速定位到目标内容。</p>
<p>创建锚点链接分为两步：</p>
<pre><code class="language-html">1. 使用相应的id名标注跳转目标的位置。 (找目标)
  &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 

2. 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） （拉关系）  我也有一个姓毕的姥爷..
  &lt;a href=&quot;#two&quot;&gt;   
</code></pre>
<p>快速记忆法：</p>
<p>好比找个人办事，  首先找到他，然后拉关系，最后看效果。</p>
<h4 id="base-标签">base 标签</h4>
<p><strong>语法：</strong></p>
<pre><code class="language-html">&lt;base target=&quot;_blank&quot; /&gt;
</code></pre>
<p>**总结： **</p>
<ol>
<li>base 可以设置整体链接的打开状态</li>
<li>base 写到  <head>  </head>  之间</li>
<li>把所有的连接 都默认添加 target=&quot;_blank&quot;</li>
</ol>
<h4 id="预格式化文本pre标签">预格式化文本pre标签</h4>
<pre> 标签可定义预格式化的文本。



被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。

```html
<pre>

  此例演示如何使用 pre 标签

  对空行和 空格

  进行控制

</pre>
<pre><code>
了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。

HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体

### 表格 table

 表格的现在还是较为常用的一种标签，但不是用来布局，**常见显示、展示表格式数据。**

因为它可以让数据显示的非常的规整，可读性非常好。

**特别是后台展示数据的时候表格运用是否熟练就显得很重要**，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。

#### **创建表格的基本语法：**

```html
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;单元格内的文字&lt;/td&gt;
    ...
  &lt;/tr&gt;
  ...
&lt;/table&gt;
</code></pre>
<p>要深刻体会表格、行、单元格他们的构成。</p>
<p>在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释</p>
<ol>
<li>
<p>table用于定义一个表格标签。</p>
</li>
<li>
<p>tr标签 用于定义表格中的行，必须嵌套在 table标签中。</p>
</li>
<li>
<p>td 用于定义表格中的单元格，必须嵌套在<tr></tr>标签中。</p>
</li>
<li>
<p>字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。</p>
</li>
</ol>
<h4 id=""><img src="F:%5CAPEX-4869%5Cmd%5Ctt.png" alt="表格属性" loading="lazy"></h4>
<h4 id="表头单元格标签th">表头单元格标签th</h4>
<ul>
<li>
<p>作用：</p>
</li>
<li>
<ul>
<li>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</li>
</ul>
</li>
<li>
<p>语法：</p>
<ul>
<li>只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。</li>
</ul>
</li>
</ul>
<p>th 也是一个单元格   只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗</p>
<h4 id="表格标题caption">表格标题caption</h4>
<p><strong>定义和用法</strong></p>
<pre><code class="language-html">&lt;table&gt;
   &lt;caption&gt;我是表格标题&lt;/caption&gt;
&lt;/table&gt;
</code></pre>
<p>**注意： **</p>
<ol>
<li>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上。</li>
<li>caption 标签必须紧随 table 标签之后。</li>
<li>这个标签只存在 表格里面才有意义。</li>
</ol>
<h4 id="合并单元格">合并单元格</h4>
<h4 id="合并单元格2种方式">合并单元格2种方式</h4>
<ul>
<li>跨行合并：rowspan=&quot;合并单元格的个数&quot;</li>
<li>跨列合并：colspan=&quot;合并单元格的个数&quot;</li>
</ul>
<p>**合并的顺序我们按照   先上 后下     先左  后右 的顺序 **</p>
<h4 id="合并单元格三步曲">合并单元格三步曲</h4>
<ol>
<li>先确定是跨行还是跨列合并</li>
<li>根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ： <td colspan="3">   </td></li>
<li>删除多余的单元格 单元格</li>
</ol>
<h3 id="总结表格">总结表格</h3>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><table></table></td>
<td style="text-align:left">表格标签</td>
<td style="text-align:left">就是一个四方的盒子</td>
</tr>
<tr>
<td><tr></tr></td>
<td style="text-align:left">表格行标签</td>
<td style="text-align:left">行标签要再table标签内部才有意义</td>
</tr>
<tr>
<td><td></td></td>
<td style="text-align:left">单元格标签</td>
<td style="text-align:left">单元格标签是个容器级元素，可以放任何东西</td>
</tr>
<tr>
<td><th></th></td>
<td style="text-align:left">表头单元格标签</td>
<td style="text-align:left">它还是一个单元格，但是里面的文字会居中且加粗</td>
</tr>
<tr>
<td><caption></caption></td>
<td style="text-align:left">表格标题标签</td>
<td style="text-align:left">表格的标题，跟着表格一起走，和表格居中对齐</td>
</tr>
<tr>
<td>clospan 和 rowspan</td>
<td style="text-align:left">合并属性</td>
<td style="text-align:left">用来合并单元格的</td>
</tr>
</tbody>
</table>
<ol>
<li>表格提供了HTML 中定义表格式数据的方法。</li>
<li>表格中由行中的单元格组成。</li>
<li>表格中没有列元素，列的个数取决于行的单元格个数。</li>
<li>表格不要纠结于外观，那是CSS 的作用。</li>
<li>表格的学习要求：  能手写表格结构，并且能简单合并单元格。</li>
</ol>
<h3 id="列表标签">列表标签</h3>
<ul>
<li>
<p>概念：</p>
<p>容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表</p>
</li>
<li>
<p>特点：</p>
<p>列表最大的特点就是  整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。</p>
</li>
</ul>
<h4 id="无序列表-ul">无序列表 ul</h4>
<p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
  &lt;li&gt;列表项3&lt;/li&gt;
  ......
&lt;/ul&gt;
</code></pre>
<pre><code> 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。
 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。
 3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！
</code></pre>
<h4 id="有序列表-ol">有序列表 ol</h4>
<p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<pre><code class="language-html">&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
  &lt;li&gt;列表项3&lt;/li&gt;
  ......
&lt;/ol&gt;
</code></pre>
<p>所有特性基本与ul 一致。  但是实际中比 无序列表 用的少很多。</p>
<p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  &lt;dd&gt;名词1解释2&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  &lt;dd&gt;名词2解释2&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<h3 id="列表总结">列表总结</h3>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:center">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><ul></ul></td>
<td style="text-align:center"><strong>无序标签</strong></td>
<td style="text-align:left">里面只能包含li    没有顺序，我们以后布局中最常用的列表</td>
</tr>
<tr>
<td><ol></ol></td>
<td style="text-align:center">有序标签</td>
<td style="text-align:left">里面只能包含li    有顺序， 使用情况较少</td>
</tr>
<tr>
<td><dl></dl></td>
<td style="text-align:center">自定义列表</td>
<td style="text-align:left">里面有2个兄弟， dt 和 dd</td>
</tr>
</tbody>
</table>
<h3 id="表单标签">表单标签</h3>
<p>**表单控件： **</p>
<p>​       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p>
<p><strong>提示信息：</strong></p>
<p>​        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p>
<p><strong>表单域：</strong></p>
<p>​      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p>
<h4 id="input-控件">input 控件</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-html">&lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt;
</code></pre>
<ul>
<li>input 输入的意思</li>
<li>&lt;input /&gt;标签为单标签</li>
<li>type属性设置不同的属性值用来指定不同的控件类型</li>
<li>除了type属性还有别的属性</li>
</ul>
</li>
</ul>
<h4 id="1-type-属性">1. type 属性</h4>
<ul>
<li>这个属性通过改变值，可以决定了你属于那种input表单。</li>
<li>比如 type = 'text'  就表示 文本框 可以做 用户名， 昵称等。</li>
<li>比如 type = 'password'  就是表示密码框   用户输入的内容 是不可见的。</li>
</ul>
<pre><code class="language-html">用户名: &lt;input type=&quot;text&quot; /&gt; 
密  码：&lt;input type=&quot;password&quot; /&gt;
</code></pre>
<h4 id="2-value属性-值">2. value属性   值</h4>
<pre><code class="language-html">用户名:&lt;input type=&quot;text&quot;  name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; 
</code></pre>
<ul>
<li>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</li>
</ul>
<h4 id="3-name属性">3. name属性</h4>
<pre><code class="language-html">用户名:&lt;input type=&quot;text&quot;  name=“username” /&gt;  
</code></pre>
<p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</p>
<ul>
<li>
<p>name属性后面的值，是我们自己定义的。</p>
</li>
<li>
<p>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</p>
</li>
</ul>
<pre><code class="language-html">&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  /&gt;男
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女
</code></pre>
<ul>
<li>name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</li>
</ul>
<h4 id="4-checked属性">4. checked属性</h4>
<ul>
<li>表示默认选中状态。  较常见于 单选按钮和复选按钮。</li>
</ul>
<pre><code class="language-html">性    别:
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 
</code></pre>
<p>上面这个，表示就默认选中了 男 这个单选按钮</p>
<h4 id="5-input-属性小结">5. input 属性小结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">说明</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td style="text-align:left">表单类型</td>
<td>用来指定不同的控件类型</td>
</tr>
<tr>
<td>value</td>
<td style="text-align:left">表单值</td>
<td>表单里面默认显示的文本</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:left">表单名字</td>
<td>页面中的表单很多，name主要作用就是用于区别不同的表单。</td>
</tr>
<tr>
<td>checked</td>
<td style="text-align:left">默认选中</td>
<td>表示那个单选或者复选按钮一开始就被选中了</td>
</tr>
</tbody>
</table>
<p>lab 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p>
<p><strong>如何绑定元素呢？</strong></p>
<ol>
<li>第一种用法就是用label直接包括input表单。</li>
</ol>
<pre><code class="language-html">&lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt;   &lt;/label&gt;
</code></pre>
<p>适合单个表单选择</p>
<ol start="2">
<li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li>
</ol>
<pre><code class="language-html">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot;&gt;
</code></pre>
<h4 id="textarea控件文本域">textarea控件(文本域)</h4>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-html">&lt;textarea &gt;
  文本内容
&lt;/textarea&gt;
</code></pre>
<ul>
<li>
<p>作用：</p>
<p>通过textarea控件可以轻松地创建多行文本输入框.</p>
<p>cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;  我们实际开发不用</p>
</li>
</ul>
<h4 id="文本框和文本域区别">文本框和文本域区别</h4>
<table>
<thead>
<tr>
<th style="text-align:left">表单</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">区别</th>
<th style="text-align:right">默认值显示</th>
<th style="text-align:right">用于场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">input type=&quot;text&quot;</td>
<td style="text-align:center">文本框</td>
<td style="text-align:center">只能显示一行文本</td>
<td style="text-align:right">单标签，通过value显示默认值</td>
<td style="text-align:right">用户名、昵称、密码等</td>
</tr>
<tr>
<td style="text-align:left">textarea</td>
<td style="text-align:center">文本域</td>
<td style="text-align:center">可以显示多行文本</td>
<td style="text-align:right">双标签，默认值写到标签中间</td>
<td style="text-align:right">留言板</td>
</tr>
</tbody>
</table>
<h4 id="select下拉列表">select下拉列表</h4>
<p><strong>语法：</strong></p>
<pre><code class="language-html">&lt;select&gt;
  &lt;option&gt;选项1&lt;/option&gt;
  &lt;option&gt;选项2&lt;/option&gt;
  &lt;option&gt;选项3&lt;/option&gt;
  ...
&lt;/select&gt;
</code></pre>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>&lt;select&gt;  中至少包含一对 option</li>
<li>在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。</li>
<li>但是我们实际开发会用的比较少</li>
</ol>
<h4 id="form表单域">form表单域</h4>
<ul>
<li>
<p>目的：</p>
<p>在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</p>
</li>
</ul>
<p>**语法: **</p>
<pre><code class="language-html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;
  各种表单控件
&lt;/form&gt;
</code></pre>
<p><strong>常用属性：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td style="text-align:left">url地址</td>
<td>用于指定接收并处理表单数据的服务器程序的url地址。</td>
</tr>
<tr>
<td>method</td>
<td style="text-align:left">get/post</td>
<td>用于设置表单数据的提交方式，其取值为get或post。</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:left">名称</td>
<td>用于指定表单的名称，以区分同一个页面中的多个表单。</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</p>
<p>经常查阅文档是一个非常好的学习习惯。</p>
<p>W3C :  http://www.w3school.com.cn/</p>
<p>MDN: https://developer.mozilla.org/zh-CN/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web代码规范]]></title>
        <id>https://xmweijh.github.io/post/web-dai-ma-gui-fan/</id>
        <link href="https://xmweijh.github.io/post/web-dai-ma-gui-fan/">
        </link>
        <updated>2021-02-07T11:32:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="代码规范">代码规范</h1>
<h2 id="1-概述">1. 概述</h2>
<p>欢迎使用品优购代码规范， 这个是我借鉴京东前端代码规范，组织的品优购内部规范。旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范，</p>
<p>以下规范是团队基本约定的内容，必须严格遵循。</p>
<h4 id="html规范">HTML规范</h4>
<p>基于 <a href="http://www.w3.org/">W3C</a>、<a href="https://developer.apple.com/">苹果开发者</a> 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p>
<h4 id="图片规范">图片规范</h4>
<p>了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p>
<h4 id="css规范">CSS规范</h4>
<p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p>
<h4 id="命名规范">命名规范</h4>
<p>从 <code>目录</code>、<code>图片</code>、<code>HTML/CSS文件</code>、<code>ClassName</code> 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p>
<h2 id="2-html-规范">2. HTML 规范</h2>
<h3 id="doctype-声明">DOCTYPE 声明</h3>
<p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>HTML5标准模版</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;zh-CN&quot;&gt;
  &lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;HTML5标准模版&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="页面语言lang">页面语言lang</h3>
<p>推荐使用属性值 <code>cmn-Hans-CN</code>（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 <code>zh-CN</code> 属性值</p>
<pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;
</code></pre>
<p>更多地区语言参考：</p>
<pre><code>zh-SG 中文 (简体, 新加坡)   对应 cmn-Hans-SG 普通话 (简体, 新加坡)
zh-HK 中文 (繁体, 香港)     对应 cmn-Hant-HK 普通话 (繁体, 香港)
zh-MO 中文 (繁体, 澳门)     对应 cmn-Hant-MO 普通话 (繁体, 澳门)
zh-TW 中文 (繁体, 台湾)     对应 cmn-Hant-TW 普通话 (繁体, 台湾)
</code></pre>
<h3 id="charset-字符集合">charset 字符集合</h3>
<p>一般情况下统一使用 “UTF-8” 编码</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;
</code></pre>
<p>由于历史原因，有些业务可能会使用 “GBK” 编码</p>
<pre><code>&lt;meta charset=&quot;GBK&quot;&gt;
</code></pre>
<p>请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 <a href="http://www.ietf.org/rfc/rfc3629">IETF对UTF-8的定义</a>，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。</p>
<h3 id="书写风格">书写风格</h3>
<h4 id="html代码大小写">HTML代码大小写</h4>
<p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p>
<p><em>推荐：</em></p>
<pre><code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;div class=&quot;DEMO&quot;&gt;&lt;/div&gt;
	
&lt;DIV CLASS=&quot;DEMO&quot;&gt;&lt;/DIV&gt;
</code></pre>
<h3 id="类型属性">类型属性</h3>
<p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含</p>
<p><em>推荐：</em></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt;
&lt;script src=&quot;&quot;&gt;&lt;/script&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; &gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
</code></pre>
<h3 id="元素属性">元素属性</h3>
<ul>
<li>元素属性值使用双引号语法</li>
<li>元素属性值可以写上的都写上</li>
</ul>
<p><em>推荐：</em></p>
<pre><code>&lt;input type=&quot;text&quot;&gt;
&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; &gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;input type=text&gt;	
&lt;input type='text'&gt;
&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked &gt;
</code></pre>
<h3 id="特殊字符引用">特殊字符引用</h3>
<p>文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。</p>
<p>在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</p>
<p><em>推荐：</em></p>
<pre><code>&lt;a href=&quot;#&quot;&gt;more&amp;gt;&amp;gt;&lt;/a&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;a href=&quot;#&quot;&gt;more&gt;&gt;&lt;/a&gt;
</code></pre>
<h3 id="代码缩进">代码缩进</h3>
<p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p>
<pre><code>&lt;div class=&quot;jdc&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<h3 id="代码嵌套">代码嵌套</h3>
<p>元素嵌套规范，每个块状元素独立一行，内联元素可选</p>
<p><em>推荐：</em></p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt; 
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>段落元素与标题元素只能嵌套内联元素</p>
<p><em>推荐：</em></p>
<pre><code>&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;
&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
</code></pre>
<h2 id="3-图片规范">3. 图片规范</h2>
<h3 id="内容图">内容图</h3>
<p>内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大</p>
<ul>
<li>优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式</li>
<li>尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大</li>
<li><strong>PC平台单张的图片的大小不应大于 200KB。</strong></li>
</ul>
<h3 id="背景图">背景图</h3>
<p>背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片</p>
<ul>
<li>PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率</li>
<li>图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式</li>
<li>图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式</li>
<li>图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式</li>
<li>条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式</li>
</ul>
<h2 id="4-css规范">4. CSS规范</h2>
<h3 id="代码格式化">代码格式化</h3>
<p>样式书写一般有两种：一种是紧凑格式 (Compact)</p>
<pre><code>.jdc{ display: block;width: 50px;}
</code></pre>
<p>一种是展开格式（Expanded）</p>
<pre><code>.jdc {
    display: block;
    width: 50px;
}
</code></pre>
<p><strong>团队约定</strong></p>
<p>统一使用展开格式书写样式</p>
<h3 id="代码大小写">代码大小写</h3>
<p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p>
<pre><code>/* 推荐 */
.jdc{
	display:block;
}
	
/* 不推荐 */
.JDC{
	DISPLAY:BLOCK;
}
</code></pre>
<h3 id="选择器">选择器</h3>
<ul>
<li>尽量少用通用选择器 <code>*</code></li>
<li>不使用 ID 选择器</li>
<li>不使用无具体语义定义的标签选择器</li>
</ul>
<pre><code class="language-css">/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}

/* 不推荐 */
*{}
#jdc {}
.jdc div{}
</code></pre>
<h3 id="代码缩进-2">代码缩进</h3>
<p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p>
<pre><code>.jdc {
    width: 100%;
    height: 100%;
}
</code></pre>
<h3 id="分号">分号</h3>
<p>每个属性声明末尾都要加分号；</p>
<pre><code>.jdc {
    width: 100%;
    height: 100%;
}
</code></pre>
<h3 id="代码易读性">代码易读性</h3>
<p>左括号与类名之间一个空格，冒号与属性值之间一个空格</p>
<p><em>推荐：</em></p>
<pre><code>.jdc { 
    width: 100%; 
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc{ 
    width:100%;
}
</code></pre>
<p>逗号分隔的取值，逗号之后一个空格</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc {
    box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;
}
</code></pre>
<p>为单个css选择器或新申明开启新行</p>
<p><em>推荐：</em></p>
<pre><code class="language-css">.jdc, 
.jdc_logo, 
.jdc_hd {
    color: #ff0;
}
.nav{
    color: #fff;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc,jdc_logo,.jdc_hd {
    color: #ff0;
}.nav{
    color: #fff;
}
</code></pre>
<p>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    color: rgba(255,255,255,.5);
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code>.jdc {
    color: rgba( 255, 255, 255, 0.5 );
}
</code></pre>
<p>属性值十六进制数值能用简写的尽量用简写</p>
<p><em>推荐：</em></p>
<pre><code>.jdc {
    color: #fff;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc {
    color: #ffffff;
}
</code></pre>
<p>不要为 <code>0</code> 指明单位</p>
<p><em>推荐：</em></p>
<pre><code class="language-css">.jdc {
    margin: 0 10px;
}
</code></pre>
<p><em>不推荐：</em></p>
<pre><code class="language-css">.jdc {
    margin: 0px 10px;
}
</code></pre>
<h3 id="属性值引号">属性值引号</h3>
<p>css属性值需要用到引号时，统一使用单引号</p>
<pre><code class="language-css">/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

/* 不推荐 */
.jdc { 
	font-family: &quot;Hiragino Sans GB&quot;;
}
</code></pre>
<h3 id="属性书写顺序">属性书写顺序</h3>
<p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li>
</ol>
<pre><code class="language-css">.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre>
<p><a href="https://www.mozilla.org/css/base/content.css">mozilla官方属性顺序推荐</a></p>
<h2 id="命名规范-2">命名规范</h2>
<p>由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。</p>
<h3 id="目录命名">目录命名</h3>
<ul>
<li>项目文件夹：pinyougou</li>
<li>样式文件夹：css</li>
<li>脚本文件夹：js</li>
<li>样式类图片文件夹：img</li>
<li>产品类图片文件夹： upload</li>
<li>字体类文件夹： fonts</li>
</ul>
<h3 id="classname命名">ClassName命名</h3>
<p>ClassName的命名应该尽量精短、明确，必须以<strong>字母开头命名</strong>，且<strong>全部字母为小写</strong>，单词之间<strong>统一使用下划线</strong> “_” 连接</p>
<p>.nav_top</p>
<h4 id="常用命名推荐">常用命名推荐</h4>
<p><strong>注意</strong>：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此</p>
<pre><code>&lt;div class=&quot;ad&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这种广告的英文或拼音类名不应该出现</p>
<p>另外，<strong>敏感不和谐字眼</strong>也不应该出现，如：</p>
<pre><code>&lt;div class=&quot;fuck&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;jer&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;sm&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;gcd&quot;&gt;&lt;/div&gt; 
&lt;div class=&quot;ass&quot;&gt;&lt;/div&gt; 
&lt;div class=&quot;KMT&quot;&gt;&lt;/div&gt; 
...
</code></pre>
<table>
<thead>
<tr>
<th>ClassName</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>about</td>
<td>关于</td>
</tr>
<tr>
<td>account</td>
<td>账户</td>
</tr>
<tr>
<td>arrow</td>
<td>箭头图标</td>
</tr>
<tr>
<td>article</td>
<td>文章</td>
</tr>
<tr>
<td>aside</td>
<td>边栏</td>
</tr>
<tr>
<td>audio</td>
<td>音频</td>
</tr>
<tr>
<td>avatar</td>
<td>头像</td>
</tr>
<tr>
<td>bg,background</td>
<td>背景</td>
</tr>
<tr>
<td>bar</td>
<td>栏（工具类）</td>
</tr>
<tr>
<td>branding</td>
<td>品牌化</td>
</tr>
<tr>
<td>crumb,breadcrumbs</td>
<td>面包屑</td>
</tr>
<tr>
<td>btn,button</td>
<td>按钮</td>
</tr>
<tr>
<td>caption</td>
<td>标题，说明</td>
</tr>
<tr>
<td>category</td>
<td>分类</td>
</tr>
<tr>
<td>chart</td>
<td>图表</td>
</tr>
<tr>
<td>clearfix</td>
<td>清除浮动</td>
</tr>
<tr>
<td>close</td>
<td>关闭</td>
</tr>
<tr>
<td>col,column</td>
<td>列</td>
</tr>
<tr>
<td>comment</td>
<td>评论</td>
</tr>
<tr>
<td>community</td>
<td>社区</td>
</tr>
<tr>
<td>container</td>
<td>容器</td>
</tr>
<tr>
<td>content</td>
<td>内容</td>
</tr>
<tr>
<td>copyright</td>
<td>版权</td>
</tr>
<tr>
<td>current</td>
<td>当前态，选中态</td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
</tr>
<tr>
<td>details</td>
<td>细节</td>
</tr>
<tr>
<td>disabled</td>
<td>不可用</td>
</tr>
<tr>
<td>entry</td>
<td>文章，博文</td>
</tr>
<tr>
<td>error</td>
<td>错误</td>
</tr>
<tr>
<td>even</td>
<td>偶数，常用于多行列表或表格中</td>
</tr>
<tr>
<td>fail</td>
<td>失败（提示）</td>
</tr>
<tr>
<td>feature</td>
<td>专题</td>
</tr>
<tr>
<td>fewer</td>
<td>收起</td>
</tr>
<tr>
<td>field</td>
<td>用于表单的输入区域</td>
</tr>
<tr>
<td>figure</td>
<td>图</td>
</tr>
<tr>
<td>filter</td>
<td>筛选</td>
</tr>
<tr>
<td>first</td>
<td>第一个，常用于列表中</td>
</tr>
<tr>
<td>footer</td>
<td>页脚</td>
</tr>
<tr>
<td>forum</td>
<td>论坛</td>
</tr>
<tr>
<td>gallery</td>
<td>画廊</td>
</tr>
<tr>
<td>group</td>
<td>模块，清除浮动</td>
</tr>
<tr>
<td>header</td>
<td>页头</td>
</tr>
<tr>
<td>help</td>
<td>帮助</td>
</tr>
<tr>
<td>hide</td>
<td>隐藏</td>
</tr>
<tr>
<td>hightlight</td>
<td>高亮</td>
</tr>
<tr>
<td>home</td>
<td>主页</td>
</tr>
<tr>
<td>icon</td>
<td>图标</td>
</tr>
<tr>
<td>info,information</td>
<td>信息</td>
</tr>
<tr>
<td>last</td>
<td>最后一个，常用于列表中</td>
</tr>
<tr>
<td>links</td>
<td>链接</td>
</tr>
<tr>
<td>login</td>
<td>登录</td>
</tr>
<tr>
<td>logout</td>
<td>退出</td>
</tr>
<tr>
<td>logo</td>
<td>标志</td>
</tr>
<tr>
<td>main</td>
<td>主体</td>
</tr>
<tr>
<td>menu</td>
<td>菜单</td>
</tr>
<tr>
<td>meta</td>
<td>作者、更新时间等信息栏，一般位于标题之下</td>
</tr>
<tr>
<td>module</td>
<td>模块</td>
</tr>
<tr>
<td>more</td>
<td>更多（展开）</td>
</tr>
<tr>
<td>msg,message</td>
<td>消息</td>
</tr>
<tr>
<td>nav,navigation</td>
<td>导航</td>
</tr>
<tr>
<td>next</td>
<td>下一页</td>
</tr>
<tr>
<td>nub</td>
<td>小块</td>
</tr>
<tr>
<td>odd</td>
<td>奇数，常用于多行列表或表格中</td>
</tr>
<tr>
<td>off</td>
<td>鼠标离开</td>
</tr>
<tr>
<td>on</td>
<td>鼠标移过</td>
</tr>
<tr>
<td>output</td>
<td>输出</td>
</tr>
<tr>
<td>pagination</td>
<td>分页</td>
</tr>
<tr>
<td>pop,popup</td>
<td>弹窗</td>
</tr>
<tr>
<td>preview</td>
<td>预览</td>
</tr>
<tr>
<td>previous</td>
<td>上一页</td>
</tr>
<tr>
<td>primary</td>
<td>主要</td>
</tr>
<tr>
<td>progress</td>
<td>进度条</td>
</tr>
<tr>
<td>promotion</td>
<td>促销</td>
</tr>
<tr>
<td>rcommd,recommendations</td>
<td>推荐</td>
</tr>
<tr>
<td>reg,register</td>
<td>注册</td>
</tr>
<tr>
<td>save</td>
<td>保存</td>
</tr>
<tr>
<td>search</td>
<td>搜索</td>
</tr>
<tr>
<td>secondary</td>
<td>次要</td>
</tr>
<tr>
<td>section</td>
<td>区块</td>
</tr>
<tr>
<td>selected</td>
<td>已选</td>
</tr>
<tr>
<td>share</td>
<td>分享</td>
</tr>
<tr>
<td>show</td>
<td>显示</td>
</tr>
<tr>
<td>sidebar</td>
<td>边栏，侧栏</td>
</tr>
<tr>
<td>slide</td>
<td>幻灯片，图片切换</td>
</tr>
<tr>
<td>sort</td>
<td>排序</td>
</tr>
<tr>
<td>sub</td>
<td>次级的，子级的</td>
</tr>
<tr>
<td>submit</td>
<td>提交</td>
</tr>
<tr>
<td>subscribe</td>
<td>订阅</td>
</tr>
<tr>
<td>subtitle</td>
<td>副标题</td>
</tr>
<tr>
<td>success</td>
<td>成功（提示）</td>
</tr>
<tr>
<td>summary</td>
<td>摘要</td>
</tr>
<tr>
<td>tab</td>
<td>标签页</td>
</tr>
<tr>
<td>table</td>
<td>表格</td>
</tr>
<tr>
<td>txt,text</td>
<td>文本</td>
</tr>
<tr>
<td>thumbnail</td>
<td>缩略图</td>
</tr>
<tr>
<td>time</td>
<td>时间</td>
</tr>
<tr>
<td>tips</td>
<td>提示</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>wrap</td>
<td>容器，包，一般用于最外层</td>
</tr>
<tr>
<td>wrapper</td>
<td>容器，包，一般用于最外层</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://xmweijh.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://xmweijh.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-08-23T03:09:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<p>计算机网络:是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p>
<p>计算机网络是<strong>互连的、自治</strong>的计算机集合。<br>
互连-互联互通通信链路<br>
自治-无主从关系</p>
<p>计算机网络的功能<br>
★1. 数据通信(连通性)<br>
2.资源共享    	硬件	软件	数据<br>
3.分布式处理		多台计算机各自承担同一工作任务的不同部分 Hadoop 平台<br>
4.提高可靠性		替代机<br>
5.负载均衡		各计算机之间更亲密</p>
<p>计算机网络的组成<br>
1.组成部分硬件、软件、协议(一系列规则和约定的集合)</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594777907079.png" alt="1594777907079" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594778204294.png" alt="1594778204294" loading="lazy"></figure>
<p>标准的分类-</p>
<p>法定标准		由权威机构制定的正式的、 合法的标准	OSI</p>
<p>事实标准		某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准<br>
TCP/IP</p>
<p>RFC (Request For Comments )一因特网标准的形式<br>
RFC要上升为因特网正式标准的四个阶段:<br>
1)因特网草案(Internet Draft)这个阶段还不是RFC文档。<br>
2)建议标准(Proposed Standard)从这个阶段开始成为RFC文档。<br>
3)草案标准( Draft Standard)<br>
IETF、IAB<br>
4)因特网标准( internet Standard)</p>
<p>国际标准化组织ISO	OSI参考模型、HDLC协议<br>
国际电信联盟ITU	制定通信规则<br>
国际电气电子工程师协会IEEE	学术机构、IEEE802 系列标准、5G<br>
Internet工程任务组IETF	负责因特网相关标准的制定RFC XXXX</p>
<p>速率即数据率或称数据传输率或比特率。<br>
比特1/0 位<br>
连接在计算机网络上的主机在数字信道上传送数据位数的速率。<br>
单位是b/s，kb/s, Mb/s, Gb/s， Tb/s</p>
<p>(1) “带宽&quot;原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz)。<br>
(2)计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中<br>
的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s, kb/s, Mb/s, Gb/s。<br>
网络设备所支持的最高速度</p>
<p>吞吐量	表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s，kb/s， Mb/s等。<br>
吞吐量受网络的带宽或网络的额定速率的限制。</p>
<p>时延<br>
指数据(报文/分组/比特流)从网络( 或链路)的-端传送到另一端所需的时间。也叫延迟或迟延。单位s。<br>
时延	发送时延(传输时延)	传播时延	排队时延	处理时延</p>
<p>时延带宽积=传播时延X带宽  	时延带宽积又称为以比特为单位的链路长度。即“某段链路现在有多少比特”	容量</p>
<p>往返时延RTT	从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多。<br>
RTT包括	往返传播时延=传播时延*2	末端处理时间</p>
<p>利用率			信道利用率		网络利用率</p>
<p>分层的基本原则<br>
1.各层之间相互独立，每层只实现一种相对独立的功能。<br>
2.每层之间界面自然清晰，易于理解，相互交流尽可能少。<br>
3.结构上可分割开。每层都采用最合适的技术来实现。<br>
4.保持下层对上层的独立性，上层单向使用下层提供的服务。<br>
5.整个分层结构应该能促进标准化工作。</p>
<p>1.实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。<br>
2.协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。【水平】<br>
语法:规定传输数据的格式<br>
语义:规定所要完成的功能<br>
同步:规定各种操作的顺序<br>
3.接口（访问服务点SAP）:上层使用下层服务的入口。<br>
4.服务:下层为相邻上层提供的功能调用。【垂直】</p>
<p>SDU服务数据单元:为完成用户所要求的功能而应传送的数据。<br>
PCI协议控制信息:控制协议操作的信息。<br>
PDU协议数据单元:对等层次之间传送的数据单位。</p>
<p>网络体系结构是从功能上描述计算机网络结构。<br>
计算机网络体系结构简称网络体系结构是分层结构。<br>
每层遵循某个/些网络协议以完成本层功能。<br>
计算机网络体系结构是计算机网络的各层及其协议的集合。<br>
体系结构是抽象的，而实现是指能运行的一些软件和硬件。<br>
第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。<br>
仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595040529479.png" alt="1595040529479" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121141004.png" alt="1595121141004" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595121523494.png" alt="1595121523494" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5C30701%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1595215799893.png" alt="1595215799893" loading="lazy"></figure>
<h2 id="物理层">物理层</h2>
<p>物理层接口特性<br>
物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。<br>
物理层主要任务:确定与传输媒体<strong>接口</strong>有关的一些特性	定义标准<br>
1<strong>机械特性</strong> 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目、引脚数量</strong>和排列情况。<br>
2<strong>电气特性 <strong>规定传输二进制位时，线路上信号的</strong>电压范围</strong>、阻抗匹配、传<strong>输速率和距离</strong>限制等。<br>
3<strong>功能特性</strong>  指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途。<br>
4<strong>规程待性</strong>	(过程特性）定义各条物理线路的工作规程和时序关系。</p>
<p>数据通信相关术语<br>
通信的目的是传送消息（消息:语音、文字、图像、视频等）。<br>
数据data:传送信息的实体，通常是有意义的符号序列。<br>
信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。<br>
数字信号/离散信号:代表消息的参数的取值是离散的。<br>
模拟信号/连续信号:代表消息的参数的取值是连续的。信源:产生和发送数据的源头。<br>
信宿:接收数据的终点。<br>
条发送信道和一条接收信道。<br>
信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>
<p>三种通信方式<br>
从通信双方信息的交互方式看，可以有三种基本方式:<br>
1.单工通信<br>
只有一个方向的通信而没有反方向的交互，仅需要一条信道。<br>
2.半双工通信/双向交替通信<br>
通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。<br>
3.全双工通信/双向同时通信<br>
通信双方可以同时发送和接受信息，也需要两条信道。</p>
<p>串行传输&amp;并行传输<br>
串行传输将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。速度慢，费用低，适合远距离<br>
并行传输将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离</p>
<p>同步传输&amp;异步传输</p>
<p>同步传输:在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p>
<p>。<br>
异步传输:异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位</p>
<p>码元<br>
码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。<br>
1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>
<p>数字通信系统数据传输速率的两种表示方法<br>
速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示<br>
1）码元传输速率:别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数)，单位是波特（Baud)。1波特表示数字通信系统每秒传输一个码元。</p>
<p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。</p>
<p>2）信息传输速率:别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)，单位是比特/秒(b/s)。<br>
带宽（Bandwidth）</p>
<p>1.模拟信号系统中:当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</p>
<p>2数字设备中:表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps)。</p>
<p>失真</p>
<p>影响失真程度的因素:1.码元传输速率﹐⒉信号传输距离  3.噪声干扰  4.传输媒体质量</p>
<p>码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。</p>
<p>奈氏准则（奈奎斯特定理）</p>
<p>奈氏准则:在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰,极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p>
<p>理想低通信道下的极限数据传输率=2Wlog2v (b/s)  v：几种码元/码元的离散电平数目</p>
<p>1.在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。<br>
2.信道的频带越宽（即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p>
<p>3.奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限<br>
4.由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多信息量，这就需要采用多元制的调制方法。</p>
<p>香农定理</p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即:</p>
<p>信噪比（dB） =10log10(S/N)	数值等价</p>
<p>香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<br>
信道的极限数据传输速率=Wlog2(1+S/N)	 (b/s)</p>
<p>1.信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p>
<p>2对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p>
<p>3.只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。<br>
4.香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p>
<p>基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。<strong>来自信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</p>
<p>宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)<br>
在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出基带型号）</p>
<p>数据   ------  数字信号   编码<br>
数据  ------   模拟信号   调制</p>
<p>数字数据编码为数字信号<br>
(1）非归零编码【NRZ】</p>
<p>(2）曼彻斯特编码</p>
<p>(3）差分曼彻斯特编码</p>
<p>(4）归零编码【RZ】</p>
<p>(5）反向不归零编码【NRZl】</p>
<p>(6）4B/5B编码</p>
<p>数字数据调制为模拟信号</p>
<p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<p>模拟数据编码为数字信号<br>
计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）。</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中,能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。</p>
<p>1.抽样:对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:f采样频率&gt;=2f信号最高频率<br>
⒉量化:把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p>
<p>3.编码:把量化的结果转换为与之对应的二进制编码。</p>
<p>模拟数据调制为模拟信号<br>
为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式，模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<p>数据交换方式<br>
电路交换<br>
报文交换<br>
存储转发</p>
<p>电路交换的原理:<br>
在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。</p>
<p>电路交换的阶段:<br>
建立连接（呼叫/电路建立）<br>
通信(数据传输）<br>
释放连接(拆除电路）</p>
<p>特点:独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p>
<p>电路交换优点<br>
传输时延小<br>
数据顺序传送，无失序问题<br>
实时性强，双方一旦建立物理通路，便可以实时通信，适用于交互式会话类通信。<br>
全双工通信，没有冲突，通信双方有不同的信道，不会争用物理信道<br>
适用于模拟信号和数字信号<br>
控制简单，电路的交换设备及控制较简单</p>
<p>电路交换缺点<br>
建立连接时间长<br>
线路独占，即使通信线路空闲，也不能供其他用户使用，信道使用效率低。<br>
灵活性差，双方连接通路中的任何一点除了故障，必须重新拨号建立新连接，不适应突发性通信。<br>
无数据存储能力，难以平滑通信量。<br>
电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信<br>
无法发现与纠正传输差错，难以在通信过程中进行差错控制。</p>
<p>报文:报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p>
<p>报文交换的原理:<br>
无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p>
<p>报文交换优点<br>
无需建立连接，无建立连接时延，用户可随时发送报文。<br>
动态分配线路，动态选择报文通过的最佳路径，可以平滑通信量。<br>
提高线路可靠性，某条传输路径发生故障，可重新选择另一条路径传输。<br>
提高线路利用率，通信双方在不同的时间一段一段地部分占有这条物理通道，多个报文可共享信道。<br>
提供多目标服务:一个报文可同时发往多个目的地址。<br>
在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度预同的计算机之间通行通信。</p>
<p>报文交换缺点<br>
实时性差，不适合传送实时或交互式业务的数据。数据进入交换结点后要经历存储转发过程，从而引起转发时延。<br>
只适用于数字信号。<br>
由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p>
<p>分组:大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet） 。</p>
<p>分组交换的原理:<br>
分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p>
<p>分组交换优点<br>
无建立时延，无需为通信双方预先建立一条专用通信线路，用户对随时发送分组。<br>
线路利用率高，通信双方在不同的时间一段一段地部分占有这条物理通道，多个分组可共享信道。<br>
简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>
加速传输，后一个分组的存储可以和前一个分组的转发并行操作;传输一个分组比一份报文所需缓冲区小，减少等待发送时间。<br>
减少出错几率和重发数据量，提高可靠性，减少传输时延。<br>
分组短小，适用于计算机之问突发式数据通信。</p>
<p>分组交换缺点<br>
尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>
每个分组都要加控制信息，一定程度上降低了通信效率，增加了处理的时间。<br>
当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p>1.传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。<br>
2.当端揣到揣的通路有很多段的链路组成时，采用分组交换传送数据较为合适。<br>
3.从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交<br>
换的时延小，尤其适合于计算机之间的突发式的数据通信。</p>
<p>数据报方式的特点<br>
1.数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p>
<p>无连接服务∶不事光为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<p>2.同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p>
<p>3.每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p>
<p>4.分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较太或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p>
<p>5.网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通</p>
<p>虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</p>
<p>虚电路方式的特点<br>
1.虚电路方式为网络层提供连接服务。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。</p>
<p>连接服务︰首光为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p>
<p>2.一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。</p>
<p>3.分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。<br>
4.每个节点可能与多个节点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务。</p>
<p>5.致命弱点:当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将会遭到破坏</p>
<p>传输介质及分类<br>
传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。<br>
<strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。<br>
但物理层规定了电气特性，因此能够识别所传送的比特流。<br>
导向性传输介质——1.双绞线<br>
双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP），无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。</p>
<p>同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类:5OQ同轴电缆和7sQ同轴电缆。其中，50Q同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用;75Q同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。</p>
<p>光纤主要由纤芯(实心的! )和包层构成，光波通过纤芯进行传导，包尾较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<p>光纤的特点:<br>
1.传输损耗小，中继距离长，对远距离传输特别经济。<br>
2.抗雷电和电磁干扰性能好。<br>
3.无串音干扰，保密性好，也不易被窃听或截取数据。<br>
4.体积小，重量轻。</p>
<p>非导向性传输介质<br>
无线电波:较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）。<br>
信号向所有方向传播</p>
<p>微波</p>
<p>红外线、激光</p>
<p>中继器的功能:对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（再生数字信号）</p>
<p>中继器的两端:两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。<br>
5-4-3规则:网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p>
<p>集线器（多口中继器）<br>
集线器的功能:对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。(再生，放大信号)</p>
<h2 id="数据链路层">数据链路层</h2>
<p>数据链路层功能概述</p>
<p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<p>功能一:为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p>
<p>功能二:链路管理，即连接的建立、维持、释放（用于面向连接的服务）</p>
<p>功能三:组帧。<br>
功能四:流量控制。<br>
功能五:差错控制（帧错/位错）。</p>
<p>封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。<br>
帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。<br>
组帧的四种方法:1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。</p>
<p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<p>决定局域网的主要要素为:网络拓扑，传输介质与介质访问控制方法。</p>
<p>局域网介质访问控制方法<br>
1.CSMA/CD常用于总线型局域网，也用于树型网络<br>
2令牌总线常用于总线型局域网，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。3.令牌环用于环形局域网，如令牌环网</p>
<p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD(载波监听多路访问及冲突检测）技术。</p>
<p>以太网两个标准<br>
DIX Ethernet V2:第一个局域网产品（以太网）规约。<br>
IEEE 802.3: IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动）</p>
<p>以太网提供无连接、不可靠的服务</p>
<p>以太网只实现无差错接收，不实现可靠传输</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。<br>
以太网拓扑:逻辑上总线型，物理上星型。</p>
<p>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。</p>
<p>物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。</p>
<p>采用曼彻斯特编码。</p>
<p>采用CSMA/CD介质访问控制。</p>
<p>计算机与外界有局域网的连接是通过通信适配器的。</p>
<p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符</p>
<p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准。</p>
<p>点对点协议PPP ( Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。<br>
只支持全双工链路。</p>
<p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪-一个接口，或者是把它丢弃(即过滤)。</p>
<h2 id="网络层">网络层</h2>
<p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层传输单位是数据报。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML基础]]></title>
        <id>https://xmweijh.github.io/post/html-ji-chu/</id>
        <link href="https://xmweijh.github.io/post/html-ji-chu/">
        </link>
        <updated>2020-04-30T00:53:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html">HTML</h2>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)  是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>常见状态码</strong></p>
<ul>
<li>200 ：成功。</li>
<li>400 ：客户端请求有语法错误，服务器端不能理解。</li>
<li>401 ：该请求可能未经过授权。</li>
<li>403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。</li>
<li>404 ：该资源没找到。</li>
<li>500 ：服务器端发生了一个不可预知的错误。</li>
<li>503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。</li>
</ul>
<p>HTML（超文本标记语言）是一种用于创建网页的标准标记语言。 HTML 不需要编译，可以直接由浏览器执行，它的解析依赖于浏览器的内核。 它不是一种编程语言，而是一种标记语言。</p>
<p>一个网页的基本结构：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>&lt;!DOCTYPE html&gt;是我们的文档声明头。他告诉了浏览器，本文档处理的是 HTML 文档。<code>html</code> 标签即根元素，此处表示文档的开始。<code>head</code> 标签是网页的头部，设置网页的相关信息。<code>title</code> 标签设置网页标题。<code>body</code> 标签定义文档的主体，也就是我们的主要内容。</p>
<p>在 HTML 中满足以下格式的内容即为注释，被注释的内容将不会被渲染和显示。</p>
<pre><code>&lt;!-- 在此处写注释 --&gt;
</code></pre>
<p>**注：**在开始标签中有一个惊叹号，但是结束标签中没有。浏览器不会显示注释，但是能够帮助记录。</p>
<p>HTML 标签的大小写无关的，例如 <code>和</code> 表示的意思是一样的，都代表“主体”，推荐使用小写。</p>
<p><strong>双标签（双标记）</strong></p>
<p>双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名&gt;&lt;/标记名&gt;
</code></pre>
<p>常见的双标签有：</p>
<pre><code class="language-html">&lt;html&gt;&lt;/html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;body&gt;&lt;/body&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;span&gt;&lt;/span&gt;
&lt;a&gt;&lt;/a&gt;
&lt;ul&gt;&lt;/ul&gt;
</code></pre>
<p><strong>单标签（单标记）</strong></p>
<p>单标记也称空标记，是指用一个标记符号即可完整地描述某个功能的标记。其基本语法格式如下：</p>
<pre><code>&lt;标记名/&gt;
</code></pre>
<p>常见的单标签有：</p>
<pre><code class="language-html">&lt;br /&gt;
&lt;!--换行--&gt;
&lt;hr /&gt;
&lt;!--水平分隔线--&gt;
&lt;meta /&gt;
&lt;img /&gt;
</code></pre>
<p><strong>标签的关系</strong></p>
<ul>
<li>嵌套关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;title&gt; &lt;/title&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>并列关系</li>
</ul>
<pre><code class="language-html">&lt;head&gt;&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
</code></pre>
<p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>例子：</p>
<pre><code class="language-html">&lt;p&gt;I Love You&lt;/p&gt;
</code></pre>
<p>注：这个元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 <code>，以及一个结束标签</code>。元素内容是：<code>I Love You</code>。</p>
<p><strong>h 系类标签</strong></p>
<p><code>h</code> 标签有六种 <code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>，它代表着我们的标题。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML 简介&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;我是一级标题&lt;/h1&gt;
    &lt;h2&gt;我是二级标题&lt;/h2&gt;
    &lt;h3&gt;我是三级标题&lt;/h3&gt;
    &lt;h4&gt;我是四级标题&lt;/h4&gt;
    &lt;h5&gt;我是五级标题&lt;/h5&gt;
    &lt;h6&gt;我是六级标题&lt;/h6&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>p 标签</strong></p>
<p><code>p</code> 标签是我们的文本标签。</p>
<p><strong>图片标签</strong></p>
<p>HTML 的图像是通过标签 &lt;img&gt;来定义的。</p>
<p><strong>a 标签</strong></p>
<p><a> 标签是超链接标签，意思就是我们点击它可以跳转到一个网页。</p>
<p><strong>div 标签</strong></p>
<div> 标签是一个块级元素，块级元素占据其父元素（容器）的整个空间，你可以把它想成一个盒子。 <div> 能够设置其宽高
<p><strong>换行标签和空格字符</strong></p>
<p>在浏览器显示页面时，浏览器会移除源代码中多余的空格和空行，所有连续的空格或空行都会被认为是一个空格。如果希望在不产生一个新段落的情况下换行，可以使用&lt;br/&gt;标签。如果想使用空格的话可以使用&amp;nbsp;字符</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;p&gt;这是一段文字 前面有很多空格但是只显示一个&lt;/p&gt;
  &lt;p&gt;这是一段文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用了空格字符&lt;/p&gt;
  &lt;br /&gt;
  &lt;p&gt;上面是换行符&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p><strong>水平分割线</strong></p>
<p>&lt;hr/&gt; 标签用于在 HTML 页面中创建一条水平线。</p>
<p>标签 <div> 可将网页页面分割成不同的独立部分，通常用于定义文档中的区域或节。该标签是一个块级元素，浏览器会自动在 <div> 和 </div> 所标记的区域前后自动放置一个换行符。</p>
<p>标签 <span> 通常作为文本的容器，它没有特定的含义和样式，只有与 CSS 同时使用才可以为指定文本设置样式属性。该标签是一个内联元素，他与块级元素相反，内联元素不会自动在前后自动放置换行符，因此内联元素会默认显示在同一行。</p>
<p>无序列表是一个项目的列表，此列项目使用实心圆、空心圆、方块进行标记，无序列表使用 <ul> 标签。同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 <ol> 标签。每个列表项始于 <li> 标签。</p>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>无序列表和有序列表的 type 属性：</strong></p>
<p>type 属性定义了列表项前项目符号的类型。</p>
<p>&lt;ul&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>disc（默认）</td>
<td>实心圆</td>
</tr>
<tr>
<td>circle</td>
<td>空心圆</td>
</tr>
<tr>
<td>square</td>
<td>小方块</td>
</tr>
</tbody>
</table>
<p>&lt;ol&gt;标签的 type 属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1（默认）</td>
<td>数字表示（1，2，3...)</td>
</tr>
<tr>
<td>A</td>
<td>大写字母表示（A,B,C...)</td>
</tr>
<tr>
<td>a</td>
<td>小写字母表示（a,b,c...)</td>
</tr>
<tr>
<td>I</td>
<td>大写罗马数字表示(I,II,III…)</td>
</tr>
<tr>
<td>i</td>
<td>小写罗马数字表示(i,ii,iii…)</td>
</tr>
</tbody>
</table>
<pre><code class="language-html">&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul type=&quot;circle&quot;&gt;
  &lt;li&gt;空心圆列表项1&lt;/li&gt;
  &lt;li&gt;空心圆列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol type=&quot;A&quot;&gt;
  &lt;li&gt;列表项1&lt;/li&gt;
  &lt;li&gt;列表项2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>自定义列表（dl）</strong></p>
<p>定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt;开始。自定义列表的列表项前没有任何项目符号。</p>
<p>语法格式：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;名词1&lt;/dt&gt;
  &lt;dd&gt;名词1解释1&lt;/dd&gt;
  ...
  &lt;dt&gt;名词2&lt;/dt&gt;
  &lt;dd&gt;名词2解释1&lt;/dd&gt;
  ...
&lt;/dl&gt;
</code></pre>
<p><strong>HTML 样式实例 - 背景颜色</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;background-color:red&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过 <code>&quot;background-color&quot;</code> 属性值的设置来给背景设置颜色。</p>
<p><strong>HTML 样式实例 - 字体、颜色和尺寸</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p style=&quot;font-family:arial;color:green;font-size:50px;&quot;&gt;xxx&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注：通过对 <code>font-family</code> 属性值的设置来设置字体，通过对 <code>color</code> 属性值的设置来设置颜色，通过对 <code>font-size</code> 属性值的设计来设计字体大小。</p>
<p><strong>HTML 样式实例 - 文本对齐</strong></p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1 style=&quot;text-align:center&quot;&gt;xxx&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<pre><code class="language-html">&lt;table&gt;   //&lt;table border=&quot;1&quot;&gt;给表格加上边框
  &lt;tr&gt;
    &lt;td&gt;第一行第一列&lt;/td&gt;
    &lt;td&gt;第一行第二列&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;第二行第一列&lt;/td&gt;
    &lt;td&gt;第二行第二列&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>表格一般都有标题，在 HTML 中表格标题通过 <caption> 定义。</p>
<figure data-type="image" tabindex="1"><img src="https://doc.shiyanlou.com/document-uid897174labid9222timestamp1545370661694.png/wm" alt="img" loading="lazy"></figure>
<p>表格的表头使用 <th> 标签进行定义，表头通常用于列名字。</p>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt;
  &lt;caption&gt;
    支出表
  &lt;/caption&gt;
  &lt;tr&gt;
    &lt;th&gt;支出&lt;/th&gt;
    &lt;th&gt;备注&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;32&lt;/td&gt;
    &lt;td&gt;买苹果&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;24&lt;/td&gt;
    &lt;td&gt;买饮料&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>绘制表格的时候，我们常常需要合并单元格，而在 HTML 中提供了 colspan（合并行）和 rowspan（合并列）属性来帮助我们实现这一效果。</p>
<blockquote>
<p>colspan 又称跨列，rowspan 又称跨行。</p>
</blockquote>
<p>设置 <code>rowspan=&quot;2&quot;</code> 表示合并该列上的两个单元格，同样的我们可以通过设置 <code>colspan</code> 来合并行</p>
<p>在网页中可以使用很多个 div，在网页制作中，使用 div 可以将网页中的任何元素布局到网页中的任何位置。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;div style=&quot;样式设置&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>table 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>理解比较简单。</li>
<li>不同的浏览器看到的效果一般相同。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>显示样式和数据绑定在一起。</li>
<li>布局的时候灵活度不高。</li>
<li>一个页面可能会有大量的 table 元素，代码冗余度高。</li>
<li>增加带宽。</li>
<li>搜索引擎不喜欢这样的布局。</li>
</ol>
<p>div 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>符合 W3C 标准。</li>
<li>搜索引擎更加友好。</li>
<li>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</li>
<li>节省代宽，代码冗余度低。</li>
<li>表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。</li>
</ol>
<p>&lt;form&gt;标签用于创建 HTML 表单，常见的表单格式为：</p>
<pre><code class="language-html">&lt;form name=&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;&lt;/form&gt;
</code></pre>
<ul>
<li>name：定义表单的名字。</li>
<li>method：定义表单结果从浏览器传送到服务器的方式，默认参数为：<code>get</code> 。<code>post</code> 安全性更高，因此常用作传输密码等，而 <code>get</code> 安全性较低，一般用于查询数据。</li>
<li>action：发送数据要去的地址。它的值必须是一个有效的 URL，可以是相对 URL 也可以是绝对 URL。如果没有提供此属性或者 <code>action=&quot;#&quot;</code>，则数据将被发送到包含表单的页面的 URL。</li>
</ul>
<p>在网页中最常见的表单元素就是文字字段，用户可以在文字字段内输入字符或者单行文本。 语法：</p>
<pre><code class="language-html">&lt;input
  type=&quot;text&quot;
  name=&quot;控件名称&quot;
  value=&quot;文字字段的默认取值&quot;
  size=&quot;控件的长度&quot;
  maxlength=&quot;最长字符数&quot;
/&gt;
</code></pre>
<p>该语法包含了许多参数，除了 <code>type</code> 参数以外，其他的参数都是可选的</p>
<p>举个例子：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;40&quot; value=&quot;10&quot; maxlength=&quot;3&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>密码输入框</strong></p>
<p>密码输入框是一种特殊的文字字段，他的各个属性和文字字段是相同的，但是输入进密码输入框的字符全部是“*”表示，保证周围人看不见输入的文本。</p>
<pre><code class="language-html">&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;
</code></pre>
<p><strong>单选按钮</strong></p>
<p>单选按钮可以使用户从选择列表中选择一个选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked /&gt;男&lt;br /&gt;
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; /&gt;女
&lt;/form&gt;
</code></pre>
<p>几个单选按钮可以连接在一起，只需要把它们的 <code>name</code> 值设置为相同的。同一组中只有一个按钮可以同时被选。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，且不会随表单提交。 可以尝试如果 name 不相同或者没有 name 会是什么情况。</p>
<p>复选框可以让用户从一个选项列表中选择超出一个的选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;music&quot; checked /&gt;音乐&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;art&quot; /&gt;美术&lt;br /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;math&quot; /&gt;数学&lt;br /&gt;
&lt;/form&gt;
</code></pre>
<p>复选框可以拥有自己的名字，并不需要属于一个组。</p>
<p><strong>按钮</strong><br>
HTML 表单中，有三种按钮：提交按钮，重置按钮，匿名按钮。我们可以使用 <button> 元素或者 <input> 元素来创建一个按钮。type 属性的值指定显示什么类型的按钮。</p>
<p><strong>提交按钮（submit）</strong></p>
<p>用于发送表单数据给服务器。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; value=&quot;输入的内容&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;
    This a submit button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p><strong>重置按钮（reset）</strong></p>
<p>重置按钮用来清除用户在页面中输入的信息。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;input type=&quot;text&quot; /&gt;
  &lt;button type=&quot;reset&quot;&gt;
    This a reset button
  &lt;/button&gt;

  &lt;!--or--&gt;

  &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>在文本框中输入内容，点击按钮即可清除。</p>
<p><strong>匿名按钮（button）</strong></p>
<p>没有自动生效的按钮，但是可以使用 JavaScript 代码进行定制。如果你省略了 <code>type</code> 属性，那么这就是默认值。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;button&gt;
  This a anonymous button
&lt;/button&gt;

&lt;!--or--&gt;
&lt;input type=&quot;button&quot; value=&quot;This is a anonymous button&quot; /&gt;
</code></pre>
<p>不管使用的是 <button> 元素还是 <input> 元素，按钮的行为都是一样的。它们的不同点在于：</p>
<p>从前面的例子中也可以看出 <button> 元素允许你使用 HTML 内容作为其标记内容，但 <input> 元素只接受纯文本内容。<br>
使用 <button> 元素，可以有一个不同于按钮标签的值（通过将其设置为 value 属性）。</p>
<p><strong>下拉菜单</strong></p>
<p>下拉菜单能够节省页面空间，正常状态下显示一个选项，单击展开所以选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>注意：下拉菜单的宽度是由 <option> 标记中包含的最长文本的宽度决定的。</p>
<p><strong>列表项</strong></p>
<p>在页面中列表项可以显示出几条信息，一旦超出这个信息量，在列表项右侧会出现滚动条，拖动滚动条可以看到所有选项。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  &lt;select name=&quot;select&quot; size=&quot;2&quot; multiple=&quot;multiple&quot;&gt;
    &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;
    &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt;
    &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt;
    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<p>当用户想要填入多行文本时，就应该使用文本域而不是文本字段。文本域使用 <textarea> 标记。</p>
<pre><code class="language-html">&lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt;
  留下您的联系方式：
  &lt;textarea name=&quot;textarea&quot; cols=&quot;35&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
&lt;/form&gt;
</code></pre>
<p><code>clos</code> 代表列数，<code>rows</code> 代表行数。</p>
<p><strong>图像标签</strong><br>
在 HTML 中，图像由 <img> 标签定义。语法为：</p>
<pre><code class="language-html">&lt;img src=&quot;url&quot; alt=&quot;&quot; /&gt;
</code></pre>
<p><img> 是空标签，它只包含属性，没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 的值是图像文件的 URL，也就是引用该图像的文件的的绝对路径或相对路径。alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。title 设置鼠标悬停时显示的内容（一般不用设置）。此外还可以通过设置 width 和 height 的值来设置图片的宽和高。</p>
<p><strong>框架</strong></p>
<p>使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p>
<p>语法：</p>
<pre><code class="language-html">&lt;iframe src=&quot;URL&quot;&gt;
  &lt;!-- URL指向不同的页面 --&gt;
&lt;/iframe&gt;
</code></pre>
<p><strong>iframe - 设置高度与宽度</strong></p>
<p>属性默认以像素为单位,但是你可以指定其按比例显示 (如：&quot;60%&quot;)。</p>
<p><strong>iframe - 移除边框</strong></p>
<p><code>frameborder</code> 属性用于定义 iframe 表示是否显示边框。设置属性值为 &quot;0&quot; 移除 iframe 的边框:</p>
<p>在标准 HTML5 中， <html> 和 <body> 标签是可以省略的。</p>
<p>HTML5 元素名可以使用大写和小写字母，建议使用小写字母，会显得更加好看一点，千万不要使用大小写混写，那样会显得很不专业。</p>
<p>图片通常使用 <code>alt</code> 属性。 在图片不能显示时，它能替代图片显示。建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。</p>
<p>等号的前后可以使用空格，也可以不使用，推荐少用空格。</p>
<p>不要无缘无故的添加空行，一般一个模块或一个功能添加一个空行便于区分，缩进使用两个空格，不建议使用 Tab。</p>
<p><strong>section 标签</strong></p>
<p>&lt;section&gt; 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。不要把 <section> 元素作为一个普通的 div 容器来使用。一般来说，一个 <section> 应该出现在文档大纲中。</p>
<p><strong>article 标签</strong></p>
<p>&lt;article&gt; 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。</p>
<p><strong>nav 标签</strong></p>
<p>&lt;nav&gt; 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。</p>
<p><strong>header 标签</strong></p>
<p>&lt;header&gt; 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。</p>
<p>通常 header 标签至少包含一个标题标记（h1-h6），还可以包括 hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。</p>
<p><strong>footer 标签</strong></p>
<p>&lt;footer&gt; 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。</p>
<p><strong>aside 标签</strong></p>
<p>&lt;aside&gt; 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</p>
<p><strong>datalist 元素</strong><br>
datalist 元素用于为文本框提供一个可供选择的列表，使用 datalist 元素来为表单小部件提供建议的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 <input> 元素)。</p>
<p>一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本。通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。</p>
<p><strong>autocomplete 属性</strong><br>
autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。当 autocomplete 属性值为 on 时表示启用自动完成功能，为 off 时表示关闭。autocomplete 属性适用于 <form>，以及下面的 <input> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p>
<p><strong>autofocus 属性</strong><br>
autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 <input> 标签的类型。</p>
]]></content>
    </entry>
</feed>
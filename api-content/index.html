{"posts":[{"title":"STL常见容器函数用法","content":"本文列出一些常用STL用法，一些注意点在上一篇STL中，两者搭配效果更佳☺ string #include &lt;string&gt; /* string 构造函数 string();//创建一个空的字符串 例如: string str; string(const string&amp; str);//使用一个string对象初始化另一个string对象 string(const char* s);//使用字符串s初始化 string(int n, char c);//使用n个字符c初始化 3.1.2.2 string基本赋值操作 string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串 string&amp; operator=(char c);//字符赋值给当前的字符串 string&amp; assign(const char *s);//把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串 string&amp; assign(int n, char c);//用n个字符c赋给当前字符串 string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串 */ //常见构造 string str; //默认构造 string str2(str); //拷贝构造 string str3 = str; string str4 = &quot;abcd&quot;; string str5(10, 'a'); //基本赋值 str = &quot;hello&quot;; str2 = str4; //string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串 str3.assign(&quot;abcdef&quot;, 4); //string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串 string str6; str6.assign(str, 1, 3); //ell ? hel 从0索引 /* string存取字符操作 char&amp; operator[](int n);//通过[]方式取字符 char&amp; at(int n);//通过at方法获取字符 */ string s = &quot;hello world&quot;; for (int i = 0; i &lt; s.size();i++) { //cout &lt;&lt; s[i] &lt;&lt; endl; cout &lt;&lt; s.at(i) &lt;&lt; endl; } //[] 和at区别？[]访问越界 直接挂掉 at会抛出异常 /* string拼接操作 string&amp; operator+=(const string&amp; str);//重载+=操作符 string&amp; operator+=(const char* str);//重载+=操作符 string&amp; operator+=(const char c);//重载+=操作符 string&amp; append(const char *s);//把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s);//同operator+=() string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾 string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c string查找和替换 int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s */ //拼接 string s1 = &quot;我&quot;; string s2 = &quot;爱北京&quot;; s1 += s2; cout &lt;&lt; s1 &lt;&lt; endl; s1.append(&quot;天安门&quot;); cout &lt;&lt; s1 &lt;&lt; endl; //find查找 string s = &quot;abcdefg&quot;; int pos = s.find(&quot;bcf&quot;); //找不到返回是 -1 cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; int pos2 = s.rfind(&quot;bc&quot;); //rfind 和find 结果一样，内部查找顺序相反 cout &lt;&lt; &quot;pos2 = &quot; &lt;&lt; pos2 &lt;&lt; endl; // 4 2 //替换 string s3 = &quot;hello&quot;; //替换从pos开始n个字符为字符串str s3.replace(1, 3, &quot;1111&quot;); cout &lt;&lt; s3 &lt;&lt; endl; // h1111o /* string比较操作 /* compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。 比较区分大小写，比较时参考字典顺序，排越前面的越小。 大写的A比小写的a小。 int compare(const string &amp;s) const;//与字符串s比较 int compare(const char *s) const;//与字符串s比较 */ string s1 = &quot;abc&quot;; string s2 = &quot;abcd&quot;; if (s1.compare(s2) == 0) { cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl; } else if (s1.compare(s2) == 1) { cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl; } /* string子串 string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串 */ string s1 = &quot;abcde&quot;; string s2 = s1.substr(1, 3); cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl; //需求 查找一个右键的 用户名 string email = &quot;zhangtao@sina.com&quot;; int pos = email.find(&quot;@&quot;);//8 cout &lt;&lt; &quot;pos &quot; &lt;&lt; pos &lt;&lt; endl; string usrName = email.substr(0, pos); cout &lt;&lt; &quot;用户名为：&quot; &lt;&lt; usrName &lt;&lt; endl; /* string插入和删除操作 string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 */ string s1 = &quot;hello&quot;; s1.insert(1, &quot;111&quot;); cout &lt;&lt; s1 &lt;&lt; endl; //h111ello //删除 111 s1.erase(1, 3); cout &lt;&lt; s1 &lt;&lt; endl; /* string和c-style字符串转换 */ void func(string s) { cout &lt;&lt; s &lt;&lt; endl; } void func2(const char * s) { cout &lt;&lt; s &lt;&lt; endl; } string s = &quot;abc&quot;; //string -&gt; const char * const char * p = s.c_str(); func(p); //const char * 隐式类型转换为 string //const char * -&gt; string string s2(p); //func2(s2); //string 不能隐式类型转换为 char * /* 写一个函数，函数内部将string字符串中的所有小写字母都变为大写字母。 */ string s = &quot;abCdEfg&quot;; for (int i = 0; i &lt; s.size();i++) { //s[i] = toupper(s[i]); //全变小写 s[i] = tolower(s[i]); } cout &lt;&lt; s &lt;&lt; endl; vector #include &lt;vector&gt; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++){ v.push_back(i); cout &lt;&lt; v.capacity() &lt;&lt; endl; // v.capacity()容器的容量 } /* vector构造函数 vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem);//构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec);//拷贝构造函数。 //例子 使用第二个构造函数 我们可以... int arr[] = {2,3,4,1,9}; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); vector常用赋值操作 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);//将n个elem拷贝赋值给本身。 vector&amp; operator=(const vector &amp;vec);//重载等号操作符 swap(vec);// 将vec与本身的元素互换。 vector大小操作 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。 capacity();//容器的容量 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 */ void printVector( vector&lt;int&gt;&amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test02() { vector &lt;int &gt;v; int arr[] = { 2, 3, 4, 1, 9 }; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); vector&lt;int&gt;v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt;v3(10, 100); printVector(v3); //赋值使用 vector&lt;int&gt;v4; v4.assign(v3.begin(), v3.end()); printVector(v4); v4.swap(v2); cout &lt;&lt; &quot;交换后的v4 &quot; &lt;&lt; endl; printVector(v4); cout &lt;&lt; &quot;v4容器的大小&quot; &lt;&lt; v4.size() &lt;&lt; endl; if (v4.empty()) { cout &lt;&lt; &quot;v4空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;v4不空&quot; &lt;&lt; endl; } //v4 23419 v4.resize(10,-1); //第二个参数是默认值 ，默认0 printVector(v4); v4.resize(3); printVector(v4); } //巧用swap收缩空间 void test03() { vector&lt;int&gt;v; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); } cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl; //巧用swap vector&lt;int&gt;(v).swap(v); cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl; } //reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 void test04() { vector&lt;int&gt;v; v.reserve(100000); //预留出空间 int * p = NULL; int num = 0; for (int i = 0; i &lt; 100000;i++) { v.push_back(i); if (p!=&amp;v[0]) { p = &amp;v[0]; num++; } } cout &lt;&lt; num &lt;&lt; endl; // 开辟100000数据用了多少次 } /* vector数据存取操作 at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。 operator[];//返回索引idx所指的数据，越界时，运行直接报错 front();//返回容器中第一个数据元素 back();//返回容器中最后一个数据元素 vector插入和删除操作 insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele. push_back(ele); //尾部插入元素ele pop_back();//删除最后一个元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 erase(const_iterator pos);//删除迭代器指向的元素 clear();//删除容器中所有元素 */ void test05() { vector&lt;int&gt;v; v.push_back(10); v.push_back(30); v.push_back(20); v.push_back(50); cout &lt;&lt; &quot;v的front&quot; &lt;&lt; v.front() &lt;&lt; endl; cout &lt;&lt; &quot;v的back&quot; &lt;&lt; v.back() &lt;&lt; endl; v.insert(v.begin(), 2 ,100); //参数1 迭代器 参数2 N个数 参数3 具体插入的内容 printVector(v); v.pop_back(); //尾删 printVector(v); v.erase(v.begin()); //删除 printVector(v); //v.erase(v.begin(), v.end()); //v.clear(); //清空所有数据 if (v.empty() ) { cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl; } } void test06() { //逆序遍历 vector&lt;int&gt;v; for ( int i = 0; i &lt; 10; i++) { v.push_back(i); } // printVector(v); //reverse_iterator 逆序迭代器 for (vector&lt;int&gt;::reverse_iterator it = v.rbegin(); it != v.rend();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //vector迭代器是随机访问的迭代器 支持跳跃式访问 vector&lt;int&gt;::iterator itBegin = v.begin(); itBegin = itBegin + 3; //如果上述写法不报错，这个迭代器是随机访问迭代器 list&lt;int&gt;l; for (int i = 0; i &lt; 10;i++) { l.push_back(i); } list&lt;int&gt;::iterator lIt = l.begin(); //lIt = lIt + 1; //不支持随机访问 } deque #include &lt;deque&gt; /* deque构造函数 deque&lt;T&gt; deqT;//默认构造形式 deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem);//构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq);//拷贝构造函数。 deque赋值操作 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);//将n个elem拷贝赋值给本身。 deque&amp; operator=(const deque &amp;deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换 deque大小操作 deque.size();//返回容器中元素的个数 deque.empty();//判断容器是否为空 deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。 */ void printDeque(const deque&lt;int&gt;&amp;d) { //iterator 普通迭代器 reverse_iterator 逆序迭代器 const_iterator 只读迭代器 for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end();it++) { //*it = 100000; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { deque&lt;int&gt;d; d.push_back(10); d.push_back(40); d.push_back(30); d.push_back(20); printDeque(d); deque&lt;int&gt;d2(d.begin(), d.end()); d2.push_back(10000); //交换 d.swap(d2); printDeque(d); // d2 10 40 30 20 if (d2.empty()) { cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;不为空 大小为：&quot; &lt;&lt;d2.size() &lt;&lt; endl; } } /* deque双端插入和删除操作 push_back(elem);//在容器尾部添加一个数据 push_front(elem);//在容器头部插入一个数据 pop_back();//删除容器最后一个数据 pop_front();//删除容器第一个数据 3.3.3.5 deque数据存取 at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。 operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 front();//返回第一个数据。 back();//返回最后一个数据 3.3.3.6 deque插入操作 insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 3.3.3.7 deque删除操作 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 */ void test02() { deque&lt;int&gt;d; d.push_back(10); d.push_back(30); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); // 200 100 10 30 20 //删除 头删 尾删 d.pop_back(); d.pop_front(); printDeque(d); // 100 10 30 cout &lt;&lt; &quot;front: &quot; &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; &quot;back: &quot; &lt;&lt; d.back() &lt;&lt; endl; //插入 deque&lt;int&gt;d2; d2.push_back(50); d2.push_back(60); d2.insert(d2.begin(), d.begin(), d.end()); printDeque(d2); // 100 10 30 50 60 } //排序规则 bool myCompare(int v1, int v2) { return v1 &gt; v2; // 100 10 } //排序 sort void test03() { deque&lt;int&gt;d; d.push_back(5); d.push_back(15); d.push_back(3); d.push_back(40); d.push_back(7); printDeque(d); //排序 sort(d.begin(), d.end()); printDeque(d); //从大到小 sort(d.begin(), d.end(), myCompare); printDeque(d); } stack #include &lt;stack&gt; /* stack构造函数 stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： stack(const stack &amp;stk);//拷贝构造函数 stack赋值操作 stack&amp; operator=(const stack &amp;stk);//重载等号操作符 stack数据存取操作 push(elem);//向栈顶添加元素 pop();//从栈顶移除第一个元素 top();//返回栈顶元素 stack大小操作 empty();//判断堆栈是否为空 size();//返回堆栈的大小 */ void test01() { stack&lt;int&gt;s; //放入数据 push s.push(10); s.push(30); s.push(20); s.push(40); while (s.size() != 0) { cout &lt;&lt; &quot;栈顶为 &quot; &lt;&lt; s.top() &lt;&lt; endl; //40 20 30 10 //弹出栈顶元素 s.pop(); } cout &lt;&lt; &quot;size = &quot; &lt;&lt; s.size() &lt;&lt; endl; } queue #include &lt;queue&gt; /* queue构造函数 queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式： queue(const queue &amp;que);//拷贝构造函数 queue存取、插入和删除操作 push(elem);//往队尾添加元素 pop();//从队头移除第一个元素 back();//返回最后一个元素 front();//返回第一个元素 queue赋值操作 queue&amp; operator=(const queue &amp;que);//重载等号操作符 queue大小操作 empty();//判断队列是否为空 size();//返回队列的大小 */ void test01() { queue&lt;int&gt;q; q.push(10);//往队尾添加元素 q.push(20); q.push(30); q.push(40); while (!q.empty()) { // 10 40 20 40 30 40 40 40 cout &lt;&lt; &quot;队头: &quot; &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; &quot;队尾: &quot; &lt;&lt; q.back() &lt;&lt; endl; //弹出队头元素 q.pop(); } cout &lt;&lt; &quot;size : &quot; &lt;&lt; q.size() &lt;&lt; endl; } list #include &lt;list&gt; //list是双向循环链表 void test01() { list&lt;int&gt; myList; for (int i = 0; i &lt; 10; i++){ myList.push_back(i); } list&lt;int&gt;::_Nodeptr node = myList._Myhead-&gt;_Next; for ( int i = 0; i &lt; myList._Mysize * 2; i++){ cout &lt;&lt; &quot;Node:&quot; &lt;&lt; node-&gt;_Myval &lt;&lt; endl; node = node-&gt;_Next; if (node == myList._Myhead){ node = node-&gt;_Next; } } } //list常用API /* list构造函数 list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式： list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem);//构造函数将n个elem拷贝给本身。 list(const list &amp;lst);//拷贝构造函数。 list数据元素插入和删除操作 push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 */ void printList(list&lt;int&gt;&amp;L) { for (list&lt;int&gt;::iterator it = L.begin(); it != L.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test02() { list&lt;int&gt;L(10,10); list&lt;int&gt;L2(L.begin(), L.end()); printList(L); printList(L2); L2.push_back(100); //逆序打印 for (list&lt;int&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //list迭代器不支持随机访问 list&lt;int&gt;::iterator itBegin = L2.begin(); //itBegin = itBegin + 1; //插入数据 list&lt;int&gt;L3; L3.push_back(10); L3.push_back(30); L3.push_back(20); L3.push_front(100); L3.push_front(300); L3.push_front(200); printList(L3); // 200 300 100 10 30 20 //删除两端数据 L3.pop_front(); //头删 L3.pop_back(); //尾删 printList(L3); // 300 100 10 30 L3.insert(L3.begin(), 1000); printList(L3); // 1000 300 100 10 30 //remove(elem);//删除容器中所有与elem值匹配的元素。 L3.push_back(10);// 1000 300 100 10 30 10 L3.remove(10); //参数 直接放值 printList(L3);//1000 300 100 30 } /* list大小操作 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(num);//重新指定容器的长度为num， 若容器变长，则以默认值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem);//重新指定容器的长度为num， 若容器变长，则以elem值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。 list赋值操作 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);//将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst);//重载等号操作符 swap(lst);//将lst与本身的元素互换。 list数据的存取 front();//返回第一个元素。 back();//返回最后一个元素。 */ void test03() { list&lt;int&gt;L3; L3.push_back(10); L3.push_back(30); L3.push_back(20); L3.push_front(100); L3.push_front(300); L3.push_front(200); cout &lt;&lt; &quot;大小：&quot; &lt;&lt; L3.size() &lt;&lt; endl; if (L3.empty()) { cout &lt;&lt; &quot;L3为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;L3不为空&quot; &lt;&lt; endl; } L3.resize(10); printList(L3); L3.resize(3); printList(L3); list&lt;int&gt; L4; L4.assign(L3.begin(), L3.end()); //200 300 100 cout &lt;&lt; &quot;front: &quot; &lt;&lt; L4.front() &lt;&lt; endl; cout &lt;&lt; &quot;back: &quot; &lt;&lt; L4.back() &lt;&lt; endl; } /* list反转排序 reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 sort(); //list排序 */ bool myCompare(int v1, int v2) { return v1 &gt; v2; //降序 } void test04() { list&lt;int&gt;L; L.push_back(10); L.push_back(20); L.push_back(40); L.push_back(30); L.reverse(); printList(L); // 30 40 20 10 //所有不支持随机访问的迭代器 不可以用系统提供的算法 // 如果不支持用系统提供算法，那么这个类内部会提供 //sort(L.begin(), L.end()); L.sort(); //从小到大 printList(L); //从大到小 L.sort(myCompare); printList(L); } //自定义数据类型 class Person { public: Person(string name, int age,int height) { this-&gt;m_Name = name; this-&gt;m_Age = age; this-&gt;m_Height = height; } //重载 == 让remove 可以删除自定义的person类型 bool operator==( const Person &amp; p) { if ( this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Height == p.m_Height) { return true; } return false; } string m_Name; int m_Age; int m_Height; //身高 }; //Person排序规则 如果年龄 相同 按照身高的升序排序 bool myComparePerson( Person &amp; p1,Person &amp; p2 ) { //if (p1.m_Age &gt; p2.m_Age) //{ // return true; //} //return false; if (p1.m_Age == p2.m_Age) { return p1.m_Height &lt; p2.m_Height; } else { return p1.m_Age &gt; p2.m_Age; } } void test05() { list&lt;Person&gt; L; Person p1(&quot;亚瑟&quot;, 10 , 165); Person p2(&quot;德玛西亚&quot;, 20 , 170); Person p3(&quot;火枪&quot;, 17,177); Person p4(&quot;德雷福斯&quot;, 19, 120); Person p5(&quot;MT&quot;, 18,200); Person p6(&quot;狗蛋&quot;, 18, 166); Person p7(&quot;狗剩&quot;, 18, 210); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); L.push_back(p7); //需求 打印数据时候 按照年龄的降序 输出 //对于自定义数据类型 ，必须要指定排序规则 L.sort( myComparePerson); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end();it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot;&lt;&lt; it-&gt;m_Height&lt;&lt; endl; } //删除 狗蛋 cout &lt;&lt; &quot; -------------------- &quot; &lt;&lt; endl; L.remove(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; } } set //set multiset头文件 #include &lt;set&gt; /* set构造函数 set&lt;T&gt; st;//set默认构造函数： mulitset&lt;T&gt; mst; //multiset默认构造函数: set(const set &amp;st);//拷贝构造函数 set赋值操作 set&amp; operator=(const set &amp;st);//重载等号操作符 swap(st);//交换两个集合容器 set大小操作 size();//返回容器中元素的数目 empty();//判断容器是否为空 set插入和删除操作 insert(elem);//在容器中插入元素。 clear();//清除所有元素 erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem);//删除容器中值为elem的元素。 */ void printSet( set&lt;int&gt;&amp; s) { for (set&lt;int&gt;::iterator it = s.begin(); it != s.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { set&lt;int&gt;s1; //关联式容器 key进行排序，从小到大 s1.insert(5); s1.insert(1); s1.insert(9); s1.insert(3); s1.insert(7); printSet(s1); if (s1.empty()) { cout &lt;&lt; &quot;空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; endl; } s1.erase(s1.begin()); // 3 5 7 9 printSet(s1); s1.erase(3); // 5 7 9 printSet(s1); } /* set查找操作 find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key);//查找键key的元素个数 lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 */ void test02() { set&lt;int&gt;s1; s1.insert(5); s1.insert(1); s1.insert(9); s1.insert(3); s1.insert(7); //对于set 没有value key就是value set&lt;int&gt;::iterator pos = s1.find(2); //判断是否找到 if (pos != s1.end()) { cout &lt;&lt; &quot;找到了：值为：&quot; &lt;&lt; *pos &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } //count(key);//查找键key的元素个数 set而言 结果 0或者1 int num = s1.count(2); cout &lt;&lt; &quot;2的个数为： &quot; &lt;&lt; num &lt;&lt; endl; //lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 set&lt;int&gt;::iterator it = s1.lower_bound(3); // 10就是未找到 if (it!= s1.end()) { cout &lt;&lt; &quot;找到了 lower_bound (3)的值为：&quot; &lt;&lt; *it &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } // upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 set&lt;int&gt;::iterator it2 = s1.upper_bound(3); if (it2 != s1.end()) { cout &lt;&lt; &quot;找到了 upper_bound (3)的值为：&quot; &lt;&lt; *it2 &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } //equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 //上下限 就是lower_bound upper_bound pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt; ret = s1.equal_range(3); //获取第一个值 if (ret.first != s1.end()) { cout &lt;&lt; &quot;找到equal_range中 lower_bound 的值 ：&quot; &lt;&lt; *(ret.first) &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } //获取第二个值 if (ret.second != s1.end()) { cout &lt;&lt; &quot;找到equal_range中 upper_bound 的值 ：&quot; &lt;&lt; *(ret.second) &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } } //set容器 不允许插入重复的键值 void test03() { set&lt;int&gt; s1; pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s1.insert(10); if (ret.second) { cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl; } ret = s1.insert(10); if (ret.second) { cout &lt;&lt; &quot;第二次插入成功&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;第二次插入失败&quot; &lt;&lt; endl; } printSet(s1); //multiset允许插入重复值 multiset&lt;int&gt; mul; mul.insert(10); mul.insert(10); } //指定set排序规则 从大到小 //仿函数 class myCompare { public: //重载 () bool operator()( int v1 ,int v2) { return v1 &gt; v2; } }; //set容器排序 void test04() { set&lt;int,myCompare&gt;s1; s1.insert(5); s1.insert(1); s1.insert(9); s1.insert(3); s1.insert(7); //printSet(s1); //从大到小排序 //在插入之前就指定排序规则 for (set&lt;int, myCompare&gt;::iterator it = s1.begin(); it != s1.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; class myComparePerson { public: bool operator()( const Person &amp; p1, const Person &amp; p2) { if (p1.m_Age &gt; p2.m_Age) //降序 { return true; } return false; } }; void test05() { set&lt;Person, myComparePerson&gt; s1; Person p1(&quot;大娃&quot;, 100); Person p2(&quot;二娃&quot;, 90); Person p3(&quot;六娃&quot;, 10); Person p4(&quot;爷爷&quot;, 1000); s1.insert(p1); s1.insert(p2); s1.insert(p3); s1.insert(p4); //插入自定义数据类型，上来就指定好排序规则 //显示 for (set&lt;Person, myComparePerson&gt;::iterator it = s1.begin(); it != s1.end();it++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } pair //创建对组 void test01() { //第一种 pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 100); //取值 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; endl; cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.second &lt;&lt; endl; //第二种创建 pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 200); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p2.first &lt;&lt; endl; cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl; } map #include &lt;map&gt; /* map构造函数 map&lt;T1, T2&gt; mapTT;//map默认构造函数: map(const map &amp;mp);//拷贝构造函数 map赋值操作 map&amp; operator=(const map &amp;mp);//重载等号操作符 swap(mp);//交换两个集合容器 map大小操作 size();//返回容器中元素的数目 empty();//判断容器是否为空 map插入数据元素操作 map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt; map&lt;int, string&gt; mapStu; // 第一种 通过pair的方式插入对象 mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;)); // 第二种 通过pair的方式插入对象 mapStu.inset(make_pair(-1, &quot;校长&quot;)); // 第三种 通过value_type的方式插入对象 mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;)); // 第四种 通过数组的方式插入值 mapStu[3] = &quot;小刘&quot;; mapStu[5] = &quot;小王&quot;; */ void test01() { map&lt;int, int&gt; m; //插入值 // 4种方式 //第一种 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种 推荐 m.insert(make_pair(2, 20)); //第三种 不推荐 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种 如果保证key存在 ，那么可以通过[]访问 m[4] = 40; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end();it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; m[5] &lt;&lt;endl; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } //cout &lt;&lt; m[4] &lt;&lt; endl; if ( m.empty()) { cout &lt;&lt; &quot;空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;size = &quot; &lt;&lt; m.size() &lt;&lt; endl; } } /* map删除操作 clear();//删除所有元素 erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(keyElem);//删除容器中key为keyElem的对组。 map查找操作 find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end(); count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。 lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 */ void test02() { map&lt;int, int&gt; m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(make_pair(2, 20)); m.insert(map&lt;int, int&gt;::value_type(3, 30)); m[4] = 40; m.erase(1); for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } map&lt;int,int&gt;::iterator pos = m.find(2); if (pos != m.end()) { cout &lt;&lt; &quot;找到：key&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } int num = m.count(3); //map的count 要么0 要么1 cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; // lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 map&lt;int,int&gt;::iterator ret = m.lower_bound(3); if (ret != m.end()) { cout &lt;&lt; &quot;lower_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } //upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 ret = m.upper_bound(3); if (ret != m.end()) { cout &lt;&lt; &quot;upper_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } //equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt; ret2 = m.equal_range(3); if (ret2.first != m.end()) { cout &lt;&lt; &quot;找到了equal_range 中的lower_bound 的key &quot; &lt;&lt; ret2.first-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.first-&gt;second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } if (ret2.second != m.end()) { cout &lt;&lt; &quot;找到了equal_range 中的upper_bound 的key &quot; &lt;&lt; ret2.second-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.second-&gt;second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } } //指定排序规则 class myCompare { public: bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void test03() { //从大到小排序 map&lt;int, int, myCompare&gt; m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(make_pair(2, 20)); m.insert(map&lt;int, int&gt;::value_type(3, 30)); m[4] = 40; for (map&lt;int, int, myCompare&gt;::iterator it = m.begin(); it != m.end();it++) { cout &lt;&lt; &quot;key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } } 常用算法 算法主要是由头文件 组成 是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等... 体积很小，只包括在几个序列容器上进行的简单运算的模板函数. 定义了一些模板类,用以声明函数对象。 遍历 /* 遍历算法 遍历容器元素 @param beg 开始迭代器 @param end 结束迭代器 @param _callback 函数回调或者函数对象 @return 函数对象 */ for_each(iterator beg, iterator end, _callback); /* transform算法 将指定容器区间元素搬运到另一容器中 注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存 @param beg1 源容器开始迭代器 @param end1 源容器结束迭代器 @param beg2 目标容器开始迭代器 @param _cakkback 回调函数或者函数对象 @return 返回目标容器迭代器 */ transform(iterator beg1, iterator end1, iterator beg2, _callbakc) 查找 /* find算法 查找元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return 返回查找元素的位置 */ find(iterator beg, iterator end, value) /* find_if算法 条件查找 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return bool 查找返回true 否则false */ find_if(iterator beg, iterator end, _callback); /* adjacent_find算法 查找相邻重复元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象) @return 返回相邻元素的第一个位置的迭代器 */ adjacent_find(iterator beg, iterator end, _callback); /* binary_search算法 二分查找法 注意: 在无序序列中不可用 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return bool 查找返回true 否则false */ bool binary_search(iterator beg, iterator end, value); /* count算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数 */ count(iterator beg, iterator end, value); /* count_if算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数 */ count_if(iterator beg, iterator end, _callback); 排序 /* merge算法 容器元素合并，并存储到另一容器中 注意:两个容器必须是有序的 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 */ merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* sort算法 容器元素排序 @param beg 容器1开始迭代器 @param end 容器1结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象) */ sort(iterator beg, iterator end, _callback) /* random_shuffle算法 对指定范围内的元素随机调整次序 @param beg 容器开始迭代器 @param end 容器结束迭代器 */ random_shuffle(iterator beg, iterator end) /* reverse算法 反转指定范围的元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 */ reverse(iterator beg, iterator end) 常用拷贝和替换算法 /* copy算法 将容器内指定范围的元素拷贝到另一容器中 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param dest 目标起始迭代器 */ copy(iterator beg, iterator end, iterator dest) /* replace算法 将容器内指定范围的旧元素修改为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param oldvalue 旧元素 @param oldvalue 新元素 */ replace(iterator beg, iterator end, oldvalue, newvalue) /* replace_if算法 将容器内指定范围满足条件的元素替换为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback函数回调或者谓词(返回Bool类型的函数对象) @param oldvalue 新元素 */ replace_if(iterator beg, iterator end, _callback, newvalue) /* swap算法 互换两个容器的元素 @param c1容器1 @param c2容器2 */ swap(container c1, container c2) 常用算数生成算法 /* accumulate算法 计算容器元素累计总和 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value累加值 */ accumulate(iterator beg, iterator end, value) /* fill算法 向容器中添加元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value t填充元素 */ fill(iterator beg, iterator end, value) 常用集合算法 /* set_intersection算法 求两个set集合的交集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* set_union算法 求两个set集合的并集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* set_difference算法 求两个set集合的差集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) ","link":"https://xmweijh.github.io/post/stl-chang-jian-rong-qi-han-shu-yong-fa/"},{"title":"杂记","content":"平常做题 写代码遇到的一些问题 TEST 阶乘计算升级版 本题要求实现一个打印非负整数阶乘的函数。 函数接口定义： void Print_Factorial ( const int N ); 其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出N!的值，否则打印“Invalid input”。 首先想到的方法是 void Print_Factorial ( const int N ) { long long sum = 1; if(N == 0) printf(&quot;%lld&quot;,sum); else if (N &gt;0) { int i; for(i = 1;i&lt;=N;i++) { sum = sum *i; } printf(&quot;%lld&quot;,sum); } else printf(&quot;Invalid input&quot;); } 但是 N取最大时不能正确运行。重点在与阶乘的结果很大，即便是long long int 任然不够，*long long int的范围最大为10的18次方，使用斯特林公式计算可知，n为12时，结果的位数已经为9,故N取1000一定远远超过了long long Int的范围*， 因此需要另辟蹊径。 求大数n！的位数。 根据n! = (int)log(n!)+1 方法1： log(n!) = log(123*...*n) = log1+log2+...+logn 方法2： 斯大林公式： n! = sqrt(2PIn)*(n/e)^n 两侧取对数有 log10(n!) = 1/2log(2PIn) + n*log(n/e) 利用类似乘法竖式计算的方法逐位相乘 else if(N&gt;12&amp;&amp;N&lt;=1000){ int num[3000] = {0}; num[0] = 1; int k=1; //位数 int n=0; //进位 int temp; for(int i=2 ;i&lt;=N ;i++){ for(int j=0;j&lt;k;j++){ temp = num[j]*i+n; //每一位相乘 再+进位 num[j] = temp%10; //更新每一位的数字 n = temp/10; //判断能否进位 } while(n!=0){ //如果可以进位 num[k] = n%10; //新增一位 n /=10; //继续判断能否进位 k++; } } for(int x=k-1;x&gt;=0;x--){ //输出数字 printf(&quot;%d&quot;,num[x]); } } 单链表逆转 List Reverse( List L ) { List head,next,prev; prev = NULL; head = L; while(head != NULL) { next = head-&gt;Next; head-&gt;Next = prev; prev = head; head = next; } return prev; } 链式表操作集 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ERROR NULL typedef int ElementType; typedef struct LNode *PtrToLNode; struct LNode { ElementType Data; PtrToLNode Next; }; typedef PtrToLNode Position; typedef PtrToLNode List; Position Find( List L, ElementType X ); List Insert( List L, ElementType X, Position P ); List Delete( List L, Position P ); int main() { List L; ElementType X; Position P, tmp; int N; L = NULL; scanf(&quot;%d&quot;, &amp;N); while ( N-- ) { scanf(&quot;%d&quot;, &amp;X); L = Insert(L, X, L); if ( L==ERROR ) printf(&quot;Wrong Answer\\n&quot;); } scanf(&quot;%d&quot;, &amp;N); while ( N-- ) { scanf(&quot;%d&quot;, &amp;X); P = Find(L, X); if ( P == ERROR ) printf(&quot;Finding Error: %d is not in.\\n&quot;, X); else { L = Delete(L, P); printf(&quot;%d is found and deleted.\\n&quot;, X); if ( L==ERROR ) printf(&quot;Wrong Answer or Empty List.\\n&quot;); } } L = Insert(L, X, NULL); if ( L==ERROR ) printf(&quot;Wrong Answer\\n&quot;); else printf(&quot;%d is inserted as the last element.\\n&quot;, X); P = (Position)malloc(sizeof(struct LNode)); tmp = Insert(L, X, P); if ( tmp!=ERROR ) printf(&quot;Wrong Answer\\n&quot;); tmp = Delete(L, P); if ( tmp!=ERROR ) printf(&quot;Wrong Answer\\n&quot;); for ( P=L; P; P = P-&gt;Next ) printf(&quot;%d &quot;, P-&gt;Data); return 0; } /* 你的代码将被嵌在这里 */ Position Find( List L, ElementType X ){ while(L!=NULL){ if(L-&gt;Data == X){ return L; } L = L-&gt;Next; } return ERROR; } List Insert( List L, ElementType X, Position P ){ List head = L; List p = (List)malloc(sizeof(List)); p-&gt;Data=X; p-&gt;Next=NULL; if(L==P){ p-&gt;Next=L; return p; } while(L){ if(P==L-&gt;Next){ p-&gt;Next=L-&gt;Next; L-&gt;Next=p; return head; } L=L-&gt;Next; } printf(&quot;Wrong Position for Insertion\\n&quot;); return ERROR; } List Delete( List L, Position P ){ if(L==P){ L=L-&gt;Next; return L; } List head = L; while(L){ if(L-&gt;Next==P){ L-&gt;Next=P-&gt;Next; return head; } L=L-&gt;Next; } printf(&quot;Wrong Position for Deletion\\n&quot;); return ERROR; } 带头结点的链式表操作集 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ERROR NULL typedef enum {false, true} bool; typedef int ElementType; typedef struct LNode *PtrToLNode; struct LNode { ElementType Data; PtrToLNode Next; }; typedef PtrToLNode Position; typedef PtrToLNode List; List MakeEmpty(); Position Find( List L, ElementType X ); bool Insert( List L, ElementType X, Position P ); bool Delete( List L, Position P ); int main() { List L; ElementType X; Position P; int N; bool flag; L = MakeEmpty(); scanf(&quot;%d&quot;, &amp;N); while ( N-- ) { scanf(&quot;%d&quot;, &amp;X); flag = Insert(L, X, L-&gt;Next); if ( flag==false ) printf(&quot;Wrong Answer\\n&quot;); } scanf(&quot;%d&quot;, &amp;N); while ( N-- ) { scanf(&quot;%d&quot;, &amp;X); P = Find(L, X); if ( P == ERROR ) printf(&quot;Finding Error: %d is not in.\\n&quot;, X); else { flag = Delete(L, P); printf(&quot;%d is found and deleted.\\n&quot;, X); if ( flag==false ) printf(&quot;Wrong Answer.\\n&quot;); } } flag = Insert(L, X, NULL); if ( flag==false ) printf(&quot;Wrong Answer\\n&quot;); else printf(&quot;%d is inserted as the last element.\\n&quot;, X); P = (Position)malloc(sizeof(struct LNode)); flag = Insert(L, X, P); if ( flag==true ) printf(&quot;Wrong Answer\\n&quot;); flag = Delete(L, P); if ( flag==true ) printf(&quot;Wrong Answer\\n&quot;); for ( P=L-&gt;Next; P; P = P-&gt;Next ) printf(&quot;%d &quot;, P-&gt;Data); return 0; } /* 你的代码将被嵌在这里 */ List MakeEmpty() { List L = (List)malloc(sizeof(List)); L-&gt;Next=NULL; return L; } Position Find( List L, ElementType X ) { L=L-&gt;Next; while(L) { if(L-&gt;Data==X) { return L; } L=L-&gt;Next; } return ERROR; } bool Insert( List L, ElementType X, Position P ) { List p = (List)malloc(sizeof(List)); p-&gt;Data=X; p-&gt;Next=NULL; List k=L; while(k) { if(k-&gt;Next==P) { p-&gt;Next=P; k-&gt;Next=p; return true; } k=k-&gt;Next; } printf(&quot;Wrong Position for Insertion\\n&quot;); return false; } bool Delete( List L, Position P ){ if(L==P){ L=L-&gt;Next; return true; } while(L){ if(L-&gt;Next==P){ L-&gt;Next=P-&gt;Next; return true; } L=L-&gt;Next; } printf(&quot;Wrong Position for Deletion\\n&quot;); return false; } 在一个数组中实现两个堆栈 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ERROR 1e8 typedef int ElementType; typedef enum { push, pop, end } Operation; typedef enum { false, true } bool; typedef int Position; struct SNode { ElementType *Data; Position Top1, Top2; int MaxSize; }; typedef struct SNode *Stack; Stack CreateStack( int MaxSize ); bool Push( Stack S, ElementType X, int Tag ); ElementType Pop( Stack S, int Tag ); Operation GetOp(); /* details omitted */ void PrintStack( Stack S, int Tag ); /* details omitted */ int main() { int N, Tag, X; Stack S; int done = 0; scanf(&quot;%d&quot;, &amp;N); S = CreateStack(N); while ( !done ) { switch( GetOp() ) { case push: scanf(&quot;%d %d&quot;, &amp;Tag, &amp;X); if (!Push(S, X, Tag)) printf(&quot;Stack %d is Full!\\n&quot;, Tag); break; case pop: scanf(&quot;%d&quot;, &amp;Tag); X = Pop(S, Tag); if ( X==ERROR ) printf(&quot;Stack %d is Empty!\\n&quot;, Tag); break; case end: PrintStack(S, 1); PrintStack(S, 2); done = 1; break; } } return 0; } /* 你的代码将被嵌在这里 */ Stack CreateStack(int MaxSize) { Stack stack = (Stack)malloc(sizeof(Stack)); stack-&gt;Data = (ElementType *)malloc(sizeof(ElementType)*MaxSize); stack-&gt;Top1 = -1; stack-&gt;Top2 = MaxSize; stack-&gt;MaxSize = MaxSize; return stack; } bool Push( Stack S, ElementType X, int Tag ) { if (S == NULL)return false; if (S-&gt;Top1+1==S-&gt;Top2) { printf(&quot;Stack Full\\n&quot;); return false; } if (Tag == 1) S-&gt;Data[++S-&gt;Top1] = X; else S-&gt;Data[--S-&gt;Top2] = X; return true; } ElementType Pop( Stack S, int Tag ) { if(S==NULL) return ERROR; if(Tag == 1) { if(S-&gt;Top1==-1) { printf(&quot;Stack 1 Empty\\n&quot;); return ERROR; } return S-&gt;Data[S-&gt;Top1--]; } else { if(S-&gt;Top2==S-&gt;MaxSize) { printf(&quot;Stack 2 Empty\\n&quot;); return ERROR; } return S-&gt;Data[S-&gt;Top2++]; } } 二叉树高度 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef char ElementType; typedef struct TNode *Position; typedef Position BinTree; struct TNode{ ElementType Data; BinTree Left; BinTree Right; }; BinTree CreatBinTree(); /* 实现细节忽略 */ int GetHeight( BinTree BT ); int main() { BinTree BT = CreatBinTree(); printf(&quot;%d\\n&quot;, GetHeight(BT)); return 0; } /* 你的代码将被嵌在这里 */ int GetHeight( BinTree BT ) { int hl = 0,hr = 0; if(!BT) return 0; if(BT) { hl = GetHeight(BT-&gt;Left); hr = GetHeight(BT-&gt;Right); return (hl &gt;= hr ? hl:hr) + 1; } } 二叉树的遍历 void InorderTraversal( BinTree BT )//中序遍历 { //①中序遍历其左子树；②访问根节点；③中序遍历其右子树 if(BT) { InorderTraversal(BT-&gt;Left); printf(&quot; %c&quot;,BT-&gt;Data); InorderTraversal(BT-&gt;Right); } } void PreorderTraversal( BinTree BT )//先序遍历 { //①访问根节点；②先序遍历其左子树；③先序遍历其右子树 if(BT) { printf(&quot; %c&quot;,BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right); } } void PostorderTraversal( BinTree BT )//后序遍历 { //①后序遍历其左子树；②后序遍历其右子树；③访问根节点 if(BT) { PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(&quot; %c&quot;,BT-&gt;Data); } } void LevelorderTraversal( BinTree BT )//层次遍历 { /* ①从队列中取出一个元素； ②访问该元素所指结点（出队）； ③若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。 */ if(!BT) return;//空树返回 BinTree q[100]; int head=0,rear=0; q[rear++] = BT; while(head&lt;rear) {//队列非空 if(q[head]-&gt;Left) q[rear++] = q[head]-&gt;Left; if(q[head]-&gt;Right) q[rear++] = q[head]-&gt;Right; printf(&quot; %c&quot;,q[head++]-&gt;Data); } } 二分查找 Position BinarySearch(List L,ElementType x) { int low=0,high=L-&gt;Last; while(low&lt;=high){ int mid=(low+high)/2; //这一步得记住 if(L-&gt;Data[mid]==x){ return mid; } if(L-&gt;Data[mid]&gt;x){ high=mid-1; } if(L-&gt;Data[mid]&lt;x){ low=mid+1; } } return NotFound; } 二叉搜索树 BinTree Insert( BinTree BST, ElementType X ){ // 函数Insert将X插入二叉搜索树BST并返回结果树的根结点指针； if(BST==NULL){ BST=(BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data=X; BST-&gt;Left=NULL; BST-&gt;Right=NULL; return BST; } BinTree BT=(BinTree)malloc(sizeof(struct TNode)); BT=BST; int flag=0; while(BT!=NULL){ if(X&gt;BT-&gt;Data){ if(BT-&gt;Right!=NULL){ BT=BT-&gt;Right; }else{ flag=1; break; } }else{ if(BT-&gt;Left!=NULL){ BT=BT-&gt;Left; }else{ flag=2; break; } } } if(flag==2){ BT-&gt;Left=(BinTree)malloc(sizeof(struct TNode)); BT-&gt;Left-&gt;Data=X; BT-&gt;Left-&gt;Left=NULL; BT-&gt;Left-&gt;Right=NULL; }else if(flag==1){ BT-&gt;Right=(BinTree)malloc(sizeof(struct TNode)); BT-&gt;Right-&gt;Data=X; BT-&gt;Right-&gt;Left=NULL; BT-&gt;Right-&gt;Right=NULL; } return BST; } Position Find( BinTree BST, ElementType X ){ // 函数Find在二叉搜索树BST中找到X，返回该结点的指针；如果找不到则返回空指针； while(BST!=NULL){ if(X&gt;BST-&gt;Data){ BST=BST-&gt;Right; }else if(X&lt;BST-&gt;Data){ BST=BST-&gt;Left; }else{ break; } } return BST; } BinTree Delete( BinTree BST, ElementType X ){ // 函数Delete将X从二叉搜索树BST中删除，并返回结果树的根结点指针；如果X不在树中，则打印一行Not Found并返回原树的根结点指针； if(BST==NULL){ printf(&quot;Not Found\\n&quot;); return BST; } if(BST-&gt;Data==X){ if(BST-&gt;Left!=NULL &amp;&amp; BST-&gt;Right!=NULL){ BinTree insert=(BinTree)malloc(sizeof(struct TNode)); insert=BST-&gt;Right; BinTree father=(BinTree)malloc(sizeof(struct TNode)); father=BST-&gt;Left; BST=BST-&gt;Left; while(father-&gt;Right!=NULL){ father=father-&gt;Right; } father-&gt;Right=insert; return BST; }else if(BST-&gt;Left!=NULL &amp;&amp; BST-&gt;Right==NULL){ return BST-&gt;Left; }else if(BST-&gt;Left==NULL &amp;&amp; BST-&gt;Right!=NULL){ return BST-&gt;Right; }else{ return NULL; } } int flag=0; BinTree father=(BinTree)malloc(sizeof(struct TNode)); father=BST; while(father!=NULL){ if(father-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Data==X){ flag=1; break; } if(father-&gt;Right!=NULL &amp;&amp; father-&gt;Right-&gt;Data==X){ flag=2; break; } if(father-&gt;Data&lt;X){ father=father-&gt;Right; }else{ father=father-&gt;Left; } } if(father==NULL){ printf(&quot;Not Found\\n&quot;); return BST; } if(flag==1){ if(father-&gt;Left-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Right!=NULL){ BinTree insert=(BinTree)malloc(sizeof(struct TNode)); insert=father-&gt;Left-&gt;Right; BinTree move=(BinTree)malloc(sizeof(struct TNode)); move=father-&gt;Left-&gt;Left; father-&gt;Left=move; while(move-&gt;Right!=NULL){ move=move-&gt;Right; } move-&gt;Right=insert; return BST; }else if(father-&gt;Left-&gt;Left==NULL &amp;&amp; father-&gt;Left-&gt;Right!=NULL){ father-&gt;Left=father-&gt;Left-&gt;Right; return BST; }else if(father-&gt;Left-&gt;Left!=NULL &amp;&amp; father-&gt;Left-&gt;Right==NULL){ father-&gt;Left=father-&gt;Left-&gt;Left; return BST; }else{ father-&gt;Left=NULL; return BST; } }else{ if(father-&gt;Right-&gt;Left!=NULL &amp;&amp; father-&gt;Right-&gt;Right!=NULL){ BinTree insert=(BinTree)malloc(sizeof(struct TNode)); insert=father-&gt;Right-&gt;Right; BinTree move=(BinTree)malloc(sizeof(struct TNode)); move=father-&gt;Right-&gt;Left; father-&gt;Right=move; while(move-&gt;Right!=NULL){ move=move-&gt;Right; } move-&gt;Right=insert; return BST; }else if(father-&gt;Right-&gt;Left==NULL &amp;&amp; father-&gt;Right-&gt;Right!=NULL){ father-&gt;Right=father-&gt;Right-&gt;Right; return BST; }else if(father-&gt;Right-&gt;Left!=NULL &amp;&amp; father-&gt;Right-&gt;Right==NULL){ father-&gt;Right=father-&gt;Right-&gt;Left; return BST; }else{ father-&gt;Right=NULL; return BST; } } } Position FindMin( BinTree BST ){ // 函数FindMin返回二叉搜索树BST中最小元结点的指针； if(BST==NULL){ return NULL; } while(BST-&gt;Left!=NULL){ BST=BST-&gt;Left; } return BST; } Position FindMax( BinTree BST ){ // 函数FindMax返回二叉搜索树BST中最大元结点的指针。 if(BST==NULL){ return NULL; } while(BST-&gt;Right!=NULL){ BST=BST-&gt;Right; } return BST; } 公约数公倍数 两个自然数的乘积等于这两个自然数的最大公约数和最小公倍数的乘积。公倍数辗转相除法 1不是完数完数的定义决定了。定义:某自然数除它本身以外的所有因子之和等于该数,则该数被称为完数。 输出所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。利用计数器控制 第一个直接输出，后续的加上空格 if(count==1) { printf(&quot;%d&quot;,fib(i)); } else { printf(&quot; %d&quot;,fib(i)); } 数组循环右移 注意考虑m=n,m&gt;n,m=kn(k为N)的情况. int ArrayShift( int a[], int n, int m ) { int i; if(!(m%n)){/*记住优先级单目高于双目所以 !m%n 是错的*/ return 0;//如果 m 为 n 的倍数不操作 } else if(m%n){ m%=n; } int b[MAXN]={0}; for(i=0;i&lt;m;++i){ b[m-i-1]=a[n-1-i];//先把右侧被挤出的存起来,存在数组b的相应位置,存b[0]~b[m-1]; } for(i=0;i&lt;n-m;++i){ b[i+m]=a[i];//把左侧要向右移动的存到数组b的相应位置 //若 a[i+m]=a[i];右边数组用到之前自己改变自己元素了 ,所以错了. } for(i=0;i&lt;n;++i){ a[i]=b[i];//把b里正确的顺序赋给a } } 报数 报数游戏是这样的：有n个人围成一圈，按顺序从1到n编好号。从第一个人开始报数，报到m（&lt;n）的人退出圈子；下一个人从1开始报数，报到m的人退出圈子。如此下去，直到留下最后一个人。 void CountOff( int n, int m, int out[] ){ int k,i,j=0; for(i=0;i&lt;n;i++)out[i]=0; for(i=0;i&lt;n;i++){ k=0;//k记录报数值 while(j&gt;=0){ j%=n;//j记录当前位置 if(out[j]==0)k++;//为0说明还没出去，此时k才加加 if(k==m){ out[j]=i+1; break;//报数成功，跳出while循环，进行下次报数 } j++; } } } if 是条件判断语句,当其中一个条件成立时,另外同级别的条件语句(else if)就不再去判断了，所以可以不用continue。 if-else语句中，if和else的配对原则都是在同一个复合语句括号“{}”作用域内就近配对的原则。如果不属于同一个复合语句括号“{}”作用域内，则不会被配对，此时如果配对存在问题，会报语法错误。 if(表达式1) if(表达式2) 语句1; else 语句2; else 语句3; 此题故意将格式错乱，让读者以为else if 和第一个if匹配，实则是最里面的if匹配。但不影响输出，用就近原则处理。 int main() { int x=10,a=10,b=20,ok1=5,ok2=0; if(a&lt;b) if(b!=15) if(!ok1) x=1; else if(ok2) x=10; else x=-1; printf(&quot;%d&quot;,x); return 0; } 实则为 int main() { int x=10,a=10,b=20,ok1=5,ok2=0; if(a&lt;b) if(b!=15) if(!ok1) x=1; else if(ok2) x=10; else x=-1; printf(&quot;%d&quot;,x); return 0; } 所以输出结果为-1 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 将第一个作为返回结果 不断与后面比较，每次不同时更新结果，最终找到公共前缀。 char * longestCommonPrefix(char ** strs, int strsSize){ if(strsSize == 0) return &quot;&quot;; char *ans = strs[0]; int i, j; for(i = 1; i &lt; strsSize; i++){ j = 0; for(; ans[j] != '\\0' &amp;&amp; strs[i][j] != '\\0'; j++){ if(ans[j] != strs[i][j]){ break; } } ans[j] = '\\0'; if(ans == NULL){ return &quot;&quot;; } } return ans; } 数组内存分配连续的，且从高位到低位分配 int main() { char a[4]={0}; char b[4]={0}; b[0]=1;b[1]=2;b[2]=3;b[3]=4;b[4]=5; printf(&quot;%d,%d,%d,%d&quot;,a[0],a[1],a[2],a[3]); return 0; } 所以b[4]地址为a[0]地址。 cahr* 对于 char *str = &quot;resource&quot;;* 把&quot;resource&quot;的值----也就是字符串常量字面值，也就是&quot;resource&quot;的地址，准确来说是起始地址----赋给字符指针 str，Linux下，&quot;resource&quot;字符串常量是存放于只读数据区的，一般来说，32位机器上，在Linux中，堆，全局数据，常量等都是存放于从0x8048000开始的内存地址，向上增长。可以打印一下&quot;resource&quot;的地址来进行验证。char *str = &quot;resource&quot;，就是把&quot;resource&quot;的首地址赋给str，所以str 存放的是一个只读数据区的地址，对只读区的数据进行写操作是禁止，具体由相应的操作系统进行判断以及处理。 这篇文章作了详细解释: https://www.cnblogs.com/yylqinghao/archive/2010/04/27/1721752.html 1003 我要通过！ 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 a.条件1：字符串中必须仅有 P、 A、 T 这三种字符，不可以包含其它字符； b.由条件2可得：PAT 或 A(n个)+PAT+A(n个) c.由条件3可得： a P b T c a P bA T ca A(0个)+ P+ A（1个） +T +A(0个) A(0个)+ P+ A(1个)+A(n个) +T +1个A(0个)+n个A(0个) A(n个)+ P+ A（1个）+ T +A(n个) A(n个)+ P+ A(1个)+A(n个) +T +1个A(n个)+n个A(n个) d.结论：（只能由条件1、2（原型）根据条件3（规则）推得的字符串才是YES） （1）只能有P、A、T；（2）P和T只能有一个，且中间至少一个A；（3）首项A个数*中间A个数==尾项。 #include&lt;stdio.h&gt; int main() { int n; scanf(&quot;%d\\n&quot;,&amp;n);//这里的\\n是为了下面的getchar而使用 char ch; for(int i=0;i&lt;n;i++) { int position=0,aa[3]={0}; while((ch=getchar())!='\\n')//该处理方式主要在于，通过每位读取，成功限定了 { //每位的表达，不是我们需要的表达，直接NO //是我们需要的表达，我们就记录下 if(ch=='A') aa[position]++;//每个A的位置所在 else if(ch=='P'&amp;&amp;position==0) position=1; //遇到P就转移了， else if(ch=='T'&amp;&amp;position==1) position=2; //再次遇到就break else break;//相当于ch=='P'&amp;&amp;position==1，这是不在前三个if中的 } if(ch=='\\n'&amp;&amp;position==2&amp;&amp;aa[1]&amp;&amp;aa[2]==aa[0]*aa[1])//条件的判定 printf(&quot;%s\\n&quot;,&quot;YES&quot;); else printf(&quot;%s\\n&quot;,&quot;NO&quot;); if(ch!='\\n')//若中途停止，剩下的也要读完哦！！！ while((ch=getchar())!='\\n'); } return 0; } test.cpp:8:5: error: use of undeclared identifier 'vector' #include 要加上using namespace std;才行 ","link":"https://xmweijh.github.io/post/za-ji/"},{"title":"window.onload与setInterval的作用域问题","content":"今天用js做一个黑白块小游戏时，将函数体封装到window.load中时，结果显示 //错误 Uncaught ReferenceError: start is not defined at HTMLButtonElement.onclick (index.html:15) //代码 //&lt;button class=&quot;start&quot; onclick=&quot;start()&quot;&gt; 检查后发现，点击事件在行内式声明，由于作用域的原因是读取不到onload中的start函数的 然后将点击事件封装在onload中 star.addEventListener('click', start); //点击开始游戏按钮 开始游戏 function start() { if (!flag) { init(); } else { alert('游戏已经开始，无须再次点击！'); } } 本以为解决了问题，兴致勃勃的打开浏览器。等来的却是又一个错误TAT VM28:1 Uncaught ReferenceError: move is not defined at &lt;anonymous&gt;:1:1 又是作用域的原因！结果调试发现在定时器这里出问题了 clock = window.setInterval('move()', 30); 通过查阅资料得知，setInterval这个方法是window对象的方法，window对象，window对象，window对象！！！（重要的事情说三遍,而且他前面明明这么大的window.)，没错！又是作用域的问题！也就是说这个方法是执行在全局作用域下，而我定义的方法没有在全局作用域下，肯定找不到了。 window.onload = function(){};是一个作用域i，函数调用在window.onload这个作用域的外面调用就会出错 所以再写代码的时候一定要注意作用域！ 最后乖乖的去掉了onload，将js引用在下面，果然一举成功！🐂 还有一点值得注意的是 window.onload = function () {}; // JavaScript $(document).ready(function () {}); // jQuery 二者的区别，window.onload只能用一次，第二次会覆盖第一次的执行。而$(function() {});可以多次使用 ，且只是DOM元素加载完就执行。 ","link":"https://xmweijh.github.io/post/windowonload-yu-setinterval-de-zuo-yong-yu-wen-ti/"},{"title":"JS续","content":"js续 面向过程与面向对象 面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。 面向过程与面向对象对比 面向过程 面向对象 优点 性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点 不易维护、不易复用、不易扩展 性能比面向过程低 对象与类 对象 对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 创建对象 //以下代码是对对象的复习 //字面量创建对象 var ldh = { name: '刘德华', age: 18 } console.log(ldh); //构造函数创建对象 function Star(name, age) { this.name = name; this.age = age; } var ldh = new Star('刘德华', 18)//实例化对象 console.log(ldh); 类 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象 创建类 语法: //步骤1 使用class关键字 class name { // class body } //步骤2使用定义的类创建实例 注意new关键字 var xx = new name(); 示例 // 1. 创建类 class 创建一个 明星类 class Star { // 类的共有属性放到 constructor 里面 constructor(name, age) { this.name = name; this.age = age; } } // 2. 利用类创建对象 new var ldh = new Star('刘德华', 18); console.log(ldh); 类创建添加属性和方法 // 1. 创建类 class 创建一个类 class Star { // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数 constructor(uname, age) { this.uname = uname; this.age = age; }//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号 sing(song) { console.log(this.uname + '唱' + song); } } // 2. 利用类创建对象 new var ldh = new Star('刘德华', 18); console.log(ldh); // Star {uname: &quot;刘德华&quot;, age: 18} ldh.sing('冰雨'); // 刘德华唱冰雨 注意哟: 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 类的继承 语法 // 父类 class Father{ } // 子类继承父类 class Son extends Father { } 示例 class Father { constructor(surname) { this.surname= surname; } say() { console.log('你的姓是' + this.surname); } } class Son extends Father{ // 这样子类就继承了父类的属性和方法 } var damao= new Son('刘'); damao.say(); //结果为 你的姓是刘 子类使用super关键字访问父类的方法 //定义了父类 class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } //子元素继承父类 class Son extends Father { constructor(x, y) { super(x, y); //使用super调用了父类中的构造函数 } } var son = new Son(1, 2); son.sum(); //结果为3 注意: 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用 // 父类有加法方法 class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father { constructor(x, y) { // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错 super(x, y); this.x = x; this.y = y; } subtract() { console.log(this.x - this.y); } } var son = new Son(5, 3); son.subtract(); //2 son.sum();//8 以上代码运行结果为: 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. constructor中的this指向的是new出来的实例对象 自定义的方法,一般也指向的new出来的实例对象 绑定事件之后this指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 面向对象版tab 栏切换 功能需求 点击 tab栏,可以切换效果. 点击 + 号, 可以添加 tab 项和内容项. 点击 x 号, 可以删除当前的tab项和内容项. 双击tab项文字或者内容项文字可以修改里面的文字内容 案例准备 获取到标题元素 获取到内容元素 获取到删除的小按钮 x号 新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改) 时刻注意this的指向问题 切换 为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引 this.lis[i].index = i; this.lis[i].onclick = this.toggleTab; 使用排他,实现只有一个元素的显示 toggleTab() { //将所有的标题与内容类样式全部移除 for (var i = 0; i &lt; this.lis.length; i++) { this.lis[i].className = ''; this.sections[i].className = ''; } //为当前的标题添加激活样式 this.className = 'liactive'; //为当前的内容添加激活样式 that.sections[this.index].className = 'conactive'; } 添加 为添加按钮+ 绑定点击事件 this.add.onclick = this.addTab; 实现标题与内容的添加,做好排他处理 addTab() { that.clearClass(); // (1) 创建li元素和section元素 var random = Math.random(); var li = '&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt; &lt;/span&gt;&lt;/li&gt;'; var section = '&lt;section class=&quot;conactive&quot;&gt;测试 ' + random + '&lt;/section&gt;'; // (2) 把这两个元素追加到对应的父元素里面 that.ul.insertAdjacentHTML('beforeend', li); that.fsection.insertAdjacentHTML('beforeend', section); that.init(); } 删除 为元素的删除按钮x绑定点击事件 this.remove[i].onclick = this.removeTab; 获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容 removeTab(e) { e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件 var index = this.parentNode.index; console.log(index); // 根据索引号删除对应的li 和section remove()方法可以直接删除指定的元素 that.lis[index].remove(); that.sections[index].remove(); that.init(); // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变 if (document.querySelector('.liactive')) return; // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态 index--; // 手动调用我们的点击事件 不需要鼠标触发 that.lis[index] &amp;&amp; that.lis[index].click(); } 编辑 为元素(标题与内容)绑定双击事件 this.spans[i].ondblclick = this.editTab; this.sections[i].ondblclick = this.editTab; 在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递 editTab() { var str = this.innerHTML; // 双击禁止选定文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); // alert(11); this.innerHTML = '&lt;input type=&quot;text&quot; /&gt;'; var input = this.children[0]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 // 当我们离开文本框就把文本框里面的值给span input.onblur = function() { this.parentNode.innerHTML = this.value; }; // 按下回车也可以把文本框里面的值给span input.onkeyup = function(e) { if (e.keyCode === 13) { // 手动调用表单失去焦点事件 不需要鼠标离开操作 this.blur(); } } } 构造函数和原型 对象的三种创建方式 字面量方式 var obj = {}; new关键字 var obj = new Object(); 构造函数方式 function Person(name,age){ this.name = name; this.age = age; } var obj = new Person('zs',12); 静态成员和实例成员 实例成员 实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log('我会唱歌'); } } var ldh = new Star('刘德华', 18); console.log(ldh.uname);//实例成员只能通过实例化的对象来访问 静态成员 静态成员 在构造函数本身上添加的成员 如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log('我会唱歌'); } } Star.sex = '男'; var ldh = new Star('刘德华', 18); console.log(Star.sex);//静态成员只能通过构造函数来访问 构造函数的问题 构造函数方法很好用，但是存在浪费内存的问题。 构造函数原型prototype 构造函数通过原型分配的函数是所有对象所共享的。 JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log('我会唱歌'); } var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); ldh.sing();//我会唱歌 zxy.sing();//我会唱歌 对象原型 对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。 __proto__对象原型和原型对象 prototype 是等价的 __proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype constructor构造函数 对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。 constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。 一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如: function Star(uname, age) { this.uname = uname; this.age = age; } // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, // 手动设置指回原来的构造函数 sing: function() { console.log('我会唱歌'); }, movie: function() { console.log('我会演电影'); } } var zxy = new Star('张学友', 19); console.log(zxy) 原型链 ​ 每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。 构造函数实例和原型对象三角关系 1.构造函数的prototype属性指向了构造函数原型对象 2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象 3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数 原型链和成员的查找机制 任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链; 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。 如果还没有就查找原型对象的原型（Object的原型对象）。 依此类推一直找到 Object 为止（null）。 __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 原型对象中this指向 构造函数中的this和原型对象的this,都指向我们new出来的实例对象 function Star(uname, age) { this.uname = uname; this.age = age; } var that; Star.prototype.sing = function() { console.log('我会唱歌'); that = this; } var ldh = new Star('刘德华', 18); // 1. 在构造函数中,里面this指向的是对象实例 ldh console.log(that === ldh);//true // 2.原型对象函数里面的this 指向的是 实例对象 ldh 通过原型为数组扩展内置方法 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum; }; //此时数组对象中已经存在sum()方法了 可以始终 数组.sum()进行数据的求 继承 call() call()可以调用函数 call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接 function fn(x, y) { console.log(this); console.log(x + y); } var o = { name: 'andy' }; fn.call(o, 1, 2);//调用了函数此时的this指向了对象o, 子构造函数继承父构造函数中的属性 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) // 1. 父构造函数 function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 3.使用call方式实现子继承父的属性 Father.call(this, uname, age); this.score = score; } var son = new Son('刘德华', 18, 100); console.log(son); 借用原型对象继承方法 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) // 1. 父构造函数 function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } Father.prototype.money = function() { console.log(100000); }; // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; } // Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log('孩子要考试'); } var son = new Son('刘德华', 18, 100); console.log(son); ES5新增方法 数组方法forEach遍历数组 arr.forEach(function(value, index, array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 }) //相当于数组遍历的 for循环 没有返回值 数组方法filter过滤数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &gt;= 20; }); console.log(newArr);//[66,88] //返回值是一个新数组 数组方法some some 查找数组中是否有满足条件的元素 var arr = [10, 30, 4]; var flag = arr.some(function(value,index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &lt; 3; }); console.log(flag);//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环 筛选商品案例 定义数组对象数据 var data = [{ id: 1, pname: '小米', price: 3999 }, { id: 2, pname: 'oppo', price: 999 }, { id: 3, pname: '荣耀', price: 1299 }, { id: 4, pname: '华为', price: 1999 }, ]; 使用forEach遍历数据并渲染到页面中 data.forEach(function(value) { var tr = document.createElement('tr'); tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;'; tbody.appendChild(tr); }); 根据价格筛选数据 获取到搜索按钮并为其绑定点击事件 search_price.addEventListener('click', function() { }); 使用filter将用户输入的价格信息筛选出来 search_price.addEventListener('click', function() { var newDate = data.filter(function(value) { //start.value是开始区间 //end.value是结束的区间 return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; }); console.log(newDate); }); 将筛选出来的数据重新渲染到表格中 将渲染数据的逻辑封装到一个函数中 function setDate(mydata) { // 先清空原来tbody 里面的数据 tbody.innerHTML = ''; mydata.forEach(function(value) { var tr = document.createElement('tr'); tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;'; tbody.appendChild(tr); }); } 将筛选之后的数据重新渲染 search_price.addEventListener('click', function() { var newDate = data.filter(function(value) { return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; }); console.log(newDate); // 把筛选完之后的对象渲染到页面中 setDate(newDate); }); 根据商品名称筛选 获取用户输入的商品名称 为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选 search_pro.addEventListener('click', function() { var arr = []; data.some(function(value) { if (value.pname === product.value) { // console.log(value); arr.push(value); return true; // return 后面必须写true } }); // 把拿到的数据渲染到页面中 setDate(arr); }) some和forEach区别 如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高 在forEach 里面 return 不会终止迭代 trim方法去除字符串两端的空格 var str = ' hello ' console.log(str.trim()） //hello 去除两端空格 var str1 = ' he l l o ' console.log(str.trim()） //he l l o 去除两端空格 获取对象的属性名 Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组 var obj = { id: 1, pname: '小米', price: 1999, num: 2000 }; var result = Object.keys(obj) console.log(result)//[id，pname,price,num] Object.defineProperty Object.defineProperty设置或修改对象中的属性 Object.defineProperty(对象，修改或新增的属性名，{ value:修改或新增的属性的值, writable:true/false,//如果值为false 不允许修改这个属性值 enumerable: false,//enumerable 如果值为false 则不允许遍历 configurable: false //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性 }) 函数的定义和调用 函数的定义方式 方式1 函数声明方式 function 关键字 (命名函数) function fn(){} 方式2 函数表达式(匿名函数) var fn = function(){} 方式3 new Function() var f = new Function('a', 'b', 'console.log(a + b)'); f(1, 2); var fn = new Function('参数1','参数2'..., '函数体') 注意 /*Function 里面参数都必须是字符串格式 第三种方式执行效率低，也不方便书写，因此较少使用 所有函数都是 Function 的实例(对象) 函数也属于对象 */ 函数的调用 /* 1. 普通函数 */ function fn() { console.log('人生的巅峰'); } fn(); /* 2. 对象的方法 */ var o = { sayHi: function() { console.log('人生的巅峰'); } } o.sayHi(); /* 3. 构造函数*/ function Star() {}; new Star(); /* 4. 绑定事件函数*/ btn.onclick = function() {}; // 点击了按钮就可以调用这个函数 /* 5. 定时器函数*/ setInterval(function() {}, 1000); 这个函数是定时器自动1秒钟调用一次 /* 6. 立即执行函数(自调用函数)*/ (function() { console.log('人生的巅峰'); })(); this 函数内部的this指向 这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同 一般指向我们的调用者. ![](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/04-JavaScript高级资料/JavaScript 高级_day03/4-笔记/images/img1.png) 改变函数内部 this 指向 call方法 call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向 应用场景: 经常做继承. var o = { name: 'andy' } function fn(a, b) { console.log(this); console.log(a+b) }; fn(1,2)// 此时的this指向的是window 运行结果为3 fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3 apply方法 apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 应用场景: 经常跟数组有关系 var o = { name: 'andy' } function fn(a, b) { console.log(this); console.log(a+b) }; fn()// 此时的this指向的是window 运行结果为3 fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3 bind方法 bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind 应用场景:不调用函数,但是还想改变this指向 var o = { name: 'andy' }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数 f();//调用新函数 this指向的是对象o 参数使用逗号隔开 call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向. 应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 严格模式 什么是严格模式 JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。 严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。 严格模式对正常的 JavaScript 语义做了一些更改： 1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。 2.消除代码运行的一些不安全之处，保证代码运行的安全。 3.提高编译器效率，增加运行速度。 4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名 开启严格模式 严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 情况一 :为脚本开启严格模式 有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。 (function (){ //在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式 &quot;use strict&quot;; var num = 10; function fn() {} })(); //或者 &lt;script&gt; &quot;use strict&quot;; //当前script标签开启了严格模式 &lt;/script&gt; &lt;script&gt; //当前script标签未开启严格模式 &lt;/script&gt; 情况二: 为函数开启严格模式 要给某个函数开启严格模式，需要把“use strict”; (或 'use strict'; ) 声明放在函数体所有语句之前。 function fn(){ &quot;use strict&quot;; return &quot;123&quot;; } //当前fn函数开启了严格模式 严格模式中的变化 严格模式对 Javascript 的语法和行为，都做了一些改变。 'use strict' num = 10 console.log(num)//严格模式后使用未声明的变量 -------------------------------------------------------------------------------- var num2 = 1; delete num2;//严格模式不允许删除变量 -------------------------------------------------------------------------------- function fn() { console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined } fn(); --------------------------------------------------------------------------------- function Star() { this.sex = '男'; } // Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错. var ldh = new Star(); console.log(ldh.sex); ---------------------------------------------------------------------------------- setTimeout(function() { console.log(this); //严格模式下，定时器 this 还是指向 window }, 2000); 更多严格模式要求参考 高阶函数 高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。 同理函数也可以作为返回值传递回来 闭包 变量的作用域复习 变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以使用全局变量。 函数外部不可以使用局部变量。 当函数执行完毕，本作用域内的局部变量会销毁。 什么是闭包 闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 闭包的作用 作用：延伸变量的作用范围。 function fn() { var num = 10; function fun() { console.log(num); } return fun; } var f = fn(); f(); 闭包的案例 利用闭包的方式得到当前li 的索引号 for (var i = 0; i &lt; lis.length; i++) { // 利用for循环创建了4个立即执行函数 // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量 (function(i) { lis[i].onclick = function() { console.log(i); } })(i); } 闭包应用-3秒钟之后,打印所有li元素的内容 for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i); } 闭包应用-计算打车价格 /*需求分析 打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格 如果有拥堵情况,总价格多收取10块钱拥堵费*/ var car = (function() { var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return { // 正常的总价 price: function(n) { if (n &lt;= 3) { total = start; } else { total = start + (n - 3) * 5 } return total; }, // 拥堵之后的费用 yd: function(flag) { return flag ? total + 10 : total; } } })(); console.log(car.price(5)); // 23 console.log(car.yd(true)); // 33 案例 var name = &quot;The Window&quot;; var object = { name: &quot;My Object&quot;, getNameFunc: function() { return function() { return this.name; }; } }; console.log(object.getNameFunc()()) ----------------------------------------------------------------------------------- var name = &quot;The Window&quot;; var object = { name: &quot;My Object&quot;, getNameFunc: function() { var that = this; return function() { return that.name; }; } }; console.log(object.getNameFunc()()) 递归 什么是递归 **递归：**如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数 **注意：**递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。 利用递归求1~n的阶乘 //利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n function fn(n) { if (n == 1) { //结束条件 return 1; } return n * fn(n - 1); } console.log(fn(3)); 利用递归求斐波那契数列 // 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21... // 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值 // 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值 function fb(n) { if (n === 1 || n === 2) { return 1; } return fb(n - 1) + fb(n - 2); } console.log(fb(3)); 利用递归遍历数据 // 我们想要做输入id号,就可以返回的数据对象 var data = [{ id: 1, name: '家电', goods: [{ id: 11, gname: '冰箱', goods: [{ id: 111, gname: '海尔' }, { id: 112, gname: '美的' }, ] }, { id: 12, gname: '洗衣机' }] }, { id: 2, name: '服饰' }]; //1.利用 forEach 去遍历里面的每一个对象 function getID(json, id) { var o = {}; json.forEach(function(item) { // console.log(item); // 2个数组元素 if (item.id == id) { // console.log(item); o = item; return o; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 } else if (item.goods &amp;&amp; item.goods.length &gt; 0) { o = getID(item.goods, id); } }); return o; } 正则表达式概述 什么是正则表达式 正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。 正则表达式的特点 灵活性、逻辑性和功能性非常的强。 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。比如：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: /[1]{3,16}$/ 正则表达式在js中的使用 正则表达式的创建 在 JavaScript 中，可以通过两种方式创建一个正则表达式。 方式一：通过调用RegExp对象的构造函数创建 var regexp = new RegExp(/123/); console.log(regexp); 方式二：利用字面量创建 正则表达式 var rg = /123/; 测试正则表达式 test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。 var rg = /123/; console.log(rg.test(123));//匹配字符中是否出现123 出现结果为true console.log(rg.test('abc'));//匹配字符中是否出现123 未出现结果为false 正则表达式中的特殊字符 正则表达式的组成 一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。 特殊字符非常多，可以参考： MDN jQuery 手册：正则表达式部分 [正则测试工具]( &lt;http://tool.oschina.net/regex) 边界符 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） 如果 ^和 $ 在一起，表示必须是精确匹配。 var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型 // /abc/ 只要包含有abc这个字符串返回的都是true console.log(rg.test('abc')); console.log(rg.test('abcd')); console.log(rg.test('aabcd')); console.log('---------------------------'); var reg = /^abc/; console.log(reg.test('abc')); // true console.log(reg.test('abcd')); // true console.log(reg.test('aabcd')); // false console.log('---------------------------'); var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范 console.log(reg1.test('abc')); // true console.log(reg1.test('abcd')); // false console.log(reg1.test('aabcd')); // false console.log(reg1.test('abcabc')); // false 字符类 字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。 [] 方括号 表示有一系列字符可供选择，只要匹配其中一个就可以了 var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true console.log(rg.test('andy'));//true console.log(rg.test('baby'));//true console.log(rg.test('color'));//true console.log(rg.test('red'));//false var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 true console.log(rg1.test('aa'));//false console.log(rg1.test('a'));//true console.log(rg1.test('b'));//true console.log(rg1.test('c'));//true console.log(rg1.test('abc'));//true ---------------------------------------------------------------------------------- var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test('a'));//true console.log(reg.test('z'));//true console.log(reg.test('A'));//false ----------------------------------------------------------------------------------- //字符组合 var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true ------------------------------------------------------------------------------------ //取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。 var reg2 = /^[^a-zA-Z0-9]$/; console.log(reg2.test('a'));//false console.log(reg2.test('B'));//false console.log(reg2.test(8));//false console.log(reg2.test('!'));//true 量词符 量词符用来设定某个模式出现的次数。 量词 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 用户名表单验证 功能需求: 如果用户名输入合法, 则后面提示信息为: 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为红色 分析: 用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位. 首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/ 当表单失去焦点就开始验证. 如果符合正则规范, 则让后面的span标签添加 right类. 如果不符合正则规范, 则让后面的span标签添加 wrong类. &lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; &lt;span&gt;请输入用户名&lt;/span&gt; &lt;script&gt; // 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]{6,16}$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线 var uname = document.querySelector('.uname'); var span = document.querySelector('span'); uname.onblur = function() { if (reg.test(this.value)) { console.log('正确的'); span.className = 'right'; span.innerHTML = '用户名格式输入正确'; } else { console.log('错误的'); span.className = 'wrong'; span.innerHTML = '用户名格式输入不正确'; } } &lt;/script&gt; 括号总结 1.大括号 量词符. 里面表示重复次数 2.中括号 字符集合。匹配方括号中的任意字符. 3.小括号表示优先级 正则表达式在线测试 预定义类 预定义类指的是某些常见模式的简写方式. 验证座机号码 var reg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/; var reg = /^\\d{3,4}-\\d{7,8}$/; 表单验证案例 //手机号验证:/^1[3|4|5|7|8][0-9]{9}$/; //验证通过与不通过更换元素的类名与元素中的内容 if (reg.test(this.value)) { // console.log('正确的'); this.nextElementSibling.className = 'success'; this.nextElementSibling.innerHTML = '&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确'; } else { // console.log('不正确'); this.nextElementSibling.className = 'error'; this.nextElementSibling.innerHTML = '&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt;格式不正确,请从新输入 '; } //QQ号验证: /^[1-9]\\d{4,}$/; //昵称验证:/^[\\u4e00-\\u9fa5]{2,8}$/ //验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可 function regexp(ele, reg) { ele.onblur = function() { if (reg.test(this.value)) { // console.log('正确的'); this.nextElementSibling.className = 'success'; this.nextElementSibling.innerHTML = '&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确'; } else { // console.log('不正确'); this.nextElementSibling.className = 'error'; this.nextElementSibling.innerHTML = '&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确,请从新输入 '; } } }; //密码验证:/^[a-zA-Z0-9_-]{6,16}$/ //再次输入密码只需匹配与上次输入的密码值 是否一致 正则替换replace replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。 var str = 'andy和red'; var newStr = str.replace('andy', 'baby'); console.log(newStr)//baby和red //等同于 此处的andy可以写在正则表达式内 var newStr2 = str.replace(/andy/, 'baby'); console.log(newStr2)//baby和red //全部替换 var str = 'abcabc' var nStr = str.replace(/a/,'哈哈') console.log(nStr) //哈哈bcabc //全部替换g var nStr = str.replace(/a/a,'哈哈') console.log(nStr) //哈哈bc哈哈bc //忽略大小写i var str = 'aAbcAba'; var newStr = str.replace(/a/gi,'哈哈')//&quot;哈哈哈哈bc哈哈b哈哈&quot; 过滤敏感词汇 &lt;textarea name=&quot;&quot; id=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() { div.innerHTML = text.value.replace(/激情|gay/g, '**'); } &lt;/script&gt; ES6语法 目标 能够说出使用let关键字声明变量的特点 能够使用解构赋值从数组中提取值 能够说出箭头函数拥有的特性 能够使用剩余参数接收剩余的函数参数 能够使用拓展运算符拆分数组 能够说出模板字符串拥有的特性 ES6相关概念（★★） 什么是ES6 ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。 为什么使用 ES6 ? 每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 变量提升特性增加了程序运行时的不可预测性 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码 ES6新增语法 let（★★★） ES6中新增了用于声明变量的关键字 let声明的变量只在所处于的块级有效 if (true) { let a = 10; } console.log(a) // a is not defined **注意：**使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。 不存在变量提升 console.log(a); // a is not defined let a = 20; 暂时性死区 利用let声明的变量会绑定在这个块级作用域，不会受外界的影响 var tmp = 123; if (true) { tmp = 'abc'; let tmp; } 经典面试题 var arr = []; for (var i = 0; i &lt; 2; i++) { arr[i] = function () { console.log(i); } } arr[0](); arr[1](); **经典面试题图解：**此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。 let arr = []; for (let i = 0; i &lt; 2; i++) { arr[i] = function () { console.log(i); } } arr[0](); arr[1](); 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值. 小结 let关键字就是用来声明变量的 使用let关键字声明的变量具有块级作用域 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的 防止循环变量变成全局变量 使用let关键字声明的变量没有变量提升 使用let关键字声明的变量具有暂时性死区特性 const（★★★） 声明常量，常量就是值（内存地址）不能变化的量 具有块级作用域 if (true) { const a = 10; } console.log(a) // a is not defined 声明常量时必须赋值 const PI; // Missing initializer in const declaration 常量赋值后，值不能修改 const PI = 3.14; PI = 100; // Assignment to constant variable. const ary = [100, 200]; ary[0] = 'a'; ary[1] = 'b'; console.log(ary); // ['a', 'b']; ary = ['a', 'b']; // Assignment to constant variable. 小结 const声明的变量是一个常量 既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值 声明 const时候必须要给定值 let、const、var 的区别 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值 解构赋值（★★★） ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构 数组解构 let [a, b, c] = [1, 2, 3]; console.log(a)//1 console.log(b)//2 console.log(c)//3 //如果解构不成功，变量的值为undefined 对象解构 let person = { name: 'zhangsan', age: 20 }; let { name, age } = person; console.log(name); // 'zhangsan' console.log(age); // 20 let {name: myName, age: myAge} = person; // myName myAge 属于别名 console.log(myName); // 'zhangsan' console.log(myAge); // 20 小结 解构赋值就是把数据结构分解，然后给变量进行赋值 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined 数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开 利用解构赋值能够让我们方便的去取对象中的属性跟方法 箭头函数（★★★） ES6中新增的定义函数的方式。 () =&gt; {} //()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；{}：函数体 const fn = () =&gt; {}//代表把一个函数赋值给fn 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号 function sum(num1, num2) { return num1 + num2; } //es6写法 const sum = (num1, num2) =&gt; num1 + num2; 如果形参只有一个，可以省略小括号 function fn (v) { return v; } //es6写法 const fn = v =&gt; v; 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this const obj = { name: '张三'} function fn () { console.log(this);//this 指向 是obj对象 return () =&gt; { console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象 } } const resFn = fn.call(obj); resFn(); 小结 箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁 箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题 面试题 var age = 100; var obj = { age: 20, say: () =&gt; { alert(this.age) } } obj.say();//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域 剩余参数（★★） 剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数 function sum (first, ...args) { console.log(first); // 10 console.log(args); // [20, 30] } sum(10, 20, 30) 剩余参数和解构配合使用 let students = ['wangwu', 'zhangsan', 'lisi']; let [s1, ...s2] = students; console.log(s1); // 'wangwu' console.log(s2); // ['zhangsan', 'lisi'] ES6 的内置对象扩展 Array 的扩展方法（★★） 扩展运算符（展开语法） 扩展运算符可以将数组或者对象转为用逗号分隔的参数序列 let ary = [1, 2, 3]; ...ary // 1, 2, 3 console.log(...ary); // 1 2 3,相当于下面的代码 console.log(1,2,3); 扩展运算符可以应用于合并数组 // 方法一 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二 ary1.push(...ary2); 将类数组或可遍历对象转换为真正的数组 let oDivs = document.getElementsByTagName('div'); oDivs = [...oDivs]; 构造函数方法：Array.from() 将伪数组或可遍历对象转换为真正的数组 //定义一个集合 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; //转成数组 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组 let arrayLike = { &quot;0&quot;: 1, &quot;1&quot;: 2, &quot;length&quot;: 2 } let newAry = Array.from(arrayLike, item =&gt; item *2)//[2,4] 注意：如果是对象，那么属性需要写对应的索引 实例方法：find() 用于找出第一个符合条件的数组成员，如果没有找到返回undefined let ary = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]; let target = ary.find((item, index) =&gt; item.id == 2);//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个 实例方法：findIndex() 用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1 let ary = [1, 5, 10, 15]; let index = ary.findIndex((value, index) =&gt; value &gt; 9); console.log(index); // 2 实例方法：includes() 判断某个数组是否包含给定的值，返回布尔值。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false String 的扩展方法 模板字符串（★★★） ES6新增的创建字符串的方式，使用反引号定义 let name = `zhangsan`; 模板字符串中可以解析变量 let name = '张三'; let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan 模板字符串中可以换行 let result = { name: 'zhangsan', age: 20, sex: '男' } let html = ` &lt;div&gt; &lt;span&gt;${result.name}&lt;/span&gt; &lt;span&gt;${result.age}&lt;/span&gt; &lt;span&gt;${result.sex}&lt;/span&gt; &lt;/div&gt; `; 在模板字符串中可以调用函数 const sayHello = function () { return '哈哈哈哈 追不到我吧 我就是这么强大'; }; let greet = `${sayHello()} 哈哈哈哈`; console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈 实例方法：startsWith() 和 endsWith() startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 let str = 'Hello world!'; str.startsWith('Hello') // true str.endsWith('!') // true 实例方法：repeat() repeat方法表示将原字符串重复n次，返回一个新字符串 'x'.repeat(3) // &quot;xxx&quot; 'hello'.repeat(2) // &quot;hellohello&quot; Set 数据结构（★★） ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构 const s = new Set(); Set函数可以接受一个数组作为参数，用来初始化。 const set = new Set([1, 2, 3, 4, 4]);//{1, 2, 3, 4} 实例方法 add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值 s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 返回布尔值 s.clear() // 清除 set 结构中的所有值 //注意：删除的是元素的值，不是代表的索引 遍历 Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 s.forEach(value =&gt; console.log(value)) a-z0-9_- ↩︎ ","link":"https://xmweijh.github.io/post/js-xu/"},{"title":"jQuerry","content":"jQuery jQuery 介绍 JavaScript 库 ​ JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 ​ 常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。 jQuery的概念 ​ jQuery总体概况如下 : jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 jQuery的优点 轻量级。核心文件才几十kb，不会影响页面加载速度。 跨浏览器兼容，基本兼容了现在主流的浏览器。 链式编程、隐式迭代。 对事件、样式、动画支持，大大简化了DOM操作。 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。 免费、开源。 jQuery 的基本使用 jQuery 的下载 ​ jQuery的官网地址： https://jquery.com/，官网即可下载最新版本。 各个版本的下载：https://code.jquery.com/ ​ 版本介绍： 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本 体验jQuery ​ 步骤： 引入jQuery文件。 在文档最末尾插入 script 标签，书写体验代码。 $('div').hide() 可以隐藏盒子。 jQuery的入口函数 ​ jQuery中常见的两种入口函数： // 第一种: 简单易用。 $(function () { ... // 此处是页面 DOM 加载完成的入口 }) ; // 第二种: 繁琐，但是也可以实现 $(document).ready(function(){ ... // 此处是页面DOM加载完成的入口 }); ​ 总结： 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。 相当于原生 js 中的 DOMContentLoaded。 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。 更推荐使用第一种方式。 jQuery中的顶级对象$ $是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。 $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。 jQuery 对象和 DOM 对象 ​ 使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : 用原生 JS 获取来的对象就是 DOM 对象 jQuery 方法获取的元素就是 jQuery 对象。 jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。 注意： 只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。 jQuery 对象和 DOM 对象转换 ​ DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 // 1.DOM对象转换成jQuery对象，方法只有一种 var box = document.getElementById('box'); // 获取DOM对象 var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象 // 2.jQuery 对象转换为 DOM 对象有两种方法： // 2.1 jQuery对象[索引值] var domObject1 = $('div')[0] // 2.2 jQuery对象.get(索引值) var domObject2 = $('div').get(0) 总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。 jQuery 选择器 ​ 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 基础选择器 $(&quot;选择器&quot;) // 里面选择器直接写 CSS 选择器即可，但是要加引号 ​ 层级选择器 ​ 层级选择器最常用的两个分别为：后代选择器和子代选择器。 ​ 基础选择器和层级选择器案例代码 &lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { console.log($(&quot;.nav&quot;)); console.log($(&quot;ul li&quot;)); }) &lt;/script&gt; &lt;/body&gt; 筛选选择器 ​ 筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 : 案例代码 &lt;body&gt; &lt;ul&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; $(function() { $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;); $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;); $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;); }) &lt;/script&gt; &lt;/body&gt; 另: jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。 知识铺垫 jQuery 设置样式 $('div').css('属性', '值') jQuery 里面的排他思想 // 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。 $(this).css(“color”,”red”); $(this).siblings(). css(“color”,””); 隐式迭代 // 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。 // 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 $('div').hide(); // 页面中所有的div全部隐藏，不用循环操作 链式编程 // 链式编程是为了节省代码量，看起来更优雅。 $(this).css('color', 'red').sibling().css('color', ''); jQuery 样式操作 ​ jQuery中常用的样式操作有两种：css() 和 设置类样式方法 方法1: 操作 css 方法 ​ jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。 ​ 常用以下三种形式 : // 1.参数只写属性名，则是返回属性值 var strColor = $(this).css('color'); // 2. 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 $(this).css(''color'', ''red''); // 3. 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号 $(this).css({ &quot;color&quot;:&quot;white&quot;, &quot;font-size&quot;:&quot;20px&quot; }); ​ 注意：css() 多用于样式少时操作，多了则不太方便。 方法2: 设置类样式方法 ​ 作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 ​ 常用的三种设置类样式方法： // 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;); // 2.删除类 $(&quot;div&quot;).removeClass(&quot;current&quot;); // 3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;); ​ 注意： 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 tab 栏切换 思路分析: 1.点击上部的li，当前li 添加current类，其余兄弟移除类。 2.点击的同时，得到当前li 的索引号 3.让下部里面相应索引号的item显示，其余的item隐藏 ​ $(function() { // 1.点击上部的li，当前li 添加current类，其余兄弟移除类 $(&quot;.tab_list li&quot;).click(function() { // 链式编程操作 $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;); // 2.点击的同时，得到当前li 的索引号 var index = $(this).index(); console.log(index); // 3.让下部里面相应索引号的item显示，其余的item隐藏 $(&quot;.tab_con .item&quot;).eq(index).show().siblings().hide(); }); }) jQuery 效果 ​ jQuery 给我们封装了很多动画效果，最为常见的如下： 显示隐藏：show() / hide() / toggle() ; 划入画出：slideDown() / slideUp() / slideToggle() ; 淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; 自定义动画：animate() ; 注意： 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 jQuery为我们提供另一个方法，可以停止动画排队：stop() ; 显示隐藏 ​ 显示隐藏动画，常见有三个方法：show() / hide() / toggle() ; ​ 语法规范如下: 1.显示语法规范 show ( [speed, [easing],[fn] ]) 2.显示参数 (1)参数都可以省略，无动画直接显示。 (2) speed:三种预定速度之一的字符串(“slow”,“normal&quot;, or“fast”)或表示动画时长的毫秒数值(如:1000)。(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.隐藏语法规范 hide i [speed, [easing] , [fn]]) 2.隐藏参数 (1)参数都可以省略，无动画直接显示。 (2) speed:三种预定速度之一的字符串(“slow&quot;,&quot;normal”, or “fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.切换语法规范 togglei( [speed, [easing] , [fn] ]) 2.切换参数 (1）参数都可以省略，无动画直接显示。 (2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”, or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear&quot;。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 建议:平时一般不带参数，直接显示隐藏即可。 代码演示 &lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { $(&quot;div&quot;).show(1000, function() { alert(1); }); }) $(&quot;button&quot;).eq(1).click(function() { $(&quot;div&quot;).hide(1000, function() { alert(1); }); }) $(&quot;button&quot;).eq(2).click(function() { $(&quot;div&quot;).toggle(1000); }) // 一般情况下，我们都不加参数直接显示隐藏就可以了 }); &lt;/script&gt; &lt;/body&gt; 滑入滑出 ​ 滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ; ​ 语法规范如下: 1.下滑效果语法规范 slideDown ( [speed, [easing],[fn] ]) 2.下滑效果参数 (1)参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”, &quot; normal”,or “fast”)或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.上滑效果语法规范 slideUp i [ speed, [easing] , [fn] ]) 2.上滑效果参数 (1)参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”,&quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.滑动切换效果语法规范 slideToggle i [speed, [easing], [fn]]) ⒉滑动切换效果参数 (1）参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 代码演示 &lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { // 下滑动 slideDown() $(&quot;div&quot;).slideDown(); }) $(&quot;button&quot;).eq(1).click(function() { // 上滑动 slideUp() $(&quot;div&quot;).slideUp(500); }) $(&quot;button&quot;).eq(2).click(function() { // 滑动切换 slideToggle() $(&quot;div&quot;).slideToggle(500); }); }); &lt;/script&gt; &lt;/body&gt; 小案例：下拉菜单略（详情参看源码）。 淡入淡出 ​ 淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; ​ 语法规范如下: 1.淡入效果语法规范 fadeIn ( [speed, [easing] ,[fn] ]) 2淡入效果参数 (1）参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow&quot;,&quot;normal”, or“fast”)或表示动画时长的毫秒数值(如:1000),(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.淡出效果语法规范 fadeout ( [speed, [easing] , [fn]]) 2.淡出效果参数 (1）参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or“fast”)或表示动画时长的毫秒数值(如:1000).(3) easing:(Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.淡入淡出切换效果语法规范 fadeToggle ( [speed, [easing] ,[fn]]) 2.淡入淡出切换效果参数 (1）参数都可以省略。 (2) speed:三种预定速度之一的字符串( “slow”,&quot;normal”, or“fast”)或表示动画时长的毫秒数值(如: 1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 1.渐进方式调整到指定的不透明度 fadeTo( [ [speed] , opacity, [easing] , [fn]]) 2效果参数 (1) opacity透明度必须写，取值0~1之间。 (2) speed:三种预定速度之一的字符串(“slow”, &quot; normal”,or“fast”)或表示动画时长的毫秒数值(如:1000)。必须写(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 代码演示 &lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { // 淡入 fadeIn() $(&quot;div&quot;).fadeIn(1000); }) $(&quot;button&quot;).eq(1).click(function() { // 淡出 fadeOut() $(&quot;div&quot;).fadeOut(1000); }) $(&quot;button&quot;).eq(2).click(function() { // 淡入淡出切换 fadeToggle() $(&quot;div&quot;).fadeToggle(1000); }); $(&quot;button&quot;).eq(3).click(function() { // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); }); }); &lt;/script&gt; &lt;/body&gt; 自定义动画 ​ 自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ; ​ 语法规范如下: 1.语法 animate (params, [speed] , [easing] , [fn] ) 2参数 (1) params:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采 取驼峰命名法borderLeft。其余参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”, &quot;normal”,or “fast”)或表示动画时长的毫秒数值(如:1000).(3) easing: (Optional)用来指定切换效果，默认是“swing”，可用参数“linear”。 (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次。 代码演示 &lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).click(function() { $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500); }) }) &lt;/script&gt; &lt;/body&gt; 停止动画排队 ​ 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 ​ 停止动画排队的方法为：stop() ; stop() 方法用于停止动画或效果。 stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 ​ 总结: 每次使用动画之前，先调用 stop() ,在调用动画。 事件切换 ​ jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下 语法 hover([over,]out) // 其中over和out为两个函数 over:鼠标移到元素上要触发的函数（相当于mouseenter） out:鼠标移出元素要触发的函数（相当于mouseleave） 如果只写一个函数，则鼠标经过和离开都会触发它 hover事件和停止动画排列案例 &lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { // 鼠标经过 // $(&quot;.nav&gt;li&quot;).mouseover(function() { // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(&quot;ul&quot;).slideDown(200); // }); // // 鼠标离开 // $(&quot;.nav&gt;li&quot;).mouseout(function() { // $(this).children(&quot;ul&quot;).slideUp(200); // }); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(&quot;.nav&gt;li&quot;).hover(function() { // $(this).children(&quot;ul&quot;).slideDown(200); // }, function() { // $(this).children(&quot;ul&quot;).slideUp(200); // }); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(&quot;.nav&gt;li&quot;).hover(function() { // stop 方法必须写到动画的前面 $(this).children(&quot;ul&quot;).stop().slideToggle(); }); }) &lt;/script&gt; &lt;/body&gt; 手风琴效果 思路分析: 1.鼠标经过某个小li 有两步操作： 2.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入 3.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出 ​ $(function() { // 鼠标经过某个小li 有两步操作： $(&quot;.king li&quot;).mouseenter(function() { // 1.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入 $(this).stop().animate({ width: 224 }).find(&quot;.small&quot;).stop().fadeOut().siblings(&quot;.big&quot;).stop().fadeIn(); // 2.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出 $(this).siblings(&quot;li&quot;).stop().animate({ width: 69 }).find(&quot;.small&quot;).stop().fadeIn().siblings(&quot;.big&quot;).stop().fadeOut(); }) }); jQuery 属性操作 ​ jQuery 常用属性操作有三种：prop() / attr() / data() ; 元素固有属性值 prop() ​ 所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 语法 1.获取属性语法 prop(&quot;属性&quot;&quot;) 2.设置属性语法 prop(&quot;属性&quot;&quot;,&quot;属性值&quot;&quot;) ​ 注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。 元素自定义属性值 attr() ​ 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 语法 1.获取属性语法 attr(&quot;届性&quot;)//类似原生getAttribute) 2.设置属性语法 attr(&quot;&quot;属性&quot;&quot;，&quot;属性值&quot;&quot;1/类似原生setAttribute() 该方法也可以获取H5自定义属性 ​ 注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性） 数据缓存 data() ​ data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 语法 1.附加数据语法 data(&quot;name&quot; ,&quot;value&quot;)!/向被选元素附加数据 2获取数据语法 date(&quot;name&quot;&quot;) //向被选元素获取数据 ​ 注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。 演示代码 &lt;body&gt; &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt; &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() { //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值 console.log($(&quot;a&quot;).prop(&quot;href&quot;)); $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;); $(&quot;input&quot;).change(function() { console.log($(this).prop(&quot;checked&quot;)); }); // console.log($(&quot;div&quot;).prop(&quot;index&quot;)); // 2. 元素的自定义属性 我们通过 attr() console.log($(&quot;div&quot;).attr(&quot;index&quot;)); $(&quot;div&quot;).attr(&quot;index&quot;, 4); console.log($(&quot;div&quot;).attr(&quot;data-index&quot;)); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); }) &lt;/script&gt; &lt;/body&gt; jQuery 文本属性值 ​ jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。 jQuery内容文本值 ​ 常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。 语法 1.普通元素内容html()（相当于原生innerHTML) html() /获取元素的内容 html(&quot;内容&quot;)/设置元素的内容 2普通元素文本内容 text()(相当与原生innerText) text() //获取元素的文本内容 text(&quot;文本内容&quot;&quot;)//设置元素的文本内容 3.表单的值val()(相当于原生value) val() //获取表单的值 val(&quot;内容&quot;)/设置表单的值 ​ 注意：html() 可识别标签，text() 不识别标签。 演示代码 &lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;123&quot;); // 2. 获取设置元素文本内容 text() console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;123&quot;); // 3. 获取设置表单值 val() console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;123&quot;); &lt;/script&gt; &lt;/body&gt; jQuery 元素操作 ​ jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。 遍历元素 ​ jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 语法1 **.(&quot;div&quot;).each(function(index,domEle)xxx;)∗∗1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个2.里面的回调函数有2个参数:index是每个元素的索引号;demEle是每个DOM元素对象，不是jquery对象3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象.( &quot;div&quot;).each (function (index, domEle) { xxx; })** 1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 2.里面的回调函数有2个参数: index是每个元素的索引号; demEle是每个DOM元素对象，不是jquery对象 3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象.(&quot;div&quot;).each(function(index,domEle)xxx;)∗∗1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个2.里面的回调函数有2个参数:index是每个元素的索引号;demEle是每个DOM元素对象，不是jquery对象3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象(domEle) ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 语法2 ​ **.each(object，function(index,element)xxx;)∗∗1..each (object， function (index, element) { xxx; })** 1..each(object，function(index,element)xxx;)∗∗1..each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象 ⒉里面的函数有2个参数: index是每个元素的索引号; element遍历内容 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 演示代码 &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() { // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; // 1. each() 方法遍历元素 $(&quot;div&quot;).each(function(i, domEle) { // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(i); // 回调函数第二个参数一定是 dom 元素对象，也是自己命名 // console.log(domEle); // 使用jQuery方法需要转换 $(domEle) $(domEle).css(&quot;color&quot;, arr[i]); sum += parseInt($(domEle).text()); }) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(&quot;div&quot;), function(i, ele) { // console.log(i); // console.log(ele); // }); // $.each(arr, function(i, ele) { // console.log(i); // console.log(ele); // }) $.each({ name: &quot;andy&quot;, age: 18 }, function(i, ele) { console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 }) }) &lt;/script&gt; &lt;/body&gt; 创建、添加、删除 ​ jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下： 语法总和 1.创建 $(&quot;&quot;&quot;); 动态的创建了一个 2.1.内部添加 element.append(&quot;内容&quot;&quot;) 把内容放入匹配元素内部最后面，类似原生appendChild。 element.prepend(&quot;内容&quot;&quot;) 把内容放入匹配元素内部最前面。 2.2.外部添加 element.after(&quot;内容&quot;&quot;)/把内容放入目标元素后面 element.before(&quot;内容&quot;)l/把内容放入目标元素前面 内部添加元素，生成之后，它们是父子关系。 外部添加元素，生成之后，他们是兄弟关系。 3.删除元素 element.remove0 //删除匹配的元素（本身) element.empty0//删除匹配的元素集合中所有的子节点 element.html(&quot;&quot;)//清空匹配的元素内容 remove删除元素本身。 empt()和htmI(&quot;&quot;)作用等价，都可以删除元素里面的内容，只不过 html还可以设置内容。 ​ 注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。 案例代码 &lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() { // 1. 创建元素 var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;); // 2. 添加元素 // 2.1 内部添加 // $(&quot;ul&quot;).append(li); 内部添加并且放到内容的最后面 $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面 // 2.2 外部添加 var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;); // $(&quot;.test&quot;).after(div); $(&quot;.test&quot;).before(div); // 3. 删除元素 // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀 // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子 $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子 }) &lt;/script&gt; &lt;/body&gt; 购物车 $(function() { // 1. 全选 全不选功能模块 // 就是把全选按钮（checkall）的状态赋值给 三个小的按钮（j-checkbox）就可以了 // 事件可以使用change $(&quot;.checkall&quot;).change(function() { // console.log($(this).prop(&quot;checked&quot;)); $(&quot;.j-checkbox, .checkall&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;)); if ($(this).prop(&quot;checked&quot;)) { // 让所有的商品添加 check-cart-item 类名 $(&quot;.cart-item&quot;).addClass(&quot;check-cart-item&quot;); } else { // check-cart-item 移除 $(&quot;.cart-item&quot;).removeClass(&quot;check-cart-item&quot;); } }); // 2. 如果小复选框被选中的个数等于3 就应该把全选按钮选上，否则全选按钮不选。 $(&quot;.j-checkbox&quot;).change(function() { // if(被选中的小的复选框的个数 === 3) { // 就要选中全选按钮 // } else { // 不要选中全选按钮 // } // console.log($(&quot;.j-checkbox:checked&quot;).length); // $(&quot;.j-checkbox&quot;).length 这个是所有的小复选框的个数 if ($(&quot;.j-checkbox:checked&quot;).length === $(&quot;.j-checkbox&quot;).length) { $(&quot;.checkall&quot;).prop(&quot;checked&quot;, true); } else { $(&quot;.checkall&quot;).prop(&quot;checked&quot;, false); } if ($(this).prop(&quot;checked&quot;)) { // 让当前的商品添加 check-cart-item 类名 $(this).parents(&quot;.cart-item&quot;).addClass(&quot;check-cart-item&quot;); } else { // check-cart-item 移除 $(this).parents(&quot;.cart-item&quot;).removeClass(&quot;check-cart-item&quot;); } }); // 3. 增减商品数量模块 首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。 $(&quot;.increment&quot;).click(function() { // 得到当前兄弟文本框的值 var n = $(this).siblings(&quot;.itxt&quot;).val(); // console.log(n); n++; $(this).siblings(&quot;.itxt&quot;).val(n); // 3. 计算小计模块 根据文本框的值 乘以 当前商品的价格 就是 商品的小计 // 当前商品的价格 p var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); // console.log(p); p = p.substr(1); console.log(p); var price = (p * n).toFixed(2); // 小计模块 // toFixed(2) 可以让我们保留2位小数 $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + price); getSum(); }); $(&quot;.decrement&quot;).click(function() { // 得到当前兄弟文本框的值 var n = $(this).siblings(&quot;.itxt&quot;).val(); if (n == 1) { return false; } // console.log(n); n--; $(this).siblings(&quot;.itxt&quot;).val(n); // var p = $(this).parent().parent().siblings(&quot;.p-price&quot;).html(); // parents(&quot;.p-num&quot;) 返回指定的祖先元素 var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); // console.log(p); p = p.substr(1); console.log(p); // 小计模块 $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + (p * n).toFixed(2)); getSum(); }); // 4. 用户修改文本框的值 计算 小计模块 $(&quot;.itxt&quot;).change(function() { // 先得到文本框的里面的值 乘以 当前商品的单价 var n = $(this).val(); // 当前商品的单价 var p = $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-price&quot;).html(); // console.log(p); p = p.substr(1); $(this).parents(&quot;.p-num&quot;).siblings(&quot;.p-sum&quot;).html(&quot;￥&quot; + (p * n).toFixed(2)); getSum(); }); // 5. 计算总计和总额模块 getSum(); function getSum() { var count = 0; // 计算总件数 var money = 0; // 计算总价钱 $(&quot;.itxt&quot;).each(function(i, ele) { count += parseInt($(ele).val()); }); $(&quot;.amount-sum em&quot;).text(count); $(&quot;.p-sum&quot;).each(function(i, ele) { money += parseFloat($(ele).text().substr(1)); }); $(&quot;.price-sum em&quot;).text(&quot;￥&quot; + money.toFixed(2)); } // 6. 删除商品模块 // (1) 商品后面的删除按钮 $(&quot;.p-action a&quot;).click(function() { // 删除的是当前的商品 $(this).parents(&quot;.cart-item&quot;).remove(); getSum(); }); // (2) 删除选中的商品 $(&quot;.remove-batch&quot;).click(function() { // 删除的是小的复选框选中的商品 $(&quot;.j-checkbox:checked&quot;).parents(&quot;.cart-item&quot;).remove(); getSum(); }); // (3) 清空购物车 删除全部商品 $(&quot;.clear-all&quot;).click(function() { $(&quot;.cart-item&quot;).remove(); getSum(); }) }) jQuery 尺寸、位置操作 ​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 jQuery 尺寸操作 ​ jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。 语法 代码演示 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. width() / height() 获取设置元素 width和height大小 console.log($(&quot;div&quot;).width()); // $(&quot;div&quot;).width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(&quot;div&quot;).innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(&quot;div&quot;).outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(&quot;div&quot;).outerWidth(true)); }) &lt;/script&gt; &lt;/body&gt; ​ 注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。 jQuery 位置操作 ​ jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: 语法 ![position](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\03-jQuery快速开发资料\\jQuery_day02\\4-笔记\\images\\position.png) ![scroll](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\03-jQuery快速开发资料\\jQuery_day02\\4-笔记\\images\\scroll.png) 代码演示 &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 获取设置距离文档的位置（偏移） offset console.log($(&quot;.son&quot;).offset()); console.log($(&quot;.son&quot;).offset().top); // $(&quot;.son&quot;).offset({ // top: 200, // left: 200 // }); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(&quot;.son&quot;).position()); // $(&quot;.son&quot;).position({ // top: 200, // left: 200 // }); // 3. 被卷去的头部 $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(&quot;.container&quot;).offset().top; $(window).scroll(function() { // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) { $(&quot;.back&quot;).fadeIn(); } else { $(&quot;.back&quot;).fadeOut(); } }); // 返回顶部 $(&quot;.back&quot;).click(function() { // $(document).scrollTop(0); $(&quot;body, html&quot;).stop().animate({ scrollTop: 0 }); // $(document).stop().animate({ // scrollTop: 0 // }); 不能是文档而是 html和body元素做动画 }) }) &lt;/script&gt; &lt;/body&gt; jQuery 事件注册 ​ jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下： 优点: 操作简单，且不用担心事件覆盖等问题。 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。 语法 语法: element.事件(function () { }) $ ( &quot;div&quot; ).click (function (){事件处理程序}) 其他事件和原生基本一致。 比如mouseover.mouseout、blur、focus、change.keydown、keyup.resize.scroll等 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 单个事件注册 $(&quot;div&quot;).click(function() { $(this).css(&quot;background&quot;, &quot;purple&quot;); }); $(&quot;div&quot;).mouseenter(function() { $(this).css(&quot;background&quot;, &quot;skyblue&quot;); }); }) &lt;/script&gt; &lt;/body&gt; jQuery 事件处理 ​ 因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下： on(): 用于事件绑定，目前最好用的事件绑定方法 off(): 事件解绑 trigger() / triggerHandler(): 事件触发 事件处理 on() 绑定事件 ​ 因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on() 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;script&gt; $(function() { // (1) on可以绑定1个或者多个事件处理程序 // $(&quot;div&quot;).on({ // mouseenter: function() { // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // }, // click: function() { // $(this).css(&quot;background&quot;, &quot;purple&quot;); // } // }); $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() { $(this).toggleClass(&quot;current&quot;); }); // (2) on可以实现事件委托（委派） // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // $(&quot;ul li&quot;).click(); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }); // (3) on可以给未来动态创建的元素绑定事件 $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }) var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;); $(&quot;ol&quot;).append(li); }) &lt;/script&gt; &lt;/body&gt; 事件处理 off() 解绑事件 ​ 当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ; 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我是一个P标签&lt;/p&gt; &lt;script&gt; $(function() { // 事件绑定 $(&quot;div&quot;).on({ click: function() { console.log(&quot;我点击了&quot;); }, mouseover: function() { console.log('我鼠标经过了'); } }); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }); // 1. 事件解绑 off // $(&quot;div&quot;).off(); // 这个是解除了div身上的所有事件 $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 2. one() 但是它只能触发事件一次 $(&quot;p&quot;).one(&quot;click&quot;, function() { alert(11); }) }) &lt;/script&gt; &lt;/body&gt; 事件处理 trigger() 自动触发事件 ​ 有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; $(function() { // 绑定事件 $(&quot;div&quot;).on(&quot;click&quot;, function() { alert(11); }); // 自动触发事件 // 1. 元素.事件() // $(&quot;div&quot;).click();会触发元素的默认行为 // 2. 元素.trigger(&quot;事件&quot;) // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为 $(&quot;input&quot;).trigger(&quot;focus&quot;); // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为 $(&quot;input&quot;).on(&quot;focus&quot;, function() { $(this).val(&quot;你好吗&quot;); }); // 一个会获取焦点，一个不会 $(&quot;div&quot;).triggerHandler(&quot;click&quot;); // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;); }); &lt;/script&gt; &lt;/body&gt; jQuery 事件对象 ​ jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(document).on(&quot;click&quot;, function() { console.log(&quot;点击了document&quot;); }) $(&quot;div&quot;).on(&quot;click&quot;, function(event) { // console.log(event); console.log(&quot;点击了div&quot;); event.stopPropagation(); }) }) &lt;/script&gt; &lt;/body&gt; 注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。 jQuery 拷贝对象 ​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 语法 演示代码 &lt;script&gt; $(function() { // 1.合并数据 var targetObj = {}; var obj = { id: 1, name: &quot;andy&quot; }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); // 2. 会覆盖 targetObj 里面原来的数据 var targetObj = { id: 0 }; var obj = { id: 1, name: &quot;andy&quot; }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); }) &lt;/script&gt; jQuery 多库共存 ​ 实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。 语法 演示代码 &lt;script&gt; $(function() { // 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(&quot;span&quot;)); }) &lt;/script&gt; jQuery 插件 ​ jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入 jQuery文件，因此也称为 jQuery 插件。 ​ jQuery 插件常用的网站： jQuery 插件库 http://www.jq22.com/ jQuery 之家 http://www.htmleaf.com/ jQuery 插件使用步骤： 引入相关文件。（jQuery 文件 和 插件文件） 复制相关html、css、js (调用插件)。 瀑布流插件（重点） ​ 我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。 代码演示 ​ 插件的使用三点： 1. 引入css. 2.引入JS 3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js） 1.引入css. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt; &lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt; &lt;style type=&quot;text/css&quot;&gt; #gallery-wrapper { position: relative; max-width: 75%; width: 75%; margin: 50px auto; } img.thumb { width: 100%; max-width: 100%; height: auto; } .white-panel { position: absolute; background: white; border-radius: 5px; box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3); padding: 10px; } .white-panel h1 { font-size: 1em; } .white-panel h1 a { color: #A92733; } .white-panel:hover { box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); margin-top: -5px; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; } &lt;/style&gt; 2.引入js. &lt;!-- 前两个必须引入 --&gt; &lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt; &lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;#gallery-wrapper&quot;).pinterest_grid({ no_columns: 5, padding_x: 15, padding_y: 10, margin_bottom: 50, single_column_breakpoint: 700 }); }); &lt;/script&gt; 3.引入html. &lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt; &lt;section id=&quot;gallery-wrapper&quot;&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; 总结：jQuery插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容） 图片懒加载插件 ​ 图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略） 代码演示 ​ 懒加载只需引入html 和 js操作 即可，此插件不涉及css。 1.引入js &lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; lazyLoadInit({ showTime: 1100, onLoadBackEnd: function(i, e) { console.log(&quot;onLoadBackEnd:&quot; + i); }, onLoadBackStart: function(i, e) { console.log(&quot;onLoadBackStart:&quot; + i); } }); &lt;/script&gt; 2.引入html &lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt; 全屏滚动插件 ​ 全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为： http://www.dowebok.com/demo/2014/77/ 代码演示 ​ 全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际 项目需要使用哪种风格引入对应的HTML和CSS。 &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() { $('#dowebok').fullpage({ sectionsColor: ['pink', '#4BBFC3', '#7BAABE', '#f90'], navigation: true }); }); &lt;/script&gt; 注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。 bootstrap组件 ​ Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式 布局，使得 Web 开发更加方便快捷。 ​ 凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件。Bootstrap组件使 用非常方便: 1.引入bootstrap相关css和js 2.去官网复制html 代码演示 引入bootstrap相关css和js &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 &lt;div class=&quot;container&quot;&gt; &lt;!-- Single button --&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; bootstrap插件（JS） ​ bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以 省略js，用属性实现）。 ​ 步骤： 1.引入bootstrap相关css和js 2.去官网复制html 3.复制js代码，启动js插件。 代码演示 引入bootstrap相关css和js &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 &lt;!-- 模态框 --&gt; &lt;!-- Large modal --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt; &lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; 里面就是模态框 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 复制js代码，启动js插件。 &lt;script&gt; // 当我们点击了自己定义的按钮，就弹出模态框 $(&quot;.myBtn&quot;).on(&quot;click&quot;, function() { // alert(11); $('#btn').modal() }) &lt;/script&gt; bootstrap案例-阿里百秀 1.通过调用组件实现导航栏 2.通过调用插件实现登录 3.通过调用插件标签页实现 tab 栏 ​ 代码实现略。(详情参考源代码) toDoList案例分析 案例介绍 // 1. 文本框里面输入内容，按下回车，就可以生成待办事项。 // 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。 // 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。 // 4. 但是本页面内容刷新页面不会丢失。 toDoList 分析 // 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage // 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据 // 3. 存储的数据格式：var todolist = [{ title : ‘xxx’, done: false}] // 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。 // 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。 toDoList 按下回车把新数据添加到本地存储里面 // 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。 // 2.利用事件对象.keyCode判断用户按下回车键（13）。 // 3.声明一个数组，保存数据。 // 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。 // 5.之后把最新从表单获取过来的数据，追加到数组里面。 // 6.最后把数组存储给本地存储 (声明函数 savaDate()) toDoList 本地存储数据渲染加载到页面 // 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用 // 2.先要读取本地存储数据。（数据不要忘记转换为对象格式） // 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。 // 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。 toDoList 删除操作 // 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。 // 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li // 3.我们可以给链接自定义属性记录当前的索引号 // 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法 // 5.存储修改后的数据，然后存储给本地存储 // 6.重新渲染加载数据列表 // 7.因为a是动态创建的，我们使用on方法绑定事件 toDoList 正在进行和已完成选项操作 // 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。 // 2.点击之后，获取本地存储数据。 // 3.修改对应数据属性 done 为当前复选框的checked状态。 // 4.之后保存数据到本地存储 // 5.重新渲染加载数据列表 // 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面 // 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面 toDoList 统计正在进行个数和已经完成个数 // 1.在我们load 函数里面操作 // 2.声明2个变量 ：todoCount 待办个数 doneCount 已完成个数 // 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++ // 4.最后修改相应的元素 text() $(function() { // alert(11); // 1. 按下回车 把完整数据 存储到本地存储里面 // 存储的数据格式 var todolist = [{title: &quot;xxx&quot;, done: false}] load(); $(&quot;#title&quot;).on(&quot;keydown&quot;, function(event) { if (event.keyCode === 13) { if ($(this).val() === &quot;&quot;) { alert(&quot;请输入您要的操作&quot;); } else { // 先读取本地存储原来的数据 var local = getDate(); // console.log(local); // 把local数组进行更新数据 把最新的数据追加给local数组 local.push({ title: $(this).val(), done: false }); // 把这个数组local 存储给本地存储 saveDate(local); // 2. toDoList 本地存储数据渲染加载到页面 load(); $(this).val(&quot;&quot;); } } }); // 3. toDoList 删除操作 $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function() { // alert(11); // 先获取本地存储 var data = getDate(); console.log(data); // 修改数据 var index = $(this).attr(&quot;id&quot;); console.log(index); data.splice(index, 1); // 保存到本地存储 saveDate(data); // 重新渲染页面 load(); }); // 4. toDoList 正在进行和已完成选项操作 $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;input&quot;, function() { // alert(11); // 先获取本地存储的数据 var data = getDate(); // 修改数据 var index = $(this).siblings(&quot;a&quot;).attr(&quot;id&quot;); console.log(index); // data[?].done = ? data[index].done = $(this).prop(&quot;checked&quot;); console.log(data); // 保存到本地存储 saveDate(data); // 重新渲染页面 load(); }); // 读取本地存储的数据 function getDate() { var data = localStorage.getItem(&quot;todolist&quot;); if (data !== null) { // 本地存储里面的数据是字符串格式的 但是我们需要的是对象格式的 return JSON.parse(data); } else { return []; } } // 保存本地存储数据 function saveDate(data) { localStorage.setItem(&quot;todolist&quot;, JSON.stringify(data)); } // 渲染加载数据 function load() { // 读取本地存储的数据 var data = getDate(); console.log(data); // 遍历之前先要清空ol里面的元素内容 $(&quot;ol, ul&quot;).empty(); var todoCount = 0; // 正在进行的个数 var doneCount = 0; // 已经完成的个数 // 遍历这个数据 $.each(data, function(i, n) { // console.log(n); if (n.done) { $(&quot;ul&quot;).prepend(&quot;&lt;li&gt;&lt;input type='checkbox' checked='checked' &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href='javascript:;' id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;); doneCount++; } else { $(&quot;ol&quot;).prepend(&quot;&lt;li&gt;&lt;input type='checkbox' &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href='javascript:;' id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;); todoCount++; } }); $(&quot;#todocount&quot;).text(todoCount); $(&quot;#donecount&quot;).text(doneCount); } }) ","link":"https://xmweijh.github.io/post/jquerry/"},{"title":"WebAPIs","content":"Web API API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。 Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。 ​ MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API DOM 文档对象模型（Document Object Model，简称DOM），是 W3C 组织推荐的处理可扩展标记语言（html或者xhtml）的标准编程接口。 ​ W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。 获取元素 根据ID获取 语法：document.getElementById(id) 作用：根据ID获取元素对象 参数：id值，区分大小写的字符串 返回值：元素对象 或 null 案例代码 &lt;body&gt; &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt; &lt;script&gt; // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面 var timer = document.getElementById('time'); console.log(timer); console.log(typeof timer); // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(timer); &lt;/script&gt; &lt;/body&gt; 根据标签名获取元素 语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') 作用：根据标签名获取元素对象 参数：标签名 返回值：元素对象集合（伪数组，数组元素是元素对象） 案例代码 &lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式 for (var i = 0; i &lt; lis.length; i++) { console.log(lis[i]); } // 3. element.getElementsByTagName() 可以得到这个元素里面的某些标签 var nav = document.getElementById('nav'); // 这个获得nav 元素 var navLis = nav.getElementsByTagName('li'); console.log(navLis); &lt;/script&gt; &lt;/body&gt; 注意: 1．因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。 2.得到元素对象是动态的 注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。 H5新增获取元素方式 案例代码 &lt;body&gt; &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 1. getElementsByClassName 根据类名获得某些元素集合 var boxs = document.getElementsByClassName('box'); console.log(boxs); // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav var firstBox = document.querySelector('.box'); console.log(firstBox); var nav = document.querySelector('#nav'); console.log(nav); var li = document.querySelector('li'); console.log(li); // 3. querySelectorAll()返回指定选择器的所有元素对象集合 var allBox = document.querySelectorAll('.box'); console.log(allBox); var lis = document.querySelectorAll('li'); console.log(lis); &lt;/script&gt; &lt;/body&gt; 获取特殊元素（body，html） 获取body元素 doucumnet.body 返回body元素对象 获取html元素 document.documentElement 返回html元素对象 // 1.获取body 元素 var bodyEle = document.body; console.log(bodyEle); console.dir(bodyEle); // 2.获取html 元素 var htmlEle = document.documentElement; console.log(htmlEle); 事件基础 事件概述 JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发--- 响应机制。 ​ 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 事件三要素 事件源（谁）：触发事件的元素 事件类型（什么事件）： 例如 click 点击事件 事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数 案例代码 &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt; &lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件是有三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById('btn'); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() { alert('点秋香'); } &lt;/script&gt; &lt;/body&gt; 执行事件的步骤 1.获取事件源 2.注册事件（绑定事件) 3.添加事件处理程序(采取函数赋值形式) 案例代码 &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector('div'); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() { console.log('我被选中了'); } &lt;/script&gt; &lt;/body&gt; 常见的鼠标事件 操作元素 ​ JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的） 改变元素内容（获取或设置） element.innerText 从起始位置到终止位置的内容,但它去除html标签，同时空格和换行也会去掉 element.innerHTML 起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行 innerText改变元素内容 &lt;body&gt; &lt;button&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;某个时间&lt;/div&gt; &lt;p&gt;1123&lt;/p&gt; &lt;script&gt; // 当我们点击了按钮， div里面的文字会发生变化 // 1. 获取元素 var btn = document.querySelector('button'); var div = document.querySelector('div'); // 2.注册事件 btn.onclick = function() { // div.innerText = '2019-6-6'; div.innerHTML = getDate(); } function getDate() { var date = new Date(); // 我们写一个 2019年 5月 1日 星期三 var year = date.getFullYear(); var month = date.getMonth() + 1; var dates = date.getDate(); var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']; var day = date.getDay(); return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day]; } &lt;/script&gt; &lt;/body&gt; innerText和innerHTML的区别 获取内容时的区别： ​ innerText会去除空格和换行，而innerHTML会保留空格和换行 设置内容时的区别： ​ innerText不会识别html，而innerHTML会识别 案例代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt; 我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText 和 innerHTML的区别 // 1. innerText 不识别html标签 非标准 去除空格和换行 var div = document.querySelector('div'); // div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019'; // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的 div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019'; // 这两个属性是可读写的 可以获取元素里面的内容 var p = document.querySelector('p'); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt; &lt;/body&gt; 常用元素的属性操作 innerText、 innerHTML改变元素内容 src、href id、 alt、 title 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 案例代码 &lt;body&gt; &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt; &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt; &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt; &lt;script&gt; // 修改元素属性 src // 1. 获取元素 var ldh = document.getElementById('ldh'); var zxy = document.getElementById('zxy'); var img = document.querySelector('img'); // 2. 注册事件 处理程序 zxy.onclick = function() { img.src = 'images/zxy.jpg'; img.title = '张学友思密达'; } ldh.onclick = function() { img.src = 'images/ldh.jpg'; img.title = '刘德华'; } &lt;/script&gt; &lt;/body&gt; 表单元素的属性操作 type、 value、 checked、 selected、 disabled 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。 案例代码 &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var input = document.querySelector('input'); // 2. 注册事件 处理程序 btn.onclick = function() { // 表单里面的值 文字内容是通过 value 来修改的 input.value = '被点击了'; // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮 button禁用 // btn.disabled = true; this.disabled = true; // this 指向的是事件函数的调用者 btn } &lt;/script&gt; &lt;/body&gt; 样式属性操作 我们可以通过 JS 修改元素的大小、颜色、位置等样式。 常用方式 element.style 行内样式操作 element.className类名样式操作 方式1：通过操作style属性 元素对象的style属性也是一个对象！ 元素对象.style.样式属性 = 值; 注意: l.JS里面的样式采取驼峰命名法比如fontSize、backgroundcolor 2.JS修改style样式操作，产生的是行内样式,css权重比较高 案例代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1. 获取元素 var div = document.querySelector('div'); // 2. 注册事件 处理程序 div.onclick = function() { // div.style里面的属性 采取驼峰命名法 this.style.backgroundColor = 'purple'; this.style.width = '250px'; } &lt;/script&gt; &lt;/body&gt; 方式2：通过操作className属性 元素对象.className = 值; 因为class是关键字，所有使用className。 注意: 1．如果样式修改较多，可以采取操作类名方式更改元素样式。 class因为是个保留字，因此使用className来操作元素类名属性 className会直接更改元素的类名，会覆盖原先的类名。 案例代码 &lt;body&gt; &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt; &lt;script&gt; // 1. 使用 element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用 var test = document.querySelector('div'); test.onclick = function() { // this.style.backgroundColor = 'purple'; // this.style.color = '#fff'; // this.style.fontSize = '25px'; // this.style.marginTop = '100px'; // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况 // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器 // this.className = 'change'; this.className = 'first change'; } &lt;/script&gt; &lt;/body&gt; 排他操作 排他思想 如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; // 1. 获取所有按钮元素 var btns = document.getElementsByTagName('button'); // btns得到的是伪数组 里面的每一个元素 btns[i] for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // (1) 我们先把所有的按钮背景颜色去掉 干掉所有人 for (var i = 0; i &lt; btns.length; i++) { btns[i].style.backgroundColor = ''; } // (2) 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = 'pink'; } } &lt;/script&gt; 换肤 &lt;body&gt; &lt;ul class=&quot;baidu&quot;&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取元素 var imgs = document.querySelector('.baidu').querySelectorAll('img'); // console.log(imgs); // 2. 循环注册事件 for (var i = 0; i &lt; imgs.length; i++) { imgs[i].onclick = function() { // this.src 就是我们点击图片的路径 images/2.jpg // console.log(this.src); // 把这个路径 this.src 给body 就可以了 document.body.style.backgroundImage = 'url(' + this.src + ')'; } } &lt;/script&gt; &lt;/body&gt; 表格隔行变色 &lt;script&gt; // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { // console.log(11); this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } } &lt;/script&gt; 全选 &lt;script&gt; // 1. 全选和取消全选做法： 让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 // 获取元素 var j_cbAll = document.getElementById('j_cbAll'); var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 全选按钮注册事件 j_cbAll.onclick = function() { // this.checked 当前复选框的选中状态 console.log(this.checked); for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].checked = this.checked; } } // 给所有的子复选框注册单击事件 for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].onclick = function() { // flag 控制全选按钮是否选中 var flag = true; // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中 for (var i = 0; i &lt; j_tbs.length; i++) { if (!j_tbs[i].checked) { flag = false; break; } } // 设置全选按钮的状态 j_cbAll.checked = flag; } } &lt;/script&gt; 自定义属性操作 获取属性值 element.属性获取属性值。 element.getAttribute(属性); 区别: element.属性获取内置属性值(元素本身自带的属性) element.getAttribute ( '属性');主要获得自定义的属性(标准)我们程序员自定义的屋性 &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); // 1. 获取元素的属性值 // (1) element.属性 console.log(div.id); //(2) element.getAttribute('属性') get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index console.log(div.getAttribute('id')); console.log(div.getAttribute('index')); &lt;/script&gt; 设置属性值 element.属性=‘值’设置内置属性值。 element.setAttribute('属性'，&quot;值'); 区别: element.属性设置内置属性值 element.setAttribute(属性');主要设置自定义的属性(标准) // 2. 设置元素属性值 // (1) element.属性= '值' div.id = 'test'; div.className = 'navs'; // (2) element.setAttribute('属性', '值'); 主要针对于自定义属性 div.setAttribute('index', 2); div.setAttribute('class', 'footer'); // class 特殊 这里面写的就是 移出属性 element.removeAttribute ('属性'); // class 不是className // 3 移除属性 removeAttribute(属性) div.removeAttribute('index'); tab栏 &lt;script&gt; // 获取元素 var tab_list = document.querySelector('.tab_list'); var lis = tab_list.querySelectorAll('li'); var items = document.querySelectorAll('.item'); // for循环，给选项卡绑定点击事件 for (var i = 0; i &lt; lis.length; i++) { // 开始给5个小li 设置索引号 lis[i].setAttribute('index', i); lis[i].onclick = function() { // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想） // 干掉所有人 其余的li清除 class 这个类 for (var i = 0; i &lt; lis.length; i++) { lis[i].className = ''; } // 留下我自己 this.className = 'current'; // 2. 下面的显示内容模块 var index = this.getAttribute('index'); console.log(index); // 干掉所有人 让其余的item 这些div 隐藏 for (var i = 0; i &lt; items.length; i++) { items[i].style.display = 'none'; } // 留下我自己 让对应的item 显示出来 items[index].style.display = 'block'; } } &lt;/script&gt; H5自定义属性 自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 H5给我们新增了自定义属性： 1.设置H5自定义属性 H5规定自定义属性data-开头做为属性名并且赋值。比如&lt;div data-index= &quot;1” &gt; 或者使用JS设置 element.setAttribute( 'data-index’,2) ⒉获取H5自定义属性 1．兼容性获取element.getAttribute( 'data-index'); 2、H5新增element.datasetindex或者element.dataset['index’ ] ie 11才开始支持 &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); // console.log(div.getTime); console.log(div.getAttribute('getTime')); div.setAttribute('data-time', 20); console.log(div.getAttribute('data-index')); console.log(div.getAttribute('data-list-name')); // h5新增的获取自定义属性的方法 它只能获取data-开头的 // dataset 是一个集合里面存放了所有以data开头的自定义属性 console.log(div.dataset); console.log(div.dataset.index); console.log(div.dataset['index']); // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法 console.log(div.dataset.listName); console.log(div.dataset['listName']); &lt;/script&gt; 节点操作 节点概述 ​ 网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 ​ HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。 ​ 一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 元素节点nodeType 为1 星性节点nodeType 为2 文本节点nodeType 为3(文本节点包含文字、空格、换行等) 我们在实际开发中，节点操作主要操作的是元素节点 节点层级 ​ 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 ​ 父级节点 node. parentNode parentNode属性可返回某节点的父节点，注意是最近的一个父节点 如果指定的节点没有父节点则返回null &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1. 父节点 parentNode var erweima = document.querySelector('.erweima'); // var box = document.querySelector('.box'); // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null console.log(erweima.parentNode); &lt;/script&gt; 子节点 所有子节点 parentNode.childNodes(标准) parentNode.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。注意:返回值里面包含了所有的子节点，包括元素节点，文本节点等。 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes 子元素节点 parentNode.children(非标准) parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(这个是我们重点掌握的)。 虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用 &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // DOM 提供的方法（API）获取 var ul = document.querySelector('ul'); var lis = ul.querySelectorAll('li'); // 1. 子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等 console.log(ul.childNodes); console.log(ul.childNodes[0].nodeType); console.log(ul.childNodes[1].nodeType); // 2. children 获取所有的子元素节点 也是我们实际开发常用的 console.log(ul.children); &lt;/script&gt; 第1个子节点 parentNode.firstChild firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。 最后1个子节点 parentNode . lastChild lastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。 第1个子元素节点 parentNode.firstElementChild firstElementchild返回第一个子元素节点，找不到则返回null。 最后1个子元素节点 parentNode . lastElementChild lastElementchild返回最后一个子元素节点，找不到则返回null。 注意:这两个方法有兼容性问题，IE9以上才支持。 ​ 实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 解决方案: 1．如果想要第一个子元素节点，可以使用naxen太Nda.shildren.[0] 2．如果想要最后一个子元素节点，可以使用parentModa.chi.ldrenlpaxentNode ..chil.dren.length - 1] &lt;ol&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;li&gt;我是li5&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; var ol = document.querySelector('ol'); // 1. firstChild 第一个子节点 不管是文本节点还是元素节点 console.log(ol.firstChild); console.log(ol.lastChild); // 2. firstElementChild 返回第一个子元素节点 ie9才支持 console.log(ol.firstElementChild); console.log(ol.lastElementChild); // 3. 实际开发的写法 既没有兼容性问题又返回第一个子元素 console.log(ol.children[0]); console.log(ol.children[ol.children.length - 1]); &lt;/script&gt; 下拉菜单 &lt;script&gt; // 1. 获取元素 var nav = document.querySelector('.nav'); var lis = nav.children; // 得到4个小li // 2.循环注册事件 for (var i = 0; i &lt; lis.length; i++) { lis[i].onmouseover = function() { this.children[1].style.display = 'block'; } lis[i].onmouseout = function() { this.children[1].style.display = 'none'; } } &lt;/script&gt; 兄弟节点 &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;script&gt; var div = document.querySelector('div'); // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等 console.log(div.nextSibling); console.log(div.previousSibling); // 2. nextElementSibling 得到下一个兄弟元素节点 console.log(div.nextElementSibling); console.log(div.previousElementSibling); &lt;/script&gt; function getNextElementSibling(element) { var el = element; while (el = el.nextSibling) { if (el.nodeType === 1) { return el; } } return null; } 创建节点 document.createElement ( 'tagName &quot; ) document.createElement()方法创建由tagName指定的HTMr元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。 添加节点 node.appendchild(child) node.appendchild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于css里面的after伪元素。 node.insertBefore(child，指定元素) node.insertBefore()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的 before伪元素。 &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1. 创建节点元素节点 var li = document.createElement('li'); // 2. 添加节点 node.appendChild(child) node 父级 child 是子级 后面追加元素 var ul = document.querySelector('ul'); ul.appendChild(li); // 3. 添加节点 node.insertBefore(child, 指定元素); var lili = document.createElement('li'); ul.insertBefore(lili, ul.children[0]); // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素 &lt;/script&gt; 简单版发布留言 &lt;body&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); // 2. 注册事件 btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { // console.log(text.value); // (1) 创建元素 var li = document.createElement('li'); // 先有li 才能赋值 li.innerHTML = text.value; // (2) 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]); } } &lt;/script&gt; &lt;/body&gt; 节点操作 删除节点 node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。 &lt;button&gt;删除&lt;/button&gt; &lt;ul&gt; &lt;li&gt;熊大&lt;/li&gt; &lt;li&gt;熊二&lt;/li&gt; &lt;li&gt;光头强&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.获取元素 var ul = document.querySelector('ul'); var btn = document.querySelector('button'); // 2. 删除元素 node.removeChild(child) // ul.removeChild(ul.children[0]); // 3. 点击按钮依次删除里面的孩子 btn.onclick = function() { if (ul.children.length == 0) { this.disabled = true; } else { ul.removeChild(ul.children[0]); } } &lt;/script&gt; 删除留言 &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); // 2. 注册事件 btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { // console.log(text.value); // (1) 创建元素 var li = document.createElement('li'); // 先有li 才能赋值 li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;; // (2) 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]); // (3) 删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelectorAll('a'); for (var i = 0; i &lt; as.length; i++) { as[i].onclick = function() { // 删除的是 li 当前a所在的li this.parentNode; ul.removeChild(this.parentNode); } } } } &lt;/script&gt; 复制（克隆）节点 node.cloneNode ( ) node.cloneNode()方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点 注意: 1.如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。 ⒉如果括号参数为true，则是深度拷贝，会复制节点本身以及里面所有的子节点。 &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容 // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili); &lt;/script&gt; 动态生成表格 &lt;script&gt; // 1.先去准备好学生的数据 var datas = [{ name: '魏璎珞', subject: 'JavaScript', score: 100 }, { name: '弘历', subject: 'JavaScript', score: 98 }, { name: '傅恒', subject: 'JavaScript', score: 99 }, { name: '明玉', subject: 'JavaScript', score: 88 }, { name: '大猪蹄子', subject: 'JavaScript', score: 0 }]; // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector('tbody'); // 遍历数组 for (var i = 0; i &lt; datas.length; i++) { // 1. 创建 tr行 var tr = document.createElement('tr'); tbody.appendChild(tr); // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数 // 使用for in遍历学生对象 for (var k in datas[i]) { // 创建单元格 var td = document.createElement('td'); // 把对象里面的属性值 datas[i][k] 给 td td.innerHTML = datas[i][k]; tr.appendChild(td); } // 3. 创建有删除2个字的单元格 var td = document.createElement('td'); td.innerHTML = '&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;'; tr.appendChild(td); } // 4. 删除操作 开始 var as = document.querySelectorAll('a'); for (var i = 0; i &lt; as.length; i++) { as[i].onclick = function() { // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) } } &lt;/script&gt; 创建元素的三种方式 document.write () element.innerHTML document.createElement () 区别 document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 innerHTMT，是将内容写入某个DOM节点，不会导致页面全部重绘 innerHTML创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂 createElement ()创建多个元素效率稍低一点点，但是结构更清晰 总结:不同浏览器下， innerHTM效率要比creatElement 高 &lt;script&gt; // 三种创建元素方式区别 // 1. document.write() 创建元素 如果页面文档流加载完毕，再调用这句话会导致页面重绘 var btn = document.querySelector('button'); btn.onclick = function() { document.write('&lt;div&gt;123&lt;/div&gt;'); } // 2. innerHTML 创建元素 var inner = document.querySelector('.inner'); for (var i = 0; i &lt;= 100; i++) { inner.innerHTML += '&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;' } var arr = []; for (var i = 0; i &lt;= 100; i++) { arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;'); } inner.innerHTML = arr.join(''); // 3. document.createElement() 创建元素 var create = document.querySelector('.create'); for (var i = 0; i &lt;= 100; i++) { var a = document.createElement('a'); create.appendChild(a); } &lt;/script&gt; innerHTML和createElement效率对比 innerHTML字符串拼接方式（效率低） &lt;script&gt; function fn() { var d1 = +new Date(); var str = ''; for (var i = 0; i &lt; 1000; i++) { document.body.innerHTML += '&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;'; } var d2 = +new Date(); console.log(d2 - d1); } fn(); &lt;/script&gt; createElement方式（效率一般） &lt;script&gt; function fn() { var d1 = +new Date(); for (var i = 0; i &lt; 1000; i++) { var div = document.createElement('div'); div.style.width = '100px'; div.style.height = '2px'; div.style.border = '1px solid red'; document.body.appendChild(div); } var d2 = +new Date(); console.log(d2 - d1); } fn(); &lt;/script&gt; innerHTML数组方式（效率高） &lt;script&gt; function fn() { var d1 = +new Date(); var array = []; for (var i = 0; i &lt; 1000; i++) { array.push('&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;'); } document.body.innerHTML = array.join(''); var d2 = +new Date(); console.log(d2 - d1); } fn(); &lt;/script&gt; DOM的核心总结 关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 创建 document.write innerHTML createElement 增加 appendChild insertBefore 删 1.removeChild 改 主要修改dom的元素属性,dom元素的内容、属性,表单的值等 1.修改元素属性:src、href、title等 2.修改普通元素内容:innerHTML、 innerText 3.修改表单元素: value、type、disabled等 4.修改元素样式: style、className 查 主要获取查询dom的元素 DOM提供的API方法: getElementByld、getElementsByTagName 古老用法不太推荐 H5提供的新方法: querySelector、querySelectorAll提倡 利用节点操作获取元素:父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling)提倡 属性操作 主要针对于自定义属性。 1.setAttribute:设置dom的属性值 2.getAttribute:得到dom的属性值 3.removeAttribute移除属性 事件操作（重点） 事件高级 注册事件（2种方式） 事件监听 addEventListener()事件监听（IE9以后支持） eventTarget.addEventListener(type, listener[, useCapture]) eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。 该方法接收三个参数: type:事件类型字符串，比如click、mouseover，注意这里不要带onlistener:事件处理函数，事件发生时，会调用该监听函数 useCapture:可选参数，是一个布尔值，默认是false。 attacheEvent()事件监听（IE678支持） eventTarget.attachEvent(eventNamewithon,callback) ​ eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 该方法接收两个参数: eventNameWithOn:事件类型字符串，比如onclick、onmouseover，这里要带oncallback:事件处理函数，当目标触发事件时回调函数被调用 注意:IE8及早期版本支持 &lt;button&gt;传统注册事件&lt;/button&gt; &lt;button&gt;方法监听注册事件&lt;/button&gt; &lt;button&gt;ie9 attachEvent&lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll('button'); // 1. 传统方式注册事件 btns[0].onclick = function() { alert('hi'); } btns[0].onclick = function() { alert('hao a u'); } // 2. 事件侦听注册事件 addEventListener // (1) 里面的事件类型是字符串 必定加引号 而且不带on // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序） btns[1].addEventListener('click', function() { alert(22); }) btns[1].addEventListener('click', function() { alert(33); }) // 3. attachEvent ie9以前的版本支持 btns[2].attachEvent('onclick', function() { alert(11); }) &lt;/script&gt; 事件监听兼容性解决方案 封装一个函数，函数中判断浏览器的类型： 删除事件（解绑事件） 1.传统注册方式 eventTarget.onclick=null; 2.方法监听注册方式 eventTarget.removeEventListener(type，listener[, useCapture] ) ;eventTarget.detachEvent (eventNamewithon,callback) ; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll('div'); divs[0].onclick = function() { alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; } // 2. removeEventListener 删除事件 divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号 function fn() { alert(22); divs[1].removeEventListener('click', fn); } // 3. detachEvent divs[2].attachEvent('onclick', fn1); function fn1() { alert(33); divs[2].detachEvent('onclick', fn1); } &lt;/script&gt; **删除事件兼容性解决方案 ** DOM事件流 html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。 当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。 那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？ 事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。 比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。 事件冒泡:IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点的过程。 事件捕获:网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。 DOM 事件流会经历3个阶段： 捕获阶段 当前目标阶段 冒泡阶段 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DoM事件流。 注意 Js代码中只能执行捕获或者冒泡其中的一个阶段。 onclick 和attachEvent只能得到冒泡阶段。 addEventListener(type，listener[，useCapture])第三个参数如果是true，表示在事件捕 获阶段调用事件处理程序;如果是false (不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。 事件冒泡 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // onclick 和 attachEvent（ie） 在冒泡阶段触发 // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 // son -&gt; father -&gt;body -&gt; html -&gt; document var son = document.querySelector('.son'); // 给son注册单击事件 son.addEventListener('click', function() { alert('son'); }, false); // 给father注册单击事件 var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false); // 给document注册单击事件，省略第3个参数 document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt; 事件捕获 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发 // document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector('.son'); // 给son注册单击事件，第3个参数为true son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); // 给father注册单击事件，第3个参数为true father.addEventListener('click', function() { alert('father'); }, true); // 给document注册单击事件，第3个参数为true document.addEventListener('click', function() { alert('document'); }, true) &lt;/script&gt; 事件对象 什么是事件对象 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。 比如： 谁绑定了这个事件。 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。 事件对象的使用 事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。 所以，在事件处理函数中声明1个形参用来接收事件对象。 事件对象的兼容性处理 事件对象本身的获取存在兼容问题： 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。 只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。 只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。 &lt;div&gt;123&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); div.onclick = function(e) { // 事件对象 e = e || window.event; console.log(e); } &lt;/script&gt; 事件对象的属性和方法 e.target 和 this 的区别 this 是事件绑定的元素（绑定这个事件处理函数的元素） 。 e.target 是事件触发的元素。 常情况下terget 和 this是一致的， 但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行）， 这时候this指向的是父元素，因为它是绑定事件的元素对象， 而target指向的是子元素，因为他是触发事件的那个具体元素对象。 &lt;div&gt;123&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); div.addEventListener('click', function(e) { // e.target 和 this指向的都是div console.log(e.target); console.log(this); }); &lt;/script&gt; 事件冒泡下的e.target和this &lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); // ul // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li console.log(e.target); // li }); &lt;/script&gt; 阻止默认行为 html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;script&gt; // 2. 阻止默认行为 让链接不跳转 var a = document.querySelector('a'); a.addEventListener('click', function(e) { e.preventDefault(); // dom 标准写法 }); // 3. 传统的注册方式 a.onclick = function(e) { // 普通浏览器 e.preventDefault(); 方法 e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 e.returnValue = false; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 return false; } &lt;/script&gt; 阻止事件冒泡 事件冒泡本身的特性，会带来的坏处，也会带来的好处。 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); // 给son注册单击事件 son.addEventListener('click', function(e) { alert('son'); e.stopPropagation(); // stop 停止 Propagation 传播 window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 }, false); var father = document.querySelector('.father'); // 给father注册单击事件 father.addEventListener('click', function() { alert('father'); }, false); // 给document注册单击事件 document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt; 阻止事件冒泡的兼容性处理 ![1551171657513](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551171657513.png) 事件委托 事件冒泡本身的特性，会带来的坏处，也会带来的好处。 什么是事件委托 把事情委托给别人，代为处理。 事件委托也称为事件代理，在 jQuery 里面称为事件委派。 说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。 事件委托的原理 ​ 给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。 事件委托的作用 我们只操作了一次 DOM ，提高了程序的性能。 动态新创建的子元素，也拥有事件。 &lt;ul&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = 'pink'; }) &lt;/script&gt; 常用鼠标事件 禁止选中文字和禁止右键菜单 &lt;body&gt; 我是一段不愿意分享的文字 &lt;script&gt; // 1. contextmenu 我们可以禁用右键菜单 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) // 2. 禁止选中文字 selectstart document.addEventListener('selectstart', function(e) { e.preventDefault(); }) &lt;/script&gt; &lt;/body&gt; 鼠标事件对象 获取鼠标在页面的坐标 &lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener('click', function(e) { // 1. client 鼠标在可视区的x和y坐标 console.log(e.clientX); console.log(e.clientY); console.log('---------------------'); // 2. page 鼠标在页面文档的x和y坐标 console.log(e.pageX); console.log(e.pageY); console.log('---------------------'); // 3. screen 鼠标在电脑屏幕的x和y坐标 console.log(e.screenX); console.log(e.screenY); }) &lt;/script&gt; 跟随鼠标 &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt; &lt;script&gt; var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { // 1. mousemove只要我们鼠标移动1px 就会触发这个事件 // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， // 把这个x和y坐标做为图片的top和left 值就可以移动图片 var x = e.pageX; var y = e.pageY; console.log('x坐标是' + x, 'y坐标是' + y); //3 . 千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; }); &lt;/script&gt; 常用的键盘事件 键盘事件 注意: 1.如果使用addEventListener 不需要加on 2.onkeypress和前面2个的区别是，它不识别功能键，比如左右箭头，shift等。 3.三个事件的执行顺序是: keydown -- keypress --- keyup &lt;script&gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 document.addEventListener('keyup', function() { console.log('我弹起了'); }) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener('keypress', function() { console.log('我按下了press'); }) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener('keydown', function() { console.log('我按下了down'); }) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup &lt;/script&gt; 键盘事件对象 注意: onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写。 2)在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键（包括功能键)3) keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCIl值 使用keyCode属性判断用户按下哪个键 &lt;script&gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 document.addEventListener('keyup', function(e) { console.log('up:' + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) { alert('您按下的a键'); } else { alert('您没有按下a键') } }) document.addEventListener('keypress', function(e) { // console.log(e); console.log('press:' + e.keyCode); }) &lt;/script&gt; 按键输入内容 当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。 注意：触发获得焦点事件，可以使用 元素对象.focus() &lt;input type=&quot;text&quot;&gt; &lt;script&gt; // 获取输入框 var search = document.querySelector('input'); // 给document注册keyup事件 document.addEventListener('keyup', function(e) { // 判断keyCode的值 if (e.keyCode === 83) { // 触发输入框的获得焦点事件 search.focus(); } }) &lt;/script&gt; 模拟京东快递单号查询 要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。 &lt;div class=&quot;search&quot;&gt; &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt; &lt;/div&gt; &lt;script&gt; // 获取要操作的元素 var con = document.querySelector('.con'); var jd_input = document.querySelector('.jd'); // 给输入框注册keyup事件 jd_input.addEventListener('keyup', function() { // 判断输入框内容是否为空 if (this.value == '') { // 为空，隐藏放大提示盒子 con.style.display = 'none'; } else { // 不为空，显示放大提示盒子，设置盒子的内容 con.style.display = 'block'; con.innerText = this.value; } }) // 给输入框注册失去焦点事件，隐藏放大提示盒子 jd_input.addEventListener('blur', function() { con.style.display = 'none'; }) // 给输入框注册获得焦点事件 jd_input.addEventListener('focus', function() { // 判断输入框内容是否为空 if (this.value !== '') { // 不为空则显示提示盒子 con.style.display = 'block'; } }) &lt;/script&gt; BOM 什么是BOM ​ BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。 ​ BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 ​ BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。 BOM的构成 BOM 比 DOM 更大，它包含 DOM。 顶级对象window window对象是浏览器的顶级对象，它具有双重角色。 1.它是S访问浏览器窗口的一个接口。 2．它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。 在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等。 注意: window下的一个特殊属性window.name window对象的常见事件 页面（窗口）加载事件（2种） 第1种 window .onload = function ( ) { }或者 window.addEventListener (&quot;load&quot; , function ( ) { }); window.onload 是窗口 (页面）加载事件，当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。 注意: 1.有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等面内容全部加载元毕，再去执行处理函数。 window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。 3.如果使用addEventListener则没有限制 第2种 document.addEventListener ( ' DOMContentLoaded' , function() { }) ​ DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 ​ IE9以上才支持！！！ ​ 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。 &lt;script&gt; window.addEventListener('load', function() { var btn = document.querySelector('button'); btn.addEventListener('click', function() { alert('点击我'); }) }) window.addEventListener('load', function() { alert(22); }) document.addEventListener('DOMContentLoaded', function() { alert(33); }) &lt;/script&gt; 调整窗口大小事件 window.onresize = function ( ) { } window.addEventListener ( &quot;resize&quot; ,function() { } ); ​ window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。 注意： 只要窗口大小发生像素变化，就会触发这个事件。 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度 &lt;script&gt; // 注册页面加载事件 window.addEventListener('load', function() { var div = document.querySelector('div'); // 注册调整窗口大小事件 window.addEventListener('resize', function() { // window.innerWidth 获取窗口大小 console.log('变化了'); if (window.innerWidth &lt;= 800) { div.style.display = 'none'; } else { div.style.display = 'block'; } }) }) &lt;/script&gt; &lt;div&gt;&lt;/div&gt; 定时器（两种） window 对象给我们提供了 2 个非常好用的方法-定时器。 setTimeout() setInterval() setTimeout() 炸弹定时器 开启定时器 window.setTimeout(调用函数，[延迟的毫秒数]); setTimeout()这个调用函数我们也称为回调函数callback 注意: window可以省略。 这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐 延迟的毫秒数省略默认是0，如果写，必须是毫秒。 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 普通函数是按照代码顺序直接调用。 简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。 例如：定时器中的调用函数，事件处理函数，也是回调函数。 以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调函数。 &lt;script&gt; // 回调函数是一个匿名函数 setTimeout(function() { console.log('时间到了'); }, 2000); function callback() { console.log('爆炸了'); } // 回调函数是一个有名函数 var timer1 = setTimeout(callback, 3000); var timer2 = setTimeout(callback, 5000); &lt;/script&gt; 5秒后关闭广告 &lt;body&gt; &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt; &lt;script&gt; // 获取要操作的元素 var ad = document.querySelector('.ad'); // 开启定时器 setTimeout(function() { ad.style.display = 'none'; }, 5000); &lt;/script&gt; &lt;/body&gt; 停止定时器 window.clearTimeout (timeoutID) clearTimeout()方法取消了先前通过调用setTimeout ()建立的定时器。 注意: window可以省略。 里面的参数就是定时器的标识符。 &lt;button&gt;点击停止定时器&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); // 开启定时器 var timer = setTimeout(function() { console.log('爆炸了'); }, 5000); // 给按钮注册单击事件 btn.addEventListener('click', function() { // 停止定时器 clearTimeout(timer); }) &lt;/script&gt; setInterval() 闹钟定时器 开启定时器 window.setInterval(回调函数，[间隔的毫秒数]); setInterval方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 注意: window可以省略。 2.这个调用函数可以直接写函数，或者写函数名或者采取字符串'函数名()’三种形式。 3.间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。 4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 5.第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行—次。 &lt;script&gt; // 1. setInterval setInterval(function() { console.log('继续输出'); }, 1000); &lt;/script&gt; 倒计时 &lt;div&gt; &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 1. 获取元素（时分秒盒子） var hour = document.querySelector('.hour'); // 小时的黑色盒子 var minute = document.querySelector('.minute'); // 分钟的黑色盒子 var second = document.querySelector('.second'); // 秒数的黑色盒子 var inputTime = +new Date('2021-5-1 18:00:00'); // 返回的是用户输入时间总的毫秒数 countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 // 2. 开启定时器 setInterval(countDown, 1000); function countDown() { var nowTime = +new Date(); // 返回的是当前时间总的毫秒数 var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 var h = parseInt(times / 60 / 60 % 24); //时 h = h &lt; 10 ? '0' + h : h; hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子 var m = parseInt(times / 60 % 60); // 分 m = m &lt; 10 ? '0' + m : m; minute.innerHTML = m; var s = parseInt(times % 60); // 当前的秒 s = s &lt; 10 ? '0' + s : s; second.innerHTML = s; } &lt;/script&gt; 停止定时器 window.clearInterval (intervalID); clearInterval()方法取消了先前通过调用setInterval()建立的定时器。 注意: 1.window可以省略。 2.里面的参数就是定时器的标识符。 发送短信倒计时 ​ 点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。 手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); // 全局变量，定义剩下的秒数 var time = 3; // 注册单击事件 btn.addEventListener('click', function() { // 禁用按钮 btn.disabled = true; // 开启定时器 var timer = setInterval(function() { // 判断剩余秒数 if (time == 0) { // 清除定时器和复原按钮 clearInterval(timer); btn.disabled = false; btn.innerHTML = '发送'; } else { btn.innerHTML = '还剩下' + time + '秒'; time--; } }, 1000); }); &lt;/script&gt; this指向问题 ​ this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。 现阶段，我们先了解一下几个this指向 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window） 方法调用中谁调用this指向谁 构造函数中this指向构造函数的实例 &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // this 指向问题 一般情况下this的最终指向的是那个调用它的对象 // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window） console.log(this); function fn() { console.log(this); } window.fn(); window.setTimeout(function() { console.log(this); }, 1000); // 2. 方法调用中谁调用this指向谁 var o = { sayHi: function() { console.log(this); // this指向的是 o 这个对象 } } o.sayHi(); var btn = document.querySelector('button'); btn.addEventListener('click', function() { console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象 }) // 3. 构造函数中this指向构造函数的实例 function Fun() { console.log(this); // this 指向的是fun 实例对象 } var fun = new Fun(); &lt;/script&gt; location对象 什么是 location 对象 window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析 URL。因为 这个属性返回的是一个对象，所以我们将这个属性也称为location对象。 URL 统一资源定位符(Uniform ResourceLocator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL的一般语法格式为: protocol:// host [ :port] /path/ [?query]#fragment http : / / www.itcast.cn/index.html?name=andy&amp;age=18#link location 对象的属性 ![1551322438200](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\02-WebAPI编程资料\\Web APIs-day04\\4-笔记\\images\\1551322438200.png) 5s自动跳转页面 &lt;button&gt;点击&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.addEventListener('click', function() { // console.log(location.href); location.href = 'http://www.itcast.cn'; }) var timer = 5; setInterval(function() { if (timer == 0) { location.href = 'http://www.itcast.cn'; } else { div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页'; timer--; } }, 1000); &lt;/script&gt; 获取URL参数 &lt;div&gt;&lt;/div&gt; &lt;script&gt; console.log(location.search); // ?uname=andy // 1.先去掉？ substr('起始的位置'，截取几个字符); var params = location.search.substr(1); // uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split('='); var arr = params.split('='); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div = document.querySelector('div'); // 3.把数据写入div中 div.innerHTML = arr[1] + '欢迎您'; &lt;/script&gt; location对象的常见方法 &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); btn.addEventListener('click', function() { // 记录浏览历史，所以可以实现后退功能 // location.assign('http://www.itcast.cn'); // 不记录浏览历史，所以不可以实现后退功能 // location.replace('http://www.itcast.cn'); location.reload(true); }) &lt;/script&gt; navigator对象 ​ navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转 if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = &quot;&quot;; //手机 } else { window.location.href = &quot;&quot;; //电脑 } history对象 ​ window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。 ![1551322885216](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\02-WebAPI编程资料\\Web APIs-day04\\4-笔记\\images\\1551322885216.png) history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。 JS执行机制 以下代码执行的结果是什么？ 1 2 3 console.log(1); setTimeout(function () { console.log(3); }, 1000); console.log(2); 以下代码执行的结果是什么？ 1 2 3 console.log(1); setTimeout(function () { console.log(3); }, 0); console.log(2); JS 是单线程 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步任务和异步任务 ​ 单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！ ​ 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了同步任务和异步任务。 同步 ​ 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 异步 ​ 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 他们的本质区别:这条流水线上各个流程的执行顺序不同。 JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务指的是： 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是： 不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。 JS执行机制（事件循环） ![1551435398306](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\02-WebAPI编程资料\\Web APIs-day04\\4-笔记\\images\\1551435398306.png) ![1551435449634](E:\\BaiduNetdiskDownload\\web\\07-10 JavaScript网页编程\\02-WebAPI编程资料\\Web APIs-day04\\4-笔记\\images\\1551435449634.png) 元素偏移量 offset 系列 offset 概述 offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度） 注意：返回的数值都不带单位 offset 与 style 区别 offset offset 可以得到任意样式表中的样式值 offset 系列获得的数值是没有单位的 offsetWidth 包含padding+border+width offsetWidth 等属性是只读属性，只能获取不能赋值 所以，我们想要获取元素大小位置，用offset更合适 style style 只能得到行内样式表中的样式值 style.width 获得的是带有单位的字符串 style.width 获得不包含padding和border 的值 style.width 是可读写属性，可以获取也可以赋值 所以，我们想要给元素更改值，则需要用style改变 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes 获取鼠标在盒子内的坐标 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。 首先得到鼠标在页面中的坐标（e.pageX, e.pageY） 其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop) 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动 var box = document.querySelector('.box'); box.addEventListener('mousemove', function(e) { var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; this.innerHTML = 'x坐标是' + x + ' y坐标是' + y; }) 模态框拖拽 弹出框，我们也称为模态框。 ​ 1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。 ​ 2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。 ​ 3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。 ​ 4.鼠标松开，可以停止拖动模态框移动 点击弹出层， 模态框和遮挡层就会显示出来 display:block; 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none; 在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标 触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup 拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了 鼠标按下触发的事件源是最上面一行，就是 id 为 title 鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。 鼠标按下，我们要得到鼠标在盒子的坐标。 鼠标移动，就让模态框的坐标 设置为 ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。 鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除 // 1. 获取元素 var login = document.querySelector('.login'); var mask = document.querySelector('.login-bg'); var link = document.querySelector('#link'); var closeBtn = document.querySelector('#closeBtn'); var title = document.querySelector('#title'); // 2. 点击弹出层这个链接 link 让mask 和login 显示出来 link.addEventListener('click', function() { mask.style.display = 'block'; login.style.display = 'block'; }) // 3. 点击 closeBtn 就隐藏 mask 和 login closeBtn.addEventListener('click', function() { mask.style.display = 'none'; login.style.display = 'none'; }) // 4. 开始拖拽 // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标 title.addEventListener('mousedown', function(e) { var x = e.pageX - login.offsetLeft; var y = e.pageY - login.offsetTop; // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值 document.addEventListener('mousemove', move) function move(e) { login.style.left = e.pageX - x + 'px'; login.style.top = e.pageY - y + 'px'; } // (3) 鼠标弹起，就让鼠标移动事件移除 document.addEventListener('mouseup', function() { document.removeEventListener('mousemove', move); }) }) 仿京东放大镜 整个案例可以分为三个功能模块 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能 黄色的遮挡层跟随鼠标功能。 移动黄色遮挡层，大图片跟随移动功能。 黄色的遮挡层跟随鼠标功能。 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。 首先是获得鼠标在盒子的坐标。 之后把数值给遮挡层做为left 和top值。 此时用到鼠标移动事件，但是还是在小图片盒子内移动。 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。 遮挡层不能超出小图片盒子范围。 如果小于零，就把坐标设置为0 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离 遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度 window.addEventListener('load', function() { var preview_img = document.querySelector('.preview_img'); var mask = document.querySelector('.mask'); var big = document.querySelector('.big'); // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子 preview_img.addEventListener('mouseover', function() { mask.style.display = 'block'; big.style.display = 'block'; }) preview_img.addEventListener('mouseout', function() { mask.style.display = 'none'; big.style.display = 'none'; }) // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走 preview_img.addEventListener('mousemove', function(e) { // (1). 先计算出鼠标在盒子内的坐标 var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; // console.log(x, y); // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了 // (3) 我们mask 移动的距离 var maskX = x - mask.offsetWidth / 2; var maskY = y - mask.offsetHeight / 2; // (4) 如果x 坐标小于了0 就让他停在0 的位置 // 遮挡层的最大移动距离 var maskMax = preview_img.offsetWidth - mask.offsetWidth; if (maskX &lt;= 0) { maskX = 0; } else if (maskX &gt;= maskMax) { maskX = maskMax; } if (maskY &lt;= 0) { maskY = 0; } else if (maskY &gt;= maskMax) { maskY = maskMax; } mask.style.left = maskX + 'px'; mask.style.top = maskY + 'px'; // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离 // 大图 var bigIMg = document.querySelector('.bigImg'); // 大图片最大移动距离 var bigMax = bigIMg.offsetWidth - big.offsetWidth; // 大图片的移动距离 X Y var bigX = maskX * bigMax / maskMax; var bigY = maskY * bigMax / maskMax; bigIMg.style.left = -bigX + 'px'; bigIMg.style.top = -bigY + 'px'; }) }) 元素可视区 client 系列 client概述 client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。 淘宝 flexible.js 源码分析 立即执行函数 (function(){})() 或者 (function(){}()) 主要作用： 创建一个独立的作用域。 避免了命名冲突问题 下面三种情况都会刷新页面都会触发 load 事件。 1.a标签的超链接 2.F5或者刷新按钮（强制刷新） 3.前进后退按钮 但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。 所以此时后退按钮不能刷新页面。 此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件 注意这个事件给window添加。 元素滚动 scroll 系列 scroll 概述 scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。 页面被卷去的头部 如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。 仿淘宝固定右侧侧边栏 原先侧边栏是绝对定位 当页面滚动到一定位置，侧边栏改为固定定位 页面继续滚动，会让 返回顶部显示出来 需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是document 滚动到某个位置，就是判断页面被卷去的上部值。 页面被卷去的头部：可以通过window.pageYOffset 获得 如果是被卷去的左侧window.pageXOffset 注意，元素被卷去的头部是element.scrollTop , 如果是页面被卷去的头部 则是 window.pageYOffset 其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了 //1. 获取元素 var sliderbar = document.querySelector('.slider-bar'); var banner = document.querySelector('.banner'); // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面 var bannerTop = banner.offsetTop // 当我们侧边栏固定定位之后应该变化的数值 var sliderbarTop = sliderbar.offsetTop - bannerTop; // 获取main 主体元素 var main = document.querySelector('.main'); var goBack = document.querySelector('.goBack'); var mainTop = main.offsetTop; // 2. 页面滚动事件 scroll document.addEventListener('scroll', function() { // console.log(11); // window.pageYOffset 页面被卷去的头部 // console.log(window.pageYOffset); // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位 if (window.pageYOffset &gt;= bannerTop) { sliderbar.style.position = 'fixed'; sliderbar.style.top = sliderbarTop + 'px'; } else { sliderbar.style.position = 'absolute'; sliderbar.style.top = '300px'; } // 4. 当我们页面滚动到main盒子，就显示 goback模块 if (window.pageYOffset &gt;= mainTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }) 页面被卷去的头部兼容性解决方案 需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法： 声明了 DTD，使用 document.documentElement.scrollTop 未声明 DTD，使用 document.body.scrollTop 新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持 function getScroll() { return { left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0, top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 }; } 使用的时候 getScroll().left 三大系列总结 他们主要用法： 1.offset系列 经常用于获得元素位置 offsetLeft offsetTop 2.client经常用于获取元素大小 clientWidth clientHeight 3.scroll 经常用于获取滚动距离 scrollTop scrollLeft 4.注意页面滚动的距离通过 window.pageXOffset 获得 mouseenter 和mouseover的区别 当鼠标移动到元素上时就会触发mouseenter 事件 类似 mouseover，它们两者之间的差别是 mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发 之所以这样，就是因为mouseenter不会冒泡 跟mouseenter搭配鼠标离开 mouseleave 同样不会冒泡 动画函数封装 动画实现原理 核心原理：通过定时器 setInterval() 不断移动盒子位置。 实现步骤： 获得盒子当前位置 让盒子在当前位置加上1个移动距离 利用定时器不断重复这个操作 加一个结束定时器的条件 注意此元素需要添加定位，才能使用element.style.left 动画函数给不同元素记录不同定时器 如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。 核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。 function animate(obj, target) { // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器 // 解决方案就是 让我们元素只有一个定时器执行 // 先清除以前的定时器，只保留当前的一个定时器执行 clearInterval(obj.timer); obj.timer = setInterval(function() { if (obj.offsetLeft &gt;= target) { // 停止动画 本质是停止定时器 clearInterval(obj.timer); } obj.style.left = obj.offsetLeft + 1 + 'px'; }, 30); } 缓动效果原理 缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 思路： 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 核心算法： (目标值 - 现在的位置) / 10 做为每次移动的距离步长 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 注意步长值需要取整 动画函数多个目标值之间移动 可以让动画函数从 800 移动到 500。 当我们点击按钮时候，判断步长是正值还是负值（否则当为距离小于10时 步长取整始终为0 不在移动） ​ 1.如果是正值，则步长往大了取整 ​ 2.如果是负值，则步长 向小了取整 动函数添加回调函数 回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。 回调函数写的位置：定时器结束的位置。 动画完整版代码: function animate(obj, target, callback) { // console.log(callback); callback = function() {} 调用的时候 callback() // 先清除以前的定时器，只保留当前的一个定时器执行 clearInterval(obj.timer); obj.timer = setInterval(function() { // 步长值写到定时器的里面 // 把我们步长值改为整数 不要出现小数的问题 // var step = Math.ceil((target - obj.offsetLeft) / 10); var step = (target - obj.offsetLeft) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if (obj.offsetLeft == target) { // 停止动画 本质是停止定时器 clearInterval(obj.timer); // 回调函数写到定时器结束里面 // if (callback) { // // 调用函数 // callback(); // } callback &amp;&amp; callback(); } // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10 obj.style.left = obj.offsetLeft + step + 'px'; }, 15); } 常见网页特效案例 网页轮播图 轮播图也称为焦点图，是网页中比较常见的网页特效。 功能需求： ​ 1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。 ​ 2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。 ​ 3.图片播放的同时，下面小圆圈模块跟随一起变化。 ​ 4.点击小圆圈，可以播放相应图片。 ​ 5.鼠标不经过轮播图，轮播图也会自动播放图片。 ​ 6.鼠标经过，轮播图模块， 自动播放停止。 window.addEventListener('load', function() { // 1. 获取元素 var arrow_l = document.querySelector('.arrow-l'); var arrow_r = document.querySelector('.arrow-r'); var focus = document.querySelector('.focus'); var focusWidth = focus.offsetWidth; // 2. 鼠标经过focus 就显示隐藏左右按钮 focus.addEventListener('mouseenter', function() { arrow_l.style.display = 'block'; arrow_r.style.display = 'block'; clearInterval(timer); timer = null; // 清除定时器变量 }); focus.addEventListener('mouseleave', function() { arrow_l.style.display = 'none'; arrow_r.style.display = 'none'; timer = setInterval(function() { //手动调用点击事件 arrow_r.click(); }, 2000); }); // 3. 动态生成小圆圈 有几张图片，我就生成几个小圆圈 var ul = focus.querySelector('ul'); var ol = focus.querySelector('.circle'); // console.log(ul.children.length); for (var i = 0; i &lt; ul.children.length; i++) { // 创建一个小li var li = document.createElement('li'); // 记录当前小圆圈的索引号 通过自定义属性来做 li.setAttribute('index', i); // 把小li插入到ol 里面 ol.appendChild(li); // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件 li.addEventListener('click', function() { // 干掉所有人 把所有的小li 清除 current 类名 for (var i = 0; i &lt; ol.children.length; i++) { ol.children[i].className = ''; } // 留下我自己 当前的小li 设置current 类名 this.className = 'current'; // 5. 点击小圆圈，移动图片 当然移动的是 ul // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值 // 当我们点击了某个小li 就拿到当前小li 的索引号 var index = this.getAttribute('index'); // 当我们点击了某个小li 就要把这个li 的索引号给 num num = index; // 当我们点击了某个小li 就要把这个li 的索引号给 circle circle = index; // num = circle = index; console.log(focusWidth); console.log(index); animate(ul, -index * focusWidth); }) } // 把ol里面的第一个小li设置类名为 current ol.children[0].className = 'current'; // 6. 克隆第一张图片(li)放到ul 最后面 var first = ul.children[0].cloneNode(true); ul.appendChild(first); // 7. 点击右侧按钮， 图片滚动一张 var num = 0; // circle 控制小圆圈的播放 var circle = 0; // flag 节流阀 var flag = true; arrow_r.addEventListener('click', function() { if (flag) { flag = false; // 关闭节流阀 // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0 if (num == ul.children.length - 1) { ul.style.left = 0; num = 0; } num++; animate(ul, -num * focusWidth, function() { flag = true; // 打开节流阀 }); // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放 circle++; // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原 if (circle == ol.children.length) { circle = 0; } // 调用函数 circleChange(); } }); // 9. 左侧按钮做法 arrow_l.addEventListener('click', function() { if (flag) { flag = false; if (num == 0) { num = ul.children.length - 1; ul.style.left = -num * focusWidth + 'px'; } num--; animate(ul, -num * focusWidth, function() { flag = true; }); // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放 circle--; // 如果circle &lt; 0 说明第一张图片，则小圆圈要改为第4个小圆圈（3） // if (circle &lt; 0) { // circle = ol.children.length - 1; // } circle = circle &lt; 0 ? ol.children.length - 1 : circle; // 调用函数 circleChange(); } }); function circleChange() { // 先清除其余小圆圈的current类名 for (var i = 0; i &lt; ol.children.length; i++) { ol.children[i].className = ''; } // 留下当前的小圆圈的current类名 ol.children[circle].className = 'current'; } // 10. 自动播放轮播图 var timer = setInterval(function() { //手动调用点击事件 arrow_r.click(); }, 2000); }) 节流阀 防止轮播图按钮连续点击造成播放过快。 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。 开始设置一个变量var flag= true; If(flag){flag = false; do something} 关闭水龙头 利用回调函数动画执行完毕， flag = true 打开水龙头 返回顶部 带有动画的返回顶部 此时可以继续使用我们封装的动画函数 只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了 页面滚动了多少，可以通过 window.pageYOffset 得到 最后是页面滚动，使用 window.scroll(x,y) //1. 获取元素 var sliderbar = document.querySelector('.slider-bar'); var banner = document.querySelector('.banner'); // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面 var bannerTop = banner.offsetTop // 当我们侧边栏固定定位之后应该变化的数值 var sliderbarTop = sliderbar.offsetTop - bannerTop; // 获取main 主体元素 var main = document.querySelector('.main'); var goBack = document.querySelector('.goBack'); var mainTop = main.offsetTop; // 2. 页面滚动事件 scroll document.addEventListener('scroll', function() { // console.log(11); // window.pageYOffset 页面被卷去的头部 // console.log(window.pageYOffset); // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位 if (window.pageYOffset &gt;= bannerTop) { sliderbar.style.position = 'fixed'; sliderbar.style.top = sliderbarTop + 'px'; } else { sliderbar.style.position = 'absolute'; sliderbar.style.top = '300px'; } // 4. 当我们页面滚动到main盒子，就显示 goback模块 if (window.pageYOffset &gt;= mainTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }) // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方 goBack.addEventListener('click', function() { // 里面的x和y 不跟单位的 直接写数字即可 // window.scroll(0, 0); // 因为是窗口滚动 所以对象是window animate(window, 0); }); 筋头云案例 利用动画函数做动画效果 原先筋斗云的起始位置是0 鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可 鼠标离开某个小li，就把目标值设为 0 如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置 window.addEventListener('load', function() { // 1. 获取元素 var cloud = document.querySelector('.cloud'); var c_nav = document.querySelector('.c-nav'); var lis = c_nav.querySelectorAll('li'); // 2. 给所有的小li绑定事件 // 这个current 做为筋斗云的起始位置 var current = 0; for (var i = 0; i &lt; lis.length; i++) { // (1) 鼠标经过把当前小li 的位置做为目标值 lis[i].addEventListener('mouseenter', function() { animate(cloud, this.offsetLeft); }); // (2) 鼠标离开就回到起始的位置 lis[i].addEventListener('mouseleave', function() { animate(cloud, current); }); // (3) 当我们鼠标点击，就把当前位置做为目标值 lis[i].addEventListener('click', function() { current = this.offsetLeft; }); } }) 触屏事件 触屏事件概述 移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下： 触摸事件对象（TouchEvent） TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 touchstart、touchmove、touchend 三个事件都会各自有事件对象。 ![图片2](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/图片2.png) 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes 移动端拖动元素 touchstart、touchmove、touchend 可以实现拖动元素 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 拖动元素三步曲： （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 （3） 离开手指 touchend: 注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault(); 移动端常见特效 案例: 移动轮播图 移动端轮播图功能和基本PC端一致。 可以自动播放图片 手指可以拖动播放轮播图 案例分析: 自动播放功能 开启定时器 移动端移动，可以使用translate 移动 想要图片优雅的移动，请添加过渡效果 // 1. 获取元素 var focus = document.querySelector('.focus'); var ul = focus.children[0]; // 获得focus 的宽度 var w = focus.offsetWidth; var ol = focus.children[1]; // 2. 利用定时器自动轮播图图片 var index = 0; var timer = setInterval(function() { index++; var translatex = -index * w; ul.style.transition = 'all .3s'; ul.style.transform = 'translateX(' + translatex + 'px)'; }, 2000); 自动播放功能-无缝滚动 注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断 此时需要添加检测过渡完成事件 transitionend 判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0 此时图片，去掉过渡效果，然后移动 如果索引号小于0， 说明是倒着走， 索引号等于2 此时图片，去掉过渡效果，然后移动 // 等着我们过渡完成之后，再去判断 监听过渡完成的事件 transitionend ul.addEventListener('transitionend', function() { // 无缝滚动 if (index &gt;= 3) { index = 0; // console.log(index); // 去掉过渡效果 这样让我们的ul 快速的跳到目标位置 ul.style.transition = 'none'; // 利用最新的索引号乘以宽度 去滚动图片 var translatex = -index * w; ul.style.transform = 'translateX(' + translatex + 'px)'; } else if (index &lt; 0) { index = 2; ul.style.transition = 'none'; // 利用最新的索引号乘以宽度 去滚动图片 var translatex = -index * w; ul.style.transform = 'translateX(' + translatex + 'px)'; } classList 属性 classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。 该属性用于在元素中添加，移除及切换 CSS 类。有以下方法 添加类： element.classList.add（’类名’）； focus.classList.add('current'); 移除类： element.classList.remove（’类名’）; focus.classList.remove('current'); 切换类： element.classList.toggle（’类名’）; focus.classList.toggle('current'); 注意:以上方法里面，所有类名都不带点 案例分析 小圆点跟随变化效果 把ol里面li带有current类名的选出来去掉类名 remove 让当前索引号的小li 加上 current add 但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面 // 3. 小圆点跟随变化 // 把ol里面li带有current类名的选出来去掉类名 remove ol.querySelector('.current').classList.remove('current'); // 让当前索引号 的小li 加上 current add ol.children[index].classList.add('current'); 手指滑动轮播图 本质就是ul跟随手指移动，简单说就是移动端拖动元素 触摸元素touchstart： 获取手指初始坐标 移动手指touchmove： 计算手指的滑动距离，并且移动盒子 离开手指touchend: 根据滑动的距离分不同的情况 如果移动距离小于某个像素 就回弹原来位置 如果移动距离大于某个像素就上一张下一张滑动。 滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑 如果是左滑就播放下一张 （index++） 如果是右滑就播放上一张 (index--) // 4. 手指滑动轮播图 // 触摸元素 touchstart： 获取手指初始坐标 var startX = 0; var moveX = 0; // 后面我们会使用这个移动距离所以要定义一个全局变量 var flag = false; ul.addEventListener('touchstart', function(e) { startX = e.targetTouches[0].pageX; // 手指触摸的时候就停止定时器 clearInterval(timer); }); // 移动手指 touchmove： 计算手指的滑动距离， 并且移动盒子 ul.addEventListener('touchmove', function(e) { // 计算移动距离 moveX = e.targetTouches[0].pageX - startX; // 移动盒子： 盒子原来的位置 + 手指移动的距离 var translatex = -index * w + moveX; // 手指拖动的时候，不需要动画效果所以要取消过渡效果 ul.style.transition = 'none'; ul.style.transform = 'translateX(' + translatex + 'px)'; flag = true; // 如果用户手指移动过我们再去判断否则不做判断效果 e.preventDefault(); // 阻止滚动屏幕的行为 }); // 手指离开 根据移动距离去判断是回弹还是播放上一张下一张 ul.addEventListener('touchend', function(e) { if (flag) { // (1) 如果移动距离大于50像素我们就播放上一张或者下一张 if (Math.abs(moveX) &gt; 50) { // 如果是右滑就是 播放上一张 moveX 是正值 if (moveX &gt; 0) { index--; } else { // 如果是左滑就是 播放下一张 moveX 是负值 index++; } var translatex = -index * w; ul.style.transition = 'all .3s'; ul.style.transform = 'translateX(' + translatex + 'px)'; } else { // (2) 如果移动距离小于50像素我们就回弹 var translatex = -index * w; ul.style.transition = 'all .1s'; ul.style.transform = 'translateX(' + translatex + 'px)'; } } // 手指离开的时候就重新开启定时器 clearInterval(timer); timer = setInterval(function() { index++; var translatex = -index * w; ul.style.transition = 'all .3s'; ul.style.transform = 'translateX(' + translatex + 'px)'; }, 2000); 案例：返回顶部 当页面滚动某个地方，就显示，否则隐藏 点击可以返回顶部 案例分析 滚动某个地方显示 事件：scroll页面滚动事件 如果被卷去的头部（window.pageYOffset ）大于某个数值 点击，window.scroll(0,0) 返回顶部 var goBack = document.querySelector('.goBack'); var nav = document.querySelector('nav'); window.addEventListener('scroll', function() { if (window.pageYOffset &gt;= nav.offsetTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }); goBack.addEventListener('click', function() { window.scroll(0, 0); }) click 延时解决方案 移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。 解决方案： ​ 1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; ​ 2.利用touch事件自己封装这个事件解决300ms 延迟。 ​ 原理就是： 当我们手指触摸屏幕，记录当前触摸时间 当我们手指离开屏幕， 用离开的时间减去触摸的时间 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击 代码如下: //封装tap，解决click 300ms 延时 function tap (obj, callback) { var isMove = false; var startTime = 0; // 记录触摸时候的时间变量 obj.addEventListener('touchstart', function (e) { startTime = Date.now(); // 记录触摸时间 }); obj.addEventListener('touchmove', function (e) { isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击 }); obj.addEventListener('touchend', function (e) { if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) { // 如果手指触摸和离开时间小于150ms 算点击 callback &amp;&amp; callback(); // 执行回调函数 } isMove = false; // 取反 重置 startTime = 0; }); } //调用 tap(div, function(){ // 执行代码 }); 使用插件。fastclick 插件解决300ms 延迟。 &lt;script&gt; if ('addEventListener' in document) { document.addEventListener('DOMContentLoaded', function() { FastClick.attach(document.body); }, false); } var div = document.querySelector('div'); div.addEventListener('click', function() { alert(11); }) &lt;/script&gt; 移动端常用开发插件 什么是插件 移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？ JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。 特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 我们以前写的animate.js 也算一个最简单的插件 fastclick 插件解决 300ms 延迟。 使用延时 GitHub官网地址： https://github.com/ftlabs/fastclick 插件的使用 引入 js 插件文件。 按照规定语法使用。 fastclick 插件解决 300ms 延迟。 使用延时 GitHub官网地址： https://github.com/ftlabs/fastclick if ('addEventListener' in document) { document.addEventListener('DOMContentLoaded', function() { FastClick.attach(document.body); }, false); } Swiper 插件的使用 中文官网地址： https://www.swiper.com.cn/ 引入插件相关文件。 按照规定语法使用 其他移动端常见插件 lsuperslide： http://www.superslide2.com/ l iscroll： https://github.com/cubiq/iscroll 插件的使用总结 1.确认插件实现的功能 2.去官网查看使用说明 3.下载插件 4.打开demo实例文件，查看需要引入的相关文件，并且引入 5.复制demo实例文件中的结构html，样式css以及js代码 移动端视频插件 zy.media.js H5 给我们提供了 video 标签，但是浏览器的支持情况不同。 不同的视频格式文件，我们可以通过source解决。 但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。 这个时候我们可以使用插件方式来制作。 我们可以通过 JS 修改元素的大小、颜色、位置等样式。 移动端常用开发框架 移动端视频插件 zy.media.js 框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。 插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端 前端常用的移动端插件有 swiper、superslide、iscroll等。 框架： 大而全，一整套解决方案 插件： 小而专一，某个功能的解决方案 Bootstrap Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。 它能开发PC端，也能开发移动端 Bootstrap JS插件使用步骤： 1.引入相关js 文件 2.复制HTML 结构 3.修改对应样式 4.修改相应JS 参数 本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 本地存储特性 1、数据存储在用户浏览器中 2、设置、读取方便、甚至页面刷新不丢失数据 3、容量较大，sessionStorage约5M、localStorage约20M 4、只能存储字符串，可以将对象JSON.stringify() 编码后存储 window.sessionStorage 1、生命周期为关闭浏览器窗口 2、在同一个窗口(页面)下数据可以共享 3、以键值对的形式存储使用 存储数据： sessionStorage.setItem(key, value) 获取数据： sessionStorage.getItem(key) 删除数据： sessionStorage.removeItem(key) 清空数据：(所有都清除掉) sessionStorage.clear() window.localStorage 1、声明周期永久生效，除非手动删除 否则关闭页面也会存在 2、可以多窗口（页面）共享（同一浏览器可以共享） 3. 以键值对的形式存储使用 存储数据： localStorage.setItem(key, value) 获取数据： localStorage.getItem(key) 删除数据： localStorage.removeItem(key) 清空数据：(所有都清除掉) localStorage.clear() 记住用户名 如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名 案例分析 把数据存起来，用到本地存储 关闭页面，也可以显示用户名，所以用到localStorage 打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框 当复选框发生改变的时候change事件 如果勾选，就存储，否则就移除 &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;remember&quot;&gt; 记住用户名 &lt;script&gt; var username = document.querySelector('#username'); var remember = document.querySelector('#remember'); if (localStorage.getItem('username')) { username.value = localStorage.getItem('username'); remember.checked = true; } remember.addEventListener('change', function() { if (this.checked) { localStorage.setItem('username', username.value) } else { localStorage.removeItem('username'); } }) &lt;/script&gt; ","link":"https://xmweijh.github.io/post/webapis/"},{"title":"JS基础","content":"JavaScript基础 JS 的组成 ECMAScript ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。 ​ ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 更多参看MDN: MDN手册 DOM——文档对象模型 文档对象模型（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等） BOM——浏览器对象模型 浏览器对象模型(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 JS 书写位置 JS 有3种书写位置，分别为行内、内嵌和外部。 行内式 &lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert('Hello World')&quot; /&gt; 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号 可读性差， 在html中编写JS大量代码时，不方便阅读； 引号易错，引号多层嵌套匹配时，非常容易弄混； 特殊情况下使用 内嵌式 &lt;script&gt; alert('Hello World~!'); &lt;/script&gt; 可以将多行JS代码写到 script 标签中 内嵌 JS 是学习时常用的方式 外部JS文件 &lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt; 利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用 引用外部 JS文件的 script 标签中间不可以写代码 适合于JS 代码量比较大的情况 JavaScript注释 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） 单行注释 为了提高代码的可读性，JS与CSS一样，也提供了注释功能。 JS中的注释主要有两种，分别是 单行注释 和 多行注释。 单行注释的注释方式如下： // 我是一行文字，不想被 JS引擎 执行，所以 注释起来 // 用来注释单行文字（ 快捷键 ctrl + / ） 多行注释 多行注释的注释方式如下： /* 获取用户年龄和姓名 并通过提示框显示出来 */ /* */ 用来注释多行文字（ 默认快捷键 alt + shift + a ） 快捷键修改为： ctrl + shift + / vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认 JavaScript输入输出语句 为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 变量的概念 白话：变量就是一个装东西的盒子。 通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 变量在内存中的存储 本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 变量的使用 变量的声明 变量的赋值 声明变量 // 声明变量 var age; // 声明一个 名称为age 的变量 var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 赋值 age = 10; // 给 age 这个变量赋值为 10 = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思 变量值是程序员保存到变量空间里的值 变量的初始化 var age = 18; // 声明变量同时赋值为 18 // 声明一个变量并赋值， 我们称之为变量的初始化。 变量语法扩展 更新变量 ​ 一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 var age = 18; age = 81; // 最后的结果就是81因为18 被覆盖掉了 同时声明多个变量 ​ 同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。 var age = 10, name = 'zs', sex = 2; 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10; console.log (age); 不声明 只赋值 10 变量命名规范 规则： 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 严格区分大小写。var app; 和 var App; 是两个变量 不能 以数字开头。 18age 是错误的 不能 是关键字、保留字。例如：var、for、while 变量名必须有意义。 MMD BBD nl → age 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName 数据类型 变量的数据类型 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： var age = 10; // 这是一个数字型 var areYouOk = '是的'; // 这是一个字符串 ​ 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： var x = 6; // x 为数字 var x = &quot;Bill&quot;; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null） 复杂数据类型 （object) 简单数据类型 简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number ​ JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。 var age = 21; // 整数 var Age = 21.3747; // 小数 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 // 1.八进制数字序列范围：0~7 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~F var num = 0xA; 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 数字型三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number，代表一个非数值 isNaN 用来判断一个变量是否为非数字的类型，返回 true 或者 false var usrAge = 21; var isOk = isNaN(userAge); console.log(isNum); // false ，21 不是一个非数字 var usrName = &quot;andy&quot;; console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字 字符串型 String ​ 字符串型可以是引号中的任意文本，其语法为 双引号 &quot;&quot; 和 单引号'' var strMsg = &quot;我爱北京天安门~&quot;; // 使用双引号表示字符串 var strMsg2 = '我爱吃猪蹄~'; // 使用单引号表示字符串 // 常见错误 var strMsg3 = 我爱大肘子; // 报错，没使用引号，会被认为是js代码，但js没有这些语法 ​ 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。 字符串引号嵌套 ​ JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双) var strMsg = '我是&quot;高帅富&quot;程序猿'; // 可以用''包含&quot;&quot; var strMsg2 = &quot;我是'高帅富'程序猿&quot;; // 也可以用&quot;&quot; 包含'' // 常见错误 var badQuotes = 'What on earth?&quot;; // 报错，不能 单双引号搭配 字符串转义符 ​ 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 ​ 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ ' ' 单引号 &quot; ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 var strMsg = &quot;我是帅气多金的程序猿！&quot;; alert(strMsg.length); // 显示 11 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 //1.1 字符串 &quot;相加&quot; alert('hello' + ' ' + 'world'); // hello world //1.2 数值字符串 &quot;相加&quot; alert('100' + '100'); // 100100 //1.3 数值字符串 + 数值 alert('11' + 12); // 1112 + 号总结口诀：数值相加 ，字符相连 字符串拼接加强 console.log('pink老师' + 18); // 只要有字符就会相连 var age = 18; console.log('pink老师age岁啦'); // 这样不行哦 console.log('pink老师' + age); // pink老师18 console.log('pink老师' + age + '岁啦'); // pink老师18岁啦 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间 布尔型Boolean ​ 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 ​ 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 console.log(true + 1); // 2 console.log(false + 1); // 1 Undefined和 Null ​ 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） var variable; console.log(variable); // undefined console.log('你好' + variable); // 你好undefined console.log(11 + variable); // NaN console.log(true + variable); // NaN ​ 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) var vari = null; console.log('你好' + vari); // 你好null console.log(11 + vari); // 11 console.log(true + vari); // 1 获取变量数据类型 获取检测变量的数据类型 ​ typeof 可用来获取检测变量的数据类型 var num = 18; console.log(typeof num) // 结果 number 字面量 ​ 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数据类型转换 ​ 什么是数据类型转换？ ​ 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换： 转换为字符串类型 转换为数字型 转换为布尔型 转换为字符串 toString() 和 String() 使用方式不一样。 三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。 转换为数字型（重点） 注意 parseInt 和 parseFloat 单词的大小写，这2个是重点 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型 转换为布尔型 代表空、否定的值会被转换为 false ，如 ''、0、NaN、null、undefined 其余值都会被转换为 true console.log(Boolean('')); // false console.log(Boolean(0)); // false console.log(Boolean(NaN)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean('小白')); // true console.log(Boolean(12)); // true 解释型语言和编译型语言 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器) 执行过程 类似于请客吃饭： 编译语言：首先把所有菜做好，才能上桌吃饭 解释语言：好比吃火锅，边吃边涮，同时进行 关键字和保留字 标识符 标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。 标识符不能是关键字或保留字。 关键字 关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。 保留字 保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。 运算符（操作符） 运算符的分类 运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。 JavaScript中常用的运算符有： 算数运算符 递增和递减运算符 比较运算符 逻辑运算符 赋值运算符 算数运算符 算术运算符概述 概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 浮点数的精度问题 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001 所以：不要直接判断两个浮点数是否相等 ! 表达式和返回值 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 简单理解：是由数字、运算符、变量等组成的式子 表达式最终都会有一个结果，返回给开发者，称为返回值 递增和递减运算符 递增和递减运算符概述 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。 在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。 注意：递增和递减运算符必须和变量配合使用。 递增运算符 前置递增运算符 ++num 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。 使用口诀：先自加，后返回值 var num = 10; alert(++num + 10); // 21 后置递增运算符 num++ 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。 使用口诀：先返回原值，后自加 var num = 10; alert(10 + num++); // 20 比较运算符 比较运算符概述 概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。 等号比较 console.log(18 == '18'); console.log(18 === '18'); 逻辑运算符 逻辑运算符概述 概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断 逻辑与&amp;&amp; 两边都是 true才返回 true，否则返回 false 逻辑或 || 两边都是 true才返回 true，否则返回 false 逻辑非 ！ 逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false var isOk = !true; console.log(isOk); // false 短路运算（逻辑中断） 短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值; 逻辑与 语法： 表达式1 &amp;&amp; 表达式2 - 如果第一个表达式的值为真，则返回表达式2 - 如果第一个表达式的值为假，则返回表达式1 console.log( 123 &amp;&amp; 456 ); // 456 console.log( 0 &amp;&amp; 456 ); // 0 console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789 逻辑或 语法： 表达式1 || 表达式2 - 如果第一个表达式的值为真，则返回表达式1 - 如果第一个表达式的值为假，则返回表达式2 console.log( 123 || 456 ); // 123 console.log( 0 || 456 ); // 456 console.log( 123 || 456 || 789 ); // 123 赋值运算符 概念：用来把数据赋值给变量的运算符。 var age = 10; age += 5; // 相当于 age = age + 5; age -= 5; // 相当于 age = age - 5; age *= 10; // 相当于 age = age * 10; 运算符优先级 一元运算符里面的逻辑非优先级很高 逻辑与比逻辑或优先级高 流程控制 流程控制概念 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。 简单理解：**流程控制就是来控制代码按照一定结构顺序来执行** 流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。 switch 语句和 if else if 语句的区别 一般情况下，它们两个语句可以相互替换 switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围) switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。 当分支比较少时，if… else语句的执行效率比 switch语句高。 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。 断点调试： 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程 断点调试的流程： 1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。 3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。 标识符命名规范 变量、函数的命名必须要有意义 变量的名称一般用名词 函数的名称一般用动词 操作符规范 // 操作符的左右两侧各保留一个空格 for (var i = 1; i &lt;= 5; i++) { if (i == 3) { break; // 直接退出整个 for 循环，跳到整个for循环下面的语句 } console.log('我正在吃第' + i + '个包子呢'); } 单行注释规范 for (var i = 1; i &lt;= 5; i++) { if (i == 3) { break; // 单行注释前面注意有个空格 } console.log('我正在吃第' + i + '个包子呢'); } 其他规范 关键词、操作符之间后加空格 创建数组 JS 中创建数组有两种方式： 利用 new 创建数组 var 数组名 = new Array() ； var arr = new Array(); // 创建一个新的空数组 注意 Array () ，A 要大写 利用数组字面量创建数组 //1. 使用数组字面量方式创建空的数组 var 数组名 = []； //2. 使用数组字面量方式创建带初始值的数组 var 数组名 = ['小白','小黑','大黄','瑞奇']; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 var arrStus = ['小白',12,true,28.9]; 获取数组中的元素 ​ 索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 ​ 数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。 // 定义数组 var arrStus = [1,2,3]; // 获取数组中的第2个元素 alert(arrStus[1]); 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 遍历数组 数组遍历 ​ 把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项 var arr = ['red','green', 'blue']; for(var i = 0; i &lt; arr.length; i++){ console.log(arrStus[i]); } 数组的长度 数组的长度：默认情况下表示数组中元素的个数 使用“数组名.length”可以访问数组元素的数量（数组长度）。 var arrStus = [1,2,3]; alert(arrStus.length); // 3 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。 当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化 数组的length属性可以被修改： 如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素； 如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除 数组中新增元素 ​ 数组中可以通过以下方式在数组的末尾插入新元素： 数组[ 数组.length ] = 新数据; 函数 函数的概念 ​ 在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 ​ 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 函数的使用 声明函数 // 声明函数 function 函数名() { //函数体代码 } function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数 // 调用函数 函数名(); // 通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） 例子：封装计算1-100累加和 /* 计算1-100之间值的函数 */ // 声明函数 function getSum(){ var sumNum = 0;// 准备一个变量，保存数字和 for (var i = 1; i &lt;= 100; i++) { sumNum += i;// 把每个数值 都累加 到变量中 } alert(sumNum); } // 调用函数 getSum(); 函数的参数 函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 ​ 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。 函数参数的运用： // 带参数的函数声明 function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔 // 函数体 } // 带参数的函数调用 函数名(实参1, 实参2, 实参3...); 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 注意：在JavaScript中，形参的默认值是undefined。 小结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配 函数的返回值 return 语句 返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 // 声明函数 function 函数名（）{ ... return 需要返回的值； } // 调用函数 函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 arguments的使用 ​ 当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。 &lt;script&gt; // 利用函数求任意个数的最大值 function getMax() { // arguments = [1,2,3] var max = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) { if (arguments[i] &gt; max) { max = arguments[i]; } } return max; } console.log(getMax(1, 2, 3)); console.log(getMax(1, 2, 3, 4, 5)); console.log(getMax(11, 2, 34, 444, 5, 100)); &lt;/script&gt; 函数案例 函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。 函数的两种声明方式 自定义函数方式(命名函数) 利用函数关键字 function 自定义函数方式 // 声明定义方式 function fn() {...} // 调用 fn(); 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数） 利用函数表达式方式的写法如下： // 这是函数表达式写法，匿名函数后面跟分号结束 var fn = function(){...}； // 调用的方式，函数调用必须写到函数体下面 fn(); 因为函数没有名字，所以也被称为匿名函数 这个fn 里面存储的是一个函数 函数表达式方式原理跟声明变量方式是一致的 函数调用的代码必须写到函数体后面 ​ 1. 我们js引擎运行js 分为两步： 预解析 代码执行 ​ (1). 预解析 js引擎会把js 里面所有的 var 还有 function 提升到当前作用域的最前面 ​ (2). 代码执行 按照代码书写的顺序从上往下执行 ​ 2. 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升） ​ (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作 ​ (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数 创建对象的三种方式 利用字面量创建对象 使用对象字面量创建对象： 就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 代码如下： var star = { name : 'pink', age : 18, sex : '男', sayHi : function(){ alert('大家好啊~'); } }; 对象[‘属性名’]，注意方括号里面的属性必须加引号 示例代码如下： console.log(star.name) // 调用名字属性 console.log(star['name']) // 调用名字属性 调用对象的方法 对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 示例代码如下： star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号 变量、属性、函数、方法总结 属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征 方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器 函数：单独存在的，通过“函数名()”的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。 利用 new Object 创建对象 创建空对象 var andy = new Obect(); 通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象 给空对象添加属性和方法 通过对象操作属性和方法的方式，来为对象增加属性和方法 示例代码如下： andy.name = 'pink'; andy.age = 18; andy.sex = '男'; andy.sayHi = function(){ alert('大家好啊~'); } 注意： Object() ：第一个字母大写 new Object() ：需要 new 关键字 使用的格式：对象.属性 = 值; 利用构造函数创建对象 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的封装格式： function 构造函数名(形参1,形参2,形参3) { this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体; } 构造函数的调用格式 var obj = new 构造函数名(实参1，实参2，实参3) 以上代码中，obj即接收到构造函数创建出来的对象。 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 其他 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this---即创建出来的对象 遍历对象 for...in 语句用于对数组或者对象的属性进行循环操作。 其语法如下： for (变量 in 对象名字) { // 在此执行代码 } 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 for (var k in obj) { console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值 } 预解析的相关概念 JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。 代码执行： 从上到下执行JS语句。 预解析会把变量和函数的声明在代码执行之前执行完成。 变量预解析 预解析也叫做变量、函数提升。 变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 console.log(num); // 结果是多少？ var num = 10; // ？ 结果：undefined 注意：**变量提升只提升声明，不提升赋值** 函数预解析 函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 fn(); function fn() { console.log('打印'); } 结果：控制台打印字符串 --- ”打印“ 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 函数表达式声明函数问题 函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用： fn(); var fn = function() { console.log('想不到吧'); } 结果：报错提示 ”fn is not a function&quot; 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用 //函数的预解析 var num=1; function demo(){ console.log(num); function demoSon(){ num=3; } var num=2; demoSon(); } demo(); //相当于 var num;//作用域在全局 function demo(); num=1; function demo(){ var num; function demoSon(); console.log(num); function demoSon(){ num=3; } num=2;//num在函数作用域 demoSon(); } demo(); //var num = 2，声明会提前，但不会赋值 num会变为undefined 所以不会输出1 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象 ​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 ​ JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 Math对象 ​ Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()/Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 ​ 注意：上面的方法使用时必须带括号 console.log(Math.round(1.5)); // 2 console.log(Math.round(-1.5)); // 这个结果是 -1 ​ 获取指定范围内的随机整数： function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } 日期对象 ​ Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化： var now = new Date(); 获取指定时间的日期对象 var future = new Date('2010/5/1'); 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 使用Date实例的方法和属性 通过Date实例获取总毫米数 总毫秒数的含义 ​ 基于1970年1月1日（世界标准时间）起的毫秒数 获取总毫秒数 // 实例化Date对象 var now = new Date(); // 1. 用于获取对象的原始值 console.log(date.valueOf()) console.log(date.getTime()) // 2. 简单写可以这么做 var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题 var now = Date.now(); 数组对象 创建数组的两种方式 字面量方式 示例代码如下： var arr = [1,&quot;test&quot;,true]; new Array() 示例代码如下： var arr = new Array(); ​ 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 ​ 参数传递规则如下： 如果只传入一个参数，则参数规定了数组的长度 如果传入了多个参数，则参数称为数组的元素 检测是否为数组 instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 var arr = [1, 23]; var obj = {}; console.log(arr instanceof Array); // true console.log(obj instanceof Array); // false Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 var arr = [1, 23]; var obj = {}; console.log(Array.isArray(arr)); // true console.log(Array.isArray(obj)); // false 添加删除数组元素的方法 数组中有进行增加、删除元素的方法，部分方法如下表 注意：push、unshift为增加元素方法；pop、shift为删除元素的方法 数组排序 数组中有对数组本身排序的方法，部分方法如下表 注意：sort方法需要传入参数来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 数组索引方法 数组中有获取数组指定元素索引值的方法，部分方法如下表 数组转换为字符串 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 其他方法 字符串对象 基本包装类型 ​ 为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 ​ 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 // 下面代码有什么问题？ var str = 'andy'; console.log(str.length); ​ 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 ​ js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： // 1. 生成临时变量，把简单类型包装为复杂数据类型 var temp = new String('andy'); // 2. 赋值给我们声明的字符变量 str = temp; // 3. 销毁临时变量 temp = null; 字符串的不可变 ​ 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 ​ 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。 ​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 根据字符返回位置 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： ​ 案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 根据位置返回字符 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： ​ 在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码 ​ 案例：判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 ​ 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数 字符串操作方法 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： replace()方法 ​ replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法 ​ split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 ​ 其使用格式如下： 字符串.split(&quot;分割字符&quot;) 简单数据类型和复杂数据类型 简单数据类型 ​ 简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 复杂数据类型 ​ 复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 堆栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 ​ 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 ​ 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 简单类型传参 ​ 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 复杂数据类型传参 ​ 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 ","link":"https://xmweijh.github.io/post/js-ji-chu/"},{"title":"STL","content":"STL STL六大组件 容器、算法、迭代器、仿函数、适配器、空间配置器 STL优点 内建在C++编译器中，不需要安装额外内容 不需要了解具体实现内容，只要熟练运用即可 高复用，可移植，高性能 容器划分 序列式容器 关联式容器 有个key起到索引作用 算法 变算法 非质变算法 vector容器 vectorv vector::iterator itBegin = v.begin(); //v.begin() 起始迭代器，指向容器中第一个数据 vector::iterator itEnd = v.end(); //v.end()；结束迭代器，指向的是容器中最后一个元素的下一个位置 利用算法遍历容器 for_each(v.begin(),v.end() , myPrint ) 头文件 algorithm 容器中存放自定义数据类型 容器中存放自定义数据类型指针 容器嵌套容器 vector&lt;vector&lt;int&gt;&gt;v; vector&lt;int&gt;v1; vector&lt;int&gt;v2; vector&lt;int&gt;v3; for (int i = 0; i &lt; 5; i++) { v1.push_back(i + 1); v2.push_back(i + 10); v3.push_back(i + 100); } //将小容器放入到大容器中 v.push_back(v1); v.push_back(v2); v.push_back(v3); //遍历大容器 for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end();it++) { // *it ==== vector&lt;int&gt; for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end();vit++) { cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } string 构造、赋值 []、at 字符存取 [] 和 at区别 []访问越界 直接挂掉，at抛出out_of_range异常 string str = &quot;hello world&quot;; //for (int i = 0; i &lt; str.size();i++) //{ // //cout &lt;&lt; str[i] &lt;&lt; endl; // cout &lt;&lt; str.at(i) &lt;&lt; endl; //} //[]和at区别，[]访问越界 直接挂掉 ， at访问越界 抛出out_of_range异常 try { //cout &lt;&lt; str[100] &lt;&lt; endl; cout &lt;&lt; str.at(100) &lt;&lt; endl; } catch (out_of_range &amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; } catch (...) { cout &lt;&lt; &quot;异常捕获&quot; &lt;&lt; endl; } 字符串拼接 += append 查找 find rfind(从右往左查找) 替换 replace //替换 //string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str str.replace(1, 3, &quot;11111&quot;);//不是只替换三个1，而是将三个替换为五个 //a11111efgde cout &lt;&lt; str &lt;&lt; endl; 比较 compare 子串 substr string email = &quot;zhangtao@sina.com&quot;; int pos = email.find(&quot;@&quot;); // 8 string userName = email.substr(0, pos);//pos任然是8而非加减，因为截取几个是从1开始的 cout &lt;&lt; userName &lt;&lt; endl; string str = &quot;www.itcast.com.cn&quot;; vector&lt;string&gt; v; //将 www itcast com cn 单词截取到 vector容器中 int start = 0; int pos = -1; while (true) { //www.itcast.com.cn pos = str.find(&quot;.&quot;, start); if (pos == -1) { //将cn截取出来 string tempStr = str.substr(start,str.size() - start); v.push_back(tempStr); break; } string tempStr = str.substr(start, pos - start); v.push_back(tempStr); start = pos + 1; } for (vector&lt;string&gt;::iterator it = v.begin(); it != v.end();it++) { cout &lt;&lt; *it &lt;&lt; endl; } 插入 insert 删除 erase string和const char* 转换 string 转 const char * .c_str(); const char * 转string 利用string 有参构造 const char *可以隐式转换为 string 反之不可以 小写转大写 toupper 大写转小写 tolower vector容器 单端数组 动态数组，自动扩展内存，所谓动态扩展内存，并不是在原有空间后续进行扩展，而是找一个更大的内存空间，将原有数据拷贝到新空间下，并且释放原有空间 接口 构造、赋值 交换 swap 大小 size 是否为空 empty 重置大小 resize 如果重置的比原来大，有默认值填充新位置 如果重置的比原来小，超出的部分删除掉 front 返回容器中第一个元素 back 返回容器中最后一个元素 插入 insert （迭代器） 删除 erase （迭代器） 尾插 push_back 尾删 pop_back 清空 clear 案例1 ：巧用swap收缩内存 vector&lt;int&gt;v; for (int i = 0; i &lt; 100000;i++) { v.push_back(i); } cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl; //巧用swap收缩内存 vector&lt;int&gt;(v).swap(v);//vector&lt;int&gt;(v) 以v的size创造匿名对象，再与v交换（实际是地址的交换），匿名对象运行后会被释放。 cout &lt;&lt; &quot;v.capacity = &quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v.size = &quot; &lt;&lt; v.size() &lt;&lt; endl; 案例2: ： 巧用reserve 预留内存 vector&lt;int&gt;v; v.reserve(100000); int * p = NULL; int num = 0; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); if (p != &amp;v[0]) { p = &amp;v[0]; num++; } } cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; 逆序遍历 reverse_iterator 非质变 判断容器的迭代器是否支持随机访问 deque容器 双端数组 可以对头部进行插入和删除操作，内部有中控器控制数据 接口 构造、赋值 交换 swap 大小 size 是否为空 empty 重置大小 resize front 返回容器中第一个元素 back 返回容器中最后一个元素 插入 insert （迭代器） 删除 erase （迭代器） 头部插入 push_front 头部删除 pop_front 尾插 push_back 尾删 pop_back 清空 clear ​ sort排序 sort(v.begin(),v.end(), 回调函数) 栈容器 Stack 符合先进后出的数据结构 对外接口 入栈 push 出栈 pop 栈顶 top 是否为空 empty 栈大小 size 队列容器 Queue 符合先进先出的数据结构 对外接口 入队 push 出队 pop 队头元素 front 队尾元素 back 是否为空 empty 队列大小 size list容器 双向循环链表 对外接口 构造、赋值、大小、重置大小、是否为空 反转 reverse 排序 sort //如果容器的迭代器支持随机访问，可以使用系统提供的标志算法 //不支持随机访问的迭代器的容器，内部会提供对应的算法接口 对于自定义数据类型，必须要指定排序规则 对自定义数据类型做了高级排序 如果利用remove删除自定义数据类型，需要重载 == set 容器 关联式容器 key就是value 默认排好序 从小到大 插入 insert 大小 size 是否为空 empty 查找 find 返回值 迭代器 统计 count 对于set的结果 要么是0 要么是1 lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 pair对组 创建方式 pair&lt;string, int&gt; p(&quot;Tom&quot;, 10); pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 18); set.insert的返回值是个对组 pair&lt;iterator, bool&gt; bool代表插入是否成功 multiset可以插入重复的key值 可以指定set容器的排序规则，但是必须在插入前指定，利用仿函数的技术 对于自定义数据类型，set通常都会指定出排序规则 map容器 关联式容器 默认按照key从小到大排序 插入 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(make_pair(2, 20)); m.insert(map&lt;int, int&gt;::value_type(3, 30)); m[4] = 40; 查找 find 返回值 是迭代器 统计 count lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 利用仿函数 实现指定排序规则 STL容器使用时机 函数对象 本质是一个类的对象，因此称为函数对象，也叫仿函数 函数对象 超出了普通函数的概念，可以拥有自己状态 函数对象可以作为函数参数 谓词 普通函数或者仿函数的返回值是bool类型，称为谓词 一元谓词 查找容器中大于20的数字 find_if 二元谓词 对容器进行排序 sort lambda表达式 {} //lambda表达式 匿名函数 []代表lambda表达式标志 [](){} for_each(v.begin(), v.end(), [](int val){ cout &lt;&lt; val &lt;&lt; &quot; &quot;; }); 内建函数对象 引入头文件 #include&lt; functional&gt; 取反 negate 加法 plus 大于 greater //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); 适配器 函数对象适配器 //1、利用bind2nd 进行绑定 //2、继承 public binary_function&lt;参数1 类型,参数2类型,返回值类型&gt; //3、加const[1] class MyPrint :public binary_function&lt;int,int,void&gt; { public: void operator()(int val , int start)const { cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; &quot; start = &quot; &lt;&lt; start &lt;&lt; &quot; sum = &quot; &lt;&lt;val + start &lt;&lt; endl; } }; for_each(v.begin(), v.end(), bind2nd( MyPrint(), num ) ); 取反适配器 一元取反 not1 //1、利用not1进行取反 //2、继承 public unary_function&lt;int,bool&gt; //3、加const class GreaterThanFive:public unary_function&lt;int,bool&gt; { public: bool operator()(int val) const { return val &gt; 5; } }; //一元取反 //vector&lt;int&gt;::iterator pos = find_if(v.begin(), v.end(), not1( GreaterThanFive())); ​ 二元取反 not2 函数指针适配器 ptr_fun将普通函数指针 适配成函数对象 ​ 成员函数适配器[2] //利用 mem_fun_ref for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::showPerson)); 如果存放的是对象实体 mem_fun_ref 如果存放的是对象指针 mem_fun 常用遍历算法 for_each 用于遍历 有返回值 class MyPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; endl; m_Count++; } int m_Count = 0; }; MyPrint print = for_each(v.begin(), v.end(), MyPrint()); cout &lt;&lt; &quot;print.count = &quot; &lt;&lt; print.m_Count &lt;&lt; endl; 可以绑定参数进行输出 class MyPrint2 :public binary_function&lt;int,int,void&gt; { public: void operator()(int val , int start) const { cout &lt;&lt; val &lt;&lt; endl; } }; transform 搬运 注意：目标容器要有容量 class MyTransform { public: int operator()(int val) { return val + 10000; } }; void test() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } vector&lt;int&gt;v2; v2.resize(v.size());//如果不rize把v1向空的v2搬运会报错，v2会动态的扩充内存 transform(v.begin(), v.end(), v2.begin(), MyTransform()); for_each(v2.begin(), v2.end(), [](int val){cout &lt;&lt; val &lt;&lt; &quot; &quot;; }); } 常用查找算法 find 查找 find_if 按条件查找 adjacent_find算法 查找相邻重复元素 binary_search算法 二分查找法 注意: 在无序序列中不可用 **count算法 **统计元素出现次数 count_if 按条件进行统计 常用排序算法 merge 合并 将两个容器合并到 目标容器中 注意： 两个容器必须是有序序列 目标容器必须有容量 sort 排序 random_shuffle 洗牌 reverse 反转 常用的拷贝和替换算法 copy 拷贝 实现打印 copy(v.begin(),v.end() , ostream_iterator(cout , “ ”)); ostream_iterator需要#include &lt;iterator&gt; replace 替换 replace_if 按条件替换 ​ swap 交换 常用的算数生成算法 头文件 #include accumulate算法 计算容器元素累计总和 fill算法 向容器中添加元素 常用集合算法 set_intersection算法 求两个set集合的交集 set_union算法 求两个set集合的并集 set_difference算法 求两个set集合的差集 注意:两个集合必须是有序序列 这个const 修饰的是this指针，表示this指针指向的内存空间不能修改 ↩︎ 成员函数与成员函数是分开存储的，可不创造对象，找到函数地址调用 ↩︎ ","link":"https://xmweijh.github.io/post/stl/"},{"title":"CSS","content":"CSS 结构(html)与样式(css)相分离 主要用于设置 HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 引入CSS样式表 行内式 概念： ​ 称行内样式、行间样式. ​ 是通过标签的style属性来设置元素的样式 其基本语法格式如下： &lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt; 实际上任何HTML标签都拥有style属性，用来设置行内式。 案例： &lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 注意： style其实就是标签的属性 样式属性和值中间是: 多组属性值之间用;隔开。 只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余 缺点： 没有实现样式和结构相分离 内部样式表（内嵌样式表） 概念： ​ 称内嵌式 ​ 是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义 其基本语法格式如下： &lt;head&gt; &lt;style type=&quot;text/CSS&quot;&gt; 选择器（选择的标签） { 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; } &lt;/style&gt; &lt;/head&gt; &lt;style&gt; div { color: red; font-size: 12px; } &lt;/style&gt; 注意： style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。 type=&quot;text/css&quot; 在html5中可以省略。 只能控制当前的页面 缺点： 没有彻底分离 外部样式表（外链式） 概念： ​ 称链入式 ​ 是将所有的样式放在一个或多个以**.CSS**为扩展名的外部样式表文件中， ​ 通过link标签将外部样式表文件链接到HTML文档中 其基本语法格式如下： &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot;&gt; &lt;/head&gt; 注意： link 是个单标签 link标签需要放在head头部标签中，并且指定link标签的三个属性 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 type 定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略 href 定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 三种样式表总结（位置） 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） CSS选择器（重点） CSS选择器作用（重点） 找到特定的HTML页面元素 选择标签用的， 把我们想要的标签选择出来 CSS基础选择器 标签选择器 概念： 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。 语法： 标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 作用： 标签选择器 可以把某一类标签全部选择出来 比如所有的div标签 和 所有的 span标签 优点： 是能快速为页面中同类型的标签统一样式 缺点： 不能设计差异化样式。 类选择器 类选择器使用“.”（英文点号）进行标识，后面紧跟类名. 语法： 类名选择器 .类名 { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签 &lt;p class='类名'&gt;&lt;/p&gt; 优点： 可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 注意 类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的) 长名称或词组可以使用中横线来为选择器命名。 不要纯数字、中文等命名， 尽量使用英文字母来表示。 类选择器特殊用法- 多类名 我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 id选择器 id选择器使用#进行标识，后面紧跟id名 其基本语法格式如下： id选择器 #id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签 &lt;p id=&quot;id名&quot;&gt;&lt;/p&gt; 元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别 W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 类选择器我们在修改样式中，用的最多。 id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。 通配符选择器 概念 通配符选择器用*号表示， * 就是 选择所有的标签 他是所有选择器中作用范围最广的，能匹配页面中所有的元素。 其基本语法格式如下： * { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 * { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/ } 注意： 会匹配页面所有的元素，降低页面响应速度，不建议随便使用 基础选择器总结 选择器 作用 缺点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p { color：red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red; } id选择器 一次只能选择器1个标签 只能使用一次 不推荐使用 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 不推荐使用 * {color: red;} CSS字体样式属性调试工具 font字体 font-size:大小 作用： font-size属性用于设置字号 p { font-size:20px; } 单位： 可以使用相对长度单位，也可以使用绝对长度单位。 相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。 谷歌浏览器默认的文字大小为16px 但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小 font-family:字体 作用： font-family属性用于设置哪一种字体。 p{ font-family:&quot;微软雅黑&quot;;} 网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。 p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;} 1. 各种字体之间必须使用英文状态下的逗号隔开。 2. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。 3. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。 4. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 font-weight:字体粗细 在html中如何将字体加粗我们可以用标签来实现 使用 b 和 strong 标签是文本加粗。 可以使用CSS 来实现，但是CSS 是没有语义的。 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold 我们重点记住这句话 提倡： 我们平时更喜欢用数字来表示加粗和不加粗 font-style:字体风格 在html中如何将字体倾斜我们可以用标签来实现 字体倾斜除了用 i 和 em 标签， 可以使用CSS 来实现，但是CSS 是没有语义的 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 font:综合设置字体样式 (重点) font属性用于对字体样式进行综合设置 基本语法格式如下： 选择器 { font: font-style font-weight font-size/line-height font-family;} 注意： 使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 font总结 属性 表示 注意点 font-size 字号 我们通常用的单位是px 像素，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体粗细 记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位 font-style 字体样式 记住倾斜是 italic 不倾斜 是 normal 工作中我们最常用 normal font 字体连写 1. 字体连写是有顺序的 不能随意换位置 2. 其中字号 和 字体 必须同时出现 CSS外观属性 color:文本颜色 作用： color属性用于定义文本的颜色， 其取值方式有如下3种： 表示表示 属性值 预定义的颜色值 red，green，blue，还有我们的御用色 pink 十六进制 #FF0000，#FF6600，#29D794 RGB代码 rgb(255,0,0)或rgb(100%,0%,0%) 注意 我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如 #f00 代表红色 text-align:文本水平对齐方式 作用： text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 注意： 是让盒子里面的内容水平居中， 而不是让盒子居中对齐 line-height:行间距 作用： line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 单位： line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 技巧： 一般情况下，行距比字号大7.8像素左右就可以了。 line-height: 24px; text-indent:首行缩进 作用： text-indent属性用于设置首行文本的缩进， 属性值 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 p { /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; } text-decoration 文本的装饰 text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本下的一条线。（不常用） CSS外观属性总结 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none Emmet的前身是Zen coding,它使用缩写,来提高html/css的编写速度。 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ .demo$*3 &lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt; 后代选择器（重点） 概念： 后代选择器又称为包含选择器 作用： 用来选择元素或元素组的子孙后代 其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔，先写父亲爷爷，在写儿子孙子。 父级 子级{属性:属性值;属性:属性值;} 语法： .class h3{color:red;font-size:16px;} 当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器 作用： 子元素选择器只能选择作为某元素**子元素(亲儿子)**的元素。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 语法： .class&gt;h3{color:red;font-size:14px;} 比如： .demo &gt; h3 {color: red;} 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 交集选择器 条件 交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。 其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即...又...的意思 比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用 并集选择器（重点） 应用： 如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。 并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 语法： 任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。 记忆技巧： 并集选择器通常用于集体声明 ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。 比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 链接伪类选择器（重点） 伪类选择器： 为了和我们刚才学的类选择器相区别 类选择器是一个点 比如 .demo {} 而我们的伪类 用 2个点 就是 冒号 比如 :link{} 伪娘 作用： 用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。 a:link /* 未访问的链接 */ a:visited /* 已访问的链接 */ a:hover /* 鼠标移动到链接上 */ a:active /* 选定的链接 */ 注意 写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。否则可能引起错误。 记忆法 love hate 爱上了讨厌 **lv **包包 非常 hao 因为叫链接伪类，所以都是 利用交集选择器 a:link a:hover 因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 实际工作开发中，我们很少写全四个状态，一般我们写法如下： a { /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; } a:hover { /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */ } 复合选择器总结 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择 最近一级元素 只选亲儿子 较少 符号是**&gt;** .nav&gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav, .header 链接伪类选择器 给链接更改状态 较多 重点记住 a{} 和 a:hover 实际开发的写法 标签显示模式（display）重点 什么是标签的显示模式？ 标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个 作用： 我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(分类) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。 块级元素(block-level) 例： 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点 （1）比较霸道，自己独占一行 （2）高度，宽度、外边距以及内边距都可以控制。 （3）宽度默认是容器（父级宽度）的100% （4）是一个容器及盒子，里面可以放行内或者块级元素。 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放div 同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 行内元素(inline-level) 例： 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素 行内元素的特点： （1）相邻行内元素在一行上，一行可以显示多个。 （2）高、宽直接设置是无效的。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。 ​ 注意： 链接里面不能再放链接。 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 行内块元素（inline-block） 例： 在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个 （2）默认宽度就是它本身内容的宽度。 （3）高度，行高、外边距以及内边距都可以控制。 三种模式总结区别 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽度 标签显示模式转换 display 块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块： display: inline-block; 此阶段，我们只需关心这三个，其他的是我们后面的工作。 行高那些事（line-height） 单行文本垂直居中 行高 = 上距离 + 内容高度 + 下距离 上距离和下距离总是相等的，因此文字看上去是垂直居中的。 行高和高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 CSS 背景(background) 背景颜色(color) 语法： background-color:颜色值; 默认的值是 transparent 透明的 背景图片(image) 语法： background-image : none | url (url) 参数 作用 none 无背景图（默认的） url 使用绝对或相对地址指定背景图像 background-image : url(images/demo.png); 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat） 语法： background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 背景位置(position) 重点 语法： background-position : length || length background-position : position || position 参数 值 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right 方位名词 注意： 必须先指定background-image属性 position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。 如果position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是y 如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中 如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标 实际工作用的最多的，就是背景图片居中对齐了。 练习1： 背景大图 练习2： 小图片在盒子左侧垂直居中 背景附着 背景附着就是解释背景是滚动的还是固定的 语法： background-attachment : scroll | fixed 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 背景简写 background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 语法： background: transparent url(image.jpg) repeat-y scroll center top ; 案例： 导航栏案例 背景透明(CSS3) 语法： background: rgba(0, 0, 0, 0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 我们习惯把0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响 因为是CSS3 ，所以 低于 ie9 的版本是不支持的。 背景总结 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/no-repeat/repeat-x/repeat-y background-position 背景位置 length/position 分别是x 和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 background-attachment 背景固定还是滚动 scroll/fixed 背景简写 更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序 背景透明 让盒子半透明 background: rgba(0,0,0,0.3); 后面必须是 4个值 CSS 三大特性 CSS层叠性 概念： 所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 原则： 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠 CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性 概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性） CSS继承性口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 CSS优先级（重点） 概念： 定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 1). 权重计算公式 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器） 0,0,0,1 每个类，伪类 0,0,1,0 每个ID 0,1,0,0 每个行内样式 style=&quot;&quot; 1,0,0,0 每个!important 重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div { color: pink!important; } 2). 权重叠加 我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。 就是一个简单的加法计算 div ul li ------&gt; 0,0,0,3 .nav ul li ------&gt; 0,0,1,2 a:hover -----—&gt; 0,0,1,1 .nav a ------&gt; 0,0,1,1 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 3). 继承的权重是0 这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。 1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。 2） 如果没有选中，那么权重是0，因为继承的权重为0. CSS注释 CSS注释规则： /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 &quot;/*&quot; 标记开始注释，在内容的结尾使用 &quot;*/&quot;结束。 例如： p { /* 所有的字体是14像素大小*/ font-size: 14px; } 盒子模型（CSS重点） 所谓盒子模型： 就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们成为 盒子的边框 盒子内容与边框的距离是内边距（类似单元格的 cellpadding) 盒子与盒子之间的距离是外边距（类似单元格的 cellspacing） 盒子边框（border） 语法： border : border-width || border-style || border-color 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 边框综合设置 border : border-width || border-style || border-color 例如： border: 1px solid red; 没有顺序 盒子边框写法总结表 很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 表格的细线边框 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过css属性： table{ border-collapse:collapse; } collapse 单词是合并的意思 border-collapse:collapse; 表示相邻边框合并在一起。 &lt;style&gt; table { width: 500px; height: 300px; border: 1px solid red; } td { border: 1px solid red; text-align: center; } table, td { border-collapse: collapse; /*合并相邻边框*/ } &lt;/style&gt; 内边距（padding） 内边距： ​ padding属性用于设置内边距。 是指 边框与内容之间的距离。 设置 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 当我们给盒子指定padding值之后， 发生了2件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大了。 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 内盒尺寸计算（元素实际大小） 宽度 Element Height = content height + padding + border （Height为内容高度） 高度 Element Width = content width + padding + border （Width为内容宽度） 盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框 padding不影响盒子大小情况 如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。 外边距（margin） ​ margin属性用于设置外边距。 margin就是控制盒子和盒子之间的距离 设置： 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。 块级盒子水平居中 可以让一个块级盒子实现水平居中必须： 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto， 实际工作中常用这种方式进行网页布局，示例代码如下： .header{ width:960px; margin:0 auto;} 常见的写法，以下下三种都可以。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 文字居中和盒子居中区别 盒子内的文字水平居中是 text-align: center, 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 auto text-align: center; /* 文字 行内元素 行内块元素水平居中 */ margin: 10px auto; /* 块级盒子水平居中 左右margin 改为 auto 就阔以了 上下margin都可以 */ 插入图片和背景图片区别 插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin 背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position img { width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */ } div { width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */ } 清除元素的默认内外边距(重要) 为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除 代码： * { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ } 注意： 行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。 外边距合并 使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 (1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom 下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和 取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案：尽量给只给一个盒子添加margin值。 (2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中的较大者 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加overflow:hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 盒子模型布局稳定性 学习完盒子模型，内边距和外边距，什么情况下用内边距，什么情况下用外边距？ 大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 ps基本操作以及常用快捷键： 因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。 文件--打开 -- 可以打开 我们要测量的图片 ctrl+r 可以打开标尺 或者 视图 -- 标尺 右击标尺， 把里面的单位改为 像素 ctrl+ 加号 键 可以 放大 视图 ctrl+ 减号 缩小视图 按住空格键， 鼠标可以 变成小手 ，拖动 ps 视图 用选区 拖动 可以 测量 大小 ctrl+ d 可以取消选区 或者旁边空白处点击一下也可以取消选区 圆角边框(CSS3) 语法： border-radius:length; 其中每一个值可以为 数值或百分比的形式。 技巧： 让一个正方形 变成圆圈 border-radius: 50%; 效果图矩形的圆角， 就不要用 百分比了，因为百分比会是表示高度和宽度的一半。 而我们这里矩形就只用 用 高度的一半就好了。精确单位。 盒子阴影(CSS3) 语法: box-shadow:水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset div { width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4); } CSS书写规范 空格规范 【强制】 选择器 与 { 之间必须包含空格。 示例： .selector { } 【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： font-size: 12px; 选择器规范 【强制】 并集选择器，每个选择器声明必须独占一行。 示例： /* good */ .post, .page, .comment { line-height: 1.5; } /* bad */ .post, .page, .comment { line-height: 1.5; } 【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： /* good */ #username input {} .comment .avatar {} /* bad */ .page .header .login input {} .comment div * {} 属性规范 【强制】 属性定义必须另起一行。 示例： /* good */ .selector { margin: 0; padding: 0; } /* bad */ .selector { margin: 0; padding: 0; } 【强制】 属性定义后必须以分号结尾。 示例： /* good */ .selector { margin: 0; } /* bad */ .selector { margin: 0 } 浮动(float) CSS 布局的三种机制 分别是普通流（标准流）、浮动和定位 概念：元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。 可以实现盒子的左右对齐等等.. 浮动最早是用来控制图片，实现文字环绕图片的效果。 语法 在 CSS 中，通过 float 中文， 浮 漏 特 属性定义浮动，语法如下： 选择器 { float: 属性值; } 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 float 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。 任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似。 float —— 浮漏特 特点 说明 浮 加了浮动的盒子是浮起来的，漂浮在其他标准流盒子的上面。 漏 加了浮动的盒子是不占位置的，它原来的位置漏给了标准流的盒子。 特 特别注意：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙 浮动(float)的应用（重要） 注意，实际重要的导航栏中，我们不会直接用链接a 而是用 li 包含链接(li+a)的做法。 li+a 语义更清晰，一看这就是有条理的列表型内容。 如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 浮动(float)的扩展 浮动元素与父盒子的关系 子盒子的浮动参照父盒子对齐 不会与父盒子的边框重叠，也不会超过父盒子的内边距 浮动元素与兄弟盒子的关系 在一个父级盒子中，如果前一个兄弟盒子是： 浮动的，那么当前盒子会与前一个盒子的顶部对齐； 普通流的，那么当前盒子会显示在前一个兄弟盒子的下方。 清除浮动 清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动的方法 在CSS中，clear属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完css会再回头分析。 语法： 选择器{clear:属性值;} clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 但是我们实际工作中， 几乎只用 clear: both; 1).额外标签法(隔墙法) 是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 2).父级添加overflow属性方法 可以给父级添加： overflow为 hidden| auto| scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 3).使用after伪元素清除浮动 :after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 使用方法： .clearfix:after { content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 4).用双伪元素清除浮动 使用方法： .clearfix:before,.clearfix:after { content:&quot;&quot;; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 常见的图片格式 1. jpg图像格式： JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的 2. gif图像格式： GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果 3. png图像格式 是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景 4. PSD图像格式 PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。 PS切图 可以 分为 利用切片工具切图 以及 利用PS的插件快速切图。 CSS属性书写顺序(重点) 建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … .jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px; } 布局流程 为了提高网页制作的效率，布局时通常有以下的布局流程，具体如下： 1、必须确定页面的版心（可视区）， 我们测量可得知。 2、分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成 3、制作HTML结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。 4、然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 定位(position) CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流、浮动和定位，其中： 普通流（标准流） 浮动 让盒子从普通流中浮起来 —— 让多个盒子(div)水平排列成一行。 定位 将盒子定在某一个位置 自由的漂浮在其他盒子的上面 —— CSS 离不开定位，特别是后面的 js 特效。 边偏移 简单说， 我们定位的盒子，是通过边偏移来移动位置的。 在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的边偏移：（方位名词） 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 定位模式 (position) 在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 选择器 { position: 属性值; } 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 相对定位(relative) - 重要 相对定位是元素相对于它 原来在标准流中的位置 来说的。（自恋型） 相对定位的特点：（务必记住） 相对于 自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 绝对定位(absolute) - 重要 绝对定位是元素以带有定位的父级元素来移动位置 （拼爹型） 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点：（务必记住） 绝对是以带有定位的父级元素来移动位置 （拼爹型） 如果父级都没有定位，则以浏览器文档为准移动位置 不保留原来的位置，完全是脱标的。 定位口诀 —— 子绝父相 刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢？ 子绝父相 —— 子级是绝对定位，父级要用相对定位。 子绝父相是使用绝对定位的口诀，要牢牢记住！ 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 固定定位(fixed) - 重要 固定定位是绝对定位的一种特殊形式： （认死理型） 如果说绝对定位是一个矩形 那么 固定定位就类似于正方形 完全脱标 —— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 定位(position)的扩展 绝对定位的盒子居中 注意：绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 堆叠顺序（z-index） 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 定位改变display属性 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 完善新浪导航案例 同时注意： 浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 圆角矩形设置4个角 圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 border-top-left-radius:20px; border-top-right-radius:20px; border-bottom-right-radius:20px; border-bottom-left-radius:20px; 如果4个角，数值相同 border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 元素的显示与隐藏 display 显示（重点） display 设置或检索对象是否及如何显示。 display: none 隐藏对象 display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 (了解) 设置或检索是否显示对象。 visibility：visible ; 对象可视 visibility：hidden; 对象隐藏 特点： 隐藏之后，继续保留原有位置。 overflow 溢出(重点) 检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究) 表单轮廓等。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 轮廓线 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 li 最直接的写法是 ： outline: 0; 或者 outline: none; &lt;input type=&quot;text&quot; style=&quot;outline: 0;&quot;/&gt; 防止拖拽文本域resize 实际开发中，我们文本域右下角是不可以拖拽： &lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt; 用户界面样式总结 属性 用途 用途 鼠标样式 更改鼠标样式cursor 样式很多，重点记住 pointer 轮廓线 表单默认outline outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用 防止拖拽 主要针对文本域resize 防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none vertical-align 垂直对齐 有宽度的块级元素居中对齐，是margin: 0 auto; 让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性。 vertical-align 垂直对齐，它只针对于行内元素或者行内块元素， vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素， 特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 图片、表单和文字对齐 去除图片底侧空白缝隙 原因： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。 就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字省略号显示 white-space white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 white-space:normal ；默认处理方式 white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 text-overflow 文字溢出 设置或检索是否使用一个省略标记（...）标示对象内文本的溢出 text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...） 注意： 一定要首先强制一行内显示，再次和overflow属性 搭配使用 总结三步曲 /*1. 先强制一行内显示文本*/ white-space: nowrap; /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; CSS精灵技术（sprite) 重点 为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。 出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术讲解 CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。 这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。 我们需要使用CSS的 background-image、 background-repeat background-position属性进行背景定位， 其中最关键的是使用background-position 属性精确地定位。 精灵技术使用的核心总结 首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。 精确测量，每个小背景图片的大小和 位置。 给盒子指定小背景图片时， 背景定位基本都是 负值。 制作精灵图(了解) CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。 我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙 在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 滑动门 核心技术 核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; css样式 * { padding:0; margin:0; } body{ background: url(images/wx.jpg) repeat-x; } .father { padding-top:20px; } li { padding-left: 16px; height: 33px; float: left; line-height: 33px; margin:0 10px; background: url(./images/to.png) no-repeat left ; } a { padding-right: 16px; height: 33px; display: inline-block; color:#fff; background: url(./images/to.png) no-repeat right ; text-decoration: none; } li:hover, li:hover a { background-image:url(./images/ao.png); } 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 margin负值之美 1). 负边距+定位：水平垂直居中 咱们前面讲过， 一个绝对定位的盒子， 利用 父级盒子的 50%， 然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。 2). 压住盒子相邻边框 CSS三角形之美 div { width: 0; height: 0; line-height:0； font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px soli #000; } 网站ico图标 1). 使用ico图标 首先把favicon.ico 这个图标放到根目录下。 再html里面， head 之间 引入 代码。 2). 制作ico图标 我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。 方法步骤： 首先把我们想要的切成图片。 要把图片转换为 ico 图标，我们借助于第三方转换网站： http://www.bitbug.net/。 比特虫 总结： 代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;/&gt; 注意： 她（它）是显示在浏览器中的网页图标。 它是图标形式，不是一个图片 位置是放到 head 标签中间。 后面的type=&quot;image/x-icon&quot; 属性可以省略。（我相信你也愿意省略。） 为了兼容性，请将favicon.ico 这个图标放到根目录下。 网站优化三大标签 1. 网页title 标题 title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。 建议： 首页标题：网站名（产品名）- 网站的介绍 例如： 品优购-综合网购首选-正品低价、品质保障、配送及时、轻松购物！ 小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站 2. Description 网站说明 对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。 我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。 品优购网： &lt;meta name=&quot;description&quot; content=&quot;品优购JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt; 注意点： 描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。 同样遵循简短原则，字符数含空格在内不要超过 120 个汉字。 补充在 title 和 keywords 中未能充分表述的说明. 用英文逗号 关键词1,关键词2 &lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt; 3. Keywords 关键字 Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。 品优购网： &lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,品优购&quot; /&gt; 小米网： &lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt; 4. 总结 我们的网页要做的优秀，符合搜索引擎的要求，才可以让搜索引擎优先显示我们的网页。 所以我们的网站要做很多的优化， 其中就有这三大标签。 一般情况下，三大标签里面的优化词，都是专门的优化人员写的，我们大概了解一下规范就可以了。 我们的主要任务是，能写出这三大标签， 然后把优化人员给我们的内容，添加到里面。 字体图标 ​ 推荐网站： http://icomoon.io icomoon字库 阿里icon font字库 http://www.iconfont.cn/ 在样式里面声明字体： 告诉别人我们自己定义的字体(一定注意字体文件路径的问题) @font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal; } 给盒子使用字体 span { font-family: &quot;icomoon&quot;; } 过渡(CSS3) 过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 过渡动画： 是从一个状态 渐渐的过渡到另外一个状态 可以让我们页面更好看，更动感十足，虽然 低版本浏览器不支持（ie9以下版本） 但是不会影响页面布局。 我们现在经常和 :hover 一起 搭配使用。 语法格式: transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 &quot;ease&quot;。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 属性 ​ 属性就是你想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。 花费时间 transition-duration 花费时间 单位是 秒（必须写单位） s ms 比如 0.5s 这个s单位必须写 ms 毫秒 运动曲线 默认是 ease 运动曲线示意图： 案例： div { width: 200px; height: 100px; background-color: pink; /* transition: 要过渡的属性 花费时间 运动曲线 何时开始; */ transition: width 0.6s ease 0s, height 0.3s ease-in 1s; /* transtion 过渡的意思 这句话写到div里面而不是 hover里面 */ } div:hover { /* 鼠标经过盒子，我们的宽度变为400 */ width: 600px; height: 300px } transition: all 0.6s; /* 所有属性都变化用all 就可以了 后面俩个属性可以省略 */ transition: all 0.5s; 获得焦点元素 :focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素 :hover 语法： .total input { border: 1px solid #ccc; height: 30px; width: 40px; transition: all .5s; } /*这个input 获得了焦点*/ .total input:focus { width: 80px; border: 1px solid skyblue; } border: 1px solid #ccc; height: 30px; width: 40px; transition: all .5s; } /这个input 获得了焦点/ .total input:focus { width: 80px; border: 1px solid skyblue; } ","link":"https://xmweijh.github.io/post/css/"},{"title":"H5,C3","content":"HTML5+CSS3 HTML5 拓展了哪些内容 语义化标签 本地存储 兼容特性 2D、3D 动画、过渡 CSS3 特性 性能与集成 HTML5 新增标签 什么是语义化 新增了那些语义化标签 header --- 头部标签 nav --- 导航标签 article --- 内容标签 section --- 块级标签 aside --- 侧边栏标签 footer --- 尾部标签 多媒体音频标签 多媒体标签有两个，分别是 音频 -- audio 视频 -- video audio 标签说明 可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放， 但是：播放格式是有限的 audio 支持的音频格式 audio 目前支持三种格式 audio 的参数 &lt;body&gt; &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt; &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt; &lt;!-- 因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件 --&gt; &lt;audio controls&gt; &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt; &lt;/audio&gt; &lt;/body&gt; 多媒体视频标签 语法格式 &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; video 参数 video 代码演示 &lt;body&gt; &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt; &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt; &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt; &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt; &lt;/body&gt; 多媒体标签总结 音频标签与视频标签使用基本一致 多媒体标签在不同浏览器下情况不同，存在兼容性问题 谷歌浏览器把音频和视频标签的自动播放都禁止了 谷歌浏览器中视频添加 muted 标签可以自己播放 注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册 新增 input 标签 新增表单属性 CSS3 属性选择器 属性选择器代码演示 button { cursor: pointer; } button[disabled] { cursor: default } input[type=search] { color: skyblue; } span[class^=black] { color: lightgreen; } span[class$=black] { color: lightsalmon; } span[class*=black] { color: lightseagreen; } 结构伪类选择器 ul li:first-child { background-color: lightseagreen; } ul li:last-child { background-color: lightcoral; } ul li:nth-child(3) { background-color: aqua; } nth-child 详解 注意：本质上就是选中第几个子元素 n 可以是数字、关键字、公式 n 如果是数字，就是选中第几个 常见的关键字有 even 偶数、odd 奇数 常见的公式如下(如果 n 是公式，则从 0 开始计算) 但是第 0 个元素或者超出了元素的个数会被忽略 nth-child 选择父元素里面的第几个子元素，不管是第几个类型 nt-of-type 选择指定类型的元素 伪元素选择器 伪类选择器注意事项 before 和 after 必须有 content 属性 before 在内容前面，after 在内容后面 before 和 after 创建的是一个元素，但是属于行内元素 创建出来的元素在 Dom 中查找不到，所以称为伪元素 伪元素和标签选择器一样，权重为 1 &lt;style&gt; div { width: 100px; height: 100px; border: 1px solid lightcoral; } div::after, div::before { width: 20px; height: 50px; text-align: center; display: inline-block; } div::after { content: '德'; background-color: lightskyblue; } div::before { content: '道'; background-color: mediumaquamarine; } &lt;/style&gt; 2D 转换之 translate 2D转换 2D 转换是改变标签在二维平面上的位置和形状 移动： translate 旋转： rotate 缩放： scale translate语法 x 就是 x 轴上水平移动 y 就是 y 轴上水平移动 transform: translate(x, y) transform: translateX(n) transfrom: translateY(n) 重点知识点 2D 的移动主要是指 水平、垂直方向上的移动 translate 最大的优点就是不影响其他元素的位置 translate 中的100%单位，是相对于本身的宽度和高度来进行计算的 行内标签没有效果 代码演示 div { background-color: lightseagreen; width: 200px; height: 100px; /* 平移 */ /* 水平垂直移动 100px */ /* transform: translate(100px, 100px); */ /* 水平移动 100px */ /* transform: translate(100px, 0) */ /* 垂直移动 100px */ /* transform: translate(0, 100px) */ /* 水平移动 100px */ /* transform: translateX(100px); */ /* 垂直移动 100px */ transform: translateY(100px) } 让一个盒子水平垂直居中 p { position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; background-color: purple; /* margin-top: -100px; margin-left: -100px; */ /* translate(-50%, -50%) 盒子往上走自己高度的一半 */ transform: translate(-50%, -50%); } span { /* translate 对于行内元素是无效的 */ transform: translate(300px, 300px); } 2D 转换 rotate rotate 旋转 2D旋转指的是让元素在二维平面内顺时针或者逆时针旋转rotate 语法 /* 单位是：deg */ transform: rotate(度数) 重点知识点 rotate 里面跟度数，单位是 deg 角度为正时，顺时针，角度为负时，逆时针 默认旋转的中心点是元素的中心点 代码演示 img:hover { transform: rotate(360deg) } rotate 2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转 使用步骤： 给元素添加转换属性 transform 属性值为 rotate(角度) 如 transform:rotate(30deg) 顺时针方向旋转30度 div{ transform: rotate(0deg); } 三角 div::after { content: &quot;&quot;; position: absolute; top: 8px; right: 15px; width: 10px; height: 10px; border-right: 1px solid #000; border-bottom: 1px solid #000; transform: rotate(45deg); transition: all 0.2s; } /* 鼠标经过div 里面的三角旋转 */ div:hover::after { transform: rotate(225deg); } 设置元素旋转中心点(transform-origin) transform-origin 基础语法 transform-origin: x y; 重要知识点 注意后面的参数 x 和 y 用空格隔开 x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 center center 还可以给 x y 设置像素或者方位名词(top、bottom、left、right、center) 旋转中心案例 代码演示 2D 转换之 scale scale 的作用 用来控制元素的放大与缩小 语法 transform: scale(x, y) 知识要点 注意，x 与 y 之间使用逗号进行分隔 transform: scale(1, 1): 宽高都放大一倍，相当于没有放大 transform: scale(2, 2): 宽和高都放大了二倍 transform: scale(2): 如果只写了一个参数，第二个参数就和第一个参数一致 transform:scale(0.5, 0.5): 缩小 scale 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子 代码演示 div:hover { /* 注意，数字是倍数的含义，所以不需要加单位 */ /* transform: scale(2, 2) */ /* 实现等比缩放，同时修改宽与高 */ /* transform: scale(2) */ /* 小于 1 就等于缩放*/ transform: scale(0.5, 0.5) } 2D 转换综合写法以及顺序问题 知识要点 同时使用多个转换，其格式为 transform: translate() rotate() scale() 顺序会影响到转换的效果(先旋转会改变坐标轴方向) 但我们同时有位置或者其他属性的时候，要将位移放到最前面 代码演示 div:hover { transform: translate(200px, 0) rotate(360deg) scale(1.2) } 动画(animation) 什么是动画 动画是 CSS3 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果 动画的基本使用 先定义动画 在调用定义好的动画 语法格式(定义动画) @keyframes 动画名称 { 0% { width: 100px; } 100% { width: 200px } } 语法格式(使用动画) div { /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间； } 动画序列 0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列 在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果 动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数 用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100% 代码演示 &lt;style&gt; div { width: 100px; height: 100px; background-color: aquamarine; animation-name: move; animation-duration: 0.5s; } @keyframes move{ 0% { transform: translate(0px) } 100% { transform: translate(500px, 0) } } &lt;/style&gt; 动画常见属性 常见的属性 代码演示 div { width: 100px; height: 100px; background-color: aquamarine; /* 动画名称 */ animation-name: move; /* 动画花费时长 */ animation-duration: 2s; /* 动画速度曲线 */ animation-timing-function: ease-in-out; /* 动画等待多长时间执行 */ animation-delay: 2s; /* 规定动画播放次数 infinite: 无限循环 */ animation-iteration-count: infinite; /* 是否逆行播放 */ animation-direction: alternate; /* 动画结束之后的状态 */ animation-fill-mode: forwards; } div:hover { /* 规定动画是否暂停或者播放 */ animation-play-state: paused; } 动画简写方式 动画简写方式 /* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */ animation: name duration timing-function delay iteration-count direction fill-mode 知识要点 简写属性里面不包含 animation-paly-state 暂停动画 animation-paly-state: paused; 经常和鼠标经过等其他配合使用 要想动画走回来，而不是直接调回来：animation-direction: alternate 盒子动画结束后，停在结束位置：animation-fill-mode: forwards 代码演示 animation: move 2s linear 1s infinite alternate forwards; 速度曲线细节 速度曲线细节 animation-timing-function: 规定动画的速度曲线，默认是ease 代码演示 div { width: 0px; height: 50px; line-height: 50px; white-space: nowrap; overflow: hidden; background-color: aquamarine; animation: move 4s steps(24) forwards; } @keyframes move { 0% { width: 0px; } 100% { width: 480px; } } 奔跑的熊大 代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { background-color: #ccc; } div { position: absolute; width: 200px; height: 100px; background: url(media/bear.png) no-repeat; /* 我们元素可以添加多个动画， 用逗号分隔 */ animation: bear .4s steps(8) infinite, move 3s forwards; } @keyframes bear { 0% { background-position: 0 0; } 100% { background-position: -1600px 0; } } @keyframes move { 0% { left: 0; } 100% { left: 50%; /* margin-left: -100px; */ transform: translateX(-50%); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ​ 3D 转换 3D 转换知识要点 3D 位移：translate3d(x, y, z) 3D 旋转：rotate3d(x, y, z) 透视：perspctive 3D呈现 transfrom-style 3D 移动 translate3d 3D 移动就是在 2D 移动的基础上多加了一个可以移动的方向，就是 z 轴方向 transform: translateX(100px)：仅仅是在 x 轴上移动 transform: translateY(100px)：仅仅是在 y 轴上移动 transform: translateZ(100px)：仅仅是在 z 轴上移动 transform: translate3d(x, y, z)：其中x、y、z 分别指要移动的轴的方向的距离 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 语法 transform: translate3d(x, y, z) 代码演示 transform: translate3d(100px, 100px, 100px) /* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */ transform: translate3d(100px, 100px, 0) 透视 perspective 知识点讲解 如果想要网页产生 3D 效果需要透视(理解成 3D 物体投影的 2D 平面上) 实际上模仿人类的视觉位置，可视为安排一直眼睛去看 透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是像素 知识要点 透视需要写在被视察元素的父盒子上面 注意下方图片 d：就是视距，视距就是指人的眼睛到屏幕的距离 z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大 ​ 代码演示 body { perspective: 1000px; } translateZ translateZ 与 perspecitve 的区别 perspecitve 给父级进行设置，translateZ 给 子元素进行设置不同的大小 3D 旋转rotateX 3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转 语法 transform: rotateX(45deg) -- 沿着 x 轴正方向旋转 45 度 transform: rotateY(45deg) -- 沿着 y 轴正方向旋转 45 度 transform: rotateZ(45deg) -- 沿着 z 轴正方向旋转 45 度 transform: rotate3d(x, y, z, 45deg) -- 沿着自定义轴旋转 45 deg 为角度 代码案例 div { perspective: 300px; } img { display: block; margin: 100px auto; transition: all 1s; } img:hover { transform: rotateX(-45deg) } ​ 3D 旋转 rotateY 代码演示 div { perspective: 500px; } img { display: block; margin: 100px auto; transition: all 1s; } img:hover { transform: rotateY(180deg) } 3D 旋转 rotateZ 代码演示 div { perspective: 500px; } img { display: block; margin: 100px auto; transition: all 1s; } img:hover { transform: rotateZ(180deg) } rotate3d transform: rotate3d(x, y, z, deg) -- 沿着自定义轴旋转 deg 为角度 x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度 transform: rotate3d(1, 1, 0, 180deg) -- 沿着对角线旋转 45deg transform: rotate3d(1, 0, 0, 180deg) -- 沿着 x 轴旋转 45deg 代码演示 div { perspective: 500px; } img { display: block; margin: 100px auto; transition: all 1s; } img:hover { transform: rotate3d(1, 1, 0, 180deg) } 3D 呈现 transform-style transform-style ☆☆☆☆☆ 控制子元素是否开启三维立体环境 transform-style: flat 代表子元素不开启 3D 立体空间，默认的 transform-style: preserve-3d 子元素开启立体空间 代码写给父级，但是影响的是子盒子 移动web meta标签 背景缩放background-size background-size 属性规定背景图像的尺寸 background-size: 背景图片宽度 背景图片高度; 单位： 长度|百分比|cover|contain; cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 移动端大量使用 CSS3盒子模型box-sizin 传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 /*CSS3盒子模型*/ box-sizing: border-box; /*传统盒子模型*/ box-sizing: content-box; 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 移动端特殊样式 /*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*点击高亮我们需要清除清除 设置为transparent 完成透明*/ -webkit-tap-highlight-color: transparent; /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img,a { -webkit-touch-callout: none; } 移动端常见布局 移动端单独制作 流式布局（百分比布局） flex 弹性布局（强烈推荐） less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp 流式布局： 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。 ","link":"https://xmweijh.github.io/post/h5c3/"},{"title":"C++记录","content":"C++ c++语言在c语言的基础上添加了面向对象编程和泛型编程的支持。c++继承了c语言高效，简洁，快速和可移植的传统。 ::作用域运算符 ​ 在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。 ​ ::代表作用域 如果前面什么都不添加 代表全局作用域 namespace命名空间 C++命名空间(namespace) 命名空间用途：解决名称冲突 ​ 可以存放 ： 变量、函数、结构体、类… ​ 命名空间必须要声明在全局作用域 命名空间可以嵌套命名空 命名空间是开放的，可以随时将新成员添加到命名空间下 ​ 命名空间可以匿名的 命名空间可以起别名 using声明 using KingGlory::sunwukongId； 当using声明与 就近原则同时出现，出错，尽量避免 using编译指令 using namespace KingGlory; 当using编译指令 与 就近原则同时出现，优先使用就近 当using编译指令有多个，需要加作用域 区分 C++对C语言增强以及扩展 全局变量检测增强 int a ; int a = 10; C下可以，C++重定义 函数检测增强 函数的返回值 形参类型 函数调用参数个数 类型转换检测增强 char * p = (char *)malloc(64) C++下必须等号左右一致类型 struct 增强 C++可以在结构体中放函数 创建结构体变量 可以简化关键字struct bool数据类型扩展 C++才有bool类型 代表真 --- 1 true 假 ---- 0 false sizeof = 1 三目运算符增强 C语言下返回的是值 C++语言下返回的是变量 a &gt; b ? a : b = 100; 结果b变为100 执行的是b=100这个式子 若是小于 a，b都不变（不要想成(a &gt; b ? a : b) = 100; b=100是个整体式子 前面条件满足才执行这个赋值语句） const增强 C语言下 全局const 直接修改 失败 间接修改 语法通过，运行失败 局部 const 直接修改 失败 间接修改 成功 C++语言下 全局 const 和C结论一样 局部 const 直接修改失败 间接修改 失败 C++const可以称为常量 const 链接属性 C语言下const修饰的全局变量默认是外部链接属性 C++下const修饰的全局变量默认是内部链接属性，可以加extern 提高作用域 const分配内存情况 对const变量 取地址 ，会分配临时内存 使用普通变量 初始化 const变量 对于自定义数据类型 尽量用const代替define define出的宏常量，没有数据类型、不重视作用域 引用 目的：起别名 语法： 类型（与原名类型必须一致） &amp;别名 = 原名 引用必须要初始化 引用一旦初始化后，就不可以引向其他变量 建立对数组引用 直接建立引用 int arr[10]; int(&amp;pArr)[10] = arr; 先定义出数组类型，再通过类型 定义引用 typedef int(ARRAY_TYPE)[10]; ARRAY_TYPE &amp; pArr2 = arr; 参数的传递方式 值传递 地址传递 引用传递 注意事项 引用必须引一块合法内存空间 不要返回局部变量的引用 当函数返回值是引用时候，那么函数的调用可以作为左值进行运算 指针的引用 利用引用可以简化指针 可以直接用同级指针的 引用 给同级指针分配空间 常量的引用 const int &amp;ref = 10; / 加了const之后， 相当于写成 int temp = 10; const int &amp;ref = temp; 常量引用的使用场景 修饰函数中的形参，防止误操作 设计类 抽象类 class 类名{ public 公共权限 ​ 设置 成员属性 ​ 设置 成员函数 } 使用类 创建对象 实例化对象 类名 对象名 通过对象 来设置属性 调用成员函数 类和对象 关系 类是对对象的抽象 对象是对类的实例 内联函数 解决宏缺陷问题 给编译器一个建议，加上关键字，编译器不一定按照内联处理 不加关键字，也许编译器还偷摸的给你加inline 成员函数 默认加上关键字 函数声明加了关键字，函数实现也要加inline关键字 函数默认参数 参数可以有默认值 如果有一个位置有了默认值，那么从这个位置开始，从左往右都必须有默认值 函数声明和实现 只能有一个有默认值 函数占位参数 void func(int) 占位参数 调用时候必须要提供这个参数 占位参数也可以有默认值 c语言中没有默认参数 和占位参数 函数重载的基本语法 函数名称相同 又在同一个作用域下 函数参数个数不同、类型不同、顺序不同都可以满足重载条件 函数的返回值可以作为函数重载条件吗？ 不可以 当函数重载碰到了函数默认参数 要注意避免二义性 extern C浅析 解决了C++文件中调用C语言的代码 方法1:+ 在C++代码中加入 告诉编译器show函数用C语言方式做链接/ /extern &quot;C&quot; void show() ; 方法2: 在c语言的头文件中加入6行代码 #ifdef__cplusplus //两个下划线 extern &quot;C&quot; { #endif #ifdef __cplusplus //两个下划线 ｝ #endif C++语言的封装 将属性和行为作为一个整体，来表示生活中具体的事物 有访问权限 class 和struct唯一区别 默认权限不同 class默认是private struct 默认是public public 是类内类外都可以访问到 protected 类内可以，类外不可以 private 类内可以，类外不可以 建议将所有成员属性设置为私有 自己提供公共的对外接口来进行 set或者get方法访问 构造函数和析构函数 构造函数 //没有返回值 不用写void //函数名 与 类名相同 //可以有参数 ，可以发生重载 //构造函数 由编译器自动调用一次 无须手动调用 析构函数 //没有返回值 不用写void 函数名 与类名相同 函数名前 加 ~ 不可以有参数 ，不可以发生重载 析构函数 也是由编译器自动调用一次，无须手动调用 构造函数的分类和调用 分类 按照参数分类： 有参 无参（默认） 按照类型分类： 普通 拷贝构造 ( const Person &amp; p ) 调用 括号法 显示法 隐式法 注意事项 不要用括号法 调用无参构造函数 Person p3(); 编译器认为代码是函数的声明 不要用拷贝构造函数 初始化 匿名对象 Person(p3); 编译器认为 Person p3对象实例化 如果已经有p3 p3就重定义 匿名对象 特点： 当前行执行完后 立即释放 拷贝构造函数的调用时机 用已经创建好的对象来初始化新的对象 值传递的方式 给函数参数传值 以值方式 返回局部对象 构造函数的调用规则 //1、编译器会给一个类 至少添加3个函数 默认构造（空实现） 析构函数（空实现） 拷贝构造（值拷贝） //2、如果我们自己提供了 有参构造函数，编译器就不会提供默认构造函数，但是依然会提供拷贝构造函数 //3、如果我们自己提供了 拷贝构造函数，编译器就不会提供其他构造函数 深拷贝与浅拷贝的问题以及解决 如果有属性开辟到堆区，利用编译器提供拷贝构造函数会调用浅拷贝带来的析构重复释放堆区内存的问题 利用深拷贝解决浅拷贝问题 自己提供拷贝构造函数，实现深拷贝 初始化列表 可以利用初始化列表语法 对类中属性进行初始化 语法：构造函数名称后 ： 属性(值), 属性（值）... Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) 类对象作为类中成员 当其他类对象 作为本类成员，先构造其他类对象，再构造自身，析构的顺序和构造相反 explicit关键字 explicit用途： 防止利用隐式类型转换方式来构造对象 new和delete malloc 和 new 区别 malloc 和 free 属于 库函数 new 和delete属于 运算符 malloc不会调用构造函数 new会调用构造函数 malloc返回void* C++下要强转 new 返回创建的对象的指针 事项 不要用void去接受new出来的对象,利用void无法调用析构函数 利用new创建数组 Person * pPerson = new Person[10]; 释放数组时候 需要加[] delete [] pPerson; 堆区开辟数组，一定会调用默认构造函数 栈上开辟数组，可不可以没有默认构造,可以没有默认构造 静态成员 静态成员变量 所有对象都共享同一份数据 编译阶段就分配内存 类内声明、类外初始化 访问方式有两种：通过对象访问、通过类名访问 静态成员变量也是有访问权限 静态成员函数 所有对象都共享同一份函数 静态成员函数 只可以访问 静态成员变量，不可以访问非静态成员变量 静态成员函数 也是有访问权限的 静态成员函数 有两种访问方式：通过对象 、通过类名 单例模式 – 主席类案例 通过一个类 只能实例化唯一的一个对象 私有化 默认构造 拷贝构造 唯一实例指针 对外提供 getInstance 接口，将指针返回 单例模式 – 打印机案例 和主席类案例一样设计单例模式 提供打印功能并且统计打印次数 C++对象模型初探 类中的成员变量 和 成员函数 是分开存储的 只有非静态成员变量 属于类对象上 空类的sizeof结果 1 this指针 this指针 指向 被调用的成员函数 所属的对象 this指针可以解决名称冲突 this指针 隐式加在每个成员函数中 *this 就是本体 ​ p1.personAddPerson(p2).personAddPerson(p2).personAddPerson(p2); //链式编程 空指针访问成员函数 如果成员函数中没有用到this指针，可以用空指针调用成员函数 如果成员函数中用到了this，那么这个this需要加判断，防止代码down掉 常对象和常函数 常函数 成员函数 声明后面加const void showPerson() const const目的是为了修饰成员函数中的this指针，让指针指向的值不可以修改 有些属性比较特殊，依然在常函数或者常对象中可以修改，需要加入关键字 mutable 常对象 const Person p 常对象也不许修改成员属性 常对象只能调用常函数 对于成员函数 ，可不可以 用static 和 const同时修饰 ，不可以 友元 全局函数作为友元函数 利用friend关键字让全局函数 goodGay作为本类好朋友，可以访问私有成员 friend void goodGay(Building * buliding); 类作为友元类 让goodGay类作为 Building的好朋友，可以访问私有成员 friend class GoodGay; ​ 类中的成员函数作为友元函数 ​ //让GoodGay类中的 visit成员函数作为友元 friend void GoodGay::visit(); 加号运算符重载 对于内置的数据类型，编译器知道如何进行运算 但是对于自定义数据类型，编译器不知道如何运算 利用运算符重载 可以让符号有新的含义 利用加号重载 实现p1 + p2 Person数据类型相加操作 利用成员函数 和 全局函数 都可以实现重载 关键字 operator + 成员本质 p1.operator+(p2) 全局本质 operator+(p1,p2) 简化 p1 + p2 运算符重载 也可以发生函数重载 左移运算符重载 不要滥用运算符重载，除非有需求 不能对内置数据类型进行重载 对于自定义数据类型，不可以直接用 cout &lt;&lt; 输出 需要重载 左移运算符 如果利用成员 函数重载 ，无法实现让cout 在左侧，因此不用成员重载 利用全局函数 实现左移运算符重载 ostream&amp; operator&lt;&lt;(ostream &amp;cout, Person &amp; p1) 如果想访问类中私有内存，可以配置友元实现 递增运算符重载 前置递增 MyInter&amp; operator++() 后置递增 MyInter operator++(int) 前置++ 效率高于 后置++ 效率 ，因为后置++会调用拷贝构造，创建新的数据 指针运算符重载 智能指针 用途： 托管new出来的对象的释放 设计smartPoint智能指针类，内部维护 Person * ，在析构时候释放堆区new出来的person对象 重载 -&gt; * 让 sp智能指针用起来向真正的指针 赋值运算符重载 编译器会默认个一个类添加4个函数 默认构造、析构 、 拷贝构造（值拷贝） 、 operator=（值拷贝） 出现 堆区内存重复释放的问题 解决方案：利用深拷贝 重载 =运算符 Person&amp; operator=( const Person &amp;p) []运算符重载 int&amp; operator[](int index); 实现访问数组时候利用[] 访问元素 关系运算符重载 对于自定义数据类型，编译器不知道如果进行比较 重载 == ！=号 bool operator==( Person &amp; p) bool operator!=(Person &amp; p) 函数调用运算符重载 重载 （） 使用时候很像函数调用，因此称为仿函数 void operator()(string text) int operator()(int a,int b) 仿函数写法不固定，比较灵活 cout &lt;&lt; MyAdd()(1, 1) &lt;&lt; endl; // 匿名函数对象 特点：当前行执行完立即释放 不要重载 &amp;&amp; 和 || 原因是无法实现短路特性 建议：将&lt;&lt; 和 &gt;&gt;写成全局函数，其他可重载的符号写到成员即可 强化训练-字符串类封装 myString类 实现自定义的字符串类 继承基本语法 继承优点：减少重复的代码，提高代码复用性 // 语法： class 子类 ： 继承方式 父类 // News 子类 派生类 // BasePage 父类 基类 继承方式 公共继承 父类中公共权限，子类中变为公共权限 父类中保护权限，子类中变为保护权限 父类中私有权限，子类访问不到 保护继承 父类中公共权限，子类中变为保护权限 父类中保护权限，子类中变为保护权限 父类中私有权限，子类访问不到 私有继承 父类中公共权限，子类中变为私有权限 父类中保护权限，子类中变为私有权限 父类中私有权限，子类访问不到 继承中的对象模型** 父类中的私有属性，子类是继承下去了，只不过由编译器给隐藏了，访问不到 可以利用开发人员工具查看对象模型 C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\Tools\\Shortcuts 打开开发人员命令工具 跳转盘符 E: 跳转文件路径 cd到文件路径下 cl /d1 reportSingleClassLayout类名 文件名 继承中的构造和析构 先调用父类构造，再调用其他成员构造， 再调用自身构造 ，析构的顺序与构造相反 利用初始化列表语法 显示调用父类中的其他构造函数 父类中 构造、析构、拷贝构造 、operator= 是不会被子类继承下去的 继承中的同名成员处理 ​ 我们可以利用作用域 访问父类中的同名成员 当子类重新定义了父类中的同名成员函数，子类的成员函数会 隐藏掉父类中所有重载版本的同名成员，可以利用作用域显示指定调用 继承中的同名 静态成员处理 结论和 非静态成员 一致 只不过调用方式有两种 通过对象 通过类名 通过类名的方式 访问 父类作用域下的m_A静态成员变量 Son::Base::m_A ​ 多继承基本语法 class 子类 ： 继承方式 父类1 ， 继承方式 父类2 当多继承的两个父类中有同名成员，需要加作用域区分 菱形继承 两个类有公共的父类 和共同的子类 ，发生菱形继承 ​ 菱形继承导致数据有两份，浪费资源 解决方案：利用虚继承可以解决菱形继承问题 class Sheep : virtual public Animal{}; //当发生虚继承后，sheep和tuo类中 继承了一个 vbptr指针 虚基类指针 指向的是一个 虚基类表 vbtable ​ //虚基类表中记录了 偏移量 ，通过偏移量 可以找到唯一的一个m_Age ​ 利用地址偏移找到 vbtable中的偏移量 并且访问数据 静态联编动态联编 静态多态和动态多态 静态多态：函数重载，运算符重载 动态多态： //先有继承关系 //父类中有虚函数，子类重写父类中的虚函数 //父类的指针或引用 指向子类的对象 静态多态在编译阶段绑定地址，地址早绑定，静态联编 动态多次在运行阶段绑定地址，地址晚绑定，动态联编 多态原理 当父类写了虚函数后，类内部结构发生改变，多了一个vfptr vfptr 虚函数表指针 ---- &gt; vftable 虚函数表 虚函数表内部记录着 虚函数的入口地址 当父类指针或引用指向子类对象，发生多态，调用是时候从虚函数中找函数入口地址 虚函数 关键字 virtual 利用指针的偏移调用 函数 ((void()()) ((int )(int *)animal)) (); typedef void( __stdcall *FUNPOINT)(int); (FUNPOINT (((int)(int)animal + 1)))(10); 多态的好处 代码可读性强 组织结构清晰 扩展性强 开闭原则： 对扩展进行开放 对修改进行关闭 纯虚函数和抽象类 语法： virtual int getResult() = 0; //如果一个类中包含了纯虚函数，那么这个类就无法实例化对象了,这个类通常我们称为 抽象类 //抽象类的子类 必须要重写 父类中的纯虚函数，否则也属于抽象类 虚析构和纯虚析构 虚析构语法： virtual ~Animal(){} 如果子类中有指向堆区的属性，那么要利用虚析构技术 在delete的时候 调用子类的析构函数 纯虚析构语法： virtual ~Animal() = 0; Animal::~Animal(){ .. } ​ //纯虚析构 需要有声明 也需要有实现 ​ //如果一个类中 有了 纯虚析构函数，那么这个类也属于抽象类，无法实例化对象了 向上类型转换和向下类型转换 父转子 向下类型转换 不安全 子转父 向上类型转换 安全 如果发生多态，那么转换永远都是安全的 重载、重写、重定义 重载 函数重载 同一个作用域下，函数名称相同，参数个数、顺序、类型不同 重写 子类重写父类中的虚函数，函数返回值、函数名、形参列表完全一致称为重写 重定义 子类重新定义父类中的同名成员函数，隐藏掉父类中同名成员函数，如果想调用加作用域 函数模板 泛型编程 – 模板技术 特点：类型参数化 template&lt; typename T &gt; 告诉编译器后面紧跟着的函数或者类中出现T，不要报错，T是一个通用的数据类型 实现通用两个数进行交换函数 使用 1.自动类型推导 必须要推导出一致的T才可以使用 2.显示指定类型 mySwap(a,b); 函数模板和普通函数的区别以及调用规则 区别 如果使用自动类型推导，是不可以发生隐式类型转换的 普通函数 可以发生隐式类型转换 调用规则 如果函数模板和普通函数都可以调用，那么优先调用普通函数 如果想强制调用函数模板，可以使用空模板参数列表 myPrint&lt;&gt;(a, b); 函数模板也可以发生函数重载 如果函数模板能产生更好的匹配，那么优先使用函数模板 模板的实现机制 编译器并不是把函数模板处理成能够处理任何类型的函数 函数模板通过具体类型产生不同的函数 --- 通过函数模板产生的函数 称为模板函数 编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。 模板局限性 模板并不是真实的通用，对于自定义数据类型，可以使用具体化技术，实现对自定义数据类型特殊使用 template&lt;&gt;bool myCompare(Person &amp;a, Person &amp;b) 类模板 ​ //类模板和函数模板区别： ​ //1、类模板不可以使用自动类型推导，只能用显示指定类型 ​ //2、类模板中 可以有默认参数 类模板中成员函数创建时机 类模板中的成员函数 并不是一开始创建的，而是在运行阶段确定出T的数据类型才去创建 类模板做函数参数 1、指定传入类型 void doWork(Person &lt;string, int&gt;&amp;p) 2、参数模板化 template&lt;class T1, class T2&gt; void doWork2(Person &lt;T1, T2&gt;&amp;p) 3、整个类 模板化 template void doWork3( T &amp;p) 查看T数据类型 typeid(T).name() ​ 类模板碰到继承的问题以及解决 必须要指定出父类中的T数据类型，才能给子类分配内存 ​ template&lt;class T1 ,class T2&gt; class Son2 :public Base2 类模板中的成员函数类外实现 void Person&lt;T1, T2&gt;::showPerson() 类模板的分文件编写问题以及解决 类模板中的成员函数，不会一开始创建，因此导致分文件编写时连接不到函数的实现，出现无法解析的外部命令错误 解决方式1： 直接包含.cpp文件 （不推荐） 解决方式2： 将类声明和实现写到同一个文件中，将文件的后缀名改为 .hpp 即可 类模板碰到友元的问题以及解决 友元类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp;p) 友元类外实现 声明： friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p); 实现： template&lt;class T1,class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp;p){ 。。。} template&lt;class T1,class T2&gt; class Person; template&lt;class T1,class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp;p); 类型转换 静态类型转换 static_cast 允许内置数据类型转换 允许父子之间的指针或者引用的转换 语法 static_cast&lt;目标类型&gt;(原变量/原对象) 动态类型转换 dynamic_cast 不允许内置数据类型转换 允许父子之间指针或者引用的转换 父转子 不安全的 转换失败 子转父 安全 转换成功 如果发生多态，总是安全，可以成功 语法 dynamic_cast&lt;目标类型&gt;(原变量/原对象) 常量转换 const_cast 只允许 指针或者引用 之间转换 语法 const _cast&lt;目标类型&gt;(原变量/原对象) 重新解释转换 reinterpret_cast 最不安全一种转换，不建议使用 异常的基本语法 C++异常的处理关键字 try throw catch 可以出现异常的代码 放到 try块 利用throw抛出异常 利用catch捕获异常 catch( 类型) 如果想捕获其他类型 catch(…) 如果捕获到的异常不想处理，而继续向上抛出，利用 throw 异常必须有函数进行处理，如果都不去处理，程序自动调用 terminate函数，中断掉 异常可以是自定义数据类型 栈解旋 从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉， 释放的顺序和创建顺序相反的，这个过程我们称为栈解旋 异常的接口声明 在函数中 如果限定抛出异常的类型，可以用异常的接口声明 语法： void func()throw(int ,double) throw(空)代表 不允许抛出异常 异常变量的生命周期 //抛出的是 throw MyException(); catch (MyException e) 调用拷贝构造函数 效率低 //抛出的是 throw MyException(); catch (MyException &amp;e) 只调用默认构造函数 效率高 推荐 //抛出的是 throw &amp;MyException(); catch (MyException *e) 对象会提前释放掉，不能在非法操作 //抛出的是 new MyException(); catch (MyException *e) 只调用默认构造函数 自己要管理释放 异常的多态使用 提供基类异常类 class BaseException 纯虚函数 virtual void printError() = 0; 子类空指针异常 和 越界异常 继承 BaseException 重写virtual void printError() 测试 利用父类引用指向子类对象 系统标准异常 引入头文件 #include 抛出越界异常 throw out_of_range(“…”) 获取错误信息 catch( exception &amp; e ) e.what(); 编写自己的异常类 编写myOutofRange 继承 Exception类 重写 virtual const char * what() const 将sting 转为 const char * .c_str() ​ const char * 可以隐式类型转换为 string 反之不可以 ​ 测试，利用多态打印出错误提示信息 标准输入流 cin.get() 获取一个字符 cin.get(两个参数) 获取字符串 利用cin.get获取字符串时候，换行符遗留在缓冲区中 cin.getline() 获取字符串 利用cin.getline获取字符串时候，换行符不会被取走，也不在缓冲区中，而是直接扔掉 cin.ignore() 忽略 默认忽略1个字符， 如果填入参数X，代表忽略X个字符 cin.peek() 偷窥 cin.putback() 放回 放回原位置 标准输出流 cout.put() //向缓冲区写字符 cout.write() //从buffer中写num个字节到当前输出流中。 通过 流成员函数 格式化输出 int number = 99; cout.width(20); //指定宽度为20 cout.fill('*'); //填充 cout.setf(ios::left); //左对齐 cout.unsetf(ios::dec); //卸载十进制 cout.setf(ios::hex); //安装十六进制 cout.setf(ios::showbase); //显示基数 cout.unsetf(ios::hex); //卸载十六进制 cout.setf(ios::oct); //安装八进制 ​ cout &lt;&lt; number &lt;&lt; endl; 通过控制符 格式化输出 int number = 99; cout &lt;&lt; setw(20) //设置宽度 ​ &lt;&lt; setfill('~') //设置填充 &lt;&lt; setiosflags(ios::showbase) //显示基数 &lt;&lt; setiosflags(ios::left) //设置左对齐 &lt;&lt; hex //显示十六进制 &lt;&lt; number &lt;&lt; endl; ​ 引入头文件 #include&lt; iomanip&gt; 文件读写 头文件 #inlcude &lt; fstream&gt; 写文件 ofstream ofs (文件路径，打开方式 ios::out ) 判断文件是否打开成功 ofs.is_open ofs &lt;&lt; “…” 关闭文件 ofs.close(); 读文件 ifstream ifs(文件路径，打开方式 ios::in) 判断文件是否打开成功 ofs.is_open 利用4种方式 对文件进行读取 关闭文件 ifs.close(); ","link":"https://xmweijh.github.io/post/cji-lu/"},{"title":"C语言续","content":"c语言续 char *p1,p2 p1指针，p2字符 可用 typedef char * PCHAR 或 char *p1 , *p2解决 数据类型 编译器指定出的数据类型，为了更好地管理内存 sizeof 只是一个操作符类似于+-*/，非函数。对于数据类型，必须用（），但对于变量不用。 其返回值类型为 unsigned int 无符号整型。 当unsigned int 和 int 做运算，编译器会把数据类型都转换为unsigned int 无符号打印%u sizeof 可以统计数组长度，当数组名作为函数参数时，会退化为指针，指向数组的第一个元素 变量，可以读写的内存对象 data初始化全局变量，静态变量，常量 bss未初始化 栈区 堆区 栈，注意不要返回局部变量的地址（函数结束内存会被释放） 堆区，手动开辟的记得手动回收 如果主调函数中没有给指针分配内存，被调函数用同级指针是修饰不到主调函数中的指针的 static 静态变量 只初始化一次，在编译阶段就分配内存属于内部链接属性，只能在当前文件中使用 const 修饰的局部变量通过间接修改 成功 宏函数一定程度上比普通效率（入栈，出栈）高 ，频繁短小函数可写为宏函数 以空间换时间 调用惯例 出栈放、参数的传入顺序、函数名称的修饰 c和c++ 为cdecl 栈的生成方向 以及 内存存储方式 栈底 高地址 栈顶 低地址 （从高地址到低地址使用） 存储方式 高位字节数据 高地址 低位 低地址 （小端对齐） 空指针 不允许向NULL和非法地址拷贝内存 野指针 未初始化指针 ， malloc后free了，但没将指针置空 ， 指针操作超越作用域 指针的步长 指针变量+1后，跳跃的字节数量 解引用的时候，取得字节数 获取结构体中属性的偏移： offsetof(结构体,属性) 头文件 #include&lt;stddef.h&gt; 字符串是有结束标志 \\0 三种方式拷贝字符串：利用[] 利用指针 利用while （*dest++ = *source++） char*str 字符串常量不能改变 char str[]可以改 calloc 分配的内存会初始化为0 sscanf 将已知的字符串格式化匹配出有效信息 指针易错点 越界操作 指针叠加会不断改变指针指向 返回局部变量地址 不可以释放野指针 将文件光标置为文件首 fseek( file, 0 ,SEEK_SET) 按位取反 ~ int num =2; printf(&quot;~num = %d\\n&quot;,~num);//结果为-3 2 -&gt; 010 按位取反（符号位也取反） 101 源码 101 补码 （取反+1） 110+1（此时符号位不取反） 111 = -3 两数交换的其他方法 num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; 左移&lt;&lt; 右移&gt;&gt; 一维数组 本质并不是一个指针 ​ 有两种特殊情况：1.对数组进行sizeof 2.对数组名称取地址 ，获取的指针步长为整个数组的长度 其他情况都是指向数组首元素的地址的指针 数组名 -- 指针常量 ，指针的指向不可以修改 int * const p 访问数组元素的时候下标可以为负数 结构体偏移量 offsetof计算 或 地址相减 cpu按块读取内存，块的大小为2的n次方 有了内存对齐，更好读取 #pragma pack(show) 查看对齐模数， 默认对齐为8 可改为2的n次方 对于自定义数据类型 内存对齐规则如下: 1、从第一个属性开始 偏移为0 2、从第二个属性开始，地址要放在 该类型整数倍 与 对齐模数比 取小的值的 整数倍 3、所有的属性都计算后，整体再做二次对齐 整体需要放在属性中最大类型与 对齐模数比 取小的值的整数倍上。 结构体嵌套结构体时，只需要看子结构体中最大数据类型就可以了 文件结尾 EOF fseek(文件指针，偏移，起始位置 SEEK_SET SEEK_END SEEK_CUR) rewind(文件指正) 将文件光标置首 error宏 全局变量 perror 打印宏提示错误信息 数组缺陷，静态空间，一旦分配内存就不可以动态扩展 对属于数组头进行插入和删除效率低 头结点 好处在于头结点永远都是固定的 静态链表 栈区 动态链表 堆区 带头节点链表好处在于头节点永远都是固定的 初始化链表struct LinkNode*pHeader= init_LinkList(u 遍历链表void foreach_LinkList( struct LinkNode pHeader )u 函数指针的定义 先定义出函数类型，再通过类型定义出函数指针 typedef void(FUNC_TYPE)(); FUNC_TYPE pEunc = func 先定义出函躞指针类型，再定义函数指针÷ typedef void(*FUNC_TYPE)();' FUNC_TYPE pFunc- func; 直接定义函数指针变量 void(* pEunc )()= fung; 函数指针和指针函数的区别 函数指针是指向函数的指针 指针函数―丞|数的返回值是一个指针的函数+ 函数指针的数组定义↓ void(*pFunc[3])();. 本题要求实现一个函数，判断任一给定整数N是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。 #include &lt;stdio.h&gt; #include &lt;math.h&gt; int IsTheNumber(const int N); int main() { int n1, n2, i, cnt; scanf(&quot;%d %d&quot;, &amp;n1, &amp;n2); cnt = 0; for (i = n1; i &lt;= n2; i++) { if (IsTheNumber(i)) cnt++; } printf(&quot;cnt = %d\\n&quot;, cnt); return 0; } int IsTheNumber(const int N) { int n = N; int b; int p[10] = { 0 }; int m = sqrt(n); if (m * m == n) { while (n) { b = n % 10; p[b]++; n /= 10; } for (int i = 0;i &lt;= 9;i++) { if (p[i] &gt; 1) return 1; } } return 0; } 声明和定义区别 l 声明变量不需要建立存储空间，如：extern int a; l 定义变量需要建立存储空间，如：int b; 从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义： l int b 它既是声明，同时又是定义 l 对于 extern b来讲它只是声明不是定义 ​ 不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型 在计算机系统中，数值一律用补码来存储，主要原因是： l 统一了零的编码 l 将符号位和其它位统一处理 l 将减法运算转变为加法运算 l 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃 斯特林(Stirling)公式 求大数阶乘的位数 我们知道整数n的位数的计算方法为：log10(n)+1n!=10^m故n!的位数为 m = log10(n!)+1 #pragmaonce这个宏有什么作用？ 为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。 在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。 如果我们要在一个函数内改变一个指针的值，我们就需要将形参定义了二级指针 中缀转后缀算法∶ 遍历中缀表达式中的数字和符号∶ **对于数字︰**直接输出. 对于符号∶ 左括号∶进栈 运算符号∶与栈顶符号进行优先级比较若栈顶符号优先级低∶此符号进栈 (默认栈顶若是左括号，左括号优先级最低)&gt; 若栈顶符号优先级不低∶将栈顶符号弹出并输出，之后进栈 右括号∶将栈顶符号弹出并输出，直到匹配左括号,将左括号和右括号同时舍弃 遍历结束∶将栈中的所有符号弹出并输出 计算规则· 遍历后缀表达式中的数字和符号 对于数字∶进栈 对于符号: 从栈中弹出右操作数 从栈中弹出左操作数 根据符号进行运算 将运算结果压入栈中 遍历结束:栈中的唯—数字为计算结果 List Reverse( List L ) { List head,next,prev; prev = NULL; head = L; while(head != NULL) { next = head-&gt;Next; head-&gt;Next = prev; prev = head; head = next; } return prev; } ","link":"https://xmweijh.github.io/post/c-yu-yan-xu/"},{"title":"HTML","content":"HTML Web 标准构成 构成： 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 VSCode常用快捷键 1） ！+enter : 快速生称html代码框架 2） shift+alt+向下的方向键： 向下复制当前行 3） shift+alt+向上的方向键： 向上复制当前行 4） ctrl+S： 保存 5）shift+alt+F: 格式化代码 6） ctrl+F: 查找和替换 文档类型&lt;!DOCTYPE&gt; 用法： &lt;!DOCTYPE html&gt; 作用： <!DOCTYPE> 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 页面语言lang &lt;html lang=&quot;en&quot;&gt; 指定html 语言种类 最常见的2个： en定义语言为英语 zh-CN定义语言为中文 字符集 &lt;meta charset=&quot;UTF-8&quot; /&gt; 字符集(Character set)是多个字符的集合。 计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 GUO BIAO BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则基本包含全世界所有国家需要用到的字符 这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。 HTML常用标签 排版标签 标题标签h (熟记) 单词缩写： head 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： &lt;h1&gt; 标题文本 &lt;/h1&gt; &lt;h2&gt; 标题文本 &lt;/h2&gt; &lt;h3&gt; 标题文本 &lt;/h3&gt; &lt;h4&gt; 标题文本 &lt;/h4&gt; &lt;h5&gt; 标题文本 &lt;/h5&gt; &lt;h6&gt; 标题文本 &lt;/h6&gt; 加了标题的文字会变的加粗，字号也会依次变大 一行是只能放一个标题的 段落标签p ( 熟记) 单词缩写： paragraph 作用语义： 可以把 HTML 文档分割为若干段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 &lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签hr(认识) 单词缩写： horizontal 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： &lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 换行标签br (熟记) 单词缩写： break 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 div 和 span标签(重点) div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span 跨度，跨距；范围 语法格式： &lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们主要记住使用方法和特点就好了 div标签 用来布局的，但是现在一行只能放一个div span标签 用来布局的，一行上可以放好多个span 排版标签总结 标签名 定义 说明 标题标签 作为标题使用，并且依据重要性递减 段落标签 可以把 HTML 文档分割为若干段落 水平线标签 没啥可说的，就是一条线 换行标签 div标签 用来布局的，但是现在一行只能放一个div span标签 用来布局的，一行上可以放好多个span 文本格式化标签(熟记) 在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 区别： b 只是加粗 strong 除了可以加粗还有 强调的意思， 语义更强烈。 标签属性 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： &lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt; 图像标签img (重点) 单词缩写： image 要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。 语法如下： &lt;img src=&quot;图像URL&quot; /&gt; 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了 **注意: ** 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 采取 键值对 的格式 key=&quot;value&quot; 的格式 比如: 正常的&lt;br /&gt; &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;&lt;br /&gt; 带有边框的&lt;br /&gt; &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; /&gt;&lt;br /&gt; 有提示文本的&lt;br /&gt; &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&gt;&lt;br /&gt; 有替换文本的&lt;br /&gt; &lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;图片不存在&quot; /&gt; 链接标签(重点) 单词缩写： anchor 的缩写 在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。 语法格式： &lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，__blank为在新窗口中打开方式。 注意： 外部链接 需要添加 http:// www.baidu.com 内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 注释标签 在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 简单解释： 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 语法格式： &lt;!-- 注释语句 --&gt; 快捷键是： ctrl + / 或者 ctrl +shift + / 路径(重点、难点) 实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。 **目录文件夹： ** 就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。 **根目录 ** 打开目录文件夹的第一层 就是 根目录 页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径 相对路径 以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 路径分类 符号 说明 同一级路径 只需输入图像文件的名称即可，如&lt;img src=&quot;baidu.gif&quot; /&gt;。 下一级路径 “/” 图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images） 如&lt;img src=&quot;images/baidu.gif&quot; /&gt;。 上一级路径 “../” 在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推， 如&lt;img src=&quot;../baidu.gif&quot; /&gt;。 相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级 简单说，就是 图片 位于 HTML 页面的位置 绝对路径 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 注意： 绝对路径用的较少，我们理解下就可以了。 但是要注意，它的写法 特别是符号 \\ 并不是 相对路径的 / 锚点定位 （难点） 通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 1. 使用相应的id名标注跳转目标的位置。 (找目标) &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 2. 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） （拉关系） 我也有一个姓毕的姥爷.. &lt;a href=&quot;#two&quot;&gt; 快速记忆法： 好比找个人办事， 首先找到他，然后拉关系，最后看效果。 base 标签 语法： &lt;base target=&quot;_blank&quot; /&gt; **总结： ** base 可以设置整体链接的打开状态 base 写到 之间 把所有的连接 都默认添加 target=&quot;_blank&quot; 预格式化文本pre标签 标签可定义预格式化的文本。 被包围在 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 ```html 此例演示如何使用 pre 标签 对空行和 空格 进行控制 了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 ### 表格 table 表格的现在还是较为常用的一种标签，但不是用来布局，**常见显示、展示表格式数据。** 因为它可以让数据显示的非常的规整，可读性非常好。 **特别是后台展示数据的时候表格运用是否熟练就显得很重要**，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。 #### **创建表格的基本语法：** ```html &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; 要深刻体会表格、行、单元格他们的构成。 在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 table用于定义一个表格标签。 tr标签 用于定义表格中的行，必须嵌套在 table标签中。 td 用于定义表格中的单元格，必须嵌套在标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。 表头单元格标签th 作用： 一般表头单元格位于表格的第一行或第一列，并且文本加粗居中 语法： 只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 th 也是一个单元格 只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗 表格标题caption 定义和用法 &lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt; &lt;/table&gt; **注意： ** caption 元素定义表格标题，通常这个标题会被居中且显示于表格之上。 caption 标签必须紧随 table 标签之后。 这个标签只存在 表格里面才有意义。 合并单元格 合并单元格2种方式 跨行合并：rowspan=&quot;合并单元格的个数&quot; 跨列合并：colspan=&quot;合并单元格的个数&quot; **合并的顺序我们按照 先上 后下 先左 后右 的顺序 ** 合并单元格三步曲 先确定是跨行还是跨列合并 根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ： 删除多余的单元格 单元格 总结表格 标签名 定义 说明 表格标签 就是一个四方的盒子 表格行标签 行标签要再table标签内部才有意义 单元格标签 单元格标签是个容器级元素，可以放任何东西 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 表格的学习要求： 能手写表格结构，并且能简单合并单元格。 列表标签 概念： 容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表 特点： 列表最大的特点就是 整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。 无序列表 ul 无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...... &lt;/ul&gt; 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...... &lt;/ol&gt; 所有特性基本与ul 一致。 但是实际中比 无序列表 用的少很多。 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ... &lt;/dl&gt; 列表总结 标签名 定义 说明 无序标签 里面只能包含li 没有顺序，我们以后布局中最常用的列表 有序标签 里面只能包含li 有顺序， 使用情况较少 自定义列表 里面有2个兄弟， dt 和 dd 表单标签 **表单控件： ** ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件 语法： &lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt; input 输入的意思 &lt;input /&gt;标签为单标签 type属性设置不同的属性值用来指定不同的控件类型 除了type属性还有别的属性 1. type 属性 这个属性通过改变值，可以决定了你属于那种input表单。 比如 type = 'text' 就表示 文本框 可以做 用户名， 昵称等。 比如 type = 'password' 就是表示密码框 用户输入的内容 是不可见的。 用户名: &lt;input type=&quot;text&quot; /&gt; 密 码：&lt;input type=&quot;password&quot; /&gt; 2. value属性 值 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。 3. name属性 用户名:&lt;input type=&quot;text&quot; name=“username” /&gt; name表单的名字， 这样，后台可以通过这个name属性找到这个表单。 页面中的表单很多，name主要作用就是用于区别不同的表单。 name属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以多个选其中的一个啦 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女 name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。 4. checked属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 性 别: &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 上面这个，表示就默认选中了 男 这个单选按钮 5. input 属性小结 属性 说明 作用 type 表单类型 用来指定不同的控件类型 value 表单值 表单里面默认显示的文本 name 表单名字 页面中的表单很多，name主要作用就是用于区别不同的表单。 checked 默认选中 表示那个单选或者复选按钮一开始就被选中了 lab 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。 如何绑定元素呢？ 第一种用法就是用label直接包括input表单。 &lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt; &lt;/label&gt; 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定。 &lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot;&gt; textarea控件(文本域) 语法： &lt;textarea &gt; 文本内容 &lt;/textarea&gt; 作用： 通过textarea控件可以轻松地创建多行文本输入框. cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot; 我们实际开发不用 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type=&quot;text&quot; 文本框 只能显示一行文本 单标签，通过value显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 select下拉列表 语法： &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; 注意： &lt;select&gt; 中至少包含一对 option 在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。 但是我们实际开发会用的比较少 form表单域 目的： 在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 **语法: ** &lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件 &lt;/form&gt; 常用属性： 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get/post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 注意: 每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。 经常查阅文档是一个非常好的学习习惯。 W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/ ","link":"https://xmweijh.github.io/post/html/"},{"title":"web代码规范","content":"代码规范 1. 概述 欢迎使用品优购代码规范， 这个是我借鉴京东前端代码规范，组织的品优购内部规范。旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范， 以下规范是团队基本约定的内容，必须严格遵循。 HTML规范 基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。 图片规范 了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。 CSS规范 统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。 命名规范 从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。 2. HTML 规范 DOCTYPE 声明 HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： &lt;!DOCTYPE html&gt; HTML5标准模版 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML5标准模版&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 页面语言lang 推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 &lt;html lang=&quot;zh-CN&quot;&gt; 更多地区语言参考： zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡) zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港) zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门) zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) charset 字符集合 一般情况下统一使用 “UTF-8” 编码 &lt;meta charset=&quot;UTF-8&quot;&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 &lt;meta charset=&quot;GBK&quot;&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 书写风格 HTML代码大小写 HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; 不推荐： &lt;div class=&quot;DEMO&quot;&gt;&lt;/div&gt; &lt;DIV CLASS=&quot;DEMO&quot;&gt;&lt;/DIV&gt; 类型属性 不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt; 不推荐： &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; &gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; &gt; 不推荐： &lt;input type=text&gt; &lt;input type='text'&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked &gt; 特殊字符引用 文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： &lt;a href=&quot;#&quot;&gt;more&amp;gt;&amp;gt;&lt;/a&gt; 不推荐： &lt;a href=&quot;#&quot;&gt;more&gt;&gt;&lt;/a&gt; 代码缩进 统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） &lt;div class=&quot;jdc&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/div&gt; 代码嵌套 元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： &lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： &lt;div&gt; &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： &lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： &lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt; &lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; 3. 图片规范 内容图 内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 PC平台单张的图片的大小不应大于 200KB。 背景图 背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 4. CSS规范 代码格式化 样式书写一般有两种：一种是紧凑格式 (Compact) .jdc{ display: block;width: 50px;} 一种是展开格式（Expanded） .jdc { display: block; width: 50px; } 团队约定 统一使用展开格式书写样式 代码大小写 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。 /* 推荐 */ .jdc{ display:block; } /* 不推荐 */ .JDC{ DISPLAY:BLOCK; } 选择器 尽量少用通用选择器 * 不使用 ID 选择器 不使用无具体语义定义的标签选择器 /* 推荐 */ .jdc {} .jdc li {} .jdc li p{} /* 不推荐 */ *{} #jdc {} .jdc div{} 代码缩进 统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） .jdc { width: 100%; height: 100%; } 分号 每个属性声明末尾都要加分号； .jdc { width: 100%; height: 100%; } 代码易读性 左括号与类名之间一个空格，冒号与属性值之间一个空格 推荐： .jdc { width: 100%; } 不推荐： .jdc{ width:100%; } 逗号分隔的取值，逗号之后一个空格 推荐： .jdc { box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc; } 不推荐： .jdc { box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc; } 为单个css选择器或新申明开启新行 推荐： .jdc, .jdc_logo, .jdc_hd { color: #ff0; } .nav{ color: #fff; } 不推荐： .jdc,jdc_logo,.jdc_hd { color: #ff0; }.nav{ color: #fff; } 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0 推荐： .jdc { color: rgba(255,255,255,.5); } 不推荐： .jdc { color: rgba( 255, 255, 255, 0.5 ); } 属性值十六进制数值能用简写的尽量用简写 推荐： .jdc { color: #fff; } 不推荐： .jdc { color: #ffffff; } 不要为 0 指明单位 推荐： .jdc { margin: 0 10px; } 不推荐： .jdc { margin: 0px 10px; } 属性值引号 css属性值需要用到引号时，统一使用单引号 /* 推荐 */ .jdc { font-family: 'Hiragino Sans GB'; } /* 不推荐 */ .jdc { font-family: &quot;Hiragino Sans GB&quot;; } 属性书写顺序 建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … .jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px; } mozilla官方属性顺序推荐 命名规范 由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。 目录命名 项目文件夹：pinyougou 样式文件夹：css 脚本文件夹：js 样式类图片文件夹：img 产品类图片文件夹： upload 字体类文件夹： fonts ClassName命名 ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 .nav_top 常用命名推荐 注意：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此 &lt;div class=&quot;ad&quot;&gt;&lt;/div&gt; 这种广告的英文或拼音类名不应该出现 另外，敏感不和谐字眼也不应该出现，如： &lt;div class=&quot;fuck&quot;&gt;&lt;/div&gt; &lt;div class=&quot;jer&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sm&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gcd&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ass&quot;&gt;&lt;/div&gt; &lt;div class=&quot;KMT&quot;&gt;&lt;/div&gt; ... ClassName 含义 about 关于 account 账户 arrow 箭头图标 article 文章 aside 边栏 audio 音频 avatar 头像 bg,background 背景 bar 栏（工具类） branding 品牌化 crumb,breadcrumbs 面包屑 btn,button 按钮 caption 标题，说明 category 分类 chart 图表 clearfix 清除浮动 close 关闭 col,column 列 comment 评论 community 社区 container 容器 content 内容 copyright 版权 current 当前态，选中态 default 默认 description 描述 details 细节 disabled 不可用 entry 文章，博文 error 错误 even 偶数，常用于多行列表或表格中 fail 失败（提示） feature 专题 fewer 收起 field 用于表单的输入区域 figure 图 filter 筛选 first 第一个，常用于列表中 footer 页脚 forum 论坛 gallery 画廊 group 模块，清除浮动 header 页头 help 帮助 hide 隐藏 hightlight 高亮 home 主页 icon 图标 info,information 信息 last 最后一个，常用于列表中 links 链接 login 登录 logout 退出 logo 标志 main 主体 menu 菜单 meta 作者、更新时间等信息栏，一般位于标题之下 module 模块 more 更多（展开） msg,message 消息 nav,navigation 导航 next 下一页 nub 小块 odd 奇数，常用于多行列表或表格中 off 鼠标离开 on 鼠标移过 output 输出 pagination 分页 pop,popup 弹窗 preview 预览 previous 上一页 primary 主要 progress 进度条 promotion 促销 rcommd,recommendations 推荐 reg,register 注册 save 保存 search 搜索 secondary 次要 section 区块 selected 已选 share 分享 show 显示 sidebar 边栏，侧栏 slide 幻灯片，图片切换 sort 排序 sub 次级的，子级的 submit 提交 subscribe 订阅 subtitle 副标题 success 成功（提示） summary 摘要 tab 标签页 table 表格 txt,text 文本 thumbnail 缩略图 time 时间 tips 提示 title 标题 video 视频 wrap 容器，包，一般用于最外层 wrapper 容器，包，一般用于最外层 ","link":"https://xmweijh.github.io/post/web-dai-ma-gui-fan/"},{"title":"计算机网络","content":"计算机网络 概述 计算机网络:是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 计算机网络是互连的、自治的计算机集合。 互连-互联互通通信链路 自治-无主从关系 计算机网络的功能 ★1. 数据通信(连通性) 2.资源共享 硬件 软件 数据 3.分布式处理 多台计算机各自承担同一工作任务的不同部分 Hadoop 平台 4.提高可靠性 替代机 5.负载均衡 各计算机之间更亲密 计算机网络的组成 1.组成部分硬件、软件、协议(一系列规则和约定的集合) 标准的分类- 法定标准 由权威机构制定的正式的、 合法的标准 OSI 事实标准 某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准 TCP/IP RFC (Request For Comments )一因特网标准的形式 RFC要上升为因特网正式标准的四个阶段: 1)因特网草案(Internet Draft)这个阶段还不是RFC文档。 2)建议标准(Proposed Standard)从这个阶段开始成为RFC文档。 3)草案标准( Draft Standard) IETF、IAB 4)因特网标准( internet Standard) 国际标准化组织ISO OSI参考模型、HDLC协议 国际电信联盟ITU 制定通信规则 国际电气电子工程师协会IEEE 学术机构、IEEE802 系列标准、5G Internet工程任务组IETF 负责因特网相关标准的制定RFC XXXX 速率即数据率或称数据传输率或比特率。 比特1/0 位 连接在计算机网络上的主机在数字信道上传送数据位数的速率。 单位是b/s，kb/s, Mb/s, Gb/s， Tb/s (1) “带宽&quot;原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz)。 (2)计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中 的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s, kb/s, Mb/s, Gb/s。 网络设备所支持的最高速度 吞吐量 表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s，kb/s， Mb/s等。 吞吐量受网络的带宽或网络的额定速率的限制。 时延 指数据(报文/分组/比特流)从网络( 或链路)的-端传送到另一端所需的时间。也叫延迟或迟延。单位s。 时延 发送时延(传输时延) 传播时延 排队时延 处理时延 时延带宽积=传播时延X带宽 时延带宽积又称为以比特为单位的链路长度。即“某段链路现在有多少比特” 容量 往返时延RTT 从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。 RTT越大，在收到确认之前，可以发送的数据越多。 RTT包括 往返传播时延=传播时延*2 末端处理时间 利用率 信道利用率 网络利用率 分层的基本原则 1.各层之间相互独立，每层只实现一种相对独立的功能。 2.每层之间界面自然清晰，易于理解，相互交流尽可能少。 3.结构上可分割开。每层都采用最合适的技术来实现。 4.保持下层对上层的独立性，上层单向使用下层提供的服务。 5.整个分层结构应该能促进标准化工作。 1.实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。 2.协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。【水平】 语法:规定传输数据的格式 语义:规定所要完成的功能 同步:规定各种操作的顺序 3.接口（访问服务点SAP）:上层使用下层服务的入口。 4.服务:下层为相邻上层提供的功能调用。【垂直】 SDU服务数据单元:为完成用户所要求的功能而应传送的数据。 PCI协议控制信息:控制协议操作的信息。 PDU协议数据单元:对等层次之间传送的数据单位。 网络体系结构是从功能上描述计算机网络结构。 计算机网络体系结构简称网络体系结构是分层结构。 每层遵循某个/些网络协议以完成本层功能。 计算机网络体系结构是计算机网络的各层及其协议的集合。 体系结构是抽象的，而实现是指能运行的一些软件和硬件。 第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。 仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。 物理层 物理层接口特性 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务:确定与传输媒体接口有关的一些特性 定义标准 1机械特性 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。 2电气特性 规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。 3功能特性 指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 4规程待性 (过程特性）定义各条物理线路的工作规程和时序关系。 数据通信相关术语 通信的目的是传送消息（消息:语音、文字、图像、视频等）。 数据data:传送信息的实体，通常是有意义的符号序列。 信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。 数字信号/离散信号:代表消息的参数的取值是离散的。 模拟信号/连续信号:代表消息的参数的取值是连续的。信源:产生和发送数据的源头。 信宿:接收数据的终点。 条发送信道和一条接收信道。 信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。 三种通信方式 从通信双方信息的交互方式看，可以有三种基本方式: 1.单工通信 只有一个方向的通信而没有反方向的交互，仅需要一条信道。 2.半双工通信/双向交替通信 通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。 3.全双工通信/双向同时通信 通信双方可以同时发送和接受信息，也需要两条信道。 串行传输&amp;并行传输 串行传输将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。速度慢，费用低，适合远距离 并行传输将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离 同步传输&amp;异步传输 同步传输:在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。 。 异步传输:异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位 码元 码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。 1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。 数字通信系统数据传输速率的两种表示方法 速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示 1）码元传输速率:别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数)，单位是波特（Baud)。1波特表示数字通信系统每秒传输一个码元。 数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。 2）信息传输速率:别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)，单位是比特/秒(b/s)。 带宽（Bandwidth） 1.模拟信号系统中:当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。 2数字设备中:表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps)。 失真 影响失真程度的因素:1.码元传输速率﹐⒉信号传输距离 3.噪声干扰 4.传输媒体质量 码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。 奈氏准则（奈奎斯特定理） 奈氏准则:在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰,极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。 理想低通信道下的极限数据传输率=2Wlog2v (b/s) v：几种码元/码元的离散电平数目 1.在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。 2.信道的频带越宽（即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。 3.奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限 4.由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多信息量，这就需要采用多元制的调制方法。 香农定理 信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即: 信噪比（dB） =10log10(S/N) 数值等价 香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。 信道的极限数据传输速率=Wlog2(1+S/N) (b/s) 1.信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 2对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 3.只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。 4.香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。 基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。 宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化) 在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出基带型号） 数据 ------ 数字信号 编码 数据 ------ 模拟信号 调制 数字数据编码为数字信号 (1）非归零编码【NRZ】 (2）曼彻斯特编码 (3）差分曼彻斯特编码 (4）归零编码【RZ】 (5）反向不归零编码【NRZl】 (6）4B/5B编码 数字数据调制为模拟信号 数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。 模拟数据编码为数字信号 计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）。 最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中,能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。 1.抽样:对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:f采样频率&gt;=2f信号最高频率 ⒉量化:把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。 3.编码:把量化的结果转换为与之对应的二进制编码。 模拟数据调制为模拟信号 为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式，模拟的声音数据是加载到模拟的载波信号中传输的。 数据交换方式 电路交换 报文交换 存储转发 电路交换的原理: 在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。 电路交换的阶段: 建立连接（呼叫/电路建立） 通信(数据传输） 释放连接(拆除电路） 特点:独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况 电路交换优点 传输时延小 数据顺序传送，无失序问题 实时性强，双方一旦建立物理通路，便可以实时通信，适用于交互式会话类通信。 全双工通信，没有冲突，通信双方有不同的信道，不会争用物理信道 适用于模拟信号和数字信号 控制简单，电路的交换设备及控制较简单 电路交换缺点 建立连接时间长 线路独占，即使通信线路空闲，也不能供其他用户使用，信道使用效率低。 灵活性差，双方连接通路中的任何一点除了故障，必须重新拨号建立新连接，不适应突发性通信。 无数据存储能力，难以平滑通信量。 电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信 无法发现与纠正传输差错，难以在通信过程中进行差错控制。 报文:报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。 报文交换的原理: 无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。 报文交换优点 无需建立连接，无建立连接时延，用户可随时发送报文。 动态分配线路，动态选择报文通过的最佳路径，可以平滑通信量。 提高线路可靠性，某条传输路径发生故障，可重新选择另一条路径传输。 提高线路利用率，通信双方在不同的时间一段一段地部分占有这条物理通道，多个报文可共享信道。 提供多目标服务:一个报文可同时发往多个目的地址。 在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度预同的计算机之间通行通信。 报文交换缺点 实时性差，不适合传送实时或交互式业务的数据。数据进入交换结点后要经历存储转发过程，从而引起转发时延。 只适用于数字信号。 由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。 分组:大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet） 。 分组交换的原理: 分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。 分组交换优点 无建立时延，无需为通信双方预先建立一条专用通信线路，用户对随时发送分组。 线路利用率高，通信双方在不同的时间一段一段地部分占有这条物理通道，多个分组可共享信道。 简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。 加速传输，后一个分组的存储可以和前一个分组的转发并行操作;传输一个分组比一份报文所需缓冲区小，减少等待发送时间。 减少出错几率和重发数据量，提高可靠性，减少传输时延。 分组短小，适用于计算机之问突发式数据通信。 分组交换缺点 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。 每个分组都要加控制信息，一定程度上降低了通信效率，增加了处理的时间。 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。 1.传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。 2.当端揣到揣的通路有很多段的链路组成时，采用分组交换传送数据较为合适。 3.从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交 换的时延小，尤其适合于计算机之间的突发式的数据通信。 数据报方式的特点 1.数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。 无连接服务∶不事光为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。 2.同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。 3.每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。 4.分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较太或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。 5.网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通 虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。 虚电路方式的特点 1.虚电路方式为网络层提供连接服务。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。 连接服务︰首光为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。 2.一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，包含虚电路号，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。 3.分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。 4.每个节点可能与多个节点之间建立多条虚电路，每条虚电路支持特定的两个端系统之间的数据传输，可以对两个数据端点的流量进行控制，两个端系统之间也可以有多条虚电路为不同的进程服务。 5.致命弱点:当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将会遭到破坏 传输介质及分类 传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。 传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。 但物理层规定了电气特性，因此能够识别所传送的比特流。 导向性传输介质——1.双绞线 双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP），无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。 同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类:5OQ同轴电缆和7sQ同轴电缆。其中，50Q同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用;75Q同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。 光纤主要由纤芯(实心的! )和包层构成，光波通过纤芯进行传导，包尾较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。 光纤的特点: 1.传输损耗小，中继距离长，对远距离传输特别经济。 2.抗雷电和电磁干扰性能好。 3.无串音干扰，保密性好，也不易被窃听或截取数据。 4.体积小，重量轻。 非导向性传输介质 无线电波:较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）。 信号向所有方向传播 微波 红外线、激光 中继器的功能:对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（再生数字信号） 中继器的两端:两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。 5-4-3规则:网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。 集线器（多口中继器） 集线器的功能:对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。(再生，放大信号) 数据链路层 数据链路层功能概述 数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 功能一:为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。 功能二:链路管理，即连接的建立、维持、释放（用于面向连接的服务） 功能三:组帧。 功能四:流量控制。 功能五:差错控制（帧错/位错）。 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。 帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。 组帧的四种方法:1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。 局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。 决定局域网的主要要素为:网络拓扑，传输介质与介质访问控制方法。 局域网介质访问控制方法 1.CSMA/CD常用于总线型局域网，也用于树型网络 2令牌总线常用于总线型局域网，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。3.令牌环用于环形局域网，如令牌环网 IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。 以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD(载波监听多路访问及冲突检测）技术。 以太网两个标准 DIX Ethernet V2:第一个局域网产品（以太网）规约。 IEEE 802.3: IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动） 以太网提供无连接、不可靠的服务 以太网只实现无差错接收，不实现可靠传输 使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。 以太网拓扑:逻辑上总线型，物理上星型。 10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。 物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。 采用曼彻斯特编码。 采用CSMA/CD介质访问控制。 计算机与外界有局域网的连接是通过通信适配器的。 在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符 IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准。 点对点协议PPP ( Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。 只支持全双工链路。 网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪-一个接口，或者是把它丢弃(即过滤)。 网络层 主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。 网络层传输单位是数据报。 ","link":"https://xmweijh.github.io/post/ji-suan-ji-wang-luo/"},{"title":"HTML基础","content":"HTML 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。 常见状态码 200 ：成功。 400 ：客户端请求有语法错误，服务器端不能理解。 401 ：该请求可能未经过授权。 403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。 404 ：该资源没找到。 500 ：服务器端发生了一个不可预知的错误。 503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。 HTML（超文本标记语言）是一种用于创建网页的标准标记语言。 HTML 不需要编译，可以直接由浏览器执行，它的解析依赖于浏览器的内核。 它不是一种编程语言，而是一种标记语言。 一个网页的基本结构： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;HTML 简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt;是我们的文档声明头。他告诉了浏览器，本文档处理的是 HTML 文档。html 标签即根元素，此处表示文档的开始。head 标签是网页的头部，设置网页的相关信息。title 标签设置网页标题。body 标签定义文档的主体，也就是我们的主要内容。 在 HTML 中满足以下格式的内容即为注释，被注释的内容将不会被渲染和显示。 &lt;!-- 在此处写注释 --&gt; **注：**在开始标签中有一个惊叹号，但是结束标签中没有。浏览器不会显示注释，但是能够帮助记录。 HTML 标签的大小写无关的，例如 和 表示的意思是一样的，都代表“主体”，推荐使用小写。 双标签（双标记） 双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下： &lt;标记名&gt;&lt;/标记名&gt; 常见的双标签有： &lt;html&gt;&lt;/html&gt; &lt;head&gt;&lt;/head&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;a&gt;&lt;/a&gt; &lt;ul&gt;&lt;/ul&gt; 单标签（单标记） 单标记也称空标记，是指用一个标记符号即可完整地描述某个功能的标记。其基本语法格式如下： &lt;标记名/&gt; 常见的单标签有： &lt;br /&gt; &lt;!--换行--&gt; &lt;hr /&gt; &lt;!--水平分隔线--&gt; &lt;meta /&gt; &lt;img /&gt; 标签的关系 嵌套关系 &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 并列关系 &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 例子： &lt;p&gt;I Love You&lt;/p&gt; 注：这个元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 ，以及一个结束标签。元素内容是：I Love You。 h 系类标签 h 标签有六种 h1，h2，h3，h4，h5，h6，它代表着我们的标题。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;HTML 简介&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; &lt;h2&gt;我是二级标题&lt;/h2&gt; &lt;h3&gt;我是三级标题&lt;/h3&gt; &lt;h4&gt;我是四级标题&lt;/h4&gt; &lt;h5&gt;我是五级标题&lt;/h5&gt; &lt;h6&gt;我是六级标题&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; p 标签 p 标签是我们的文本标签。 图片标签 HTML 的图像是通过标签 &lt;img&gt;来定义的。 a 标签 标签是超链接标签，意思就是我们点击它可以跳转到一个网页。 div 标签 标签是一个块级元素，块级元素占据其父元素（容器）的整个空间，你可以把它想成一个盒子。 能够设置其宽高 换行标签和空格字符 在浏览器显示页面时，浏览器会移除源代码中多余的空格和空行，所有连续的空格或空行都会被认为是一个空格。如果希望在不产生一个新段落的情况下换行，可以使用&lt;br/&gt;标签。如果想使用空格的话可以使用&amp;nbsp;字符 &lt;body&gt; &lt;p&gt;这是一段文字 前面有很多空格但是只显示一个&lt;/p&gt; &lt;p&gt;这是一段文字&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用了空格字符&lt;/p&gt; &lt;br /&gt; &lt;p&gt;上面是换行符&lt;/p&gt; &lt;/body&gt; 水平分割线 &lt;hr/&gt; 标签用于在 HTML 页面中创建一条水平线。 标签 可将网页页面分割成不同的独立部分，通常用于定义文档中的区域或节。该标签是一个块级元素，浏览器会自动在 和 所标记的区域前后自动放置一个换行符。 标签 通常作为文本的容器，它没有特定的含义和样式，只有与 CSS 同时使用才可以为指定文本设置样式属性。该标签是一个内联元素，他与块级元素相反，内联元素不会自动在前后自动放置换行符，因此内联元素会默认显示在同一行。 无序列表是一个项目的列表，此列项目使用实心圆、空心圆、方块进行标记，无序列表使用 标签。同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 标签。每个列表项始于 标签。 &lt;p&gt;无序列表&lt;/p&gt; &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;有序列表&lt;/p&gt; &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 无序列表和有序列表的 type 属性： type 属性定义了列表项前项目符号的类型。 &lt;ul&gt;标签的 type 属性： 值 备注 disc（默认） 实心圆 circle 空心圆 square 小方块 &lt;ol&gt;标签的 type 属性： 值 备注 1（默认） 数字表示（1，2，3...) A 大写字母表示（A,B,C...) a 小写字母表示（a,b,c...) I 大写罗马数字表示(I,II,III…) i 小写罗马数字表示(i,ii,iii…) &lt;p&gt;无序列表&lt;/p&gt; &lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;空心圆列表项1&lt;/li&gt; &lt;li&gt;空心圆列表项2&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;有序列表&lt;/p&gt; &lt;ol type=&quot;A&quot;&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;/ol&gt; 自定义列表（dl） 定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt;开始。自定义列表的列表项前没有任何项目符号。 语法格式： &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; ... &lt;/dl&gt; HTML 样式实例 - 背景颜色 &lt;html&gt; &lt;body&gt; &lt;p style=&quot;background-color:red&quot;&gt;xxx&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 注：通过 &quot;background-color&quot; 属性值的设置来给背景设置颜色。 HTML 样式实例 - 字体、颜色和尺寸 &lt;html&gt; &lt;body&gt; &lt;p style=&quot;font-family:arial;color:green;font-size:50px;&quot;&gt;xxx&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 注：通过对 font-family 属性值的设置来设置字体，通过对 color 属性值的设置来设置颜色，通过对 font-size 属性值的设计来设计字体大小。 HTML 样式实例 - 文本对齐 &lt;html&gt; &lt;body&gt; &lt;h1 style=&quot;text-align:center&quot;&gt;xxx&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 表格由 标签来定义。每个表格均有若干行（由 标签定义），每行被分割为若干单元格（由 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 &lt;table&gt; //&lt;table border=&quot;1&quot;&gt;给表格加上边框 &lt;tr&gt; &lt;td&gt;第一行第一列&lt;/td&gt; &lt;td&gt;第一行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二行第一列&lt;/td&gt; &lt;td&gt;第二行第二列&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 表格一般都有标题，在 HTML 中表格标题通过 定义。 表格的表头使用 标签进行定义，表头通常用于列名字。 &lt;table border=&quot;1&quot; width=&quot;300px&quot; height=&quot;150px&quot;&gt; &lt;caption&gt; 支出表 &lt;/caption&gt; &lt;tr&gt; &lt;th&gt;支出&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;32&lt;/td&gt; &lt;td&gt;买苹果&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;24&lt;/td&gt; &lt;td&gt;买饮料&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 绘制表格的时候，我们常常需要合并单元格，而在 HTML 中提供了 colspan（合并行）和 rowspan（合并列）属性来帮助我们实现这一效果。 colspan 又称跨列，rowspan 又称跨行。 设置 rowspan=&quot;2&quot; 表示合并该列上的两个单元格，同样的我们可以通过设置 colspan 来合并行 在网页中可以使用很多个 div，在网页制作中，使用 div 可以将网页中的任何元素布局到网页中的任何位置。 语法： &lt;div style=&quot;样式设置&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; table 元素布局： 优点： 理解比较简单。 不同的浏览器看到的效果一般相同。 缺点： 显示样式和数据绑定在一起。 布局的时候灵活度不高。 一个页面可能会有大量的 table 元素，代码冗余度高。 增加带宽。 搜索引擎不喜欢这样的布局。 div 元素布局： 优点： 符合 W3C 标准。 搜索引擎更加友好。 样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。 节省代宽，代码冗余度低。 表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。 &lt;form&gt;标签用于创建 HTML 表单，常见的表单格式为： &lt;form name=&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;&lt;/form&gt; name：定义表单的名字。 method：定义表单结果从浏览器传送到服务器的方式，默认参数为：get 。post 安全性更高，因此常用作传输密码等，而 get 安全性较低，一般用于查询数据。 action：发送数据要去的地址。它的值必须是一个有效的 URL，可以是相对 URL 也可以是绝对 URL。如果没有提供此属性或者 action=&quot;#&quot;，则数据将被发送到包含表单的页面的 URL。 在网页中最常见的表单元素就是文字字段，用户可以在文字字段内输入字符或者单行文本。 语法： &lt;input type=&quot;text&quot; name=&quot;控件名称&quot; value=&quot;文字字段的默认取值&quot; size=&quot;控件的长度&quot; maxlength=&quot;最长字符数&quot; /&gt; 该语法包含了许多参数，除了 type 参数以外，其他的参数都是可选的 举个例子： &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; /&gt;&lt;br /&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;40&quot; value=&quot;10&quot; maxlength=&quot;3&quot; /&gt; &lt;/form&gt; 密码输入框 密码输入框是一种特殊的文字字段，他的各个属性和文字字段是相同的，但是输入进密码输入框的字符全部是“*”表示，保证周围人看不见输入的文本。 &lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt; 单选按钮 单选按钮可以使用户从选择列表中选择一个选项。 &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked /&gt;男&lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; /&gt;女 &lt;/form&gt; 几个单选按钮可以连接在一起，只需要把它们的 name 值设置为相同的。同一组中只有一个按钮可以同时被选。如果没有选中任何一个，那么整个单选按钮池就被认为处于未知状态，且不会随表单提交。 可以尝试如果 name 不相同或者没有 name 会是什么情况。 复选框可以让用户从一个选项列表中选择超出一个的选项。 &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;music&quot; checked /&gt;音乐&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;art&quot; /&gt;美术&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;math&quot; /&gt;数学&lt;br /&gt; &lt;/form&gt; 复选框可以拥有自己的名字，并不需要属于一个组。 按钮 HTML 表单中，有三种按钮：提交按钮，重置按钮，匿名按钮。我们可以使用 元素或者 元素来创建一个按钮。type 属性的值指定显示什么类型的按钮。 提交按钮（submit） 用于发送表单数据给服务器。 语法： &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;输入的内容&quot; /&gt; &lt;button type=&quot;submit&quot;&gt; This a submit button &lt;/button&gt; &lt;!--or--&gt; &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt; &lt;/form&gt; 重置按钮（reset） 重置按钮用来清除用户在页面中输入的信息。 语法： &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;button type=&quot;reset&quot;&gt; This a reset button &lt;/button&gt; &lt;!--or--&gt; &lt;input type=&quot;reset&quot; value=&quot;This is a reset button&quot; /&gt; &lt;/form&gt; 在文本框中输入内容，点击按钮即可清除。 匿名按钮（button） 没有自动生效的按钮，但是可以使用 JavaScript 代码进行定制。如果你省略了 type 属性，那么这就是默认值。 语法： &lt;button type=&quot;button&quot;&gt; This a anonymous button &lt;/button&gt; &lt;!--or--&gt; &lt;button&gt; This a anonymous button &lt;/button&gt; &lt;!--or--&gt; &lt;input type=&quot;button&quot; value=&quot;This is a anonymous button&quot; /&gt; 不管使用的是 元素还是 元素，按钮的行为都是一样的。它们的不同点在于： 从前面的例子中也可以看出 元素允许你使用 HTML 内容作为其标记内容，但 元素只接受纯文本内容。 使用 元素，可以有一个不同于按钮标签的值（通过将其设置为 value 属性）。 下拉菜单 下拉菜单能够节省页面空间，正常状态下显示一个选项，单击展开所以选项。 &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;select name=&quot;select&quot;&gt; &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt; &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt; &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; 注意：下拉菜单的宽度是由 标记中包含的最长文本的宽度决定的。 列表项 在页面中列表项可以显示出几条信息，一旦超出这个信息量，在列表项右侧会出现滚动条，拖动滚动条可以看到所有选项。 &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;select name=&quot;select&quot; size=&quot;2&quot; multiple=&quot;multiple&quot;&gt; &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt; &lt;option value=&quot;广州&quot;&gt;广州 &lt;/option&gt; &lt;option value=&quot;四川&quot;&gt;四川&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; 当用户想要填入多行文本时，就应该使用文本域而不是文本字段。文本域使用 标记。 &lt;form name=&quot;formBox&quot; method=&quot;post&quot; action=&quot;&quot;&gt; 留下您的联系方式： &lt;textarea name=&quot;textarea&quot; cols=&quot;35&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt; &lt;/form&gt; clos 代表列数，rows 代表行数。 图像标签 在 HTML 中，图像由 标签定义。语法为： &lt;img src=&quot;url&quot; alt=&quot;&quot; /&gt; 是空标签，它只包含属性，没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 的值是图像文件的 URL，也就是引用该图像的文件的的绝对路径或相对路径。alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。title 设置鼠标悬停时显示的内容（一般不用设置）。此外还可以通过设置 width 和 height 的值来设置图片的宽和高。 框架 使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 语法： &lt;iframe src=&quot;URL&quot;&gt; &lt;!-- URL指向不同的页面 --&gt; &lt;/iframe&gt; iframe - 设置高度与宽度 属性默认以像素为单位,但是你可以指定其按比例显示 (如：&quot;60%&quot;)。 iframe - 移除边框 frameborder 属性用于定义 iframe 表示是否显示边框。设置属性值为 &quot;0&quot; 移除 iframe 的边框: 在标准 HTML5 中， 和 标签是可以省略的。 HTML5 元素名可以使用大写和小写字母，建议使用小写字母，会显得更加好看一点，千万不要使用大小写混写，那样会显得很不专业。 图片通常使用 alt 属性。 在图片不能显示时，它能替代图片显示。建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。 等号的前后可以使用空格，也可以不使用，推荐少用空格。 不要无缘无故的添加空行，一般一个模块或一个功能添加一个空行便于区分，缩进使用两个空格，不建议使用 Tab。 section 标签 &lt;section&gt; 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。不要把 元素作为一个普通的 div 容器来使用。一般来说，一个 应该出现在文档大纲中。 article 标签 &lt;article&gt; 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。 nav 标签 &lt;nav&gt; 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。 header 标签 &lt;header&gt; 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。 通常 header 标签至少包含一个标题标记（h1-h6），还可以包括 hgroup 标签，还可以包括表格内容、标识、搜索表单、nav 导航等。 footer 标签 &lt;footer&gt; 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。 aside 标签 &lt;aside&gt; 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。 datalist 元素 datalist 元素用于为文本框提供一个可供选择的列表，使用 datalist 元素来为表单小部件提供建议的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 元素)。 一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本。通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。 autocomplete 属性 autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。当 autocomplete 属性值为 on 时表示启用自动完成功能，为 off 时表示关闭。autocomplete 属性适用于 ，以及下面的 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。 autofocus 属性 autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 标签的类型。 ","link":"https://xmweijh.github.io/post/html-ji-chu/"},{"title":"SQL语言","content":"SELECT SELECT column_name,column_name FROM table_name;//选出特定列 SELECT * FROM table_name;//选取所有列 SELECT DISTINCT column_name,column_name FROM table_name;//返回列中不同值（去除掉重复值） SELECT column_name new_column_name FROM table_name;使用列别名可以改变查询结果的列标题 WHERE SELECT column_name,column_name FROM table_name WHERE column_name operator value;//提取那些满足指定条件的记录 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值字段，请不要使用引号。 可以在 WHERE 子句中使用的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 逻辑运算 not and or （优先级从左到右下降） 空值判断： is null ORDER BY SELECT column_name,column_name FROM table_name ORDER BY column_name,column_name ASC|DESC;//对结果集按照一个列或者多个列进行排序,默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。 ORDER BY 多列的时候，先按照第一个column name排序，再按照第二个column name排序 desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。 INSERT INTO INSERT INTO table_name VALUES (value1,value2,value3,...);//无需指定要插入数据的列名，只需提供被插入的值即可 INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);//指定列名及被插入的值 UPDATE UPDATE table_name SET column1=value1,column2=value2,... WHERE some_column=some_value;//更新表中已存在的记录。 如果您省略了 WHERE 子句，所有的记录都将被更新！ DELETE DELETE FROM table_name WHERE some_column=some_value;//删除表中的行。 如果您省略了 WHERE 子句，所有的记录都将被删除！ SELECT TOP, LIMIT, ROWNUM 子句 SELECT TOP number|percent column_name(s) FROM table_name; SELECT column_name(s) FROM table_name LIMIT number; SELECT column_name(s) FROM table_name WHERE ROWNUM &lt;= number;//用于规定要返回的记录的数目 LIKE SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern;//操作符用于在 WHERE 子句中搜索列中的指定模式。 '%a' //以a结尾的数据 'a%' //以a开头的数据 '%a%' //含有a的数据 ‘_a_’ //三位且中间字母是a的 '_a' //两位且结尾字母是a的 'a_' //两位且开头字母是a的 SQL 通配符 在 SQL 中，通配符与 SQL LIKE 操作符一起使用。 SQL 通配符用于搜索表中的数据。 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 IN SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...);//IN 操作符允许您在 WHERE 子句中规定多个值。 BETWEEN SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2;//用于选取介于两个值之间的数据范围内的值。 SQL 别名 SELECT column_name AS alias_name FROM table_name;//列的 SQL 别名语法 SELECT column_name(s) FROM table_name AS alias_name;//表的 SQL 别名语法 SQL 连接(JOIN) INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 SQL INNER JOIN 语法 INNER JOIN 关键字在表中存在至少一个匹配时返回行。 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name; SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name=table2.column_name;//INNER JOIN 与 JOIN 是相同的。 在使用 join 时，on 和 where 条件的区别如下： 1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。 2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 SQL LEFT JOIN 语法 LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; SELECT column_name(s) FROM table1 LEFT OUTER JOIN table2 ON table1.column_name=table2.column_name;//在某些数据库中，LEFT JOIN 称为 LEFT //OUTER JOIN。 SQL RIGHT JOIN 语法 RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; SELECT column_name(s) FROM table1 RIGHT OUTER JOIN table2 ON table1.column_name=table2.column_name;//在某些数据库中，RIGHT JOIN 称为 RIGHT //OUTER JOIN。 SQL FULL OUTER JOIN 语法 FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行. FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。 SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; //默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2; SELECT INTO SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。 SELECT * INTO newtable [IN externaldb] FROM table1; SELECT column_name(s) INTO newtable [IN externaldb] FROM table1; INSERT INTO SELECT INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。 INSERT INTO table2 SELECT * FROM table1; INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; CREATE DATABASE CREATE DATABASE dbname;//用于创建数据库。 CREATE TABLE CREATE TABLE table_name ( column_name1 data_type(size), column_name2 data_type(size), column_name3 data_type(size), .... );//用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。 //column_name 参数规定表中列的名称。 //data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。 //size 参数规定表中列的最大长度。 SQL 约束（Constraints） CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... );//用于规定表中的数据规则。 在 SQL 中，我们有如下约束： NOT NULL - 指示某列不能存储 NULL 值。 ​ NOT NULL 约束强制列不接受 NULL 值。 ​ NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或 者更新记录。 UNIQUE - 保证某列的每行必须有唯一的值。 ​ UNIQUE 约束唯一标识数据库表中的每条记录。 ​ UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 ​ PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。 ​ 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 ​ PRIMARY KEY 约束唯一标识数据库表中的每条记录。 ​ 主键必须包含唯一的值。 ​ 主键列不能包含 NULL 值。 ​ 每个表都应该有一个主键，并且每个表只能有一个主键。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 ​ 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 ​ 如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限 制。 DEFAULT - 规定没有给列赋值时的默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 CREATE INDEX 语句 CREATE INDEX 语句用于在表中创建索引。 在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。 CREATE INDEX index_name ON table_name (column_name)//在表上创建一个简单的索引。允许使用重复的值 CREATE UNIQUE INDEX index_name ON table_name (column_name)//在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着 //两个行不能拥有相同的索引值 DROP 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。 ALTER TABLE ALTER TABLE 语句用于在已有的表中添加、删除或修改列。 SQL ALTER TABLE 语法 如需在表中添加列，请使用下面的语法: ALTER TABLE table_name ADD column_name datatype 如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）： ALTER TABLE table_name DROP COLUMN column_name AUTO INCREMENT Auto-increment 会在新记录插入表中时生成一个唯一的数字。 视图（Views） 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。 您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。 SQL CREATE VIEW 语法 CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition **注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。 您可以使用下面的语法来更新视图： SQL CREATE OR REPLACE VIEW 语法 CREATE OR REPLACE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 您可以通过 DROP VIEW 命令来删除视图。 SQL DROP VIEW 语法 DROP VIEW view_name ","link":"https://xmweijh.github.io/post/sql-yu-yan/"},{"title":"Python","content":"基础知识 print括号中可以单引号或者双引号 多行打印时,使用三个引号 print(''' ''') true类型只用True 和False 注意大小写 空值 None 表示无，与0 不同 input（输入） 当输入输出括号中字符串中还有引号，需要转义符\\区别 &gt;&gt;&gt; string = 'hello_shiyanlou' &gt;&gt;&gt; string[0] # 获取第一个字符 'h' &gt;&gt;&gt; string[-2] # 获取倒数第二个字符 'o' 注意负值代表倒数第几个（倒数不从0开始，毕竟 -0 = 0） print('你叫'+name+'，今年' + age + '岁了') #等价于 print('你叫{}，今年{}岁了'.format(name,age)) #下面代码代表保留2位小数 print(&quot;{:.2f}&quot;.format(3.1415926)) #单行注释 逻辑运算符 and or not 条件判断 if: *** elif: *** else: *** 后面加冒号 if下面的代码4个缩进 input 读取的为字符串类型 &gt;&gt;&gt; a = 3 &gt;&gt;&gt; if a&lt;1: ... print(&quot;a&lt;1&quot;) ... else: ... pass ... &gt;&gt;&gt; #程序没有报错 pass会跳过这里的代码执行后面的代码 for 元素 in 集合: do something range(x)函数 可以生成一个从0到x-1的整数序列 range() 函数返回的并不是列表而是一种可迭代对象： range(a,b) a 到b-1，包头不包尾 while condition: do something 所以如果是用空格，就一直用空格缩进，不要使用制表符。 建议遵守以下约定： 使用 4 个空格来缩进 永远不要混用空格和制表符 在函数之间空一行 在类之间空两行 字典，列表，元组以及参数列表中，在 , 后添加一个空格。对于字典，: 后面也添加一个空格 在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：a = f(1, 2) + g(3, 4) // 取整除 - 返回商的整数部分（向下取整） divmod(num1, num2) 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 * 运算符拆封这个元组，得到这两个值。 默认情况下，print() 除了打印你提供的字符串之外，还会打印一个换行符 print() 的另一个参数 end 来替换这个换行符 print(b, end=' ') print(&quot;-&quot; * 50) #打印50个- #列表的元素不必是同一类型 &gt;&gt;&gt; a = [ 1, 342, 223, 'India', 'Fedora'] Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。 对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 a[2:4] 是 2。 返回a[2]和a[3]两个 切片操作还可以设置步长 &gt;&gt;&gt; a[1::2] [342, 'India'] 意思是，从切片索引 1 到列表末尾，每隔两个元素取值。 len() 我们可以获得列表的长度 如果你想要检查列表是否为空 if list_name: # 列表不为空 pass else: # 列表为空 pass 列表 a.append(45) 添加元素 45 到列表末尾。有些时候我们需要将数据插入到列表的任何位置，这时我们可以使用列表的 insert() 方法。 count(s) 会返回列表元素中 s 的数量。 如果你想要在列表中移除任意指定值，你需要使用 remove() 方法。 a.reverse() 反转整个列表。 将一个列表的所有元素添加到另一个列表的末尾呢，可以使用列表的 extend() 方法。 给列表排序，我们使用列表的 sort() 方法， 用 del 关键字删除指定位置的列表元素。 &gt;&gt;&gt; a = [23, 45, 1, -3434, 43624356, 234] &gt;&gt;&gt; a.append(45) &gt;&gt;&gt; a.insert(0, 1) &gt;&gt;&gt; a.count(45) 栈 pop()。传入一个参数 i 即 pop(i) 会将第 i 个元素弹出。 栈使用a.pop() 将顶部元素弹出， a.append(x) 入栈 队列 a.pop(0) 出队 a.append(x) 入队 列表推导式 squares = [x**2 for x in range(10)] &gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] #等价于 &gt;&gt;&gt; combs = [] &gt;&gt;&gt; for x in [1,2,3]: ... for y in [3,1,4]: ... if x != y: ... combs.append((x, y)) ... &gt;&gt;&gt; combs [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。 元组 元组是由数个逗号分割的值组成。 &gt;&gt;&gt; a = 'Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus' &gt;&gt;&gt; a ('Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus') &gt;&gt;&gt; a[1] 'ShiYanLou' &gt;&gt;&gt; for x in a: ... print(x, end=' ') ... Fedora ShiYanLou Kubuntu Pardus 以对任何一个元组执行拆封操作并赋值给多个变量 &gt;&gt;&gt; x, y = divmod(15,2) &gt;&gt;&gt; x 7 &gt;&gt;&gt; y 1 元组是不可变类型，这意味着你不能在元组内删除或添加或编辑任何值。 要创建只含有一个元素的元组，在值后面跟一个逗号。 通过内建函数 type() 你可以知道任意变量的数据类型。 集合 集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。 大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典 &gt;&gt;&gt; basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} &gt;&gt;&gt; print(basket) # 你可以看到重复的元素被去除 {'orange', 'banana', 'pear', 'apple'} &gt;&gt;&gt; 'orange' in basket True &gt;&gt;&gt; 'crabgrass' in basket False &gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作 ... &gt;&gt;&gt; a = set('abracadabra') &gt;&gt;&gt; b = set('alacazam') &gt;&gt;&gt; a # a 去重后的字母 {'a', 'r', 'b', 'c', 'd'} &gt;&gt;&gt; a - b # a 有而 b 没有的字母 {'r', 'd', 'b'} &gt;&gt;&gt; a | b # 存在于 a 或 b 的字母 {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} &gt;&gt;&gt; a &amp; b # a 和 b 都有的字母 {'a', 'c'} &gt;&gt;&gt; a ^ b # 存在于 a 或 b 但不同时存在的字母 {'r', 'd', 'b', 'm', 'z', 'l'} #添加或弹出元素 &gt;&gt;&gt; a = {'a','e','h','g'} &gt;&gt;&gt; a.pop() # pop 方法随机删除一个元素并打印 'h' &gt;&gt;&gt; a.add('c') &gt;&gt;&gt; a {'c', 'e', 'g', 'a'} 字典 字典是是无序的键值对（key:value）集合，同一个字典内的键必须是互不相同的。一对大括号 {} 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。 &gt;&gt;&gt; data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'} &gt;&gt;&gt; data {'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'} &gt;&gt;&gt; data['kart_'] 'Debian' &gt;&gt;&gt; data['parthan'] = 'Ubuntu' &gt;&gt;&gt; data {'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'} # 使用del关键字删除任意指定的键值对 &gt;&gt;&gt; del data['kushal'] &gt;&gt;&gt; data {'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu' # 使用 in 关键字查询指定的键是否在字典中 &gt;&gt;&gt; 'ShiYanLou' in data False #必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作 #为键。dict() 可以从包含键值对的元组中创建字典。 &gt;&gt;&gt; dict((('Indian','Delhi'),('Bangladesh','Dhaka'))) {'Indian': 'Delhi', 'Bangladesh': 'Dhaka'} #遍历一个字典，使用字典的 items() 方法。 &gt;&gt;&gt; data {'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'} &gt;&gt;&gt; for x, y in data.items(): ... print(&quot;{} uses {}&quot;.format(x, y)) ... Kushal uses Fedora Jace uses Mac kart_ uses Debian parthan uses Ubuntu 许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。我们可以使用 dict.setdefault(key, default) 更有效率的完成这个事情。 &gt;&gt;&gt; data = {} &gt;&gt;&gt; data.setdefault('names', []).append('Ruby') &gt;&gt;&gt; data {'names': ['Ruby']} &gt;&gt;&gt; data.setdefault('names', []).append('Python') &gt;&gt;&gt; data {'names': ['Ruby', 'Python']} &gt;&gt;&gt; data.setdefault('names', []).append('C') &gt;&gt;&gt; data {'names': ['Ruby', 'Python', 'C']} 试图索引一个不存在的键将会抛出一个 keyError 错误。我们可以使用 dict.get(key, default) 来索引键，如果键不存在，那么返回指定的 default 值。 如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate()。 &gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']): ... print(i, j) ... 0 a 1 b 2 c 要同时遍历两个序列类型，你可以使用 zip() 函数。 &gt;&gt;&gt; a = ['Pradeepto', 'Kushal'] &gt;&gt;&gt; b = ['OpenSUSE', 'Fedora'] &gt;&gt;&gt; for x, y in zip(a, b): ... print(&quot;{} uses {}&quot;.format(x, y)) ... Pradeepto uses OpenSUSE Kushal uses Fedora 字符串 title() 返回字符串的标题版本，即单词首字母大写其余字母小写。 方法 upper() 返回字符串全部大写的版本，反之 lower() 返回字符串的全部小写版本。 方法 swapcase() 返回字符串大小写交换后的版本 方法 isalnum() 检查所有字符是否只有字母和数字 方法 isalpha() 检查字符串之中是否只有字母。 &gt;&gt;&gt; s = &quot;1234&quot; &gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字 True &gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot; &gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写 False &gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot; &gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式 True &gt;&gt;&gt; s = &quot;CHINA&quot; &gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写 True split() 分割任意字符串，split() 允许有一个参数，用来指定字符串以什么字符分隔（默认为 &quot; &quot;），它返回一个包含所有分割后的字符串的列表。 join() 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。 最简单的一个是 strip(chars)，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符 find() 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1 格式化操作符（%） print(&quot;my name is %s.I am %d years old&quot; % ('Shixiaolou',4)) 在这个例子中，%s 为第一个格式符，表示一个字符串；%d 为第二个格式符，表示一个整数。格式符为真实值预留位置，并控制显示的格式。常用的有： %s 字符串（用 str() 函数进行字符串转换） %r 字符串（用 repr() 函数进行字符串转换） %d 十进制整数 %f 浮点数 %% 字符“%” 函数 def 来定义一个函数 def 函数名(参数): 语句1 语句2 global 关键字，对函数中的a标志为全局变量 ， 让函数内部使用全局变量的 a。 函数的参数变量可以有默认值，也就是说如果我们对指定的参数变量没有给出任何值则会赋其默认值。 &gt;&gt;&gt; def test(a , b=-99): ... if a &gt; b: ... return True ... else: ... return False 在函数的参数列表写出 b = -99。这表示如果调用者未给出 b 的值，那么 b 的值默认为 -99。 &gt;&gt;&gt; test(12, 23) False &gt;&gt;&gt; test(12) True 有两个非常重要的地方，第一个是具有默认值的参数后面不能再有普通参数，比如 f(a,b=90,c) 就是错误的。 第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。 &gt;&gt;&gt; def f(a, data=[]): ... data.append(a) ... return data ... &gt;&gt;&gt; print(f(1)) [1] &gt;&gt;&gt; print(f(2)) [1, 2] &gt;&gt;&gt; print(f(3)) [1, 2, 3] &gt;&gt;&gt; def f(a, data=None): ... if data is None: ... data = [] ... data.append(a) ... return data ... &gt;&gt;&gt; print(f(1)) [1] &gt;&gt;&gt; print(f(2)) [2] 高阶函数（Higher-order function）或仿函数（functor）是可以接受函数作为参数的函数： 使用一个或多个函数作为参数 返回另一个函数作为输出 Python 里的任何函数都可以作为高阶函数 # 创建一个函数，将参数列表中每个元素都变成全大写 &gt;&gt;&gt; def high(l): ... return [i.upper() for i in l] ... # 创建高阶函数，接受一个函数和一个列表作为参数 &gt;&gt;&gt; def test(h, l): ... return h(l) ... &gt;&gt;&gt; l = ['python', 'Linux', 'Git'] # 运行高阶函数，返回预期的结果 &gt;&gt;&gt; test(high, l) ['PYTHON', 'LINUX', 'GIT'] map 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。 文件 使用 open() 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的： &quot;r&quot;，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容 &quot;w&quot;，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入 &quot;a&quot;，以追加模式打开，写入到文件中的任何数据将自动添加到末尾 默认的模式为只读模式，也就是说如果你不提供任何模式，open() 函数将会以只读模式打开文件。 close() 关闭文件 read() 方法一次性读取整个文件。 read(size) 有一个可选的参数 size，用于指定字符串长度。如果没有指定 size 或者指定为负数，就会读取并返回整个文件。 readline() 能帮助你每次读取文件的一行。 使用 readlines() 方法读取所有行到一个列表中。 write() 方法打开一个文件写入一些文本。 模块 sys。sys.argv 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 cp 命令替代：在 cp 后首先输入被拷贝的文件的文件名，然后输入新文件名。 with 语句处理文件对象，它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写 在 Linux 下你可以使用 lscpu 命令来查看当前电脑的 CPU 相关信息 ， 实际上 lscpu 命令是读取 /proc/cpuinfo 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 /proc/cpuinfo 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 lscpu 命令了 :） 异常 我们使用 try...except 块来处理任意异常。基本的语法像这样： try: statements to be inside try clause statement2 statement3 ... except ExceptionName: statements to evaluated in case of ExceptionName happens 使用 raise 语句抛出一个异常。 &gt;&gt;&gt; try: ... raise ValueError(&quot;A value error happened.&quot;) ... except ValueError: ... print(&quot;ValueError in our code.&quot;) ... ValueError in our code. try 语句还有另一个可选的 finally 子句，目的在于定义在任何情况下都一定要执行的功能， 不管有没有发生异常，finally 子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常（或者它发生在 except 或 else 子句中），在 finally 子句执行完后它会被重新抛出。 with 语句，它是 try-finally 块的简写，使用 with 语句能保证文件始终被关闭。 类 class nameoftheclass(parent_class): statement1 statement2 statement3 在类的声明中你可以写任何 Python 语句，包括定义函数（在类中我们称为方法）。 类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。 x = MyClass() 类定义了 __init__() 方法的话，类的实例化操作会自动为新创建的类实例调用 __init__() 方法。 def __init__(self): self.data = [] 一个类可以继承自多个类，具有父类的所有变量和方法，语法如下： class MyClass(Parentclass1, Parentclass2,...): def __init__(self): Parentclass1.__init__(self) Parentclass2.__init__(self) ... ... 删除一个对象使用关键字 del 。 更精确的调整控制属性访问权限，你可以使用 @property 装饰器，@property 装饰器就是负责把一个方法变成属性调用的。 模块 模块是包括 Python 定义和声明的文件。文件名就是模块名加上 .py 后缀。 从模块中导入指定的函数。这样做： &gt;&gt;&gt; from bars import simplebar, starbar &gt;&gt;&gt; simplebar(20) 含有 __init__.py 文件的目录可以用来作为一个包，目录里的所有 .py 文件都是这个包的子模块。 os 模块提供了与操作系统相关的功能。getuid() 函数返回当前进程的有效用户 id。getpid() 函数返回当前进程的 id。getppid() 返回父进程的 id。uname() 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 uname -a 命令得到。uname() 返回的对象是一个元组，（sysname, nodename, release, version, machine）。getcwd() 函数返回当前工作目录。chdir(path) 则是更改当前目录到 path。 Requests 是一个第三方 Python 模块， 第三方模块并不是默认的模块，意味着你需要安装它，我们使用 pip3 安装它。 $ sudo apt-get update $ sudo apt-get install python3-pip $ sudo pip3 install requests 你可以使用 get() 方法获取任意一个网页。 &gt;&gt;&gt; import requests &gt;&gt;&gt; req = requests.get('https://github.com') &gt;&gt;&gt; req.status_code 200 req 的 text 属性存有服务器返回的 HTML 网页使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序。 #!/usr/bin/env python3 import requests def download(url): ''' 从指定的 URL 中下载文件并存储到当前目录 url: 要下载页面内容的网址 ''' # 检查 URL 是否存在 try: req = requests.get(url) except requests.exceptions.MissingSchema: print('Invalid URL &quot;{}&quot;'.format(url)) return # 检查是否成功访问了该网站 if req.status_code == 403: print('You do not have the authority to access this page.') return filename = url.split('/')[-1] with open(filename, 'w') as fobj: fobj.write(req.content.decode('utf-8')) print(&quot;Download over.&quot;) if __name__ == '__main__': url = input('Enter a URL: ') download(url) if __name__ == '__main__': 这条语句，它的作用是，只有在当前模块名为 __main__ 的时候（即作为脚本执行的时候）才会执行此 if 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，if 块内的语句并不会执行。 命令行传入的所有参数都可以使用 sys.argv 获取。如果希望对参数进行处理可以使用 argparse 模块 collections 模块 Counter &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; import re &gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt' &gt;&gt;&gt; words = re.findall('\\w+', open(path).read().lower()) &gt;&gt;&gt; Counter(words).most_common(10) [('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)] Counter 对象有一个叫做 elements() 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的。 &gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; list(c.elements()) ['b','b','a', 'a', 'a', 'a'] most_common() 方法返回最常见的元素及其计数，顺序为最常见到最少。 &gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; list(c.elements()) ['b','b','a', 'a', 'a', 'a'] defaultdict defaultdict 是内建 dict 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同。 defaultdict() 第一个参数提供了 default_factory 属性的初始值，默认值为 None，default_factory 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数。 同样的功能使用 defaultdict 比使用 dict.setdefault 方法快。 &gt;&gt;&gt; from collections import defaultdict &gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] &gt;&gt;&gt; d = defaultdict(list) &gt;&gt;&gt; for k, v in s: ... d[k].append(v) ... &gt;&gt;&gt; d.items() dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]) namedtuple 命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息。 &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y']) # 定义命名元组 &gt;&gt;&gt; p = Point(10, y=20) # 创建一个对象 &gt;&gt;&gt; p Point(x=10, y=20) &gt;&gt;&gt; p.x + p.y 30 &gt;&gt;&gt; p[0] + p[1] # 像普通元组那样访问元素 30 &gt;&gt;&gt; x, y = p # 元组拆封 &gt;&gt;&gt; x 10 &gt;&gt;&gt; y 20 Python排版 每层缩进使用4个空格。 限制每行的最大长度为79个字符。 限制每行的最大长度为79个字符。 顶级函数和类定义上下使用两个空行分隔。 类内的方法定义使用一个空行分隔。 顶级函数和类定义上下使用两个空行分隔。 类内的方法定义使用一个空行分隔。 import语句分组顺序如下： 导入标准库模块 导入相关第三方库模块 导入当前应用程序/库模块 避免在下列情况中使用多余的空格： 与括号保持紧凑（小括号、中括号、大括号）： 与后面的逗号、分号或冒号保持紧凑 切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。 函数名与其后参数列表的左括号应该保持紧凑 与切片或索引的左括号保持紧凑 在赋值操作符（或其它）的两侧保持多余一个的空格 总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。 在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。 不要在关键值参数或默认值参数的等号两边加入空格。 【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的-&gt;左右各插入一个空格。 打消使用复合语句（多条语句在同一行）的念头。 有时候把 if/for/while 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。 块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以#起头，并且#后要跟一个空格（除非是注释内的缩进文本）。 有节制的使用行内注释。 一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以#打头，#后接一个空格。 无谓的行内注释如果状态明显，会转移注意力。 为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。 PEP 257 描述了良好的文档字符串的约定。注意，文档字符串的结尾&quot;&quot;&quot;应该放在单独的一行，例如： 对于单行的文档字符串，把结尾&quot;&quot;&quot;放在同一行。 迭代器 Python 迭代器（Iterators）对象在遵守迭代器协议时需要支持如下两种方法。 __iter__()，返回迭代器对象自身。这用在 for 和 in 语句中。 __next__()，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 StopIteration 异常。 class Counter(object): def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def __next__(self): #返回下一个值直到当前值大于 high if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1 &gt;&gt;&gt; c = Counter(5,10) &gt;&gt;&gt; for i in c: ... print(i, end=' ') ... 5 6 7 8 9 10 请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 StopIteration，它会持续抛出相同的异常。 Python 生成器（Generators），生成器是更简单的创建迭代器的方法，这通过在函数中使用 yield 关键字完成： &gt;&gt;&gt; def my_generator(): ... print(&quot;Inside my generator&quot;) ... yield 'a' ... yield 'b' ... yield 'c' ... &gt;&gt;&gt; my_generator() &lt;generator object my_generator at 0x7fbcfa0a6aa0&gt; &gt;&gt;&gt; for char in my_generator(): ... print(char) ... Inside my generator a b c &gt;&gt;&gt; def counter_generator(low, high): ... while low &lt;= high: ... yield low ... low += 1 ... &gt;&gt;&gt; for i in counter_generator(5,10): ... print(i, end=' ') ... 5 6 7 8 9 10 我们会发现生成器的一个特点：它们是不可重复使用的。 生成器表达式（Generator expressions），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广。 &gt;&gt;&gt; sum([x*x for x in range(1,10)]) 这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。 &gt;&gt;&gt; sum(x*x for x in range(1,10)) 生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。 闭包（Closures）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和。 &gt;&gt;&gt; def add_number(num): ... def adder(number): ... #adder 是一个闭包 ... return num + number ... return adder ... &gt;&gt;&gt; a_10 = add_number(10) &gt;&gt;&gt; a_10(21) 31 &gt;&gt;&gt; a_10(34) 44 &gt;&gt;&gt; a_5 = add_number(5) &gt;&gt;&gt; a_5(3) 8 装饰器（Decorators）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的。 &gt;&gt;&gt; def my_decorator(func): ... def wrapper(*args, **kwargs): ... print(&quot;Before call&quot;) ... result = func(*args, **kwargs) ... print(&quot;After call&quot;) ... return result ... return wrapper ... &gt;&gt;&gt; @my_decorator ... def add(a, b): ... #我们的求和函数 ... return a + b ... &gt;&gt;&gt; add(1, 3) Before call After call 4 ","link":"https://xmweijh.github.io/post/python/"},{"title":"Git","content":"git init 将一个已存在的文件夹，置于Git的控制管理之下 git add 将创建或修改的文件添加到本地的暂存区 git add . 命令全部添加到暂存区。 撤销暂存区的修改执行 git reset -- [文件名] 或者 git rm --cached [文件名] 命令即可 git commit 提交文件到本体仓库----每当完成一些工作，都可以创建一次提交，保存当前的版本 提交之前，设置名字和email 相当于签名，每次提交会包含这些信息 git config 配置 git config -l 可以查看配置信息 $ git config --global user.name &quot;YourName&quot; $ git config --global user.email &quot;YourEmail@xxx.com&quot; git commit -m &quot;first commit&quot; -m&quot;注释&quot; 提交加注释辨别不同版本，便于理解对代码做了什么修改 git push 同步到远端仓库 git status 监测当前目录和缓存区的状态 git remote add origin 仓库链接 git push origin master （origin为仓库名） git clone 拷贝一个Git仓库到本地，让自己能够查看修改。 git diff用来查看工作区被跟踪的文件的修改详情 git diff --cached 查看暂存区的全部修改 git log，它用来查看版本区的提交历史记录 git log [分支名] 查看某分支的提交历史，不写分支名查看当前所在分支 git log --oneline 一行显示提交历史 git log -n 其中 n 是数字，查看最近 n 个提交 git log --author [贡献者名字] 查看指定贡献者的提交记录 git log --graph 图示法显示提交历史 git log 查看提交记录 时间正序排列的信息，那么可以使用 git log --reverse 命令。 (按q退出此界面) git branch -avv，它用来查看全部分支信息 git reset --soft HEAD^ 撤销最近的一次提交，将修改还原到暂存区。 --soft 表示软退回，对应的还有 --hard 硬退，HEAD^表示撤销一次提交，HEAD^^表示撤销两次提交，撤销 n 次可以简写为HEAD~n`。 ","link":"https://xmweijh.github.io/post/git/"},{"title":"Linux常用操作","content":"目录 shiyanlou:~/ $ 当前所处的目录位置 shiiyanlou： 用户名 $命令提示符 **ls ：**查找目录中的内容 （蓝字目录，白字内容） cd: 进入目录 上下键可以快速选择前面输过的命令 **cd ..**可以回到上一级目录（中间有空格） **cd -**上次所在的目录 **cd ~**回到主目录 **cd /**进入根目录 文件 tree 列出文件夹下所有子文件和文件（树形结构） Ctrl + c 停止 pwd 获得当前目录的绝对路径 mkdir 创建目录 加入**-p**一次性创建多级目录 touch 新建文件 cp 复制文件到指定目录 cp -r 复制目录 rm 删除文件 删除目录加 -r mv移动文件或者目录 还可以用来重命名 cat 将文件内容打印到屏幕 cat -n带上行号 ","link":"https://xmweijh.github.io/post/linux-chang-yong-cao-zuo/"},{"title":"Matlab的一些点","content":"用mod时，不管被除数是正是负，余数的符号与除数相同，rem反之。 直接输入用中括号，同行空格或者逗号不同行用；号。 冒号表达式格式： 初始值：步长：终止值 linspace（第一个元素，最后一个元素，元素总数） matlab元素按列储存，先第一列在第二列。 矩阵拆分用：号 ~=是不等于 fix朝零方向取整，如fix(-1.3)=-1; fix(1.3)=1; floor，顾名思义，就是地板，所以是取比它小的整数，即朝负无穷方向取整，如floor(-1.3)=-2; floor(1.3)=1;floor(-1.8)=-2，floor(1.8)=1 ceil，与floor相反，它的意思是天花板，也就是取比它大的最小整数，即朝正无穷方向取整，如ceil(-1.3)=-1; ceil(1.3)=2;ceil(-1.8)=-1，ceil(1.8)=2 round四舍五入到最近的整数，如round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2。 在进行矩阵之间的运算时“.”和“”的意义就有所不同了。假设a，b表示两个矩阵，a*b表示矩阵a与矩阵b进行矩阵相乘，a.*b表示矩阵a中的元素与矩阵b中的元素按位置依次相乘，得到的结果将作为新矩阵中相同位置的元素 a:c:b表示[a,a+c,……,a+n*c],其中n=fix((b-a)/c) Syms 变量间不打符号 abs函数求实数的绝对值，复数的模，字符串的asc|| 在plot写完后 加上axis([0 1 2 3]) 则表明图线的x轴范围为01y轴范围为23 hold on是当前轴及图像保持而不被刷新，准备接受此后将绘制的图形，多图共存 即，启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。 hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即，关闭图形保持功能。 ","link":"https://xmweijh.github.io/post/matlab-de-yi-xie-dian/"},{"title":"C++","content":"C++比C更丰富 (1).支持面向对象，将问题域和方法域统一化。宏观面向对象，微观面向过程。 (2).支持泛型编程。 int add (int a, int b) { ... } template\\&lt;typename T&gt; T add (T a, T b) { ... } (3).支持异常机制。 int func (void) { ... } int main (void) { if (func () == -1) { ​ //错误处理; } } (4).操作符重载 不再使用scanf/printf而是cin/cout。 头文件：#include\\大多数标准库头文件没有.h后缀。 输出：cout – 标准输出对象 输入运算符：&lt;&lt; 提取输出运算符：&gt;&gt; \\#include &lt;iostream&gt; int main (void) { std::cout &lt;&lt; &quot;Hello, World !&quot; &lt;&lt; std::endl; int i; double d; char s[256]; // scanf (&quot;%d%lf%s&quot;, &amp;i, &amp;d, s); std::cin &gt;&gt; i &gt;&gt; d &gt;&gt; s; // printf (&quot;%d %lf %s\\n&quot;, i, d, s); std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; d &lt;&lt; ' ' &lt;&lt; s &lt;&lt; '\\n'; return 0; } A. 结构 定义结构型变量时，可以省略struct关键字。 1)结构内部可以定义函数——成员函数。 2)sizeof(空结构) -&gt; 1 C++层面上引用和指针存在以下不同： (a). 指针是实体变量，但是引用不是实体变量。 int&amp; a=b; sizeof (a);//4 double&amp; d=f; sizeof (d);//8 (b). 指针可以不初始化，但是引用必须初始化。 (c). 指针的目标可以修改，但是引用的目标的不能修改。 (d). 可以定义指针的指针，但是不能定义引用的指针。 int a; int* p = &amp;a; int** pp = &amp;p;//ok int&amp; r = a; int&amp;* pr = &amp;r;//ERROR (e). 可以定义指针的引用，但是不能定义引用的引用。 int a; int* p = &amp;a; int*&amp; q = p;//ok int&amp; r = a; int&amp;&amp; s = r;//ERROR (f). 可以定义指针的数组，但不能定义引用的数组。 int a, b, c; int* parr[] = {&amp;a,&amp;b,&amp;c};/ok int&amp; rarr[] = {a,b,c};//ERROR //可以定义数组的引用。 int arr[] = {1 ,2,3}; 建议: (1). 少用宏，多用const，enum和inline。 \\#define PAI 3.14159 const double PAI = 3.14159; #define ERORR_FILE -1; #defile ERORR_MEM -2; enum { ERORR_FILE = -1, ERORR_MEM = -2 }; #define max(a,b) ((a) &gt; (b) ? (a) : (b)) inline int double max (double a,double b){return a &gt; b ? a : b;} (2). 变量随用随时声明同时初始化。 (3). 少用malloc/free,多用new/delete。 (4). 少用C风格的强制类型转换，多用类型转换运算符。 (5). 少用C风格的字符串，多用string。 (6). 树立面向对象的编程思想。 类和对象 什么是对象 1 万物皆对象 程序就是一组对象，对象之间通过消息交换信息 类就是对对象的描述和抽象，对象就是类的具体化和实例化。 2 通过类描述对象 属性：姓名、年龄、学号 行为：吃饭、睡觉、学习 类就是从属性和行为两个方面对对象进行抽象。 3 面向对象程序设计（OOP） 现实世界 虚拟世界 对象 -&gt; 抽象 -&gt; 类 -&gt; 对象 至少掌握一种OOP编程语言 精通一种面向对象的元语言—UML 研究设计模式，GOF ","link":"https://xmweijh.github.io/post/c/"},{"title":"汇编语言的一些基础知识","content":" Int add_a_and_b(int a,int b){ returna+b; } Int main(){ returnadd_a_and_b(2,3); } _add_a_and_b: push%ebx mov%eax, [%esp+8]mov%ebx, [%esp+12]add%eax,%ebx pop%ebx ret _main:push3 push2 call _add_a_and_b add%esp,8ret 针对8086CPU，有14个寄存器，分别为： AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW。 ABCD-X，通用寄存器，存储一般性数据。 不过，在汇编中，CX 有个特殊功能，用于存储 loop的循环次数。 这里的寄存器都有分高低位，H、L分别表示高低。示例： mov ax, 11 ; 将11送入寄存器ax mov bl, 3 ; 将3送入bl寄存器 add ax, 5 ; 将ax寄存器的值加3 CS、IP 是最关键的两个寄存器，它们指示了当前 要读取指令的地址，CS是段地址，IP是指令指针寄存器。 CSx16+IP 就是CPU当前要执行的指令。换个通俗的话，要让CPU执行什么命令，只要改变这两个寄存器的值，就可以做到了。（有一种皇帝的感觉，哈哈），但是CPU不可能提供 mov cs, 11h 等命令操作，使用jmp cs:ip 进行更改值，从而跳转到想执行的命令处。 DS 寄存器是用于存储数据的段地址，比如要读取某段数据中的值，那么就要先DS指向那里的地址，再加上偏移地址 [...]，就可以进行数据读取了（ES作为附加段寄存器，与DS功能一致，在段太多的情况，可以视情况选用即可） SS, SP, BP 是栈相关寄存器。CPU提供的栈机制 在语言层面表现出来就是，push, pop 两个命令，任意时刻，SS:SP都指向栈顶元素。 push 时， SP=SP-2，pop时，如果有接收的寄存器则先将栈顶值送入，然后 SP=SP+2，指向下面一个单元。 这有什么用呢？ 当然有用，它可以用来临时保存各种数据，然后再插入功能执行完成后，进行现场的恢复，事实上，大部分时候是这么用的。 ","link":"https://xmweijh.github.io/post/hui-bian-yu-yan-de-yi-xie-ji-chu-zhi-shi/"},{"title":"C语言的一些笔记","content":"该运算只适合用两个整数进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。 注意：复合运算符中运算符和等号之间是不存在空格的。 * 整个逗号表达式的值是最后一个表达式的值c = (++a, a *= 2, b = a * 5); &lt;==&gt; c=b; 数组a的地址是ffc1，数组a[0]的地址也是ffc1，即a = a[0]； 注意了，尾部有个'\\0'，如果没有这个结束标记，说明这个字符数组存储的并不是字符串 使用‘’初始化时，一定记得加‘\\0’， 而“”初始化时，系统会自动在字符串尾部加上一个\\0结束符 gets可以读入包含空格、tab的字符串，直到遇到回车为止；scanf不能用来读取空格、tab 算法：可以没有输入，但是一定要有输出。 %符号两边要，求是整数。不是整数就错了。 int x=y=10: 错啦，定义时，不可以连续赋值。int x,y; x=y=10; 对滴，定义完成后，可以连续赋值。 逗号表达式： 优先级别最低。表达式的数值逗号最右边的那个表达式的数值 z=（2，3，4）(整个是赋值表达式) 这个时候z的值为4。 z= 2，3，4 （整个是逗号表达式）这个时候z的值为2。 注释不是C语言，不占运行时间，没有分号。不可以嵌套！ 数组名代表的值不可以改变，他是地址常量名。 在C语言中，二维数组元素的内存中的存放顺序是按行主顺序存放 while(k++&amp;&amp;n++&gt;2); k=1，n=2，因为k++为0不计算后面的n++，k变化，n不变 最终可以得出结论：a = a[0] = &amp;a[0][0]，以此类推，可以得出a[1] = &amp;a[1][0] sqrt()算术平方根函数，fabs()绝对值函数，pow()幂函数，sin()正弦函数 指数形式字母e或E前必须有数字，且后面的数字必须为整数。 for 循环三个表达式可以省去，第二表达式只要为真就执行，无特殊格式。 ​ int main(int argc, const char * argv[]) { clock_t start,finish; start = clock(); printf(&quot;计算结果：%d\\n&quot;, fib(45)); finish = clock(); printf(&quot;花费时间--------%lu\\n&quot;,finish - start); start = clock(); printf(&quot;计算结果：%d\\n&quot;, tailfib(45,1,1)); finish = clock(); printf(&quot;花费时间--------%lu\\n&quot;,finish - start); return 0; ","link":"https://xmweijh.github.io/post/c-yu-yan-de-yi-xie-bi-ji/"}]}
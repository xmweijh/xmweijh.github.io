<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>WebAPIs | 小虾米的记录</title>

<link rel="shortcut icon" href="https://xmweijh.github.io//favicon.ico?v=1625390008738">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmweijh.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            小虾米的记录
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1625390008738"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    WebAPIs
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-02-18 ·
                    </time>
                    
                        <a href="https://xmweijh.github.io/tag/vXmkk1Jyb/" class="post-tags">
                            # web
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>Web API</p>
<p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</p>
<p>Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p>
<p>​	MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API</p>
<h2 id="dom">DOM</h2>
<p>文档对象模型（Document Object Model，简称DOM），是 <a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p>
<p>​	W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p>
<blockquote>
<p>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</p>
</blockquote>
<h3 id="获取元素">获取元素</h3>
<h3 id="根据id获取">根据ID获取</h3>
<pre><code class="language-js">语法：document.getElementById(id)
作用：根据ID获取元素对象
参数：id值，区分大小写的字符串
返回值：元素对象 或 null
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;
    &lt;script&gt;
        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
        var timer = document.getElementById('time');
        console.log(timer);
        console.log(typeof timer);
        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法
        console.dir(timer);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="根据标签名获取元素">根据标签名获取元素</h3>
<pre><code>语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') 
作用：根据标签名获取元素对象
参数：标签名
返回值：元素对象集合（伪数组，数组元素是元素对象）
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul id=&quot;nav&quot;&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的
        var lis = document.getElementsByTagName('li');
        console.log(lis);
        console.log(lis[0]);
        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式
        for (var i = 0; i &lt; lis.length; i++) {
            console.log(lis[i]);
        }
        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签
        var nav = document.getElementById('nav'); // 这个获得nav 元素
        var navLis = nav.getElementsByTagName('li');
        console.log(navLis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>注意:<br>
1．因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。<br>
2.得到元素对象是动态的</p>
<p>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</p>
<h3 id="h5新增获取元素方式">H5新增获取元素方式</h3>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C1550733518278.png" alt="1550733518278" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C1550733734425.png" alt="1550733734425" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;首页&lt;/li&gt;
            &lt;li&gt;产品&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. getElementsByClassName 根据类名获得某些元素集合
        var boxs = document.getElementsByClassName('box');
        console.log(boxs);
        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav
        var firstBox = document.querySelector('.box');
        console.log(firstBox);
        var nav = document.querySelector('#nav');
        console.log(nav);
        var li = document.querySelector('li');
        console.log(li);
        // 3. querySelectorAll()返回指定选择器的所有元素对象集合
        var allBox = document.querySelectorAll('.box');
        console.log(allBox);
        var lis = document.querySelectorAll('li');
        console.log(lis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="获取特殊元素bodyhtml">获取特殊元素（body，html）</h3>
<p><strong>获取body元素</strong></p>
<p>doucumnet.body 	返回body元素对象</p>
<p><strong>获取html元素</strong></p>
<p>document.documentElement 		返回html元素对象</p>
<pre><code class="language-js">		// 1.获取body 元素
        var bodyEle = document.body;
        console.log(bodyEle);
        console.dir(bodyEle);
        // 2.获取html 元素
        var htmlEle = document.documentElement;
        console.log(htmlEle);
</code></pre>
<h2 id="事件基础">事件基础</h2>
<h3 id="事件概述">事件概述</h3>
<p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解： <strong>触发--- 响应机制</strong>。</p>
<p>​	网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>
<h3 id="事件三要素">事件三要素</h3>
<ul>
<li>事件源（谁）：触发事件的元素</li>
<li>事件类型（什么事件）： 例如 click 点击事件</li>
<li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li>
</ul>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;
    &lt;script&gt;
        // 点击一个按钮，弹出对话框
        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素
        //(1) 事件源 事件被触发的对象   谁  按钮
        var btn = document.getElementById('btn');
        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
        //(3) 事件处理程序  通过一个函数赋值的方式 完成
        btn.onclick = function() {
            alert('点秋香');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="执行事件的步骤">执行事件的步骤</h3>
<p>1.获取事件源<br>
2.注册事件（绑定事件)<br>
3.添加事件处理程序(采取函数赋值形式)</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        // 执行事件步骤
        // 点击div 控制台输出 我被选中了
        // 1. 获取事件源
        var div = document.querySelector('div');
        // 2.绑定事件 注册事件
        // div.onclick 
        // 3.添加事件处理程序 
        div.onclick = function() {
            console.log('我被选中了');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="常见的鼠标事件">常见的鼠标事件</h3>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5C1550734506084.png" alt="1550734506084" loading="lazy"></figure>
<h2 id="操作元素">操作元素</h2>
<p>​	JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p>
<h3 id="改变元素内容获取或设置">改变元素内容（获取或设置）</h3>
<p>element.innerText<br>
从起始位置到终止位置的内容,但它去除html标签，同时空格和换行也会去掉<br>
element.innerHTML<br>
起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p>
<p><strong>innerText改变元素内容</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;显示当前系统时间&lt;/button&gt;
    &lt;div&gt;某个时间&lt;/div&gt;
    &lt;p&gt;1123&lt;/p&gt;
    &lt;script&gt;
        // 当我们点击了按钮，  div里面的文字会发生变化
        // 1. 获取元素 
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function() {
            // div.innerText = '2019-6-6';
            div.innerHTML = getDate();
        }
        function getDate() {
            var date = new Date();
            // 我们写一个 2019年 5月 1日 星期三
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var dates = date.getDate();
            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            var day = date.getDay();
            return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day];
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><strong>innerText和innerHTML的区别</strong></p>
<ul>
<li>获取内容时的区别：</li>
</ul>
<p>​	innerText会去除空格和换行，而innerHTML会保留空格和换行</p>
<ul>
<li>设置内容时的区别：</li>
</ul>
<p>​	innerText不会识别html，而innerHTML会识别</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;p&gt;
        我是文字
        &lt;span&gt;123&lt;/span&gt;
    &lt;/p&gt;
    &lt;script&gt;
        // innerText 和 innerHTML的区别 
        // 1. innerText 不识别html标签 非标准  去除空格和换行
        var div = document.querySelector('div');
        // div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的
        div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 这两个属性是可读写的  可以获取元素里面的内容
        var p = document.querySelector('p');
        console.log(p.innerText);
        console.log(p.innerHTML);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="常用元素的属性操作">常用元素的属性操作</h3>
<ol>
<li>innerText、 innerHTML改变元素内容</li>
<li>src、href</li>
<li>id、 alt、 title</li>
</ol>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;
    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;
    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;
    &lt;script&gt;
        // 修改元素属性  src
        // 1. 获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');
        // 2. 注册事件  处理程序
        zxy.onclick = function() {
            img.src = 'images/zxy.jpg';
            img.title = '张学友思密达';
        }
        ldh.onclick = function() {
            img.src = 'images/ldh.jpg';
            img.title = '刘德华';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="表单元素的属性操作">表单元素的属性操作</h3>
<p>type、 value、 checked、 selected、 disabled</p>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
<p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;按钮&lt;/button&gt;
    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2. 注册事件 处理程序
        btn.onclick = function() {
            // 表单里面的值 文字内容是通过 value 来修改的
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 btn
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="样式属性操作">样式属性操作</h3>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<p><strong>常用方式</strong></p>
<ol>
<li>element.style<br>
行内样式操作</li>
<li>element.className类名样式操作</li>
</ol>
<h4 id="方式1通过操作style属性">方式1：通过操作style属性</h4>
<blockquote>
<p>元素对象的style属性也是一个对象！</p>
<p>元素对象.style.样式属性 = 值;</p>
</blockquote>
<p>注意:<br>
l.JS里面的样式采取驼峰命名法比如fontSize、backgroundcolor<br>
2.JS修改style样式操作，产生的是行内样式,css权重比较高</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素
        var div = document.querySelector('div');
        // 2. 注册事件 处理程序
        div.onclick = function() {
            // div.style里面的属性 采取驼峰命名法 
            this.style.backgroundColor = 'purple';
            this.style.width = '250px';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="方式2通过操作classname属性">方式2：通过操作className属性</h4>
<blockquote>
<p>元素对象.className = 值;</p>
<p>因为class是关键字，所有使用className。</p>
</blockquote>
<p>注意:<br>
1．如果样式修改较多，可以采取操作类名方式更改元素样式。</p>
<ol start="2">
<li>class因为是个保留字，因此使用className来操作元素类名属性</li>
<li>className会直接更改元素的类名，会覆盖原先的类名。</li>
</ol>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;
    &lt;script&gt;
        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
        var test = document.querySelector('div');
        test.onclick = function() {
            // this.style.backgroundColor = 'purple';
            // this.style.color = '#fff';
            // this.style.fontSize = '25px';
            // this.style.marginTop = '100px';

            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
            // this.className = 'change';
            this.className = 'first change';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C1550737354861.png" alt="1550737354861" loading="lazy"></figure>
<h2 id="排他操作">排他操作</h2>
<h3 id="排他思想">排他思想</h3>
<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：</p>
<ol>
<li>
<p>所有元素全部清除样式（干掉其他人）</p>
</li>
<li>
<p>给当前元素设置样式 （留下我自己）</p>
</li>
<li>
<p>注意顺序不能颠倒，首先干掉其他人，再设置自己</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;按钮1&lt;/button&gt;
    &lt;button&gt;按钮2&lt;/button&gt;
    &lt;button&gt;按钮3&lt;/button&gt;
    &lt;button&gt;按钮4&lt;/button&gt;
    &lt;button&gt;按钮5&lt;/button&gt;
    &lt;script&gt;
        // 1. 获取所有按钮元素
        var btns = document.getElementsByTagName('button');
        // btns得到的是伪数组  里面的每一个元素 btns[i]
        for (var i = 0; i &lt; btns.length; i++) {
            btns[i].onclick = function() {
                // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人
                for (var i = 0; i &lt; btns.length; i++) {
                    btns[i].style.backgroundColor = '';
                }
                // (2) 然后才让当前的元素背景颜色为pink 留下我自己
                this.style.backgroundColor = 'pink';

            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="换肤">换肤</h2>
<pre><code class="language-js">&lt;body&gt;
    &lt;ul class=&quot;baidu&quot;&gt;
        &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素 
        var imgs = document.querySelector('.baidu').querySelectorAll('img');
        // console.log(imgs);
        // 2. 循环注册事件 
        for (var i = 0; i &lt; imgs.length; i++) {
            imgs[i].onclick = function() {
                // this.src 就是我们点击图片的路径   images/2.jpg
                // console.log(this.src);
                // 把这个路径 this.src 给body 就可以了
                document.body.style.backgroundImage = 'url(' + this.src + ')';
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="表格隔行变色">表格隔行变色</h2>
<pre><code class="language-js">    &lt;script&gt;
        // 1.获取元素 获取的是 tbody 里面所有的行
        var trs = document.querySelector('tbody').querySelectorAll('tr');
        // 2. 利用循环绑定注册事件
        for (var i = 0; i &lt; trs.length; i++) {
            // 3. 鼠标经过事件 onmouseover
            trs[i].onmouseover = function() {
                    // console.log(11);
                    this.className = 'bg';
                }
                // 4. 鼠标离开事件 onmouseout
            trs[i].onmouseout = function() {
                this.className = '';
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="全选">全选</h2>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        
        var j_cbAll = document.getElementById('j_cbAll'); 
        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); 
        // 全选按钮注册事件
        j_cbAll.onclick = function() {
                // this.checked 当前复选框的选中状态
                console.log(this.checked);
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    j_tbs[i].checked = this.checked;
                }
         }
         // 给所有的子复选框注册单击事件
        for (var i = 0; i &lt; j_tbs.length; i++) {
            j_tbs[i].onclick = function() {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    if (!j_tbs[i].checked) {
                        flag = false;
                        break; 
                    }
                }
                // 设置全选按钮的状态
                j_cbAll.checked = flag;
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="自定义属性操作">自定义属性操作</h2>
<h3 id="获取属性值">获取属性值</h3>
<p>element.属性获取属性值。<br>
element.getAttribute(属性);<br>
区别:<br>
element.属性获取内置属性值(元素本身自带的属性)<br>
element.getAttribute ( '属性');主要获得自定义的属性(标准)我们程序员自定义的屋性</p>
<pre><code class="language-js">    &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
	&lt;/script&gt;
</code></pre>
<h3 id="设置属性值">设置属性值</h3>
<p>element.属性=‘值’设置内置属性值。<br>
element.setAttribute('属性'，&quot;值');<br>
区别:<br>
element.属性设置内置属性值<br>
element.setAttribute(属性');主要设置自定义的属性(标准)</p>
<pre><code class="language-js">        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是
</code></pre>
<h3 id="移出属性">移出属性</h3>
<p>element.removeAttribute ('属性');</p>
<pre><code class="language-js">		// class 不是className
        // 3 移除属性 removeAttribute(属性)    
        div.removeAttribute('index');
</code></pre>
<h3 id="tab栏">tab栏</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 获取元素
        var tab_list = document.querySelector('.tab_list');
        var lis = tab_list.querySelectorAll('li');
        var items = document.querySelectorAll('.item');
        // for循环，给选项卡绑定点击事件
        for (var i = 0; i &lt; lis.length; i++) {
            // 开始给5个小li 设置索引号 
            lis[i].setAttribute('index', i);
            lis[i].onclick = function() {
                // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）
                // 干掉所有人 其余的li清除 class 这个类
                for (var i = 0; i &lt; lis.length; i++) {
                    lis[i].className = '';
                }
                // 留下我自己 
                this.className = 'current';
                // 2. 下面的显示内容模块
                var index = this.getAttribute('index');
                console.log(index);
                // 干掉所有人 让其余的item 这些div 隐藏
                for (var i = 0; i &lt; items.length; i++) {
                    items[i].style.display = 'none';
                }
                // 留下我自己 让对应的item 显示出来
                items[index].style.display = 'block';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="h5自定义属性">H5自定义属性</h3>
<p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</p>
<p>自定义属性获取是通过getAttribute(‘属性’) 获取。</p>
<p>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</p>
<p>H5给我们新增了自定义属性：</p>
<p>1.设置H5自定义属性<br>
H5规定自定义属性data-开头做为属性名并且赋值。比如&lt;div data-index= &quot;1” &gt;</div><br>
或者使用JS设置<br>
element.setAttribute( 'data-index’,2)<br>
⒉获取H5自定义属性<br>
1．兼容性获取element.getAttribute( 'data-index');<br>
2、H5新增element.datasetindex或者element.dataset['index’ ] ie 11才开始支持</p>
<pre><code class="language-js">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // console.log(div.getTime);
        console.log(div.getAttribute('getTime'));
        div.setAttribute('data-time', 20);
        console.log(div.getAttribute('data-index'));
        console.log(div.getAttribute('data-list-name'));
        // h5新增的获取自定义属性的方法 它只能获取data-开头的
        // dataset 是一个集合里面存放了所有以data开头的自定义属性
        console.log(div.dataset);
        console.log(div.dataset.index);
        console.log(div.dataset['index']);
        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法
        console.log(div.dataset.listName);
        console.log(div.dataset['listName']);
    &lt;/script&gt;
</code></pre>
<h2 id="节点操作">节点操作</h2>
<h3 id="节点概述">节点概述</h3>
<p>​	网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p>
<p>​	HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5C1550970944363.png" alt="1550970944363" loading="lazy"></figure>
<p>​	一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p>
<p>元素节点nodeType 为1<br>
星性节点nodeType 为2<br>
文本节点nodeType 为3(文本节点包含文字、空格、换行等)<br>
我们在实际开发中，节点操作主要操作的是元素节点</p>
<h3 id="节点层级">节点层级</h3>
<p>​	利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p>
<p>​</p>
<h3 id="父级节点">父级节点</h3>
<p>node. parentNode<br>
parentNode属性可返回某节点的父节点，注意是最近的一个父节点<br>
如果指定的节点没有父节点则返回null</p>
<pre><code class="language-js">    &lt;div class=&quot;demo&quot;&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
        console.log(erweima.parentNode);
    &lt;/script&gt;
</code></pre>
<h3 id="子节点">子节点</h3>
<p><strong>所有子节点</strong></p>
<p>parentNode.childNodes(标准)<br>
parentNode.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。注意:返回值里面包含了所有的子节点，包括元素节点，文本节点等。<br>
如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</p>
<p><strong>子元素节点</strong></p>
<ol start="2">
<li>parentNode.children(非标准)<br>
parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(这个是我们重点掌握的)。<br>
虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用</li>
</ol>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // DOM 提供的方法（API）获取
        var ul = document.querySelector('ul');
        var lis = ul.querySelectorAll('li');
        // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
        console.log(ul.childNodes);
        console.log(ul.childNodes[0].nodeType);
        console.log(ul.childNodes[1].nodeType);
        // 2. children 获取所有的子元素节点 也是我们实际开发常用的
        console.log(ul.children);
    &lt;/script&gt;
</code></pre>
<p><strong>第1个子节点</strong></p>
<p>parentNode.firstChild<br>
firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<p><strong>最后1个子节点</strong></p>
<p>parentNode . lastChild<br>
lastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<p><strong>第1个子元素节点</strong></p>
<p>parentNode.firstElementChild<br>
firstElementchild返回第一个子元素节点，找不到则返回null。</p>
<p><strong>最后1个子元素节点</strong></p>
<p>parentNode . lastElementChild<br>
lastElementchild返回最后一个子元素节点，找不到则返回null。<br>
注意:这两个方法有兼容性问题，IE9以上才支持。</p>
<p>​	实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p>
<p>解决方案:<br>
1．如果想要第一个子元素节点，可以使用naxen太Nda.shildren.[0]<br>
2．如果想要最后一个子元素节点，可以使用parentModa.chi.ldrenlpaxentNode ..chil.dren.length - 1]</p>
<pre><code class="language-js">    &lt;ol&gt;
        &lt;li&gt;我是li1&lt;/li&gt;
        &lt;li&gt;我是li2&lt;/li&gt;
        &lt;li&gt;我是li3&lt;/li&gt;
        &lt;li&gt;我是li4&lt;/li&gt;
        &lt;li&gt;我是li5&lt;/li&gt;
    &lt;/ol&gt;
    &lt;script&gt;
        var ol = document.querySelector('ol');
        // 1. firstChild 第一个子节点 不管是文本节点还是元素节点
        console.log(ol.firstChild);
        console.log(ol.lastChild);
        // 2. firstElementChild 返回第一个子元素节点 ie9才支持
        console.log(ol.firstElementChild);
        console.log(ol.lastElementChild);
        // 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        console.log(ol.children[ol.children.length - 1]);
    &lt;/script&gt;
</code></pre>
<h3 id="下拉菜单">下拉菜单</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 获取元素
        var nav = document.querySelector('.nav');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i &lt; lis.length; i++) {
            lis[i].onmouseover = function() {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function() {
                this.children[1].style.display = 'none';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="兄弟节点">兄弟节点</h3>
<pre><code class="language-js">    &lt;div&gt;我是div&lt;/div&gt;
    &lt;span&gt;我是span&lt;/span&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
        console.log(div.nextSibling);
        console.log(div.previousSibling);
        // 2. nextElementSibling 得到下一个兄弟元素节点
        console.log(div.nextElementSibling);
        console.log(div.previousElementSibling);
    &lt;/script&gt;
</code></pre>
<pre><code class="language-js">   function getNextElementSibling(element) {
      var el = element;
      while (el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
      }
      return null;
    }  
</code></pre>
<h3 id="创建节点">创建节点</h3>
<p>document.createElement ( 'tagName &quot; )<br>
document.createElement()方法创建由tagName指定的HTMr元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。</p>
<h3 id="添加节点">添加节点</h3>
<p>node.appendchild(child)<br>
node.appendchild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于css里面的after伪元素。</p>
<p>node.insertBefore(child，指定元素)<br>
node.insertBefore()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的 before伪元素。</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;123&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 创建节点元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    &lt;/script&gt;
</code></pre>
<h3 id="简单版发布留言">简单版发布留言</h3>
<pre><code class="language-js">&lt;body&gt;
    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="节点操作-2">节点操作</h2>
<h3 id="删除节点">删除节点</h3>
<p>node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</p>
<pre><code class="language-js">    &lt;button&gt;删除&lt;/button&gt;
    &lt;ul&gt;
        &lt;li&gt;熊大&lt;/li&gt;
        &lt;li&gt;熊二&lt;/li&gt;
        &lt;li&gt;光头强&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素  node.removeChild(child)
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮依次删除里面的孩子
        btn.onclick = function() {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="删除留言">删除留言</h3>
<pre><code class="language-js">    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li  它的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i &lt; as.length; i++) {
                    as[i].onclick = function() {
                        // 删除的是 li 当前a所在的li  this.parentNode;
                        ul.removeChild(this.parentNode);
                    }
                }
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="复制克隆节点">复制（克隆）节点</h3>
<p>node.cloneNode ( )<br>
node.cloneNode()方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点<br>
注意:<br>
1.如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。<br>
⒉如果括号参数为true，则是深度拷贝，会复制节点本身以及里面所有的子节点。</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;1111&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
        var lili = ul.children[0].cloneNode(true);
        ul.appendChild(lili);
    &lt;/script&gt;
</code></pre>
<h3 id="动态生成表格">动态生成表格</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 1.先去准备好学生的数据
        var datas = [{
            name: '魏璎珞',
            subject: 'JavaScript',
            score: 100
        }, {
            name: '弘历',
            subject: 'JavaScript',
            score: 98
        }, {
            name: '傅恒',
            subject: 'JavaScript',
            score: 99
        }, {
            name: '明玉',
            subject: 'JavaScript',
            score: 88
        }, {
            name: '大猪蹄子',
            subject: 'JavaScript',
            score: 0
        }];
        // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
        var tbody = document.querySelector('tbody');
		// 遍历数组
        for (var i = 0; i &lt; datas.length; i++) { 
            // 1. 创建 tr行
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
            // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数  
            // 使用for in遍历学生对象
            for (var k in datas[i]) { 
                // 创建单元格 
                var td = document.createElement('td');
                // 把对象里面的属性值 datas[i][k] 给 td  
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 3. 创建有删除2个字的单元格 
            var td = document.createElement('td');
            td.innerHTML = '&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;';
            tr.appendChild(td);

        }
        // 4. 删除操作 开始 
        var as = document.querySelectorAll('a');
        for (var i = 0; i &lt; as.length; i++) {
            as[i].onclick = function() {
                // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  
                tbody.removeChild(this.parentNode.parentNode)
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="创建元素的三种方式">创建元素的三种方式</h3>
<p>document.write ()<br>
element.innerHTML<br>
document.createElement ()<br>
区别</p>
<ol>
<li>document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTMT，是将内容写入某个DOM节点，不会导致页面全部重绘</li>
<li>innerHTML创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂</li>
<li>createElement ()创建多个元素效率稍低一点点，但是结构更清晰<br>
总结:不同浏览器下， innerHTM效率要比creatElement 高</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 三种创建元素方式区别 
        // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘
         var btn = document.querySelector('button');
         btn.onclick = function() {
             document.write('&lt;div&gt;123&lt;/div&gt;');
         }

        // 2. innerHTML 创建元素
        var inner = document.querySelector('.inner');
         for (var i = 0; i &lt;= 100; i++) {
             inner.innerHTML += '&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;'
         }
        var arr = [];
        for (var i = 0; i &lt;= 100; i++) {
            arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');
        }
        inner.innerHTML = arr.join('');
        // 3. document.createElement() 创建元素
        var create = document.querySelector('.create');
        for (var i = 0; i &lt;= 100; i++) {
            var a = document.createElement('a');
            create.appendChild(a);
        }
    &lt;/script&gt;
</code></pre>
<h3 id="innerhtml和createelement效率对比">innerHTML和createElement效率对比</h3>
<p><strong>innerHTML字符串拼接方式（效率低）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var str = '';
        for (var i = 0; i &lt; 1000; i++) {
            document.body.innerHTML += '&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;';
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>createElement方式（效率一般）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();

        for (var i = 0; i &lt; 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>innerHTML数组方式（效率高）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var array = [];
        for (var i = 0; i &lt; 1000; i++) {
            array.push('&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;');
        }
        document.body.innerHTML = array.join('');
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<h2 id="dom的核心总结">DOM的核心总结</h2>
<p>关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</p>
<h3 id="创建">创建</h3>
<ol>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ol>
<h3 id="增加">增加</h3>
<ol>
<li>appendChild</li>
<li>insertBefore</li>
</ol>
<h3 id="删">删</h3>
<p>1.removeChild</p>
<h3 id="改">改</h3>
<p>主要修改dom的元素属性,dom元素的内容、属性,表单的值等<br>
1.修改元素属性:src、href、title等<br>
2.修改普通元素内容:innerHTML、 innerText<br>
3.修改表单元素: value、type、disabled等<br>
4.修改元素样式: style、className</p>
<h3 id="查">查</h3>
<p>主要获取查询dom的元素</p>
<ol>
<li>DOM提供的API方法: getElementByld、getElementsByTagName 古老用法不太推荐</li>
<li>H5提供的新方法: querySelector、querySelectorAll提倡</li>
<li>利用节点操作获取元素:父(parentNode)、子(children)、兄(previousElementSibling、<br>
nextElementSibling)提倡</li>
</ol>
<h3 id="属性操作">属性操作</h3>
<p>主要针对于自定义属性。<br>
1.setAttribute:设置dom的属性值<br>
2.getAttribute:得到dom的属性值<br>
3.removeAttribute移除属性</p>
<h3 id="事件操作重点">事件操作（重点）</h3>
<h2 id="事件高级">事件高级</h2>
<h3 id="注册事件2种方式">注册事件（2种方式）</h3>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5C1551165252019.png" alt="1551165252019" loading="lazy"></figure>
<h3 id="事件监听">事件监听</h3>
<h4 id="addeventlistener事件监听ie9以后支持">addEventListener()事件监听（IE9以后支持）</h4>
<pre><code class="language-js">eventTarget.addEventListener(type, listener[, useCapture])
</code></pre>
<p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>该方法接收三个参数:<br>
type:事件类型字符串，比如click、mouseover，注意这里不要带onlistener:事件处理函数，事件发生时，会调用该监听函数<br>
useCapture:可选参数，是一个布尔值，默认是false。</p>
<h4 id="attacheevent事件监听ie678支持">attacheEvent()事件监听（IE678支持）</h4>
<pre><code>eventTarget.attachEvent(eventNamewithon,callback)
</code></pre>
<p>​	eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>该方法接收两个参数:<br>
eventNameWithOn:事件类型字符串，比如onclick、onmouseover，这里要带oncallback:事件处理函数，当目标触发事件时回调函数被调用<br>
注意:IE8及早期版本支持</p>
<pre><code class="language-js">&lt;button&gt;传统注册事件&lt;/button&gt;
&lt;button&gt;方法监听注册事件&lt;/button&gt;
&lt;button&gt;ie9 attachEvent&lt;/button&gt;
&lt;script&gt;
    var btns = document.querySelectorAll('button');
    // 1. 传统方式注册事件
    btns[0].onclick = function() {
        alert('hi');
    }
    btns[0].onclick = function() {
            alert('hao a u');
        }
   // 2. 事件侦听注册事件 addEventListener 
   // (1) 里面的事件类型是字符串 必定加引号 而且不带on
   // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
    btns[1].addEventListener('click', function() {
        alert(22);
    })
    btns[1].addEventListener('click', function() {
            alert(33);
    })
    // 3. attachEvent ie9以前的版本支持
    btns[2].attachEvent('onclick', function() {
        alert(11);
    })
&lt;/script&gt;
</code></pre>
<h4 id="事件监听兼容性解决方案">事件监听兼容性解决方案</h4>
<p>封装一个函数，函数中判断浏览器的类型：</p>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C1551166023885.png" alt="1551166023885" loading="lazy"></figure>
<h3 id="删除事件解绑事件">删除事件（解绑事件）</h3>
<p><strong>1.传统注册方式</strong><br>
eventTarget.onclick=null;<br>
<strong>2.方法监听注册方式</strong><br>
eventTarget.removeEventListener(type，listener[, useCapture] ) ;eventTarget.detachEvent (eventNamewithon,callback) ;</p>
<pre><code class="language-js">    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;script&gt;
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号
        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    &lt;/script&gt;
</code></pre>
<p>**删除事件兼容性解决方案 **</p>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5C1551166332453.png" alt="1551166332453" loading="lazy"></figure>
<h3 id="dom事件流">DOM事件流</h3>
<blockquote>
<pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。
当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。

那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？
</code></pre>
</blockquote>
<p>事件流描述的是从页面中接收事件的顺序。<br>
事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p>
<blockquote>
<p>比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</p>
</blockquote>
<p>事件冒泡:IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点的过程。<br>
事件捕获:网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</p>
<p>DOM 事件流会经历3个阶段：</p>
<ol>
<li>
<p>捕获阶段</p>
</li>
<li>
<p>当前目标阶段</p>
</li>
<li>
<p>冒泡阶段</p>
</li>
</ol>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DoM事件流。<br>
注意</p>
<ol>
<li>Js代码中只能执行捕获或者冒泡其中的一个阶段。</li>
<li>onclick 和attachEvent只能得到冒泡阶段。</li>
<li>addEventListener(type，listener[，useCapture])第三个参数如果是true，表示在事件捕<br>
获阶段调用事件处理程序;如果是false (不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。</li>
<li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li>
<li>有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave</li>
<li>事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。</li>
</ol>
<p><strong>事件冒泡</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // onclick 和 attachEvent（ie） 在冒泡阶段触发
        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 
        // son -&gt; father -&gt;body -&gt; html -&gt; document
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function() {
            alert('son');
        }, false);
		// 给father注册单击事件
        var father = document.querySelector('.father');
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件，省略第3个参数
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>事件捕获</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发
        // document -&gt; html -&gt; body -&gt; father -&gt; son
         var son = document.querySelector('.son');
		// 给son注册单击事件，第3个参数为true
         son.addEventListener('click', function() {
             alert('son');
         }, true);
         var father = document.querySelector('.father');
		// 给father注册单击事件，第3个参数为true
         father.addEventListener('click', function() {
             alert('father');
         }, true);
		// 给document注册单击事件，第3个参数为true
        document.addEventListener('click', function() {
            alert('document');
        }, true)
    &lt;/script&gt;
</code></pre>
<h3 id="事件对象">事件对象</h3>
<h4 id="什么是事件对象">什么是事件对象</h4>
<p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</p>
<p>比如：</p>
<ol>
<li>
<p>谁绑定了这个事件。</p>
</li>
<li>
<p>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</p>
</li>
<li>
<p>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p>
</li>
</ol>
<h4 id="事件对象的使用">事件对象的使用</h4>
<p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</p>
<p>所以，在事件处理函数中声明1个形参用来接收事件对象。</p>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5C1551169537789.png" alt="1551169537789" loading="lazy"></figure>
<h4 id="事件对象的兼容性处理">事件对象的兼容性处理</h4>
<p>事件对象本身的获取存在兼容问题：</p>
<ol>
<li>
<p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p>
</li>
<li>
<p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</p>
</li>
</ol>
<pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。
只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。
</code></pre>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.onclick = function(e) {
                // 事件对象
                e = e || window.event;
                console.log(e);
        }
    &lt;/script&gt;
</code></pre>
<h4 id="事件对象的属性和方法">事件对象的属性和方法</h4>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5C1551169931778.png" alt="1551169931778" loading="lazy"></figure>
<h4 id="etarget-和-this-的区别">e.target 和 this 的区别</h4>
<ul>
<li>
<p>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</p>
</li>
<li>
<p>e.target 是事件触发的元素。</p>
</li>
</ul>
<blockquote>
<pre><code>常情况下terget 和 this是一致的，
但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），
	这时候this指向的是父元素，因为它是绑定事件的元素对象，
	而target指向的是子元素，因为他是触发事件的那个具体元素对象。
</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.addEventListener('click', function(e) {
            // e.target 和 this指向的都是div
            console.log(e.target);
            console.log(this);

        });
    &lt;/script&gt;
</code></pre>
<p>事件冒泡下的e.target和this</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
              // 我们给ul 绑定了事件  那么this 就指向ul  
              console.log(this); // ul

              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li
              console.log(e.target); // li
        });
    &lt;/script&gt;
</code></pre>
<h3 id="阻止默认行为">阻止默认行为</h3>
<blockquote>
<p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p>
</blockquote>
<pre><code class="language-js">    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;
    &lt;script&gt;
        // 2. 阻止默认行为 让链接不跳转 
        var a = document.querySelector('a');
        a.addEventListener('click', function(e) {
             e.preventDefault(); //  dom 标准写法
        });
        // 3. 传统的注册方式
        a.onclick = function(e) {
            // 普通浏览器 e.preventDefault();  方法
            e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            e.returnValue = false;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题
            return false;
        }
    &lt;/script&gt;
</code></pre>
<h3 id="阻止事件冒泡">阻止事件冒泡</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5C1551171467194.png" alt="1551171467194" loading="lazy"></figure>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function(e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
        }, false);

        var father = document.querySelector('.father');
		// 给father注册单击事件
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>阻止事件冒泡的兼容性处理</strong></p>
<p>![1551171657513](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551171657513.png)</p>
<h3 id="事件委托">事件委托</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<h4 id="什么是事件委托">什么是事件委托</h4>
<pre><code>把事情委托给别人，代为处理。
</code></pre>
<p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p>
<blockquote>
<p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p>
</blockquote>
<h4 id="事件委托的原理">事件委托的原理</h4>
<p>​	给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p>
<h4 id="事件委托的作用">事件委托的作用</h4>
<ul>
<li>
<p>我们只操作了一次 DOM ，提高了程序的性能。</p>
</li>
<li>
<p>动态新创建的子元素，也拥有事件。</p>
</li>
</ul>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
            // e.target 这个可以得到我们点击的对象
            e.target.style.backgroundColor = 'pink';
        })
    &lt;/script&gt;
</code></pre>
<h2 id="常用鼠标事件">常用鼠标事件</h2>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5C1551172699854.png" alt="1551172699854" loading="lazy"></figure>
<h3 id="禁止选中文字和禁止右键菜单">禁止选中文字和禁止右键菜单</h3>
<pre><code class="language-js">&lt;body&gt;
    我是一段不愿意分享的文字
    &lt;script&gt;
        // 1. contextmenu 我们可以禁用右键菜单
        document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
        })
        // 2. 禁止选中文字 selectstart
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="鼠标事件对象">鼠标事件对象</h3>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5C1551173103741.png" alt="1551173103741" loading="lazy"></figure>
<h3 id="获取鼠标在页面的坐标">获取鼠标在页面的坐标</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 鼠标事件对象 MouseEvent
        document.addEventListener('click', function(e) {
            // 1. client 鼠标在可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('---------------------');

            // 2. page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('---------------------');

            // 3. screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);

        })
    &lt;/script&gt;
</code></pre>
<h3 id="跟随鼠标">跟随鼠标</h3>
<pre><code class="language-js">    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;
    &lt;script&gt;
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function(e) {
        	// 1. mousemove只要我们鼠标移动1px 就会触发这个事件
        	// 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 
            // 把这个x和y坐标做为图片的top和left 值就可以移动图片
        	var x = e.pageX;
        	var y = e.pageY;
        	console.log('x坐标是' + x, 'y坐标是' + y);
        	//3 . 千万不要忘记给left 和top 添加px 单位
        	pic.style.left = x - 50 + 'px';
        	pic.style.top = y - 40 + 'px';
    	});
    &lt;/script&gt;
</code></pre>
<h2 id="常用的键盘事件">常用的键盘事件</h2>
<h3 id="键盘事件">键盘事件</h3>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5C1551318122855.png" alt="1551318122855" loading="lazy"></figure>
<p>注意:<br>
1.如果使用addEventListener 不需要加on</p>
<p>2.onkeypress和前面2个的区别是，它不识别功能键，比如左右箭头，shift等。</p>
<p>3.三个事件的执行顺序是: keydown -- keypress --- keyup</p>
<pre><code class="language-js">    &lt;script&gt;
        // 常用的键盘事件
        //1. keyup 按键弹起的时候触发 
        document.addEventListener('keyup', function() {
            console.log('我弹起了');
        })

        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keypress', function() {
                console.log('我按下了press');
        })
        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keydown', function() {
                console.log('我按下了down');
        })
        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup
    &lt;/script&gt;
</code></pre>
<h3 id="键盘事件对象">键盘事件对象</h3>
<p>注意:</p>
<ol>
<li>onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写。<br>
2)在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键（包括功能键)3) keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCIl值</li>
</ol>
<p><strong>使用keyCode属性判断用户按下哪个键</strong></p>
<pre><code class="language-js">    &lt;script&gt;
        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
        document.addEventListener('keyup', function(e) {
            console.log('up:' + e.keyCode);
            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键
            if (e.keyCode === 65) {
                alert('您按下的a键');
            } else {
                alert('您没有按下a键')
            }
        })
        document.addEventListener('keypress', function(e) {
            // console.log(e);
            console.log('press:' + e.keyCode);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="按键输入内容">按键输入内容</h3>
<p>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</p>
<blockquote>
<p>注意：触发获得焦点事件，可以使用 元素对象.focus()</p>
</blockquote>
<pre><code class="language-js">    &lt;input type=&quot;text&quot;&gt;
    &lt;script&gt;
        // 获取输入框
        var search = document.querySelector('input');
		// 给document注册keyup事件
        document.addEventListener('keyup', function(e) {
            // 判断keyCode的值
            if (e.keyCode === 83) {
                // 触发输入框的获得焦点事件
                search.focus();
            }
        })
    &lt;/script&gt;
</code></pre>
<h3 id="模拟京东快递单号查询">模拟京东快递单号查询</h3>
<p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</p>
<pre><code class="language-js">    &lt;div class=&quot;search&quot;&gt;
        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var con = document.querySelector('.con');
        var jd_input = document.querySelector('.jd');
		// 给输入框注册keyup事件
        jd_input.addEventListener('keyup', function() {
				// 判断输入框内容是否为空
                if (this.value == '') {
                    // 为空，隐藏放大提示盒子
                    con.style.display = 'none';
                } else {
                    // 不为空，显示放大提示盒子，设置盒子的内容
                    con.style.display = 'block';
                    con.innerText = this.value;
                }
            })
        // 给输入框注册失去焦点事件，隐藏放大提示盒子
        jd_input.addEventListener('blur', function() {
                con.style.display = 'none';
            })
        // 给输入框注册获得焦点事件
        jd_input.addEventListener('focus', function() {
            // 判断输入框内容是否为空
            if (this.value !== '') {
                // 不为空则显示提示盒子
                con.style.display = 'block';
            }
        })
    &lt;/script&gt;
</code></pre>
<h2 id="bom">BOM</h2>
<h3 id="什么是bom">什么是BOM</h3>
<p>​	BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p>
<p>​	BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p>
<p>​	BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5C1551319264407.png" alt="1551319264407" loading="lazy"></figure>
<h3 id="bom的构成">BOM的构成</h3>
<p>BOM 比 DOM 更大，它包含 DOM。</p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5C1551319344183.png" alt="1551319344183" loading="lazy"></figure>
<h3 id="顶级对象window">顶级对象window</h3>
<p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色。</p>
<p>1.它是S访问浏览器窗口的一个接口。<br>
2．它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。<br>
在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等。</p>
<p><strong>注意: window下的一个特殊属性window.name</strong></p>
<h3 id="window对象的常见事件">window对象的常见事件</h3>
<h4 id="页面窗口加载事件2种">页面（窗口）加载事件（2种）</h4>
<p><strong>第1种</strong></p>
<pre><code class="language-js">window .onload = function ( ) { }或者
window.addEventListener (&quot;load&quot; , function ( ) { });
</code></pre>
<p>window.onload 是窗口 (页面）加载事件，<strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p>
<p>注意:<br>
1.有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等面内容全部加载元毕，再去执行处理函数。</p>
<ol start="2">
<li>window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。</li>
<li>3.如果使用addEventListener则没有限制</li>
</ol>
<p><strong>第2种</strong></p>
<pre><code class="language-js">document.addEventListener ( ' DOMContentLoaded' , function() { })

</code></pre>
<p>​	DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p>
<p>​	IE9以上才支持！！！</p>
<p>​	如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p>
<pre><code class="language-js">    &lt;script&gt;
        window.addEventListener('load', function() {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function() {
                alert('点击我');
            })
        })
        window.addEventListener('load', function() {
            alert(22);
        })
        document.addEventListener('DOMContentLoaded', function() {
            alert(33);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="调整窗口大小事件">调整窗口大小事件</h4>
<pre><code class="language-js">window.onresize = function ( ) { }
window.addEventListener ( &quot;resize&quot; ,function() { } );
</code></pre>
<p>​	window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。</p>
<p>注意：</p>
<ol>
<li>
<p>只要窗口大小发生像素变化，就会触发这个事件。</p>
</li>
<li>
<p>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p>
</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 注册页面加载事件
        window.addEventListener('load', function() {
            var div = document.querySelector('div');
        	// 注册调整窗口大小事件
            window.addEventListener('resize', function() {
                // window.innerWidth 获取窗口大小
                console.log('变化了');
                if (window.innerWidth &lt;= 800) {
                    div.style.display = 'none';
                } else {
                    div.style.display = 'block';
                }
            })
        })
    &lt;/script&gt;
    &lt;div&gt;&lt;/div&gt;
</code></pre>
<h3 id="定时器两种">定时器（两种）</h3>
<p>window 对象给我们提供了 2 个非常好用的方法-定时器。</p>
<ul>
<li>
<p>setTimeout()</p>
</li>
<li>
<p>setInterval()</p>
</li>
</ul>
<h4 id="settimeout-炸弹定时器">setTimeout() 炸弹定时器</h4>
<h5 id="开启定时器">开启定时器</h5>
<p><strong>window.setTimeout(调用函数，[延迟的毫秒数]);</strong><br>
<strong>setTimeout()这个调用函数我们也称为回调函数callback</strong><br>
<strong>注意:</strong></p>
<ol>
<li>window可以省略。</li>
<li>这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐</li>
<li>延迟的毫秒数省略默认是0，如果写，必须是毫秒。</li>
<li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li>
</ol>
<blockquote>
<pre><code>普通函数是按照代码顺序直接调用。

简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。
例如：定时器中的调用函数，事件处理函数，也是回调函数。

以前我们讲的   element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。

</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;script&gt;
        // 回调函数是一个匿名函数
         setTimeout(function() {
             console.log('时间到了');

         }, 2000);
        function callback() {
            console.log('爆炸了');
        }
		// 回调函数是一个有名函数
        var timer1 = setTimeout(callback, 3000);
        var timer2 = setTimeout(callback, 5000);
    &lt;/script&gt;
</code></pre>
<h5 id="5秒后关闭广告">5秒后关闭广告</h5>
<pre><code class="language-js">&lt;body&gt;
    &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var ad = document.querySelector('.ad');
		// 开启定时器
        setTimeout(function() {
            ad.style.display = 'none';
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h5 id="停止定时器">停止定时器</h5>
<p><strong>window.clearTimeout (timeoutID)</strong><br>
<strong>clearTimeout()方法取消了先前通过调用setTimeout ()建立的定时器。</strong><br>
<strong>注意:</strong></p>
<ol>
<li>window可以省略。</li>
<li>里面的参数就是定时器的标识符。</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;点击停止定时器&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 开启定时器
        var timer = setTimeout(function() {
            console.log('爆炸了');
        }, 5000);
		// 给按钮注册单击事件
        btn.addEventListener('click', function() {
            // 停止定时器
            clearTimeout(timer);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="setinterval-闹钟定时器">setInterval() 闹钟定时器</h4>
<h5 id="开启定时器-2">开启定时器</h5>
<p><strong>window.setInterval(回调函数，[间隔的毫秒数]);</strong><br>
<strong>setInterval</strong>方法<strong>重复调用一个函数</strong>，每隔这个时间，就去调用一次回调函数。<br>
注意:</p>
<ol>
<li>window可以省略。<br>
2.这个调用函数可以直接写函数，或者写函数名或者采取字符串'函数名()’三种形式。<br>
3.间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。<br>
4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。<br>
5.第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行—次。</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 1. setInterval 
        setInterval(function() {
            console.log('继续输出');
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h5 id="倒计时">倒计时</h5>
<pre><code class="language-js">    &lt;div&gt;
        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素（时分秒盒子） 
        var hour = document.querySelector('.hour'); // 小时的黑色盒子
        var minute = document.querySelector('.minute'); // 分钟的黑色盒子
        var second = document.querySelector('.second'); // 秒数的黑色盒子
        var inputTime = +new Date('2021-5-1 18:00:00'); // 返回的是用户输入时间总的毫秒数

        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 

        // 2. 开启定时器
        setInterval(countDown, 1000);
		
        function countDown() {
            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 
            var h = parseInt(times / 60 / 60 % 24); //时
            h = h &lt; 10 ? '0' + h : h;
            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子
            var m = parseInt(times / 60 % 60); // 分
            m = m &lt; 10 ? '0' + m : m;
            minute.innerHTML = m;
            var s = parseInt(times % 60); // 当前的秒
            s = s &lt; 10 ? '0' + s : s;
            second.innerHTML = s;
        }
    &lt;/script&gt;
</code></pre>
<h5 id="停止定时器-2">停止定时器</h5>
<p>window.clearInterval (intervalID);<br>
clearInterval()方法取消了先前通过调用setInterval()建立的定时器。<br>
注意:<br>
1.window可以省略。<br>
2.里面的参数就是定时器的标识符。</p>
<h4 id="发送短信倒计时">发送短信倒计时</h4>
<p>​	点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。</p>
<pre><code class="language-js">    手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 全局变量，定义剩下的秒数
        var time = 3; 
		// 注册单击事件
        btn.addEventListener('click', function() {
            // 禁用按钮
            btn.disabled = true;
            // 开启定时器
            var timer = setInterval(function() {
                // 判断剩余秒数
                if (time == 0) {
                    // 清除定时器和复原按钮
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.innerHTML = '发送';
                } else {
                    btn.innerHTML = '还剩下' + time + '秒';
                    time--;
                }
            }, 1000);
        });
    &lt;/script&gt;
</code></pre>
<h3 id="this指向问题">this指向问题</h3>
<p>​	this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p>
<p>现阶段，我们先了解一下几个this指向</p>
<ol>
<li>
<p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p>
</li>
<li>
<p>方法调用中谁调用this指向谁</p>
</li>
<li>
<p>构造函数中this指向构造函数的实例</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        // this 指向问题 一般情况下this的最终指向的是那个调用它的对象
        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）
        console.log(this);
        function fn() {
            console.log(this);
        }
        window.fn();
        window.setTimeout(function() {
            console.log(this);
        }, 1000);
        // 2. 方法调用中谁调用this指向谁
        var o = {
            sayHi: function() {
                console.log(this); // this指向的是 o 这个对象
            }
        }
        o.sayHi();
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
                console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象
            })
        // 3. 构造函数中this指向构造函数的实例
        function Fun() {
            console.log(this); // this 指向的是fun 实例对象
        }
        var fun = new Fun();
    &lt;/script&gt;
</code></pre>
<h3 id="location对象">location对象</h3>
<h4 id="什么是-location-对象">什么是 location 对象</h4>
<p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析<br>
URL。因为<br>
这个属性返回的是一个对象，所以我们将这个属性也称为location对象。</p>
<h4 id="url">URL</h4>
<p>统一资源定位符(Uniform ResourceLocator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<br>
URL的一般语法格式为:<br>
protocol:// host [ :port] /path/ [?query]#fragment<br>
http : / / www.itcast.cn/index.html?name=andy&amp;age=18#link</p>
<figure data-type="image" tabindex="17"><img src="E:%5CAPTX-4869%5Cmd%5C1551322387201.png" alt="1551322387201" loading="lazy"></figure>
<h4 id="location-对象的属性">location 对象的属性</h4>
<figure data-type="image" tabindex="18"><img src="E:%5CAPTX-4869%5Cmd%5C1551322416716.png" alt="1551322416716" loading="lazy"></figure>
<p>![1551322438200](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551322438200.png)</p>
<h4 id="5s自动跳转页面">5s自动跳转页面</h4>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        btn.addEventListener('click', function() {
            // console.log(location.href);
            location.href = 'http://www.itcast.cn';
        })
        var timer = 5;
        setInterval(function() {
            if (timer == 0) {
                location.href = 'http://www.itcast.cn';
            } else {
                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';
                timer--;
            }
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h4 id="获取url参数">获取URL参数</h4>
<pre><code class="language-js">    &lt;div&gt;&lt;/div&gt;
	&lt;script&gt;
        console.log(location.search); // ?uname=andy
        // 1.先去掉？  substr('起始的位置'，截取几个字符);
        var params = location.search.substr(1); // uname=andy
        console.log(params);
        // 2. 利用=把字符串分割为数组 split('=');
        var arr = params.split('=');
        console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;]
        var div = document.querySelector('div');
        // 3.把数据写入div中
        div.innerHTML = arr[1] + '欢迎您';
    &lt;/script&gt;
</code></pre>
<h4 id="location对象的常见方法">location对象的常见方法</h4>
<figure data-type="image" tabindex="19"><img src="E:%5CAPTX-4869%5Cmd%5C1551322750241.png" alt="1551322750241" loading="lazy"></figure>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
            // 记录浏览历史，所以可以实现后退功能
            // location.assign('http://www.itcast.cn');
            // 不记录浏览历史，所以不可以实现后退功能
            // location.replace('http://www.itcast.cn');
            location.reload(true);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="navigator对象">navigator对象</h3>
<p>​	navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
<p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<pre><code class="language-js">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    window.location.href = &quot;&quot;;     //手机
 } else {
    window.location.href = &quot;&quot;;     //电脑
 }
</code></pre>
<h3 id="history对象">history对象</h3>
<p>​	window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p>
<p>![1551322885216](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551322885216.png)</p>
<p>history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p>
<h2 id="js执行机制">JS执行机制</h2>
<p>以下代码执行的结果是什么？</p>
<p>1 2 3</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 1000);
 
 console.log(2);
</code></pre>
<p>以下代码执行的结果是什么？</p>
<p>1 2 3</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 0);
 
 console.log(2);
</code></pre>
<h3 id="js-是单线程">JS 是单线程</h3>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p>
<pre><code class="language-js">	单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
	这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
</code></pre>
<h3 id="同步任务和异步任务">同步任务和异步任务</h3>
<p>​	单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</p>
<p>​	为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了<strong>同步任务</strong>和<strong>异步任务</strong>。</p>
<h4 id="同步">同步</h4>
<p>​	前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。</p>
<h4 id="异步">异步</h4>
<p>​	你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p>
<p><strong>他们的本质区别:这条流水线上各个流程的执行顺序不同。</strong></p>
<blockquote>
<pre><code class="language-js">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。

同步任务指的是：
	在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
异步任务指的是：
	不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。
</code></pre>
</blockquote>
<figure data-type="image" tabindex="20"><img src="E:%5CAPTX-4869%5Cmd%5C1551434972778.png" alt="1551434972778" loading="lazy"></figure>
<h3 id="js执行机制事件循环">JS执行机制（事件循环）</h3>
<figure data-type="image" tabindex="21"><img src="E:%5CAPTX-4869%5Cmd%5C1551435335464.png" alt="1551435335464" loading="lazy"></figure>
<p>![1551435398306](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551435398306.png)</p>
<p>![1551435449634](E:\BaiduNetdiskDownload\web\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day04\4-笔记\images\1551435449634.png)</p>
<h2 id="元素偏移量-offset-系列">元素偏移量 offset 系列</h2>
<h3 id="offset-概述">offset 概述</h3>
<p>offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p>
<ol>
<li>
<p>获得元素距离带有定位父元素的位置</p>
</li>
<li>
<p>获得元素自身的大小（宽度高度）</p>
</li>
<li>
<p>注意：返回的数值都不带单位</p>
<figure data-type="image" tabindex="22"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%871.png" alt="图片1" loading="lazy"></figure>
</li>
</ol>
<h3 id="offset-与-style-区别">offset 与 style 区别</h3>
<h4 id="offset">offset</h4>
<ul>
<li>
<p>offset 可以得到任意样式表中的样式值</p>
</li>
<li>
<p>offset 系列获得的数值是没有单位的</p>
</li>
<li>
<p>offsetWidth 包含padding+border+width</p>
</li>
<li>
<p>offsetWidth 等属性是<strong>只读属性</strong>，只能获取不能赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要获取元素大小位置，用offset更合适</p>
</blockquote>
</li>
</ul>
<h4 id="style">style</h4>
<ul>
<li>
<p>style 只能得到<strong>行内样式表中的样式值</strong></p>
</li>
<li>
<p>style.width 获得的是带有单位的字符串</p>
</li>
<li>
<p>style.width 获得不包含padding和border 的值</p>
</li>
<li>
<p>style.width 是可读写属性，可以获取也可以赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要给元素更改值，则需要用style改变</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="获取鼠标在盒子内的坐标">获取鼠标在盒子内的坐标</h3>
<ol>
<li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</li>
<li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li>
<li>其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop)</li>
<li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标</li>
<li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动</li>
</ol>
<pre><code class="language-javascript">var box = document.querySelector('.box');
box.addEventListener('mousemove', function(e) {
var x = e.pageX - this.offsetLeft;
var y = e.pageY - this.offsetTop;
this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
})
</code></pre>
<h3 id="模态框拖拽">模态框拖拽</h3>
<p>弹出框，我们也称为模态框。</p>
<p>​	1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。</p>
<p>​	2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。</p>
<p>​	3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。</p>
<p>​	4.鼠标松开，可以停止拖动模态框移动</p>
<ol>
<li>点击弹出层， 模态框和遮挡层就会显示出来 display:block;</li>
<li>点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</li>
<li>在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标</li>
<li>触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</li>
<li>拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</li>
<li>鼠标按下触发的事件源是最上面一行，就是  id 为 title</li>
<li>鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。</li>
<li>鼠标按下，我们要得到鼠标在盒子的坐标。</li>
<li>鼠标移动，就让模态框的坐标  设置为  ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。</li>
<li>鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除</li>
</ol>
<pre><code class="language-javascript"> // 1. 获取元素
        var login = document.querySelector('.login');
        var mask = document.querySelector('.login-bg');
        var link = document.querySelector('#link');
        var closeBtn = document.querySelector('#closeBtn');
        var title = document.querySelector('#title');
        // 2. 点击弹出层这个链接 link  让mask 和login 显示出来
        link.addEventListener('click', function() {
                mask.style.display = 'block';
                login.style.display = 'block';
            })
            // 3. 点击 closeBtn 就隐藏 mask 和 login 
        closeBtn.addEventListener('click', function() {
                mask.style.display = 'none';
                login.style.display = 'none';
            })
            // 4. 开始拖拽
            // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
        title.addEventListener('mousedown', function(e) {
            var x = e.pageX - login.offsetLeft;
            var y = e.pageY - login.offsetTop;
            // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
            document.addEventListener('mousemove', move)

            function move(e) {
                login.style.left = e.pageX - x + 'px';
                login.style.top = e.pageY - y + 'px';
            }
            // (3) 鼠标弹起，就让鼠标移动事件移除
            document.addEventListener('mouseup', function() {
                document.removeEventListener('mousemove', move);
            })
        })

</code></pre>
<h3 id="仿京东放大镜">仿京东放大镜</h3>
<ol>
<li>
<p>整个案例可以分为三个功能模块</p>
</li>
<li>
<p>鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能</p>
</li>
<li>
<p>黄色的遮挡层跟随鼠标功能。</p>
</li>
<li>
<p>移动黄色遮挡层，大图片跟随移动功能。</p>
</li>
<li>
<p>黄色的遮挡层跟随鼠标功能。</p>
</li>
<li>
<p>把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。</p>
</li>
<li>
<p>首先是获得鼠标在盒子的坐标。</p>
</li>
<li>
<p>之后把数值给遮挡层做为left 和top值。</p>
</li>
<li>
<p>此时用到鼠标移动事件，但是还是在小图片盒子内移动。</p>
</li>
<li>
<p>发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</p>
</li>
<li>
<p>遮挡层不能超出小图片盒子范围。</p>
</li>
<li>
<p>如果小于零，就把坐标设置为0</p>
</li>
<li>
<p>如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离</p>
</li>
<li>
<p>遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</p>
</li>
</ol>
<pre><code class="language-javascript">window.addEventListener('load', function() {
    var preview_img = document.querySelector('.preview_img');
    var mask = document.querySelector('.mask');
    var big = document.querySelector('.big');
    // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
    preview_img.addEventListener('mouseover', function() {
        mask.style.display = 'block';
        big.style.display = 'block';
    })
    preview_img.addEventListener('mouseout', function() {
            mask.style.display = 'none';
            big.style.display = 'none';
        })
        // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
    preview_img.addEventListener('mousemove', function(e) {
        // (1). 先计算出鼠标在盒子内的坐标
        var x = e.pageX - this.offsetLeft;
        var y = e.pageY - this.offsetTop;
        // console.log(x, y);
        // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了
        // (3) 我们mask 移动的距离
        var maskX = x - mask.offsetWidth / 2;
        var maskY = y - mask.offsetHeight / 2;
        // (4) 如果x 坐标小于了0 就让他停在0 的位置
        // 遮挡层的最大移动距离
        var maskMax = preview_img.offsetWidth - mask.offsetWidth;
        if (maskX &lt;= 0) {
            maskX = 0;
        } else if (maskX &gt;= maskMax) {
            maskX = maskMax;
        }
        if (maskY &lt;= 0) {
            maskY = 0;
        } else if (maskY &gt;= maskMax) {
            maskY = maskMax;
        }
        mask.style.left = maskX + 'px';
        mask.style.top = maskY + 'px';
        // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
        // 大图
        var bigIMg = document.querySelector('.bigImg');
        // 大图片最大移动距离
        var bigMax = bigIMg.offsetWidth - big.offsetWidth;
        // 大图片的移动距离 X Y
        var bigX = maskX * bigMax / maskMax;
        var bigY = maskY * bigMax / maskMax;
        bigIMg.style.left = -bigX + 'px';
        bigIMg.style.top = -bigY + 'px';

    })

})
</code></pre>
<h2 id="元素可视区-client-系列">元素可视区 client 系列</h2>
<h3 id="client概述">client概述</h3>
<p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>
系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p>
<figure data-type="image" tabindex="23"><img src="E:%5CAPTX-4869%5Cmd%5Cclient3.png" alt="图片3" loading="lazy"></figure>
<h3 id="淘宝-flexiblejs-源码分析">淘宝 flexible.js 源码分析</h3>
<p>立即执行函数 (function(){})()  或者 (function(){}())</p>
<p>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</p>
<p>下面三种情况都会刷新页面都会触发 load 事件。</p>
<p>1.a标签的超链接</p>
<p>2.F5或者刷新按钮（强制刷新）</p>
<p>3.前进后退按钮</p>
<p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</p>
<p>所以此时后退按钮不能刷新页面。</p>
<p>此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</p>
<p><code>注意这个事件给window添加。</code></p>
<h2 id="元素滚动-scroll-系列">元素滚动 scroll 系列</h2>
<h3 id="scroll-概述">scroll 概述</h3>
<p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<figure data-type="image" tabindex="24"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%875.png" alt="图片5" loading="lazy"></figure>
<h3 id="页面被卷去的头部">页面被卷去的头部</h3>
<p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</p>
<h3 id="仿淘宝固定右侧侧边栏">仿淘宝固定右侧侧边栏</h3>
<ol>
<li>
<p>原先侧边栏是绝对定位</p>
</li>
<li>
<p>当页面滚动到一定位置，侧边栏改为固定定位</p>
</li>
<li>
<p>页面继续滚动，会让 返回顶部显示出来</p>
</li>
<li>
<p>需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是document</p>
</li>
<li>
<p>滚动到某个位置，就是判断页面被卷去的上部值。</p>
</li>
<li>
<p><strong>页面被卷去的头部</strong>：可以通过window.pageYOffset 获得  如果是被卷去的左侧window.pageXOffset</p>
</li>
<li>
<p>注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset</p>
</li>
<li>
<p>其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了</p>
</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset);
            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
            if (window.pageYOffset &gt;= bannerTop) {
                sliderbar.style.position = 'fixed';
                sliderbar.style.top = sliderbarTop + 'px';
            } else {
                sliderbar.style.position = 'absolute';
                sliderbar.style.top = '300px';
            }
            // 4. 当我们页面滚动到main盒子，就显示 goback模块
            if (window.pageYOffset &gt;= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';
            }

        })
</code></pre>
<h3 id="页面被卷去的头部兼容性解决方案">页面被卷去的头部兼容性解决方案</h3>
<p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p>
<ol>
<li>声明了 DTD，使用 document.documentElement.scrollTop</li>
<li>未声明 DTD，使用  document.body.scrollTop</li>
<li>新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</li>
</ol>
<pre><code class="language-javascript">function getScroll() {
    return {
      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    };
 } 
使用的时候  getScroll().left

</code></pre>
<h2 id="三大系列总结">三大系列总结</h2>
<figure data-type="image" tabindex="25"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%877.png" alt="图片7" loading="lazy"></figure>
<p>他们主要用法：</p>
<p>1.offset系列 经常用于获得元素位置    offsetLeft  offsetTop</p>
<p>2.client经常用于获取元素大小  clientWidth clientHeight</p>
<p>3.scroll 经常用于获取滚动距离 scrollTop  scrollLeft</p>
<p>4.注意页面滚动的距离通过 window.pageXOffset  获得</p>
<h2 id="mouseenter-和mouseover的区别">mouseenter 和mouseover的区别</h2>
<ul>
<li>当鼠标移动到元素上时就会触发mouseenter 事件</li>
<li>类似 mouseover，它们两者之间的差别是</li>
<li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li>
<li>之所以这样，就是因为mouseenter不会冒泡</li>
<li>跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</li>
</ul>
<h2 id="动画函数封装">动画函数封装</h2>
<h3 id="动画实现原理">动画实现原理</h3>
<blockquote>
<p>核心原理：通过定时器 setInterval() 不断移动盒子位置。</p>
</blockquote>
<p>实现步骤：</p>
<ol>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上1个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>加一个结束定时器的条件</li>
<li>注意此元素需要添加定位，才能使用element.style.left</li>
</ol>
<h3 id="动画函数给不同元素记录不同定时器">动画函数给不同元素记录不同定时器</h3>
<p>如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p>
<blockquote>
<p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p>
</blockquote>
<pre><code class="language-javascript"> function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function() {
                if (obj.offsetLeft &gt;= target) {
                    // 停止动画 本质是停止定时器
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';

            }, 30);
        }

</code></pre>
<h3 id="缓动效果原理">缓动效果原理</h3>
<p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p>
<p>思路：</p>
<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li>
<li>核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</li>
<li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器</li>
<li>注意步长值需要取整</li>
</ol>
<h3 id="动画函数多个目标值之间移动">动画函数多个目标值之间移动</h3>
<p>可以让动画函数从 800 移动到 500。</p>
<p>当我们点击按钮时候，判断步长是正值还是负值（否则当为距离小于10时 步长取整始终为0 不在移动）</p>
<p>​	1.如果是正值，则步长往大了取整</p>
<p>​	2.如果是负值，则步长 向小了取整</p>
<h3 id="动函数添加回调函数">动函数添加回调函数</h3>
<p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当<strong>那个函数执行完之后，再执行传进去的这个函</strong>数，这个过程就叫做回调。</p>
<p>回调函数写的位置：定时器结束的位置。</p>
<h3 id="动画完整版代码">动画完整版代码:</h3>
<pre><code class="language-javascript">function animate(obj, target, callback) {
    // console.log(callback);  callback = function() {}  调用的时候 callback()

    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function() {
        // 步长值写到定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题
        // var step = Math.ceil((target - obj.offsetLeft) / 10);
        var step = (target - obj.offsetLeft) / 10;
        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft == target) {
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            // if (callback) {
            //     // 调用函数
            //     callback();
            // }
            callback &amp;&amp; callback();
        }
        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
        obj.style.left = obj.offsetLeft + step + 'px';

    }, 15);
}
</code></pre>
<h2 id="常见网页特效案例">常见网页特效案例</h2>
<h3 id="网页轮播图">网页轮播图</h3>
<p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p>
<p>功能需求：</p>
<p>​	1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</p>
<p>​	2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</p>
<p>​	3.图片播放的同时，下面小圆圈模块跟随一起变化。</p>
<p>​	4.点击小圆圈，可以播放相应图片。</p>
<p>​	5.鼠标不经过轮播图，轮播图也会自动播放图片。</p>
<p>​	6.鼠标经过，轮播图模块， 自动播放停止。</p>
<pre><code>window.addEventListener('load', function() {
    // 1. 获取元素
    var arrow_l = document.querySelector('.arrow-l');
    var arrow_r = document.querySelector('.arrow-r');
    var focus = document.querySelector('.focus');
    var focusWidth = focus.offsetWidth;
    // 2. 鼠标经过focus 就显示隐藏左右按钮
    focus.addEventListener('mouseenter', function() {
        arrow_l.style.display = 'block';
        arrow_r.style.display = 'block';
        clearInterval(timer);
        timer = null; // 清除定时器变量
    });
    focus.addEventListener('mouseleave', function() {
        arrow_l.style.display = 'none';
        arrow_r.style.display = 'none';
        timer = setInterval(function() {
            //手动调用点击事件
            arrow_r.click();
        }, 2000);
    });
    // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈
    var ul = focus.querySelector('ul');
    var ol = focus.querySelector('.circle');
    // console.log(ul.children.length);
    for (var i = 0; i &lt; ul.children.length; i++) {
        // 创建一个小li 
        var li = document.createElement('li');
        // 记录当前小圆圈的索引号 通过自定义属性来做 
        li.setAttribute('index', i);
        // 把小li插入到ol 里面
        ol.appendChild(li);
        // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件
        li.addEventListener('click', function() {
            // 干掉所有人 把所有的小li 清除 current 类名
            for (var i = 0; i &lt; ol.children.length; i++) {
                ol.children[i].className = '';
            }
            // 留下我自己  当前的小li 设置current 类名
            this.className = 'current';
            // 5. 点击小圆圈，移动图片 当然移动的是 ul 
            // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值
            // 当我们点击了某个小li 就拿到当前小li 的索引号
            var index = this.getAttribute('index');
            // 当我们点击了某个小li 就要把这个li 的索引号给 num  
            num = index;
            // 当我们点击了某个小li 就要把这个li 的索引号给 circle  
            circle = index;
            // num = circle = index;
            console.log(focusWidth);
            console.log(index);

            animate(ul, -index * focusWidth);
        })
    }
    // 把ol里面的第一个小li设置类名为 current
    ol.children[0].className = 'current';
    // 6. 克隆第一张图片(li)放到ul 最后面
    var first = ul.children[0].cloneNode(true);
    ul.appendChild(first);
    // 7. 点击右侧按钮， 图片滚动一张
    var num = 0;
    // circle 控制小圆圈的播放
    var circle = 0;
    // flag 节流阀
    var flag = true;
    arrow_r.addEventListener('click', function() {
        if (flag) {
            flag = false; // 关闭节流阀
            // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0
            if (num == ul.children.length - 1) {
                ul.style.left = 0;
                num = 0;
            }
            num++;
            animate(ul, -num * focusWidth, function() {
                flag = true; // 打开节流阀
            });
            // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle++;
            // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原
            if (circle == ol.children.length) {
                circle = 0;
            }
            // 调用函数
            circleChange();
        }
    });

    // 9. 左侧按钮做法
    arrow_l.addEventListener('click', function() {
        if (flag) {
            flag = false;
            if (num == 0) {
                num = ul.children.length - 1;
                ul.style.left = -num * focusWidth + 'px';

            }
            num--;
            animate(ul, -num * focusWidth, function() {
                flag = true;
            });
            // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle--;
            // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）
            // if (circle &lt; 0) {
            //     circle = ol.children.length - 1;
            // }
            circle = circle &lt; 0 ? ol.children.length - 1 : circle;
            // 调用函数
            circleChange();
        }
    });

    function circleChange() {
        // 先清除其余小圆圈的current类名
        for (var i = 0; i &lt; ol.children.length; i++) {
            ol.children[i].className = '';
        }
        // 留下当前的小圆圈的current类名
        ol.children[circle].className = 'current';
    }
    // 10. 自动播放轮播图
    var timer = setInterval(function() {
        //手动调用点击事件
        arrow_r.click();
    }, 2000);

})
</code></pre>
<h3 id="节流阀">节流阀</h3>
<p>防止轮播图按钮连续点击造成播放过快。</p>
<p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p>
<p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p>
<p>开始设置一个变量var flag= true;</p>
<p>If(flag){flag = false; do something}       关闭水龙头</p>
<p>利用回调函数动画执行完毕， flag = true     打开水龙头</p>
<h3 id="返回顶部">返回顶部</h3>
<ol>
<li>带有动画的返回顶部</li>
<li>此时可以继续使用我们封装的动画函数</li>
<li>只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了</li>
<li>页面滚动了多少，可以通过 window.pageYOffset 得到</li>
<li>最后是页面滚动，使用 window.scroll(x,y)</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
                // console.log(11);
                // window.pageYOffset 页面被卷去的头部
                // console.log(window.pageYOffset);
                // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
                if (window.pageYOffset &gt;= bannerTop) {
                    sliderbar.style.position = 'fixed';
                    sliderbar.style.top = sliderbarTop + 'px';
                } else {
                    sliderbar.style.position = 'absolute';
                    sliderbar.style.top = '300px';
                }
                // 4. 当我们页面滚动到main盒子，就显示 goback模块
                if (window.pageYOffset &gt;= mainTop) {
                    goBack.style.display = 'block';
                } else {
                    goBack.style.display = 'none';
                }

            })
            // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方
        goBack.addEventListener('click', function() {
            // 里面的x和y 不跟单位的 直接写数字即可
            // window.scroll(0, 0);
            // 因为是窗口滚动 所以对象是window
            animate(window, 0);
        });

</code></pre>
<h3 id="筋头云案例">筋头云案例</h3>
<ol>
<li>利用动画函数做动画效果</li>
<li>原先筋斗云的起始位置是0</li>
<li>鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可</li>
<li>鼠标离开某个小li，就把目标值设为 0</li>
<li>如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置</li>
</ol>
<pre><code class="language-javascript"> window.addEventListener('load', function() {
            // 1. 获取元素
            var cloud = document.querySelector('.cloud');
            var c_nav = document.querySelector('.c-nav');
            var lis = c_nav.querySelectorAll('li');
            // 2. 给所有的小li绑定事件 
            // 这个current 做为筋斗云的起始位置
            var current = 0;
            for (var i = 0; i &lt; lis.length; i++) {
                // (1) 鼠标经过把当前小li 的位置做为目标值
                lis[i].addEventListener('mouseenter', function() {
                    animate(cloud, this.offsetLeft);
                });
                // (2) 鼠标离开就回到起始的位置 
                lis[i].addEventListener('mouseleave', function() {
                    animate(cloud, current);
                });
                // (3) 当我们鼠标点击，就把当前位置做为目标值
                lis[i].addEventListener('click', function() {
                    current = this.offsetLeft;
                });
            }
        })

</code></pre>
<h2 id="触屏事件">触屏事件</h2>
<h3 id="触屏事件概述">触屏事件概述</h3>
<p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。</p>
<p>touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p>
<p>常见的触屏事件如下：</p>
<figure data-type="image" tabindex="26"><img src="E:%5CAPTX-4869%5Cmd%5Ctouch1.png" alt="图片1" loading="lazy"></figure>
<h3 id="触摸事件对象touchevent">触摸事件对象（TouchEvent）</h3>
<p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p>
<p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p>
<p>![图片2](E:/BaiduNetdiskDownload/web/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/图片2.png)</p>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="移动端拖动元素">移动端拖动元素</h3>
<ol>
<li>touchstart、touchmove、touchend 可以实现拖动元素</li>
<li>但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY</li>
<li>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li>
<li>手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</li>
</ol>
<p>拖动元素三步曲：</p>
<p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p>
<p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p>
<p>（3） 离开手指 touchend:</p>
<blockquote>
<p><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></p>
</blockquote>
<h2 id="移动端常见特效">移动端常见特效</h2>
<h3 id="案例-移动轮播图">案例: 移动轮播图</h3>
<p><code>移动端轮播图功能和基本PC端一致。</code></p>
<ol>
<li>可以自动播放图片</li>
<li>手指可以拖动播放轮播图</li>
</ol>
<h3 id="案例分析">案例分析:</h3>
<ol>
<li>
<p>自动播放功能</p>
</li>
<li>
<p>开启定时器</p>
</li>
<li>
<p>移动端移动，可以使用translate 移动</p>
</li>
<li>
<p>想要图片优雅的移动，请添加过渡效果</p>
<pre><code class="language-js"> // 1. 获取元素 
    var focus = document.querySelector('.focus');
    var ul = focus.children[0];
    // 获得focus 的宽度
    var w = focus.offsetWidth;
    var ol = focus.children[1];
    // 2. 利用定时器自动轮播图图片
    var index = 0;
    var timer = setInterval(function() {
        index++;
        var translatex = -index * w;
        ul.style.transition = 'all .3s';
        ul.style.transform = 'translateX(' + translatex + 'px)';
    }, 2000);
</code></pre>
</li>
<li>
<p>自动播放功能-无缝滚动</p>
</li>
<li>
<p>注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断</p>
</li>
<li>
<p>此时需要添加检测过渡完成事件  transitionend</p>
</li>
<li>
<p>判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
</li>
<li>
<p>如果索引号小于0， 说明是倒着走， 索引号等于2</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
<pre><code class="language-js">// 等着我们过渡完成之后，再去判断 监听过渡完成的事件 transitionend 
    ul.addEventListener('transitionend', function() {
        // 无缝滚动
        if (index &gt;= 3) {
            index = 0;
            // console.log(index);
            // 去掉过渡效果 这样让我们的ul 快速的跳到目标位置
            ul.style.transition = 'none';
            // 利用最新的索引号乘以宽度 去滚动图片
            var translatex = -index * w;
            ul.style.transform = 'translateX(' + translatex + 'px)';
        } else if (index &lt; 0) {
            index = 2;
            ul.style.transition = 'none';
            // 利用最新的索引号乘以宽度 去滚动图片
            var translatex = -index * w;
            ul.style.transform = 'translateX(' + translatex + 'px)';
        }
</code></pre>
</li>
</ol>
<h2 id="classlist-属性">classList 属性</h2>
<p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p>
<p>该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p>
<p><strong>添加类：</strong></p>
<p>element.classList.add（’类名’）；</p>
<pre><code class="language-javascript">focus.classList.add('current');
</code></pre>
<p><strong>移除类：</strong></p>
<p>element.classList.remove（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.remove('current');
</code></pre>
<p><strong>切换类：</strong></p>
<p>element.classList.toggle（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.toggle('current');
</code></pre>
<p><code>注意:以上方法里面，所有类名都不带点</code></p>
<h3 id="案例分析-2">案例分析</h3>
<ol>
<li>
<p>小圆点跟随变化效果</p>
</li>
<li>
<p>把ol里面li带有current类名的选出来去掉类名 remove</p>
</li>
<li>
<p>让当前索引号的小li 加上 current   add</p>
</li>
<li>
<p>但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面</p>
<pre><code class="language-js">// 3. 小圆点跟随变化
        // 把ol里面li带有current类名的选出来去掉类名 remove
        ol.querySelector('.current').classList.remove('current');
        // 让当前索引号 的小li 加上 current   add
        ol.children[index].classList.add('current');
</code></pre>
</li>
<li>
<p>手指滑动轮播图</p>
</li>
<li>
<p>本质就是ul跟随手指移动，简单说就是移动端拖动元素</p>
</li>
<li>
<p>触摸元素touchstart：  获取手指初始坐标</p>
</li>
<li>
<p>移动手指touchmove：  计算手指的滑动距离，并且移动盒子</p>
</li>
<li>
<p>离开手指touchend:   根据滑动的距离分不同的情况</p>
</li>
<li>
<p>如果移动距离小于某个像素  就回弹原来位置</p>
</li>
<li>
<p>如果移动距离大于某个像素就上一张下一张滑动。</p>
</li>
<li>
<p>滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑</p>
</li>
<li>
<p>如果是左滑就播放下一张 （index++）</p>
</li>
<li>
<p>如果是右滑就播放上一张  (index--)</p>
</li>
</ol>
<pre><code class="language-js">    // 4. 手指滑动轮播图 
    // 触摸元素 touchstart： 获取手指初始坐标
    var startX = 0;
    var moveX = 0; // 后面我们会使用这个移动距离所以要定义一个全局变量
    var flag = false;
    ul.addEventListener('touchstart', function(e) {
        startX = e.targetTouches[0].pageX;
        // 手指触摸的时候就停止定时器
        clearInterval(timer);
    });
    // 移动手指 touchmove： 计算手指的滑动距离， 并且移动盒子
    ul.addEventListener('touchmove', function(e) {
        // 计算移动距离
        moveX = e.targetTouches[0].pageX - startX;
        // 移动盒子：  盒子原来的位置 + 手指移动的距离 
        var translatex = -index * w + moveX;
        // 手指拖动的时候，不需要动画效果所以要取消过渡效果
        ul.style.transition = 'none';
        ul.style.transform = 'translateX(' + translatex + 'px)';
        flag = true; // 如果用户手指移动过我们再去判断否则不做判断效果
        e.preventDefault(); // 阻止滚动屏幕的行为
    });
    // 手指离开 根据移动距离去判断是回弹还是播放上一张下一张
    ul.addEventListener('touchend', function(e) {
        if (flag) {
            // (1) 如果移动距离大于50像素我们就播放上一张或者下一张
            if (Math.abs(moveX) &gt; 50) {
                // 如果是右滑就是 播放上一张 moveX 是正值
                if (moveX &gt; 0) {
                    index--;
                } else {
                    // 如果是左滑就是 播放下一张 moveX 是负值
                    index++;
                }
                var translatex = -index * w;
                ul.style.transition = 'all .3s';
                ul.style.transform = 'translateX(' + translatex + 'px)';
            } else {
                // (2) 如果移动距离小于50像素我们就回弹
                var translatex = -index * w;
                ul.style.transition = 'all .1s';
                ul.style.transform = 'translateX(' + translatex + 'px)';
            }
        }
        // 手指离开的时候就重新开启定时器
        clearInterval(timer);
        timer = setInterval(function() {
            index++;
            var translatex = -index * w;
            ul.style.transition = 'all .3s';
            ul.style.transform = 'translateX(' + translatex + 'px)';
        }, 2000);
</code></pre>
<h3 id="案例返回顶部">案例：返回顶部</h3>
<p>当页面滚动某个地方，就显示，否则隐藏</p>
<p>点击可以返回顶部</p>
<h3 id="案例分析-3">案例分析</h3>
<ol>
<li>滚动某个地方显示</li>
<li>事件：scroll页面滚动事件</li>
<li>如果被卷去的头部（window.pageYOffset ）大于某个数值</li>
<li>点击，window.scroll(0,0) 返回顶部</li>
</ol>
<pre><code class="language-js"> var goBack = document.querySelector('.goBack');
    var nav = document.querySelector('nav');
    window.addEventListener('scroll', function() {
        if (window.pageYOffset &gt;= nav.offsetTop) {
            goBack.style.display = 'block';
        } else {
            goBack.style.display = 'none';
        }
    });
    goBack.addEventListener('click', function() {
        window.scroll(0, 0);
    })
</code></pre>
<h2 id="click-延时解决方案">click 延时解决方案</h2>
<p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。</p>
<p>解决方案：</p>
<p>​	1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。</p>
<pre><code class="language-html">  &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<p>​	2.利用touch事件自己封装这个事件解决300ms 延迟。</p>
<p>​	原理就是：</p>
<ol>
<li>当我们手指触摸屏幕，记录当前触摸时间</li>
<li>当我们手指离开屏幕， 用离开的时间减去触摸的时间</li>
<li>如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击</li>
</ol>
<p>代码如下:</p>
<pre><code class="language-javascript">//封装tap，解决click 300ms 延时
function tap (obj, callback) {
        var isMove = false;
        var startTime = 0; // 记录触摸时候的时间变量
        obj.addEventListener('touchstart', function (e) {
            startTime = Date.now(); // 记录触摸时间
        });
        obj.addEventListener('touchmove', function (e) {
            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击
        });
        obj.addEventListener('touchend', function (e) {
            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) {  // 如果手指触摸和离开时间小于150ms 算点击
                callback &amp;&amp; callback(); // 执行回调函数
            }
            isMove = false;  //  取反 重置
            startTime = 0;
        });
}
//调用  
  tap(div, function(){   // 执行代码  });

</code></pre>
<ol start="3">
<li>
<p>使用插件。fastclick 插件解决300ms 延迟。</p>
<pre><code class="language-js">  &lt;script&gt;
        if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                FastClick.attach(document.body);
            }, false);
        }
        var div = document.querySelector('div');
        div.addEventListener('click', function() {
            alert(11);
        })
    &lt;/script&gt;
</code></pre>
</li>
</ol>
<h2 id="移动端常用开发插件">移动端常用开发插件</h2>
<h3 id="什么是插件">什么是插件</h3>
<p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？</p>
<p>JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。</p>
<p>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>我们以前写的animate.js 也算一个最简单的插件</p>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
<p>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://</a><a href="https://github.com/ftlabs/fastclick">github.com/ftlabs/fastclick</a></p>
<h3 id="插件的使用">插件的使用</h3>
<ol>
<li>
<p>引入 js 插件文件。</p>
</li>
<li>
<p>按照规定语法使用。</p>
</li>
<li>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
</li>
<li>
<p>GitHub官网地址： https://github.com/ftlabs/fastclick</p>
<pre><code class="language-javascript">if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                       FastClick.attach(document.body);
            }, false);
}
</code></pre>
</li>
</ol>
<h3 id="swiper-插件的使用">Swiper 插件的使用</h3>
<p>中文官网地址： https://www.swiper.com.cn/</p>
<ol>
<li>引入插件相关文件。</li>
<li>按照规定语法使用</li>
</ol>
<h3 id="其他移动端常见插件">其他移动端常见插件</h3>
<p>lsuperslide： http://www.superslide2.com/</p>
<p>l iscroll： https://github.com/cubiq/iscroll</p>
<h3 id="插件的使用总结">插件的使用总结</h3>
<p>1.确认插件实现的功能</p>
<p>2.去官网查看使用说明</p>
<p>3.下载插件</p>
<p>4.打开demo实例文件，查看需要引入的相关文件，并且引入</p>
<p>5.复制demo实例文件中的结构html，样式css以及js代码</p>
<h3 id="移动端视频插件-zymediajs">移动端视频插件 zy.media.js</h3>
<p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。</p>
<p>不同的视频格式文件，我们可以通过source解决。</p>
<p>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。</p>
<p>这个时候我们可以使用插件方式来制作。</p>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<h2 id="移动端常用开发框架">移动端常用开发框架</h2>
<h3 id="移动端视频插件-zymediajs-2">移动端视频插件 zy.media.js</h3>
<p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p>
<p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端</p>
<p>前端常用的移动端插件有 swiper、superslide、iscroll等。</p>
<p>框架： 大而全，一整套解决方案</p>
<p>插件： 小而专一，某个功能的解决方案</p>
<h3 id="bootstrap">Bootstrap</h3>
<p>Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。</p>
<p>它能开发PC端，也能开发移动端</p>
<p>Bootstrap JS插件使用步骤：</p>
<p>1.引入相关js 文件</p>
<p>2.复制HTML 结构</p>
<p>3.修改对应样式</p>
<p>4.修改相应JS 参数</p>
<h2 id="本地存储">本地存储</h2>
<p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p>
<h3 id="本地存储特性">本地存储特性</h3>
<p>1、数据存储在用户浏览器中</p>
<p>2、设置、读取方便、甚至页面刷新不丢失数据</p>
<p>3、容量较大，sessionStorage约5M、localStorage约20M</p>
<p>4、只能存储字符串，可以将对象JSON.stringify() 编码后存储</p>
<h3 id="windowsessionstorage">window.sessionStorage</h3>
<p>1、生命周期为关闭浏览器窗口</p>
<p>2、在同一个窗口(页面)下数据可以共享</p>
<p>3、以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">sessionStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">sessionStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">sessionStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">sessionStorage.clear()
</code></pre>
<h3 id="windowlocalstorage">window.localStorage</h3>
<p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3.  以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">localStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">localStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">localStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">localStorage.clear()
</code></pre>
<h3 id="记住用户名">记住用户名</h3>
<p>如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名</p>
<h4 id="案例分析-4">案例分析</h4>
<ol>
<li>
<p>把数据存起来，用到本地存储</p>
</li>
<li>
<p>关闭页面，也可以显示用户名，所以用到localStorage</p>
</li>
<li>
<p>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</p>
</li>
<li>
<p>当复选框发生改变的时候change事件</p>
</li>
<li>
<p>如果勾选，就存储，否则就移除</p>
</li>
</ol>
<pre><code class="language-js">&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;remember&quot;&gt; 记住用户名
    &lt;script&gt;
        var username = document.querySelector('#username');
        var remember = document.querySelector('#remember');
        if (localStorage.getItem('username')) {
            username.value = localStorage.getItem('username');
            remember.checked = true;
        }
        remember.addEventListener('change', function() {
            if (this.checked) {
                localStorage.setItem('username', username.value)
            } else {
                localStorage.removeItem('username');
            }
        })
    &lt;/script&gt;
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmweijh.github.io/post/js-ji-chu/" class="post-title gt-a-link">
                    JS基础
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">努力成就自我</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmweijh.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

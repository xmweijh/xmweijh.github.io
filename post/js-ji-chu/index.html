<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>JS基础 | 小虾米的记录</title>

<link rel="shortcut icon" href="https://xmweijh.github.io//favicon.ico?v=1614068817563">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmweijh.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            小虾米的记录
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1614068817563"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    JS基础
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-02-17 ·
                    </time>
                    
                        <a href="https://xmweijh.github.io/tag/vXmkk1Jyb/" class="post-tags">
                            # web
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="javascript基础">JavaScript基础</h1>
<h3 id="js-的组成">JS 的组成</h3>
<ol>
<li>
<h4 id="ecmascript"><strong>ECMAScript</strong></h4>
<p>ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>
<p>​		ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
<p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p>
</li>
<li>
<h4 id="dom文档对象模型"><strong>DOM——文档对象模型</strong></h4>
<p><strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p>
</li>
<li>
<h4 id="bom浏览器对象模型"><strong>BOM——浏览器对象模型</strong></h4>
<p><strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>
</li>
</ol>
<h3 id="js-书写位置">JS 书写位置</h3>
<pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。
</code></pre>
<ol>
<li>
<p>行内式</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert('Hello World')&quot; /&gt;
</code></pre>
<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>
<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
</li>
<li>
<p>内嵌式</p>
<pre><code class="language-html">&lt;script&gt;
    alert('Hello  World~!');
&lt;/script&gt;
</code></pre>
<ul>
<li>可以将多行JS代码写到 script 标签中</li>
<li>内嵌 JS 是学习时常用的方式</li>
</ul>
</li>
<li>
<p>外部JS文件</p>
<pre><code class="language-html">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
</li>
</ol>
<h3 id="javascript注释">JavaScript注释</h3>
<ul>
<li>flex子项目占的份数</li>
<li>align-self控制子项自己在侧轴的排列方式</li>
<li>order属性定义子项的排列顺序（前后顺序）</li>
</ul>
<h4 id="单行注释">单行注释</h4>
<pre><code>为了提高代码的可读性，JS与CSS一样，也提供了注释功能。
JS中的注释主要有两种，分别是 单行注释 和 多行注释。
</code></pre>
<p>单行注释的注释方式如下：</p>
<pre><code class="language-html">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来	
</code></pre>
<pre><code>// 用来注释单行文字（  快捷键   ctrl  +  /   ）
</code></pre>
<h4 id="多行注释">多行注释</h4>
<p>多行注释的注释方式如下：</p>
<pre><code class="language-html">/*
  获取用户年龄和姓名
  并通过提示框显示出来
*/
</code></pre>
<pre><code>/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） 
</code></pre>
<p>快捷键修改为：   ctrl + shift  +  /</p>
<p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p>
<h3 id="javascript输入输出语句">JavaScript输入输出语句</h3>
<p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li>
</ul>
<h3 id="变量的概念">变量的概念</h3>
<p>白话：变量就是一个装东西的盒子。</p>
<p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。</p>
<p>变量在内存中的存储</p>
<pre><code>	本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。  
</code></pre>
<h3 id="变量的使用">变量的使用</h3>
<ul>
<li>变量的声明</li>
<li>变量的赋值</li>
</ul>
<h4 id="声明变量">声明变量</h4>
<pre><code class="language-javascript">//  声明变量  
var age; //  声明一个 名称为age 的变量     
</code></pre>
<ul>
<li>
<p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p>
</li>
<li>
<p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p>
</li>
</ul>
<h4 id="赋值">赋值</h4>
<pre><code class="language-javascript">age = 10; // 给 age  这个变量赋值为 10          
</code></pre>
<ul>
<li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<h4 id="变量的初始化">变量的初始化</h4>
<pre><code class="language-js">var age  = 18;  // 声明变量同时赋值为 18
// 声明一个变量并赋值， 我们称之为变量的初始化。
</code></pre>
<h4 id="变量语法扩展">变量语法扩展</h4>
<ul>
<li>
<p>更新变量</p>
<p>​		一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<pre><code class="language-js">var age = 18;

age = 81;   // 最后的结果就是81因为18 被覆盖掉了          
</code></pre>
</li>
<li>
<p>同时声明多个变量</p>
<p>​		同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。</p>
<pre><code class="language-js">var age = 10,  name = 'zs', sex = 2;       
</code></pre>
</li>
<li>
<p>声明变量特殊情况</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>var  age ; console.log (age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值  直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age   = 10; console.log (age);</td>
<td>不声明   只赋值</td>
<td>10</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="变量命名规范">变量命名规范</h4>
<p>规则：</p>
<ul>
<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li>
<li>严格区分大小写。var app; 和 var App; 是两个变量</li>
<li>不能 以数字开头。  18age   是错误的</li>
<li>不能 是关键字、保留字。例如：var、for、while</li>
<li>变量名必须有意义。 MMD   BBD        nl   →     age</li>
<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>
<p>变量的数据类型</p>
<p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定：</p>
<pre><code class="language-js">var age = 10;        // 这是一个数字型
var areYouOk = '是的';   // 这是一个字符串     
</code></pre>
<p>​		在<strong>代码运行</strong>时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着<strong>相同的变量可用作不同的类型</strong>：</p>
<pre><code class="language-js">var x = 6;           // x 为数字
var x = &quot;Bill&quot;;      // x 为字符串    
</code></pre>
</li>
<li>
<p>数据类型的分类</p>
<p>JS 把数据类型分为两类：</p>
<ul>
<li>
<p>简单数据类型 （Number,String,Boolean,Undefined,Null）</p>
</li>
<li>
<p>复杂数据类型 （object)</p>
</li>
</ul>
</li>
</ul>
<h4 id="简单数据类型">简单数据类型</h4>
<p>简单数据类型（基本数据类型）</p>
<p>JavaScript 中的简单数据类型及其说明如下：</p>
<figure data-type="image" tabindex="1"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8716.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>数字型 Number</p>
<p>​		JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p>
<pre><code class="language-js">var age = 21;       // 整数
var Age = 21.3747;  // 小数     
</code></pre>
<ol>
<li>
<p>数字型进制</p>
<p>最常见的进制有二进制、八进制、十进制、十六进制。</p>
<pre><code class="language-js">  // 1.八进制数字序列范围：0~7
 var num1 = 07;   // 对应十进制的7
 var num2 = 019;  // 对应十进制的19
 var num3 = 08;   // 对应十进制的8
  // 2.十六进制数字序列范围：0~9以及A~F
 var num = 0xA;   
</code></pre>
<p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x</p>
</li>
<li>
<p>数字型范围</p>
<p>JavaScript中数值的最大和最小值</p>
<ul>
<li>
<p>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</p>
</li>
<li>
<p>最小值：Number.MIN_VALUE，这个值为：5e-32</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>
<p>数字型三个特殊值</p>
<ul>
<li>
<p>Infinity ，代表无穷大，大于任何数值</p>
</li>
<li>
<p>-Infinity ，代表无穷小，小于任何数值</p>
</li>
<li>
<p>NaN ，Not a number，代表一个非数值</p>
</li>
</ul>
</li>
<li>
<p>isNaN</p>
<p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p>
</li>
</ol>
<pre><code class="language-js">  var usrAge = 21;
var isOk = isNaN(userAge);
  console.log(isNum);          // false ，21 不是一个非数字
var usrName = &quot;andy&quot;;
  console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字
</code></pre>
<ul>
<li>
<p>字符串型 String</p>
<p>​		字符串型可以是引号中的任意文本，其语法为 双引号 &quot;&quot; 和 单引号''</p>
<pre><code class="language-js">var strMsg = &quot;我爱北京天安门~&quot;;  // 使用双引号表示字符串
var strMsg2 = '我爱吃猪蹄~';    // 使用单引号表示字符串
// 常见错误
var strMsg3 = 我爱大肘子;       // 报错，没使用引号，会被认为是js代码，但js没有这些语法
</code></pre>
<p>​		因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</p>
<ol>
<li>
<p>字符串引号嵌套</p>
<p>​		JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p>
<pre><code class="language-js">var strMsg = '我是&quot;高帅富&quot;程序猿';   // 可以用''包含&quot;&quot;
var strMsg2 = &quot;我是'高帅富'程序猿&quot;;  // 也可以用&quot;&quot; 包含''
//  常见错误
var badQuotes = 'What on earth?&quot;; // 报错，不能 单双引号搭配
</code></pre>
</li>
<li>
<p>字符串转义符</p>
<p>​		类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p>
<p>​		转义符都是 \ 开头的，常用的转义符及其说明如下：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符，n   是   newline   的意思</td>
</tr>
<tr>
<td>\ \</td>
<td>斜杠   \</td>
</tr>
<tr>
<td>'</td>
<td>'   单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>”双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab  缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格 ，b   是   blank  的意思</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>字符串长度</p>
<p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p>
<pre><code class="language-js">var strMsg = &quot;我是帅气多金的程序猿！&quot;;
alert(strMsg.length); // 显示 11
</code></pre>
</li>
<li>
<p>字符串拼接</p>
<ul>
<li>
<p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p>
</li>
<li>
<p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p>
<pre><code class="language-js">//1.1 字符串 &quot;相加&quot;
alert('hello' + ' ' + 'world'); // hello world
//1.2 数值字符串 &quot;相加&quot;
alert('100' + '100'); // 100100
//1.3 数值字符串 + 数值
alert('11' + 12);     // 1112 
</code></pre>
<ul>
<li><em><strong>+ 号总结口诀：数值相加 ，字符相连</strong></em></li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串拼接加强</p>
<pre><code class="language-js">console.log('pink老师' + 18);        // 只要有字符就会相连 
var age = 18;
console.log('pink老师age岁啦');      // 这样不行哦
console.log('pink老师' + age);         // pink老师18
console.log('pink老师' + age + '岁啦'); // pink老师18岁啦
</code></pre>
<ul>
<li>经常会将字符串和变量来拼接，变量可以很方便地修改里面的值</li>
<li>变量是不能添加引号的，因为加引号的变量会变成字符串</li>
<li>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</li>
</ul>
</li>
</ol>
</li>
<li>
<p>布尔型Boolean</p>
<p>​		布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p>
<p>​		布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p>
<pre><code class="language-js">console.log(true + 1);  // 2
console.log(false + 1); // 1
</code></pre>
</li>
<li>
<p>Undefined和 Null</p>
<p>​		一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</p>
<pre><code class="language-js">var variable;
console.log(variable);           // undefined
console.log('你好' + variable);  // 你好undefined
console.log(11 + variable);     // NaN
console.log(true + variable);   //  NaN
</code></pre>
<p>​		一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p>
<pre><code class="language-js">var vari = null;
console.log('你好' + vari);  // 你好null
console.log(11 + vari);     // 11
console.log(true + vari);   //  1
</code></pre>
</li>
</ul>
<h4 id="获取变量数据类型">获取变量数据类型</h4>
<ul>
<li>
<p>获取检测变量的数据类型</p>
<p>​		typeof 可用来获取检测变量的数据类型</p>
<pre><code class="language-js">var num = 18;
console.log(typeof num) // 结果 number      
</code></pre>
</li>
<li>
<p>字面量</p>
<p>​		字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。</p>
</li>
</ul>
<h4 id="数据类型转换">数据类型转换</h4>
<p>​		什么是数据类型转换？</p>
<p>​		使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</p>
<pre><code>转换为字符串类型
转换为数字型
转换为布尔型
</code></pre>
<ul>
<li>
<p>转换为字符串</p>
<figure data-type="image" tabindex="2"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8719.png" alt="" loading="lazy"></figure>
<ul>
<li>toString() 和 String()  使用方式不一样。</li>
<li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li>
</ul>
</li>
<li>
<p>转换为数字型（重点）</p>
<figure data-type="image" tabindex="3"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8720.png" alt="" loading="lazy"></figure>
<ul>
<li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li>
<li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li>
</ul>
</li>
<li>
<p>转换为布尔型</p>
<figure data-type="image" tabindex="4"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8721.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>代表空、否定的值会被转换为 false  ，如 ''、0、NaN、null、undefined</p>
</li>
<li>
<p>其余值都会被转换为 true</p>
<pre><code class="language-js">console.log(Boolean('')); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean('小白')); // true
console.log(Boolean(12)); // true
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="解释型语言和编译型语言">解释型语言和编译型语言</h3>
<pre><code>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。
</code></pre>
<ul>
<li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li>
<li>编译器是在代码执行之前进行编译，生成中间代码文件</li>
<li>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</li>
</ul>
<h4 id="执行过程">执行过程</h4>
<figure data-type="image" tabindex="5"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8723.png" alt="" loading="lazy"></figure>
<pre><code>类似于请客吃饭：

	编译语言：首先把所有菜做好，才能上桌吃饭

	解释语言：好比吃火锅，边吃边涮，同时进行
</code></pre>
<h3 id="关键字和保留字">关键字和保留字</h3>
<h4 id="标识符">标识符</h4>
<pre><code>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。

标识符不能是关键字或保留字。
</code></pre>
<h4 id="关键字">关键字</h4>
<pre><code>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。

包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。
</code></pre>
<h4 id="保留字">保留字</h4>
<pre><code>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。

注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。
</code></pre>
<h3 id="运算符操作符">运算符（操作符）</h3>
<h4 id="运算符的分类">运算符的分类</h4>
<p><strong>运算符</strong>（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p>
<pre><code>JavaScript中常用的运算符有：
</code></pre>
<ul>
<li>算数运算符</li>
<li>递增和递减运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
</ul>
<h4 id="算数运算符">算数运算符</h4>
<ul>
<li>
<p>算术运算符概述</p>
<p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。</p>
</li>
<li>
<p>浮点数的精度问题</p>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p>
<pre><code class="language-js">var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004
console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001
</code></pre>
<p>所以：不要直接判断两个浮点数是否相等 !</p>
</li>
<li>
<p>表达式和返回值</p>
<p>表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合</p>
<p>简单理解：是由数字、运算符、变量等组成的式子</p>
<p>表达式最终都会有一个结果，返回给开发者，称为返回值</p>
</li>
</ul>
<h4 id="递增和递减运算符">递增和递减运算符</h4>
<ul>
<li>
<p>递增和递减运算符概述</p>
<p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。</p>
<p>在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。</p>
<p>注意：递增和递减运算符必须和变量配合使用。</p>
</li>
<li>
<p>递增运算符</p>
<ul>
<li>
<p>前置递增运算符</p>
<p>++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。</p>
<p>使用口诀：先自加，后返回值</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(++num + 10);   // 21
</code></pre>
<ul>
<li>
<p>后置递增运算符</p>
<p>num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。</p>
<p>使用口诀：先返回原值，后自加</p>
</li>
</ul>
<pre><code class="language-js">var  num = 10;
alert(10 + num++);  // 20
</code></pre>
</li>
</ul>
<h4 id="比较运算符">比较运算符</h4>
<ul>
<li>
<p>比较运算符概述</p>
<p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。</p>
</li>
<li>
<p>等号比较</p>
<figure data-type="image" tabindex="6"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%873.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">console.log(18 == '18');
console.log(18 === '18'); 
</code></pre>
</li>
</ul>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ul>
<li>
<p>逻辑运算符概述</p>
<p>概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p>
</li>
<li>
<p>逻辑与&amp;&amp;</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑或 ||</p>
<p>两边都是 true才返回 true，否则返回 false</p>
</li>
<li>
<p>逻辑非 ！</p>
<p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p>
<pre><code class="language-js">var isOk = !true;
console.log(isOk);  // false
</code></pre>
</li>
<li>
<p>短路运算（逻辑中断）</p>
<p>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p>
<ul>
<li>
<p>逻辑与</p>
<p>语法： 表达式1 &amp;&amp; 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式2

- 如果第一个表达式的值为假，则返回表达式1
</code></pre>
<pre><code class="language-js">console.log( 123 &amp;&amp; 456 );        // 456
console.log( 0 &amp;&amp; 456 );          // 0
console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789
</code></pre>
</li>
<li>
<p>逻辑或</p>
<p>语法： 表达式1 || 表达式2</p>
<pre><code>- 如果第一个表达式的值为真，则返回表达式1

- 如果第一个表达式的值为假，则返回表达式2
</code></pre>
<pre><code class="language-js">console.log( 123 || 456 );         //  123
console.log( 0 ||  456 );          //  456
console.log( 123 || 456 || 789 );  //  123
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<pre><code>概念：用来把数据赋值给变量的运算符。
</code></pre>
<pre><code class="language-js">var age = 10;
age += 5;  // 相当于 age = age + 5;
age -= 5;  // 相当于 age = age - 5;
age *= 10; // 相当于 age = age * 10;
</code></pre>
<h4 id="运算符优先级">运算符优先级</h4>
<figure data-type="image" tabindex="7"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%8710.png" alt="" loading="lazy"></figure>
<ul>
<li>一元运算符里面的逻辑非优先级很高</li>
<li>逻辑与比逻辑或优先级高</li>
</ul>
<h3 id="流程控制">流程控制</h3>
<h4 id="流程控制概念">流程控制概念</h4>
<pre><code>在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解：**流程控制就是来控制代码按照一定结构顺序来执行**

流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。
</code></pre>
<ul>
<li>
<p>switch 语句和 if else if 语句的区别</p>
<ul>
<li>一般情况下，它们两个语句可以相互替换</li>
<li>switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)</li>
<li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。</li>
<li>当分支比较少时，if… else语句的执行效率比 switch语句高。</li>
<li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。</li>
</ul>
</li>
</ul>
<p>断点调试：</p>
<pre><code>	断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程
</code></pre>
<pre><code class="language-html">断点调试的流程：
1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点
2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。
3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
</code></pre>
<h3 id="标识符命名规范">标识符命名规范</h3>
<ul>
<li>变量、函数的命名必须要有意义</li>
<li>变量的名称一般用名词</li>
<li>函数的名称一般用动词</li>
</ul>
<h4 id="操作符规范">操作符规范</h4>
<pre><code class="language-js">// 操作符的左右两侧各保留一个空格
for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 直接退出整个 for 循环，跳到整个for循环下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="单行注释规范">单行注释规范</h4>
<pre><code class="language-js">for (var i = 1; i &lt;= 5; i++) {
   if (i == 3) {
       break; // 单行注释前面注意有个空格
   }
   console.log('我正在吃第' + i + '个包子呢');
}
</code></pre>
<h4 id="其他规范">其他规范</h4>
<pre><code>关键词、操作符之间后加空格
</code></pre>
<h3 id="创建数组">创建数组</h3>
<p>JS 中创建数组有两种方式：</p>
<ul>
<li>
<p>利用  new 创建数组</p>
<pre><code class="language-js">var 数组名 = new Array() ；
var arr = new Array();   // 创建一个新的空数组
</code></pre>
<p>注意 Array () ，A 要大写</p>
</li>
<li>
<p>利用数组字面量创建数组</p>
<pre><code class="language-js">//1. 使用数组字面量方式创建空的数组
var  数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var  数组名 = ['小白','小黑','大黄','瑞奇'];
</code></pre>
<ul>
<li>数组的字面量是方括号 [ ]</li>
<li>声明数组并赋值称为数组的初始化</li>
<li>这种字面量方式也是我们以后最多使用的方式</li>
</ul>
</li>
<li>
<p>数组元素的类型</p>
<p>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p>
<pre><code class="language-js">var arrStus = ['小白',12,true,28.9];
</code></pre>
</li>
</ul>
<h3 id="获取数组中的元素">获取数组中的元素</h3>
<p>​		索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</p>
<p>​		数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</p>
<pre><code class="language-js">// 定义数组
var arrStus = [1,2,3];
// 获取数组中的第2个元素
alert(arrStus[1]);    
</code></pre>
<p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</p>
<h3 id="遍历数组">遍历数组</h3>
<ul>
<li>
<p>数组遍历</p>
<p>​		把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</p>
</li>
</ul>
<pre><code class="language-js">var arr = ['red','green', 'blue'];
for(var i = 0; i &lt; arr.length; i++){
    console.log(arrStus[i]);
}
</code></pre>
<ul>
<li>
<p>数组的长度</p>
<p>数组的长度：默认情况下表示数组中元素的个数</p>
<p>使用“数组名.length”可以访问数组元素的数量（数组长度）。</p>
<pre><code class="language-js">var arrStus = [1,2,3];
alert(arrStus.length);  // 3
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</li>
</ul>
</li>
<li>
<p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p>
<ul>
<li>数组的length属性可以被修改：</li>
</ul>
</li>
<li>
<p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p>
<ul>
<li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li>
</ul>
</li>
</ul>
<h3 id="数组中新增元素">数组中新增元素</h3>
<p>​		数组中可以通过以下方式在数组的末尾插入新元素：</p>
<pre><code class="language-js">  数组[ 数组.length ] = 新数据;
</code></pre>
<h2 id="函数">函数</h2>
<h3 id="函数的概念">函数的概念</h3>
<p>​		在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。</p>
<p>​		函数：就是<strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以<strong>实现大量代码的重复使用</strong>。</p>
<h3 id="函数的使用">函数的使用</h3>
<h4 id="声明函数">声明函数</h4>
<pre><code class="language-js">// 声明函数
function 函数名() {
    //函数体代码
}
</code></pre>
<ul>
<li>
<p>function 是声明函数的关键字,必须小写</p>
</li>
<li>
<p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p>
</li>
</ul>
<h4 id="调用函数">调用函数</h4>
<pre><code class="language-js">// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
</code></pre>
<ul>
<li>
<p>调用的时候千万不要忘记添加小括号</p>
</li>
<li>
<p>口诀：函数不调用，自己不执行</p>
<p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p>
</li>
</ul>
<h4 id="函数的封装">函数的封装</h4>
<ul>
<li>
<p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</p>
</li>
<li>
<p>简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）</p>
<p>例子：封装计算1-100累加和</p>
<pre><code class="language-js">/* 
   计算1-100之间值的函数
*/
// 声明函数
function getSum(){
  var sumNum = 0;// 准备一个变量，保存数字和
  for (var i = 1; i &lt;= 100; i++) {
    sumNum += i;// 把每个数值 都累加 到变量中
  }
  alert(sumNum);
}
// 调用函数
getSum();
</code></pre>
</li>
</ul>
<h3 id="函数的参数">函数的参数</h3>
<h4 id="函数参数语法">函数参数语法</h4>
<ul>
<li>
<p>形参：函数定义时设置接收调用时传入</p>
</li>
<li>
<p>实参：函数调用时传入小括号内的真实数据</p>
<p>​	参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</p>
<p>函数参数的运用：</p>
<pre><code class="language-js">// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
</code></pre>
<ol>
<li>调用的时候实参值是传递给形参的</li>
<li>形参简单理解为：不用声明的变量</li>
<li>实参和形参的多个参数之间用逗号（,）分隔</li>
</ol>
</li>
</ul>
<h4 id="函数形参和实参数量不匹配时">函数形参和实参数量不匹配时</h4>
<figure data-type="image" tabindex="8"><img src="E:%5CAPTX-4869%5Cmd%5C%E5%9B%BE%E7%89%874.png" alt="" loading="lazy"></figure>
<pre><code>注意：在JavaScript中，形参的默认值是undefined。
</code></pre>
<p>小结：</p>
<ul>
<li>函数可以带参数也可以不带参数</li>
<li>声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined</li>
<li>调用函数的时候，函数名括号里面的是实参</li>
<li>多个参数中间用逗号分隔</li>
<li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li>
</ul>
<h3 id="函数的返回值">函数的返回值</h3>
<h4 id="return-语句">return 语句</h4>
<pre><code>返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。
</code></pre>
<pre><code class="language-js">// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
</code></pre>
<ul>
<li>在使用 return 语句时，函数会停止执行，并返回指定的值</li>
<li>如果函数没有 return ，返回的值是 undefined</li>
</ul>
<h4 id="break-continue-return-的区别">break ,continue ,return 的区别</h4>
<ul>
<li>break ：结束当前的循环体（如 for、while）</li>
<li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li>
<li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li>
</ul>
<h3 id="arguments的使用">arguments的使用</h3>
<p>​		当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>
<p>具有 length 属性</p>
</li>
<li>
<p>按索引方式储存数据</p>
</li>
<li>
<p>不具有数组的 push , pop 等方法</p>
<p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p>
<pre><code class="language-javascript">    &lt;script&gt;
        // 利用函数求任意个数的最大值
        function getMax() { // arguments = [1,2,3]
            var max = arguments[0];
            for (var i = 1; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) {
                    max = arguments[i];
                }
            }
            return max;
        }
        console.log(getMax(1, 2, 3));
        console.log(getMax(1, 2, 3, 4, 5));
        console.log(getMax(11, 2, 34, 444, 5, 100));
    &lt;/script&gt;
</code></pre>
</li>
</ul>
<h3 id="函数案例">函数案例</h3>
<pre><code>	函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。
</code></pre>
<h3 id="函数的两种声明方式">函数的两种声明方式</h3>
<ul>
<li>
<p>自定义函数方式(命名函数)</p>
<p>利用函数关键字 function 自定义函数方式</p>
<pre><code class="language-js">// 声明定义方式
function fn() {...}
// 调用  
fn();  
</code></pre>
<ul>
<li>因为有名字，所以也被称为命名函数</li>
<li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li>
</ul>
</li>
<li>
<p>函数表达式方式(匿名函数）</p>
<p>利用函数表达式方式的写法如下：</p>
<pre><code class="language-js">// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
</code></pre>
<ul>
<li>因为函数没有名字，所以也被称为匿名函数</li>
<li>这个fn 里面存储的是一个函数</li>
<li>函数表达式方式原理跟声明变量方式是一致的</li>
<li>函数调用的代码必须写到函数体后面</li>
</ul>
</li>
</ul>
<p>​    <strong>1. 我们js引擎运行js 分为两步： 预解析 代码执行</strong></p>
<p>​    (1). 预解析 js引擎会把js 里面所有的 var 还有 function 提升到当前作用域的最前面</p>
<p>​    (2). 代码执行 按照代码书写的顺序从上往下执行</p>
<p>​    <strong>2. 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）</strong></p>
<p>​    (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作</p>
<p>​    (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数</p>
<h3 id="创建对象的三种方式">创建对象的三种方式</h3>
<ul>
<li>
<p>利用字面量创建对象</p>
<h5 id="使用对象字面量创建对象"><strong>使用对象字面量创建对象</strong>：</h5>
<pre><code>  就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 
</code></pre>
<ul>
<li>
<p>键：相当于属性名</p>
</li>
<li>
<p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p>
<p>代码如下：</p>
<pre><code class="language-js">var star = {
    name : 'pink',
    age : 18,
    sex : '男',
    sayHi : function(){
        alert('大家好啊~');
    }
};
</code></pre>
<p>对象[‘属性名’]，注意方括号里面的属性必须加引号</p>
</li>
<li>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">console.log(star.name)     // 调用名字属性
console.log(star['name'])  // 调用名字属性
</code></pre>
</li>
</ul>
</li>
<li>
<p>调用对象的方法</p>
<ul>
<li>
<p>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号</p>
<p>示例代码如下：</p>
<pre><code class="language-js">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号
</code></pre>
</li>
</ul>
</li>
<li>
<p>变量、属性、函数、方法总结</p>
<pre><code>属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器
</code></pre>
<ul>
<li>
<p>变量：单独声明赋值，单独存在</p>
</li>
<li>
<p>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</p>
<p>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</p>
</li>
<li>
<p>函数：单独存在的，通过“函数名()”的方式就可以调用</p>
</li>
<li>
<p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用 new Object 创建对象</p>
<ul>
<li>
<p>创建空对象</p>
<pre><code class="language-js">var andy = new Obect();
</code></pre>
<p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p>
</li>
<li>
<p>给空对象添加属性和方法</p>
<ul>
<li>
<p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p>
<p>示例代码如下：</p>
</li>
</ul>
<pre><code class="language-js">andy.name = 'pink';
andy.age = 18;
andy.sex = '男';
andy.sayHi = function(){
    alert('大家好啊~');
}
</code></pre>
<p>注意：</p>
<ul>
<li>Object() ：第一个字母大写</li>
<li>new Object() ：需要 new 关键字</li>
<li>使用的格式：对象.属性 =  值;</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用构造函数创建对象</p>
<ul>
<li>
<p>构造函数</p>
<ul>
<li>
<p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
</li>
<li>
<p>构造函数的封装格式：</p>
<pre><code class="language-js">function 构造函数名(形参1,形参2,形参3) {
     this.属性名1 = 参数1;
     this.属性名2 = 参数2;
     this.属性名3 = 参数3;
     this.方法名 = 函数体;
}
</code></pre>
</li>
<li>
<p>构造函数的调用格式</p>
<pre><code>var obj = new 构造函数名(实参1，实参2，实参3)
</code></pre>
<p>以上代码中，obj即接收到构造函数创建出来的对象。</p>
</li>
<li>
<p>注意事项</p>
<ol>
<li>构造函数约定<strong>首字母大写</strong>。</li>
<li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li>
<li>构造函数中<strong>不需要 return 返回结果</strong>。</li>
<li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li>
</ol>
</li>
<li>
<p>其他</p>
<p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>
创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>new关键字的作用</p>
<ol>
<li>在构造函数代码开始执行之前，创建一个空对象；</li>
<li>修改this的指向，把this指向创建出来的空对象；</li>
<li>执行函数的代码</li>
<li>在函数完成之后，返回this---即创建出来的对象</li>
</ol>
<h3 id="遍历对象">遍历对象</h3>
<p>for...in 语句用于对数组或者对象的属性进行循环操作。</p>
<p>其语法如下：</p>
<pre><code class="language-js">for (变量 in 对象名字) {
    // 在此执行代码
}
</code></pre>
<p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p>
<pre><code class="language-js">for (var k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
</code></pre>
</li>
</ul>
<h3 id="预解析的相关概念">预解析的相关概念</h3>
<pre><code>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。
</code></pre>
<ul>
<li>
<p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中<strong>进行提前声明或者定义。</strong></p>
</li>
<li>
<p>代码执行： 从上到下执行JS语句。</p>
<p><strong>预解析会把变量和函数的声明在代码执行之前执行完成。</strong></p>
</li>
</ul>
<p>变量预解析</p>
<pre><code>预解析也叫做变量、函数提升。
变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。
</code></pre>
<pre><code class="language-js">console.log(num);  // 结果是多少？
var num = 10;      // ？
</code></pre>
<pre><code>结果：undefined

注意：**变量提升只提升声明，不提升赋值**
</code></pre>
<p>函数预解析</p>
<pre><code>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。
</code></pre>
<pre><code class="language-js">fn();
function fn() {
    console.log('打印');
}
</code></pre>
<pre><code>结果：控制台打印字符串 --- ”打印“ 

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	
</code></pre>
<p>函数表达式声明函数问题</p>
<pre><code>函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：
</code></pre>
<pre><code class="language-js">fn();
var  fn = function() {
    console.log('想不到吧');
}
</code></pre>
<pre><code>结果：报错提示 ”fn is not a function&quot;

解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
</code></pre>
<pre><code class="language-javascript">//函数的预解析
		var num=1;
		function demo(){
			console.log(num);
			function demoSon(){
				num=3;
			}
			var num=2;
			demoSon();
		}
		demo();

//相当于
var num;//作用域在全局
		function demo();
		num=1;
		function demo(){
			var num;
			function demoSon();
			console.log(num);
			function demoSon(){
				num=3;
			}
			num=2;//num在函数作用域
			demoSon();
		}
		demo();
//var num = 2，声明会提前，但不会赋值 num会变为undefined 所以不会输出1 
</code></pre>
<p>JavaScript 中的对象分为3种：<strong>自定义对象 、内置对象、 浏览器对象</strong><br>
​		前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是<strong>最基本而必要的功能</strong>（属性和方法），内置对象最大的优点就是帮助我们快速开发</p>
<p>​	 	JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</p>
<h3 id="math对象">Math对象</h3>
<p>​		Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p>
<table>
<thead>
<tr>
<th>属性、方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.round()</td>
<td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td>
</tr>
<tr>
<td>Math.abs()</td>
<td>绝对值</td>
</tr>
<tr>
<td>Math.max()/Math.min()</td>
<td>求最大和最小值</td>
</tr>
<tr>
<td>Math.random()</td>
<td>获取范围在[0,1)内的随机值</td>
</tr>
</tbody>
</table>
<p>​	注意：上面的方法使用时必须带括号</p>
<pre><code class="language-js">console.log(Math.round(1.5)); // 2
console.log(Math.round(-1.5)); // 这个结果是 -1
</code></pre>
<p>​	<strong>获取指定范围内的随机整数</strong>：</p>
<pre><code class="language-javascript"> function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min; 
}
</code></pre>
<h3 id="日期对象">日期对象</h3>
<p>​	 	Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p>
<ul>
<li>
<p>使用Date实例化日期对象</p>
<ul>
<li>获取当前时间必须实例化：</li>
</ul>
<pre><code class="language-js">var now = new Date();
</code></pre>
<ul>
<li>获取指定时间的日期对象</li>
</ul>
<pre><code class="language-js">var future = new Date('2010/5/1');
</code></pre>
<p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p>
</li>
<li>
<p>使用Date实例的方法和属性</p>
<figure data-type="image" tabindex="9"><img src="E:%5CAPTX-4869%5Cmd%5Ctime1.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>通过Date实例获取总毫米数</p>
<ul>
<li>
<p>总毫秒数的含义</p>
<p>​	基于1970年1月1日（世界标准时间）起的毫秒数</p>
</li>
<li>
<p>获取总毫秒数</p>
<pre><code class="language-js">// 实例化Date对象
var now = new Date();
// 1. 用于获取对象的原始值
console.log(date.valueOf())	
console.log(date.getTime())	
// 2. 简单写可以这么做
var now = + new Date();			
// 3. HTML5中提供的方法，有兼容性问题
var now = Date.now();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="数组对象">数组对象</h3>
<h4 id="创建数组的两种方式">创建数组的两种方式</h4>
<ul>
<li>
<p>字面量方式</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code class="language-js">var arr = [1,&quot;test&quot;,true];
</code></pre>
</li>
</ul>
</li>
<li>
<p>new Array()</p>
<ul>
<li>
<p>示例代码如下：</p>
<pre><code>var arr = new Array();
</code></pre>
<p>​	注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p>
<p>​	参数传递规则如下：</p>
<ul>
<li>
<p>如果只传入一个参数，则参数规定了数组的长度</p>
</li>
<li>
<p>如果传入了多个参数，则参数称为数组的元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="检测是否为数组">检测是否为数组</h4>
<ul>
<li>
<p>instanceof 运算符</p>
<ul>
<li>
<p>instanceof 可以判断一个对象是否是某个构造函数的实例</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
</code></pre>
</li>
</ul>
</li>
<li>
<p>Array.isArray()</p>
<ul>
<li>
<p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p>
<pre><code class="language-js">var arr = [1, 23];
var obj = {};
console.log(Array.isArray(arr));   // true
console.log(Array.isArray(obj));   // false
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="添加删除数组元素的方法">添加删除数组元素的方法</h4>
<ul>
<li>
<p>数组中有进行增加、删除元素的方法，部分方法如下表</p>
<figure data-type="image" tabindex="10"><img src="E:%5CAPTX-4869%5Cmd%5Cp%E5%9B%BE%E7%89%872.png" alt="" loading="lazy"></figure>
<p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p>
</li>
</ul>
<h4 id="数组排序">数组排序</h4>
<ul>
<li>
<p>数组中有对数组本身排序的方法，部分方法如下表</p>
<figure data-type="image" tabindex="11"><img src="E:%5CAPTX-4869%5Cmd%5Carray3.png" alt="" loading="lazy"></figure>
<p>注意：sort方法需要传入参数来设置升序、降序排序</p>
<ul>
<li>如果传入“function(a,b){ return a-b;}”，则为升序</li>
<li>如果传入“function(a,b){ return b-a;}”，则为降序</li>
</ul>
</li>
</ul>
<h4 id="数组索引方法">数组索引方法</h4>
<ul>
<li>
<p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p>
<figure data-type="image" tabindex="12"><img src="E:%5CAPTX-4869%5Cmd%5Carray4.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h4 id="数组转换为字符串">数组转换为字符串</h4>
<ul>
<li>
<p>数组中有把数组转化为字符串的方法，部分方法如下表</p>
<figure data-type="image" tabindex="13"><img src="E:%5CAPTX-4869%5Cmd%5Carray5.png" alt="" loading="lazy"></figure>
<p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p>
</li>
</ul>
<h4 id="其他方法">其他方法</h4>
<figure data-type="image" tabindex="14"><img src="E:%5CAPTX-4869%5Cmd%5Carray6.png" alt="" loading="lazy"></figure>
<h3 id="字符串对象">字符串对象</h3>
<h4 id="基本包装类型">基本包装类型</h4>
<p>​		为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p>
<p>​		基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<pre><code class="language-js">// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
</code></pre>
<p>​		按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为</p>
<p>​		js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p>
<pre><code class="language-js">// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
</code></pre>
<h4 id="字符串的不可变">字符串的不可变</h4>
<p>​		指的是里面的值不可变，虽然看上去可以改变内容，但其实是<strong>地址变了</strong>，内存中新开辟了一个内存空间。</p>
<p>​		当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>
​		由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</p>
<h4 id="根据字符返回位置">根据字符返回位置</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p>
<figure data-type="image" tabindex="15"><img src="E:%5CAPTX-4869%5Cmd%5Carray7.png" alt="" loading="lazy"></figure>
<p>​		案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数</p>
<ol>
<li>先查找第一个o出现的位置</li>
<li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li>
<li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</li>
</ol>
<h4 id="根据位置返回字符">根据位置返回字符</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p>
<figure data-type="image" tabindex="16"><img src="E:%5CAPTX-4869%5Cmd%5Carray8.png" alt="" loading="lazy"></figure>
<p>​		在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码</p>
<p>​		案例：判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数</p>
<ol>
<li>
<p>核心算法：利用 charAt(） 遍历这个字符串</p>
</li>
<li>
<p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p>
</li>
<li>
<p>遍历对象，得到最大值和该字符</p>
<p>​	注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数</p>
</li>
</ol>
<h4 id="字符串操作方法">字符串操作方法</h4>
<p>​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</p>
<figure data-type="image" tabindex="17"><img src="E:%5CAPTX-4869%5Cmd%5Cstring10.png" alt="" loading="lazy"></figure>
<h4 id="replace方法">replace()方法</h4>
<p>​		replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</p>
<pre><code>字符串.replace(被替换的字符串， 要替换为的字符串)；
</code></pre>
<h4 id="split方法">split()方法</h4>
<p>​		split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<p>​		其使用格式如下：</p>
<pre><code>字符串.split(&quot;分割字符&quot;)
</code></pre>
<h2 id="简单数据类型和复杂数据类型">简单数据类型和复杂数据类型</h2>
<h3 id="简单数据类型-2">简单数据类型</h3>
<p>​		<strong>简单类型</strong>（<strong>基本数据类型</strong>、<strong>值类型</strong>）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</p>
<h3 id="复杂数据类型">复杂数据类型</h3>
<p>​		<strong>复杂数据类型（引用类型）</strong>：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</p>
<h3 id="堆栈">堆栈</h3>
<ul>
<li>堆栈空间分配区别：</li>
</ul>
<p>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>简单数据类型存放到栈里面</p>
<p>2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
<ul>
<li>
<p>简单数据类型的存储方式</p>
<p>​		值类型变量的数据直接存放在变量（栈空间）中</p>
</li>
<li>
<p>复杂数据类型的存储方式</p>
<p>​		引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</p>
</li>
</ul>
<h3 id="简单类型传参">简单类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<h3 id="复杂数据类型传参">复杂数据类型传参</h3>
<p>​		函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmweijh.github.io/post/stl/" class="post-title gt-a-link">
                    STL
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">努力成就自我</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmweijh.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

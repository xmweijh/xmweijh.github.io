<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Pyhton的一些 | 小虾米的记录</title>

<link rel="shortcut icon" href="https://xmweijh.github.io//favicon.ico?v=1626350788642">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmweijh.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            小虾米的记录
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1626350788642"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Pyhton的一些
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-07-15 ·
                    </time>
                    
                        <a href="https://xmweijh.github.io/tag/xHTgICqZ2/" class="post-tags">
                            # Python
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="多任务的介绍">多任务的介绍</h2>
<p>多任务是指在<strong>同一时间内</strong>执行<strong>多个任务</strong>，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。</p>
<h3 id="多任务的执行方式">多任务的执行方式</h3>
<ul>
<li>并发</li>
<li>并行</li>
</ul>
<p><strong>并发:</strong></p>
<p>在一段时间内<strong>交替</strong>去执行任务。</p>
<p>单核cpu是并发的执行多任务的。</p>
<p><strong>并行:</strong></p>
<p>对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，<strong>多个内核是真正的一起执行软件</strong>。这里需要注意<strong>多核cpu是并行的执行多任务，始终有多个软件一起执行</strong>。</p>
<h3 id="进程的介绍">进程的介绍</h3>
<p>在Python程序中，想要实现多任务可以使用进程来完成，进程是实现多任务的一种方式。</p>
<h3 id="进程的概念">进程的概念</h3>
<p>一个正在运行的程序或者软件就是一个进程，<strong>它是操作系统进行资源分配的基本单位</strong>，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p>
<p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程</strong>，进程里面可以创建多个线程，<strong>线程是依附在进程里面的，没有进程就没有线程</strong>。</p>
<h3 id="多进程的使用">多进程的使用</h3>
<h4 id="导入进程包">导入进程包</h4>
<pre><code class="language-py">#导入进程包
import multiprocessing
</code></pre>
<h3 id="process进程类的说明">Process进程类的说明</h3>
<p><strong>Process([group [, target [, name [, args [, kwargs]]]]])</strong></p>
<ul>
<li>group：指定进程组，目前只能使用None</li>
<li>target：执行的目标任务名</li>
<li>name：进程名字</li>
<li>args：以元组方式给执行任务传参</li>
<li>kwargs：以字典方式给执行任务传参</li>
</ul>
<p><strong>Process创建的实例对象的常用方法:</strong></p>
<ul>
<li>start()：启动子进程实例（创建子进程）</li>
<li>join()：等待子进程执行结束</li>
<li>terminate()：不管任务是否完成，立即终止子进程</li>
</ul>
<p><strong>Process创建的实例对象的常用属性:</strong></p>
<p>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</p>
<ol>
<li>导入进程包
<ul>
<li>import multiprocessing</li>
</ul>
</li>
<li>创建子进程并指定执行的任务
<ul>
<li>sub_process = multiprocessing.Process (target=任务名)</li>
</ul>
</li>
<li>启动进程执行任务
<ul>
<li>sub_process.start()</li>
</ul>
</li>
</ol>
<h3 id="获取进程编号">获取进程编号</h3>
<p><strong>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由哪个主进程创建出来的。</strong></p>
<p>获取进程编号的两种操作</p>
<ul>
<li>获取当前进程编号</li>
</ul>
<p><strong>os.getpid()</strong> 表示获取当前进程编号</p>
<ul>
<li>获取当前父进程编号</li>
</ul>
<p><strong>os.getppid()</strong> 表示获取当前父进程编号</p>
<p><strong>进程执行带有参数的任务</strong></p>
<ul>
<li><strong>元组方式传参(args)</strong>: 元组方式传参一定要和参数的顺序保持一致。</li>
<li><strong>字典方式传参(kwargs)</strong>: 字典方式传参字典中的key一定要和参数名保持一致。</li>
</ul>
<pre><code class="language-python">  sub_process = multiprocessing.Process(target=task, args=(5,))
  sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})

</code></pre>
<h3 id="进程的注意点">进程的注意点</h3>
<ol>
<li>进程之间不共享全局变量</li>
<li>主进程会等待所有的子进程执行结束再结束</li>
</ol>
<figure data-type="image" tabindex="1"><img src="Python%E8%BF%9B%E9%98%B6.assets/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="进程关系" loading="lazy"></figure>
<ul>
<li>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</li>
</ul>
<p><strong>主进程会等待所有的子进程执行结束再结束</strong></p>
<ul>
<li>
<p>我们可以设置<strong>守护主进程</strong> 或者 在主进程退出之前 <strong>让子进程销毁</strong></p>
</li>
<li>
<p>设置守护主进程方式： <strong>子进程对象.daemon = True</strong></p>
</li>
<li>
<p><strong>守护主进程:</strong></p>
<ul>
<li>守护主进程就是主进程退出子进程销毁不再执行</li>
</ul>
<p><strong>子进程销毁:</strong></p>
<ul>
<li>子进程执行结束</li>
</ul>
</li>
<li>
<p>销毁子进程方式： <strong>子进程对象.terminate()</strong></p>
</li>
</ul>
<h3 id="线程">线程</h3>
<p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是<strong>cpu调度的基本单位</strong>，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p>
<ol>
<li>
<p><strong>导入线程模块</strong></p>
<ul>
<li><strong>import threading</strong></li>
</ul>
<p>Thread([group [, target [, name [, args [, kwargs]]]]])</p>
<ul>
<li>group: 线程组，目前只能使用None</li>
<li>target: 执行的目标任务名</li>
<li>args: 以元组的方式给执行任务传参</li>
<li>kwargs: 以字典方式给执行任务传参</li>
<li>name: 线程名，一般不用设置</li>
</ul>
</li>
<li>
<p><strong>创建子线程并指定执行的任务</strong></p>
<ul>
<li><strong>sub_thread = threading.Thread(target=任务名)</strong></li>
</ul>
</li>
<li>
<p><strong>启动线程执行任务</strong></p>
<ul>
<li><strong>sub_thread.start()</strong></li>
</ul>
</li>
</ol>
<p><strong>线程执行带有参数的任务的介绍</strong></p>
<p>Thread类执行任务并给任务传参数有两种方式:</p>
<ul>
<li>args 表示以元组的方式给执行任务传参</li>
<li>kwargs 表示以字典方式给执行任务传参</li>
</ul>
<p>与进程相同</p>
<h3 id="线程的注意点">线程的注意点</h3>
<ol>
<li>线程之间执行是无序的</li>
<li>主线程会等待所有的子线程执行结束再结束</li>
</ol>
<blockquote>
<p><strong>守护主线程:</strong></p>
<ul>
<li>守护主线程就是主线程退出子线程销毁不再执行</li>
</ul>
<p><strong>设置守护主线程有两种方式：</strong></p>
<ol>
<li>threading.Thread(target=show_info, daemon=True)</li>
<li>线程对象.setDaemon(True)</li>
</ol>
</blockquote>
<ol>
<li><strong>线程之间共享全局变量</strong></li>
<li>线程之间共享全局变量数据出现错误问题</li>
</ol>
<blockquote>
<p>线程同步的方式:</p>
<ol>
<li><strong>线程等待(join)</strong></li>
<li><strong>互斥锁</strong></li>
</ol>
</blockquote>
<h3 id="互斥锁">互斥锁</h3>
<p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p>
<p>threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。</p>
<pre><code class="language-py"># 创建锁
mutex = threading.Lock()

# 上锁
mutex.acquire()

...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...

# 释放锁
mutex.release()
</code></pre>
<ul>
<li><strong>acquire和release方法之间的代码同一时刻只能有一个线程去操作</strong></li>
<li><strong>如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。</strong></li>
</ul>
<p>死锁: 一直等待对方释放锁的情景就是死锁</p>
<ul>
<li>使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。</li>
<li>死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。</li>
</ul>
<h3 id="进程和线程的对比">进程和线程的对比</h3>
<ol>
<li>
<p>线程是依附在进程里面的，没有进程就没有线程。</p>
</li>
<li>
<p>一个进程默认提供一条线程，进程可以创建多个线程。</p>
</li>
<li>
<p>进程之间不共享全局变量</p>
</li>
<li>
<p>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</p>
</li>
<li>
<p>创建进程的资源开销要比创建线程的资源开销要大</p>
</li>
<li>
<p>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</p>
</li>
<li>
<p>线程不能够独立执行，必须依存在进程中</p>
</li>
<li>
<p>多进程开发比单进程多线程开发稳定性要强</p>
</li>
</ol>
<ul>
<li>进程优缺点:
<ul>
<li>优点：可以用多核</li>
<li>缺点：资源开销大</li>
</ul>
</li>
<li>线程优缺点:
<ul>
<li>优点：资源开销小</li>
<li>缺点：不能使用多核</li>
</ul>
</li>
</ul>
<h2 id="tcp-网络应用程序开发流程">TCP 网络应用程序开发流程</h2>
<figure data-type="image" tabindex="2"><img src="Python%E8%BF%9B%E9%98%B6.assets/tcp%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="TCP客户端程序开发流程" loading="lazy"></figure>
<p>导入 socket 模块 <strong>import socket</strong></p>
<p>创建客户端 socket 对象 <strong>socket.socket(AddressFamily, Type)</strong></p>
<p><strong>参数说明:</strong></p>
<ul>
<li>AddressFamily 表示IP地址类型, 分为TPv4和IPv6</li>
<li>Type 表示传输协议类型</li>
</ul>
<p><strong>方法说明:</strong></p>
<ul>
<li>connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号</li>
<li>send(data) 表示发送数据，data是二进制数据</li>
<li>recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度</li>
</ul>
<h3 id="tcp-客户端程序开发示例代码">TCP 客户端程序开发示例代码</h3>
<pre><code class="language-py">import socket


if __name__ == '__main__':
    # 创建tcp客户端套接字
    # 1. AF_INET：表示ipv4
    # 2. SOCK_STREAM: tcp传输协议
    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 和服务端应用程序建立连接
    tcp_client_socket.connect((&quot;192.168.131.62&quot;, 8080))
    # 代码执行到此，说明连接建立成功
    # 准备发送的数据
    send_data = &quot;你好服务端，我是客户端小黑!&quot;.encode(&quot;gbk&quot;)
    # 发送数据
    tcp_client_socket.send(send_data)
    # 接收数据, 这次接收的数据最大字节数是1024
    recv_data = tcp_client_socket.recv(1024)
    # 返回的直接是服务端程序发送的二进制数据
    print(recv_data)
    # 对数据进行解码
    recv_content = recv_data.decode(&quot;gbk&quot;)
    print(&quot;接收服务端的数据为:&quot;, recv_content)
    # 关闭套接字
    tcp_client_socket.close()
</code></pre>
<p>服务端：</p>
<ul>
<li>bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。</li>
<li>listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。</li>
<li>accept() 表示等待接受客户端的连接请求</li>
<li>send(data) 表示发送数据，data 是二进制数据</li>
<li>recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度</li>
</ul>
<h3 id="tcp-服务端程序开发示例代码">TCP 服务端程序开发示例代码</h3>
<pre><code class="language-py">import socket
import threading


# 处理客户端的请求操作
def handle_client_request(service_client_socket, ip_port):
    # 循环接收客户端发送的数据
    while True:
        # 接收客户端发送的数据
        recv_data = service_client_socket.recv(1024)
        # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败
        # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据
        if recv_data:
            print(recv_data.decode(&quot;gbk&quot;), ip_port)
            # 回复
            service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;gbk&quot;))

        else:
            print(&quot;客户端下线了:&quot;, ip_port)
            break
    # 终止和客户端进行通信
    service_client_socket.close()


if __name__ == '__main__':
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用，让程序退出端口号立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind((&quot;&quot;, 9090))
    # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求
    tcp_server_socket.listen(128)
    # 循环等待接收客户端的连接请求
    while True:
        # 等待接收客户端的连接请求
        service_client_socket, ip_port = tcp_server_socket.accept()
        print(&quot;客户端连接成功:&quot;, ip_port)
        # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息
        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))
        # 设置守护主线程
        sub_thread.setDaemon(True)
        # 启动子线程
        sub_thread.start()


    # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行
    # tcp_server_socket.close()
</code></pre>
<p>端口号复用(推荐大家使用)，也就是说让服务端程序退出后端口号立即释放。</p>
<pre><code class="language-py"># 参数1: 表示当前套接字
# 参数2: 设置端口号复用选项
# 参数3: 设置端口号复用选项对应的值
tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
</code></pre>
<h3 id="tcp网络应用程序的注意点介绍">TCP网络应用程序的注意点介绍</h3>
<ol>
<li>当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先<strong>建立连接</strong></li>
<li>TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。</li>
<li><strong>TCP 服务端程序必须绑定端口号</strong>，否则客户端找不到这个 TCP 服务端程序。</li>
<li>listen 后的套接字是被动套接字，<strong>只负责接收新的客户端的连接请求，不能收发消息。</strong></li>
<li>当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个<strong>新的套接字</strong>，收发客户端消息使用该套接字。</li>
<li><strong>关闭 accept 返回的套接字意味着和这个客户端已经通信完毕</strong>。</li>
<li><strong>关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。</strong></li>
<li><strong>当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0</strong>，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之<strong>服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0</strong>。</li>
</ol>
<h2 id="http">HTTP</h2>
<ul>
<li>开发者工具的Headers选项总共有三部分组成:
<ol>
<li>General: 主要信息</li>
<li>Response Headers: 响应头</li>
<li>Request Headers: 请求头</li>
</ol>
</li>
<li>Response选项是查看响应体信息的</li>
</ul>
<p><strong>HTTP最常见的请求报文有两种:</strong></p>
<ol>
<li>GET 方式的请求报文</li>
<li>POST 方式的请求报文</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>
<p>GET: 获取web服务器数据</p>
</li>
<li>
<p>POST: 向web服务器提交数据</p>
</li>
<li>
<p>一个HTTP请求报文可以由<strong>请求行、请求头、空行和请求体</strong>4个部分组成。</p>
</li>
<li>
<p>请求行是由三部分组成:</p>
<ol>
<li><strong>请求方式</strong></li>
<li><strong>请求资源路径</strong></li>
<li><strong>HTTP协议版本</strong></li>
</ol>
</li>
<li>
<p><strong>GET方式的请求报文没有请求体，只有请求行、请求头、空行组成</strong>。</p>
</li>
<li>
<p><strong>POST方式的请求报文可以有请求行、请求头、空行、请求体四部分组成，注意:POST方式可以允许没有请求体，但是这种格式很少见</strong>。</p>
</li>
</ul>
<p>HTTP 状态码是<strong>用于表示web服务器响应状态的3位数字代码</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">请求成功</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">重定向</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">错误的请求，请求地址或者参数有误</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">请求资源在服务器不存在</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">服务器内部源代码出现错误</td>
</tr>
</tbody>
</table>
<p>一个HTTP响应报文是由<strong>响应行、响应头、空行和响应体</strong>4个部分组成。</p>
<ul>
<li>响应行是由三部分组成：<strong>HTTP协议版本 状态码 状态描述</strong>，最常见的状态码是200</li>
</ul>
<h2 id="静态web服务器">静态Web服务器</h2>
<pre><code class="language-py">import socket
import threading


# 定义web服务器类
class HttpWebServer(object):
    def __init__(self):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind((&quot;&quot;, 9000))
        # 设置监听
        tcp_server_socket.listen(128)
        # 保存创建成功的服务器套接字
        self.tcp_server_socket = tcp_server_socket

    # 处理客户端的请求
    @staticmethod
    def handle_client_request(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print(&quot;关闭浏览器了&quot;)
            new_socket.close()
            return

        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)

        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)

        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == &quot;/&quot;:
            request_path = &quot;/index.html&quot;

        try:
            # 动态打开指定文件
            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;
            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:
                file_data = file.read()
            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;
            # 响应头
            response_header = &quot;Server: PWS1.0\r\n&quot;

            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

    # 启动web服务器进行工作
    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            # 当客户端和服务器建立连接程，创建子线程
            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))
            # 设置守护主线程
            sub_thread.setDaemon(True)
            # 启动子线程执行对应的任务
            sub_thread.start()


# 程序入口函数
def main():
    # 创建web服务器对象
    web_server = HttpWebServer()
    # 启动web服务器进行工作
    web_server.start()


if __name__ == '__main__':
    main()
</code></pre>
<ol>
<li>
<p>获取执行python程序的终端命令行参数</p>
<pre><code class="language-py"> sys.argv
</code></pre>
</li>
</ol>
<h2 id="闭包">闭包</h2>
<p><strong>闭包的定义:</strong></p>
<p>在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个<strong>使用外部函数变量的内部函数称为闭包</strong>。</p>
<ol>
<li>
<p>当返回的内部函数使用了外部函数的变量就形成了闭包</p>
</li>
<li>
<p>闭包可以对外部函数的变量进行保存</p>
</li>
<li>
<p>实现闭包的标准格式:</p>
<pre><code class="language-py"> # 外部函数
 def test1(a):
     b = 10
     # 内部函数
     def test2():
         # 内部函数使用了外部函数的变量或者参数
         print(a, b)
     # 返回内部函数, 这里返回的内部函数就是闭包实例
     return test2
</code></pre>
</li>
</ol>
<h3 id="装饰器的定义">装饰器的定义</h3>
<p>就是<strong>给已有函数增加额外功能的函数，它本质上就是一个闭包函数</strong>。</p>
<p><strong>装饰器的功能特点:</strong></p>
<ol>
<li>不修改已有函数的源代码</li>
<li>不修改已有函数的调用方式</li>
<li>给已有函数增加额外的功能</li>
</ol>
<pre><code class="language-py"># 添加一个登录验证的功能
def check(fn):
    def inner():
        print(&quot;请先登录....&quot;)
        fn()
    return inner


def comment():
    print(&quot;发表评论&quot;)

# 使用装饰器来装饰函数
comment = check(comment)
comment()

# 装饰器的基本雏形
# def decorator(fn): # fn:目标函数.
#     def inner():
#         '''执行函数之前'''
#         fn() # 执行被装饰的函数
#         '''执行函数之后'''
#     return inner
</code></pre>
<p><strong>代码说明:</strong></p>
<ul>
<li>闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。</li>
<li>写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。</li>
</ul>
<h3 id="装饰器的语法糖写法">装饰器的语法糖写法</h3>
<p>如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。</p>
<p>Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰</p>
<pre><code class="language-py"># 添加一个登录验证的功能
def check(fn):
    print(&quot;装饰器函数执行了&quot;)
    def inner():
        print(&quot;请先登录....&quot;)
        fn()
    return inner

# 使用语法糖方式来装饰函数
@check
def comment():
    print(&quot;发表评论&quot;)


comment()
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>@check 等价于 comment = check(comment)</li>
<li>装饰器的执行时间是加载模块时立即执行。</li>
</ul>
<h3 id="装饰器的使用">装饰器的使用</h3>
<h3 id="装饰器实现已有函数执行时间的统计">装饰器实现已有函数执行时间的统计</h3>
<pre><code class="language-py">import time

# 装饰器函数
def get_time(func):
    def inner():
        begin = time.time()
        func()
        end = time.time()
        print(&quot;函数执行花费%f&quot; % (end-begin))
    return inner


@get_time
def func1():
    for i in range(100000):
        print(i)


func1()
</code></pre>
<h3 id="装饰带有参数的函数">装饰带有参数的函数</h3>
<pre><code class="language-py"># 添加输出日志的功能
def logging(fn):
    def inner(num1, num2):
        print(&quot;--正在努力计算--&quot;)
        fn(num1, num2)

    return inner


# 使用装饰器装饰函数
@logging
def sum_num(a, b):
    result = a + b
    print(result)
</code></pre>
<h3 id="通用装饰器">通用装饰器</h3>
<pre><code class="language-py"># 添加输出日志的功能
def logging(fn):
    def inner(*args, **kwargs):
        print(&quot;--正在努力计算--&quot;)
        result = fn(*args, **kwargs)
        return result

    return inner


# 使用语法糖装饰函数
@logging
def sum_num(*args, **kwargs):
    result = 0
    for value in args:
        result += value

    for value in kwargs.values():
        result += value

    return result


@logging
def subtraction(a, b):
    result = a - b
    print(result)

result = sum_num(1, 2, a=10)
print(result)

subtraction(4, 2)
</code></pre>
<ul>
<li>
<p>多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程</p>
</li>
<li>
<p>使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器，因为 @ 符号需要配合装饰器实例使用</p>
</li>
</ul>
<h3 id="类装饰器的介绍">类装饰器的介绍</h3>
<pre><code class="language-py">lass Check(object):
    def __init__(self, fn):
        # 初始化操作在此完成
        self.__fn = fn

    # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。
    def __call__(self, *args, **kwargs):
        # 添加装饰功能
        print(&quot;请先登陆...&quot;)
        self.__fn()


@Check
def comment():
    print(&quot;发表评论&quot;)


comment()
</code></pre>
<ul>
<li>@Check 等价于 comment = Check(comment), 所以需要提供一个<strong>init</strong>方法，并多增加一个fn参数。</li>
<li>要想类的实例对象能够像函数一样调用，需要在类里面使用<strong>call</strong>方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。</li>
<li>在<strong>call</strong>方法里进行对fn函数的装饰，可以添加额外的功能</li>
</ul>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmweijh.github.io/post/linux-ji-chu/" class="post-title gt-a-link">
                    Linux基础
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">努力成就自我</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmweijh.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

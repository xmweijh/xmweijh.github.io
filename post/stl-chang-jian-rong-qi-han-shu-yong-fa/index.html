<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>STL常见容器函数用法 | 小虾米的记录</title>

<link rel="shortcut icon" href="https://xmweijh.github.io//favicon.ico?v=1625390237696">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmweijh.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            小虾米的记录
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1625390237696"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    STL常见容器函数用法
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-03-18 ·
                    </time>
                    
                        <a href="https://xmweijh.github.io/tag/3AyLbslIy/" class="post-tags">
                            # C/C++
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>本文列出一些常用STL用法，一些注意点在上一篇STL中，两者搭配效果更佳☺</p>
<h2 id="string">string</h2>
<pre><code class="language-c">	#include &lt;string&gt;
	
/*
string 构造函数
string();//创建一个空的字符串 例如: string str;
string(const string&amp; str);//使用一个string对象初始化另一个string对象
string(const char* s);//使用字符串s初始化
string(int n, char c);//使用n个字符c初始化

3.1.2.2 string基本赋值操作
string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串
string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串
string&amp; operator=(char c);//字符赋值给当前的字符串
string&amp; assign(const char *s);//把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串
string&amp; assign(int n, char c);//用n个字符c赋给当前字符串
string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串

*/
	//常见构造
	string str; //默认构造
	string str2(str); //拷贝构造
	string str3 = str;

	string str4 = &quot;abcd&quot;;
	string str5(10, 'a');


	//基本赋值
	str = &quot;hello&quot;;
	str2 = str4;

	//string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串
	str3.assign(&quot;abcdef&quot;, 4);

	//string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串
	string str6;
	str6.assign(str, 1, 3); //ell ? hel 从0索引


/*
string存取字符操作
char&amp; operator[](int n);//通过[]方式取字符
char&amp; at(int n);//通过at方法获取字符

*/
	string s = &quot;hello world&quot;;

	for (int i = 0; i &lt; s.size();i++)
	{
		//cout &lt;&lt; s[i] &lt;&lt; endl;
		cout &lt;&lt; s.at(i) &lt;&lt; endl;
	}
	//[] 和at区别？[]访问越界  直接挂掉 at会抛出异常

	


/*
string拼接操作
string&amp; operator+=(const string&amp; str);//重载+=操作符
string&amp; operator+=(const char* str);//重载+=操作符
string&amp; operator+=(const char c);//重载+=操作符
string&amp; append(const char *s);//把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾
string&amp; append(const string &amp;s);//同operator+=()
string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾
string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c

string查找和替换
int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置
int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置
string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s

*/

	//拼接
	string s1 = &quot;我&quot;;
	string s2 = &quot;爱北京&quot;;
	s1 += s2;
	cout &lt;&lt; s1 &lt;&lt; endl;
	s1.append(&quot;天安门&quot;);

	cout &lt;&lt; s1 &lt;&lt; endl;

	//find查找

	string s = &quot;abcdefg&quot;;
	int pos = s.find(&quot;bcf&quot;); //找不到返回是 -1
	cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
	
	int pos2 = s.rfind(&quot;bc&quot;); //rfind  和find 结果一样，内部查找顺序相反
	cout &lt;&lt; &quot;pos2 = &quot; &lt;&lt; pos2 &lt;&lt; endl; // 4 2 


	//替换
	string s3 = &quot;hello&quot;; //替换从pos开始n个字符为字符串str
	s3.replace(1, 3, &quot;1111&quot;);
	cout &lt;&lt; s3 &lt;&lt; endl; // h1111o



/*
string比较操作
/*
compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。
比较区分大小写，比较时参考字典顺序，排越前面的越小。
大写的A比小写的a小。

int compare(const string &amp;s) const;//与字符串s比较
int compare(const char *s) const;//与字符串s比较
*/
	string s1 = &quot;abc&quot;;
	string s2 = &quot;abcd&quot;;

	if (s1.compare(s2) == 0)
	{
		cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;
	}
	else if (s1.compare(s2) == 1)
	{
		cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;
	}

/*
string子串
string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串

*/
	string s1 = &quot;abcde&quot;;

	string s2 = s1.substr(1, 3);
	cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

	//需求  查找一个右键的 用户名
	string email = &quot;zhangtao@sina.com&quot;;

	int pos = email.find(&quot;@&quot;);//8 
	cout &lt;&lt; &quot;pos &quot; &lt;&lt; pos &lt;&lt; endl;

	string usrName = email.substr(0, pos);
	cout &lt;&lt; &quot;用户名为：&quot; &lt;&lt; usrName &lt;&lt; endl;


/*
string插入和删除操作
string&amp; insert(int pos, const char* s); //插入字符串
string&amp; insert(int pos, const string&amp; str); //插入字符串
string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c
string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符

*/
	string s1 = &quot;hello&quot;;
	s1.insert(1, &quot;111&quot;);
	cout &lt;&lt; s1 &lt;&lt; endl; //h111ello

	//删除 111
	s1.erase(1, 3);
	cout &lt;&lt; s1 &lt;&lt; endl;

/*
string和c-style字符串转换
*/
void func(string s)
{
	cout &lt;&lt; s &lt;&lt; endl;
}

void func2(const char * s)
{
	cout &lt;&lt; s &lt;&lt; endl;
}
	string s = &quot;abc&quot;;
	//string -&gt; const char *

	const char * p = s.c_str();

	func(p); //const char * 隐式类型转换为 string

	//const char * -&gt; string 

	string s2(p);
	//func2(s2); //string 不能隐式类型转换为 char * 


/*
写一个函数，函数内部将string字符串中的所有小写字母都变为大写字母。
*/
	string s = &quot;abCdEfg&quot;;

	for (int i = 0; i &lt; s.size();i++)
	{
		//s[i] = toupper(s[i]);

		//全变小写
		s[i] = tolower(s[i]);
	}

	cout &lt;&lt; s &lt;&lt; endl;
</code></pre>
<h2 id="vector">vector</h2>
<pre><code class="language-c">#include &lt;vector&gt;

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++){
		v.push_back(i);
		cout &lt;&lt; v.capacity() &lt;&lt; endl;  // v.capacity()容器的容量
	}

/*
vector构造函数
vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);//构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);//拷贝构造函数。

//例子 使用第二个构造函数 我们可以...
int arr[] = {2,3,4,1,9};
vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));

vector常用赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector&amp; operator=(const vector  &amp;vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。

vector大小操作
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。

*/
void printVector( vector&lt;int&gt;&amp;v)
{
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}
void test02()
{
	vector &lt;int &gt;v;
	int arr[] = { 2, 3, 4, 1, 9 };
	vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));

	vector&lt;int&gt;v2(v1.begin(), v1.end());

	printVector(v2);

	vector&lt;int&gt;v3(10, 100);

	printVector(v3);

	//赋值使用
	vector&lt;int&gt;v4;
	v4.assign(v3.begin(), v3.end());
	printVector(v4);


	v4.swap(v2);

	cout &lt;&lt; &quot;交换后的v4 &quot; &lt;&lt; endl;
	printVector(v4);

	cout &lt;&lt; &quot;v4容器的大小&quot; &lt;&lt; v4.size() &lt;&lt; endl;

	if (v4.empty())
	{
		cout &lt;&lt; &quot;v4空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;v4不空&quot; &lt;&lt; endl;
	}
	
	//v4 23419
	v4.resize(10,-1); //第二个参数是默认值 ，默认0 
	printVector(v4);

	v4.resize(3);
	printVector(v4);

}
//巧用swap收缩空间
void test03()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 100000; i++)
	{
		v.push_back(i);
	}

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;

	v.resize(3);

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;

	//巧用swap
	vector&lt;int&gt;(v).swap(v);

	cout &lt;&lt; &quot;v的容量&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小&quot; &lt;&lt; v.size() &lt;&lt; endl;
}

//reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
void test04()
{
	vector&lt;int&gt;v;

	v.reserve(100000); //预留出空间

	int * p = NULL;
	int num = 0;
	for (int i = 0; i &lt; 100000;i++)
	{
		v.push_back(i);
		if (p!=&amp;v[0])
		{
			p = &amp;v[0];
			num++;
		}
	}
	cout &lt;&lt; num &lt;&lt; endl;
	// 开辟100000数据用了多少次
}



/*
vector数据存取操作
at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素

 vector插入和删除操作
insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素

*/

void test05()
{
	vector&lt;int&gt;v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(20);
	v.push_back(50);

	cout &lt;&lt; &quot;v的front&quot; &lt;&lt; v.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的back&quot; &lt;&lt; v.back() &lt;&lt; endl;


	v.insert(v.begin(), 2 ,100); //参数1  迭代器   参数2  N个数  参数3 具体插入的内容

	printVector(v);

	v.pop_back(); //尾删
	printVector(v);

	v.erase(v.begin()); //删除 
	printVector(v);

	//v.erase(v.begin(), v.end());
	//v.clear(); //清空所有数据
	if (v.empty() )
	{
		cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl;
	}

}
void test06()
{
	//逆序遍历
	vector&lt;int&gt;v;
	for ( int  i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

//	printVector(v);
	//reverse_iterator 逆序迭代器
	for (vector&lt;int&gt;::reverse_iterator it = v.rbegin(); it != v.rend();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//vector迭代器是随机访问的迭代器  支持跳跃式访问
	vector&lt;int&gt;::iterator itBegin = v.begin();
	itBegin = itBegin + 3;
	//如果上述写法不报错，这个迭代器是随机访问迭代器


	list&lt;int&gt;l;
	for (int i = 0; i &lt; 10;i++)
	{
		l.push_back(i);
	}
	list&lt;int&gt;::iterator lIt = l.begin();
	//lIt = lIt + 1; //不支持随机访问

}
</code></pre>
<h2 id="deque">deque</h2>
<pre><code class="language-c">#include &lt;deque&gt;

/*
deque构造函数
deque&lt;T&gt; deqT;//默认构造形式
deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);//构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);//拷贝构造函数。

deque赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
deque&amp; operator=(const deque &amp;deq); //重载等号操作符
swap(deq);// 将deq与本身的元素互换

deque大小操作
deque.size();//返回容器中元素的个数
deque.empty();//判断容器是否为空
deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
*/
void printDeque(const deque&lt;int&gt;&amp;d)
{
	//iterator 普通迭代器  reverse_iterator 逆序迭代器  const_iterator 只读迭代器
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end();it++)
	{
		//*it = 100000;
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	deque&lt;int&gt;d;

	d.push_back(10);
	d.push_back(40);
	d.push_back(30);
	d.push_back(20);

	printDeque(d);

	deque&lt;int&gt;d2(d.begin(), d.end());
	d2.push_back(10000);

	//交换
	d.swap(d2);

	printDeque(d);


	// d2  10 40 30 20
	if (d2.empty())
	{
		cout &lt;&lt; &quot;为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;不为空 大小为：&quot; &lt;&lt;d2.size() &lt;&lt; endl;
	}
}

/*
deque双端插入和删除操作
push_back(elem);//在容器尾部添加一个数据
push_front(elem);//在容器头部插入一个数据
pop_back();//删除容器最后一个数据
pop_front();//删除容器第一个数据

3.3.3.5 deque数据存取
at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();//返回第一个数据。
back();//返回最后一个数据
3.3.3.6 deque插入操作
insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
3.3.3.7 deque删除操作
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。

*/

void test02()
{
	deque&lt;int&gt;d;
	d.push_back(10);
	d.push_back(30);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	printDeque(d); // 200 100 10 30 20

	//删除 头删 尾删
	d.pop_back();
	d.pop_front();
	printDeque(d); // 100 10 30

	cout &lt;&lt; &quot;front: &quot; &lt;&lt; d.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;back: &quot; &lt;&lt; d.back() &lt;&lt; endl;

	//插入
	deque&lt;int&gt;d2;
	d2.push_back(50);
	d2.push_back(60);
	d2.insert(d2.begin(), d.begin(), d.end());
	printDeque(d2);  //  100 10 30 50 60


}

//排序规则
bool myCompare(int v1, int v2)
{
	return v1 &gt; v2; // 100 10
}

//排序 sort
void test03()
{
	deque&lt;int&gt;d;
	d.push_back(5);
	d.push_back(15);
	d.push_back(3);
	d.push_back(40);
	d.push_back(7);

	printDeque(d);
	//排序
	sort(d.begin(), d.end());

	printDeque(d);

	//从大到小
	sort(d.begin(), d.end(), myCompare);
	printDeque(d);

}
</code></pre>
<h2 id="stack">stack</h2>
<pre><code class="language-c">#include &lt;stack&gt;
/*
stack构造函数
stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &amp;stk);//拷贝构造函数
stack赋值操作
stack&amp; operator=(const stack &amp;stk);//重载等号操作符
stack数据存取操作
push(elem);//向栈顶添加元素
pop();//从栈顶移除第一个元素
top();//返回栈顶元素
stack大小操作
empty();//判断堆栈是否为空
size();//返回堆栈的大小
*/

void test01()
{
	stack&lt;int&gt;s;
	//放入数据 push
	s.push(10);
	s.push(30);
	s.push(20);
	s.push(40);

	while (s.size() != 0)
	{
		cout &lt;&lt; &quot;栈顶为 &quot; &lt;&lt; s.top() &lt;&lt; endl;  //40  20  30  10
		//弹出栈顶元素
		s.pop();
	}
	cout &lt;&lt; &quot;size = &quot; &lt;&lt; s.size() &lt;&lt; endl;
	
}

</code></pre>
<h2 id="queue">queue</h2>
<pre><code class="language-c">#include &lt;queue&gt;

/*
queue构造函数
queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &amp;que);//拷贝构造函数
queue存取、插入和删除操作
push(elem);//往队尾添加元素
pop();//从队头移除第一个元素
back();//返回最后一个元素
front();//返回第一个元素

queue赋值操作
queue&amp; operator=(const queue &amp;que);//重载等号操作符
 queue大小操作
empty();//判断队列是否为空
size();//返回队列的大小

*/

void test01()
{
	queue&lt;int&gt;q;
	q.push(10);//往队尾添加元素
	q.push(20); 
	q.push(30); 
	q.push(40);

	while (!q.empty())
	{

		//  10 40  20 40  30  40  40  40
		cout &lt;&lt; &quot;队头: &quot; &lt;&lt; q.front() &lt;&lt; endl; 
		cout &lt;&lt; &quot;队尾: &quot; &lt;&lt; q.back() &lt;&lt; endl; 
		//弹出队头元素
		q.pop();
	}

	cout &lt;&lt; &quot;size : &quot; &lt;&lt; q.size() &lt;&lt; endl;
}
</code></pre>
<h2 id="list">list</h2>
<pre><code class="language-c">#include &lt;list&gt;
//list是双向循环链表
void test01()
{
	list&lt;int&gt; myList;
	for (int i = 0; i &lt; 10; i++){
		myList.push_back(i);
	}

	list&lt;int&gt;::_Nodeptr node = myList._Myhead-&gt;_Next;

	for ( int i = 0; i &lt; myList._Mysize * 2; i++){
		cout &lt;&lt; &quot;Node:&quot; &lt;&lt; node-&gt;_Myval &lt;&lt; endl;
		node = node-&gt;_Next;
		if (node == myList._Myhead){
			node = node-&gt;_Next;
		}
	}


}

//list常用API
/*
list构造函数
list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：
list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);//构造函数将n个elem拷贝给本身。
list(const list &amp;lst);//拷贝构造函数。
list数据元素插入和删除操作
push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。
*/

void printList(list&lt;int&gt;&amp;L)
{
	for (list&lt;int&gt;::iterator it = L.begin(); it != L.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test02()
{
	list&lt;int&gt;L(10,10);
	list&lt;int&gt;L2(L.begin(), L.end());

	printList(L);
	printList(L2);
	L2.push_back(100);

	//逆序打印
	for (list&lt;int&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//list迭代器不支持随机访问
	list&lt;int&gt;::iterator itBegin = L2.begin();
	//itBegin = itBegin + 1;


	//插入数据
	list&lt;int&gt;L3;
	L3.push_back(10);
	L3.push_back(30);
	L3.push_back(20);
	L3.push_front(100);
	L3.push_front(300);
	L3.push_front(200);

	printList(L3); //  200 300 100 10 30 20 

	//删除两端数据
	L3.pop_front(); //头删
	L3.pop_back(); //尾删
	printList(L3); // 300 100 10 30

	L3.insert(L3.begin(), 1000);
	printList(L3); // 1000 300 100 10 30

	//remove(elem);//删除容器中所有与elem值匹配的元素。
	L3.push_back(10);// 1000 300 100 10 30 10
	L3.remove(10); //参数 直接放值

	printList(L3);//1000 300 100  30
}


/*
list大小操作
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。

 list赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list&amp; operator=(const list &amp;lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换。
 list数据的存取
front();//返回第一个元素。
back();//返回最后一个元素。
*/

void test03()
{
	list&lt;int&gt;L3;
	L3.push_back(10);
	L3.push_back(30);
	L3.push_back(20);
	L3.push_front(100);
	L3.push_front(300);
	L3.push_front(200);

	cout &lt;&lt; &quot;大小：&quot; &lt;&lt; L3.size() &lt;&lt; endl;
	if (L3.empty())
	{
		cout &lt;&lt; &quot;L3为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;L3不为空&quot; &lt;&lt; endl;
	}

	L3.resize(10);
	printList(L3);

	L3.resize(3);
	printList(L3);

	list&lt;int&gt; L4;
	L4.assign(L3.begin(), L3.end());

	//200 300 100
	cout &lt;&lt; &quot;front: &quot; &lt;&lt; L4.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;back: &quot; &lt;&lt; L4.back() &lt;&lt; endl;
}

/*
list反转排序
reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); //list排序
*/

bool myCompare(int v1, int v2)
{	
	return v1 &gt; v2; //降序
}

void test04()
{
	list&lt;int&gt;L;

	L.push_back(10);
	L.push_back(20);
	L.push_back(40);
	L.push_back(30);

	L.reverse();
	printList(L); // 30 40 20 10

	//所有不支持随机访问的迭代器 不可以用系统提供的算法
	// 如果不支持用系统提供算法，那么这个类内部会提供
	//sort(L.begin(), L.end()); 
	L.sort(); //从小到大

	printList(L);

	//从大到小
	L.sort(myCompare);
	printList(L);

}

//自定义数据类型
class Person
{
public:
	Person(string name, int age,int height)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
		this-&gt;m_Height = height;
	}

	//重载 == 让remove 可以删除自定义的person类型
	bool operator==( const  Person &amp; p)
	{
		if ( this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age &amp;&amp; this-&gt;m_Height == p.m_Height)
		{
			return true;
		}
		return false;
	}

	string m_Name;
	int m_Age;
	int m_Height; //身高 
};

//Person排序规则 如果年龄 相同  按照身高的升序排序
bool myComparePerson( Person &amp; p1,Person &amp; p2 )
{
	//if (p1.m_Age &gt; p2.m_Age)
	//{
	//	return true;
	//}
	//return false;

	if (p1.m_Age == p2.m_Age)
	{
		return p1.m_Height &lt; p2.m_Height;
	}
	else
	{
		return p1.m_Age &gt; p2.m_Age;
	}
	

}

void test05()
{
	list&lt;Person&gt; L;

	Person p1(&quot;亚瑟&quot;, 10 , 165);
	Person p2(&quot;德玛西亚&quot;, 20 , 170);
	Person p3(&quot;火枪&quot;, 17,177);
	Person p4(&quot;德雷福斯&quot;, 19, 120);
	Person p5(&quot;MT&quot;, 18,200);
	Person p6(&quot;狗蛋&quot;, 18, 166);
	Person p7(&quot;狗剩&quot;, 18, 210);

	L.push_back(p1);
	L.push_back(p2);
	L.push_back(p3);
	L.push_back(p4);
	L.push_back(p5);
	L.push_back(p6);
	L.push_back(p7);

	//需求 打印数据时候 按照年龄的降序 输出
	//对于自定义数据类型 ，必须要指定排序规则
	L.sort( myComparePerson);
	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end();it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot;&lt;&lt; it-&gt;m_Height&lt;&lt; endl;
	}

	//删除 狗蛋 
	cout &lt;&lt; &quot; -------------------- &quot; &lt;&lt; endl;

	L.remove(p6);
	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高：&quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
	}

}

</code></pre>
<h2 id="set">set</h2>
<pre><code class="language-c">//set  multiset头文件
#include &lt;set&gt;

/*
set构造函数
set&lt;T&gt; st;//set默认构造函数：
mulitset&lt;T&gt; mst; //multiset默认构造函数:
set(const set &amp;st);//拷贝构造函数
set赋值操作
set&amp; operator=(const set &amp;st);//重载等号操作符
swap(st);//交换两个集合容器
 set大小操作
size();//返回容器中元素的数目
empty();//判断容器是否为空

set插入和删除操作
insert(elem);//在容器中插入元素。
clear();//清除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);//删除容器中值为elem的元素。

*/

void printSet( set&lt;int&gt;&amp; s)
{
	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	set&lt;int&gt;s1;
	//关联式容器 key进行排序，从小到大
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);
	printSet(s1);

	if (s1.empty())
	{
		cout &lt;&lt; &quot;空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; endl;
	}

	s1.erase(s1.begin()); // 3 5 7 9
	printSet(s1);
	s1.erase(3); //  5 7 9
	printSet(s1);
}

/*
set查找操作
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);//查找键key的元素个数
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。

*/

void test02()
{
	set&lt;int&gt;s1;
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);
	//对于set 没有value  key就是value

	set&lt;int&gt;::iterator pos = s1.find(2);
	//判断是否找到
	if (pos != s1.end())
	{
		cout &lt;&lt; &quot;找到了：值为：&quot; &lt;&lt; *pos &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//count(key);//查找键key的元素个数 set而言 结果 0或者1 

	int num =  s1.count(2);
	cout &lt;&lt;  &quot;2的个数为： &quot; &lt;&lt; num &lt;&lt; endl;


	//lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
	set&lt;int&gt;::iterator it =  s1.lower_bound(3); // 10就是未找到
	if (it!= s1.end())
	{
		cout &lt;&lt; &quot;找到了 lower_bound (3)的值为：&quot; &lt;&lt; *it &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
	// upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
	set&lt;int&gt;::iterator it2 = s1.upper_bound(3);
	if (it2 != s1.end())
	{
		cout &lt;&lt; &quot;找到了 upper_bound (3)的值为：&quot; &lt;&lt; *it2 &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
	//上下限 就是lower_bound   upper_bound
	pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt;  ret =  s1.equal_range(3);
	//获取第一个值

	if (ret.first != s1.end())
	{
		cout &lt;&lt; &quot;找到equal_range中 lower_bound 的值 ：&quot; &lt;&lt; *(ret.first) &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//获取第二个值
	if (ret.second != s1.end())
	{
		cout &lt;&lt; &quot;找到equal_range中 upper_bound 的值 ：&quot; &lt;&lt; *(ret.second) &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
	
}


//set容器 不允许插入重复的键值
void test03()
{
	set&lt;int&gt; s1;
	pair&lt;set&lt;int&gt;::iterator,bool&gt; ret =  s1.insert(10);

	if (ret.second)
	{
		cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl;
	}

	ret = s1.insert(10);
	if (ret.second)
	{
		cout &lt;&lt; &quot;第二次插入成功&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;第二次插入失败&quot; &lt;&lt; endl;
	}

	printSet(s1);
	

	//multiset允许插入重复值
	multiset&lt;int&gt; mul;
	mul.insert(10);
	mul.insert(10);

}

//指定set排序规则 从大到小
//仿函数
class myCompare
{
public:
	//重载 ()
	bool operator()( int v1 ,int v2)
	{
		return v1 &gt; v2;
	}
};


//set容器排序
void test04()
{
	set&lt;int,myCompare&gt;s1;
	
	s1.insert(5);
	s1.insert(1);
	s1.insert(9);
	s1.insert(3);
	s1.insert(7);

	//printSet(s1);

	//从大到小排序
	//在插入之前就指定排序规则

	for (set&lt;int, myCompare&gt;::iterator it = s1.begin(); it != s1.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

class myComparePerson
{
public:
	bool operator()( const Person &amp; p1, const Person &amp; p2)
	{
		if (p1.m_Age &gt; p2.m_Age) //降序
		{
			return true;
		}
		return false;
	}

};

void test05()
{
	set&lt;Person, myComparePerson&gt; s1;

	Person p1(&quot;大娃&quot;, 100);
	Person p2(&quot;二娃&quot;, 90);
	Person p3(&quot;六娃&quot;, 10);
	Person p4(&quot;爷爷&quot;, 1000);

	s1.insert(p1);
	s1.insert(p2);
	s1.insert(p3);
	s1.insert(p4);

	//插入自定义数据类型，上来就指定好排序规则

	//显示
	for (set&lt;Person, myComparePerson&gt;::iterator it = s1.begin(); it != s1.end();it++)
	{
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	}

}
</code></pre>
<h2 id="pair">pair</h2>
<pre><code class="language-c">//创建对组
void test01()
{
	//第一种
	pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 100);

	//取值
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; endl;
	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;

	//第二种创建
	pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 200);
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p2.first &lt;&lt; endl;
	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;

}
</code></pre>
<h2 id="map">map</h2>
<pre><code class="language-c">#include &lt;map&gt;

/*
map构造函数
map&lt;T1, T2&gt; mapTT;//map默认构造函数:
map(const map &amp;mp);//拷贝构造函数
 map赋值操作
map&amp; operator=(const map &amp;mp);//重载等号操作符
swap(mp);//交换两个集合容器

 map大小操作
size();//返回容器中元素的数目
empty();//判断容器是否为空
 map插入数据元素操作
map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;
// 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));
// 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, &quot;校长&quot;));
// 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));
// 第四种 通过数组的方式插入值
mapStu[3] = &quot;小刘&quot;;
mapStu[5] = &quot;小王&quot;;

*/

void test01()
{
	map&lt;int, int&gt; m;
	//插入值
	// 4种方式
	//第一种
	m.insert(pair&lt;int, int&gt;(1, 10));
	//第二种 推荐
	m.insert(make_pair(2, 20));
	//第三种 不推荐
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	//第四种 如果保证key存在 ，那么可以通过[]访问
	m[4] = 40;

	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end();it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}

	cout &lt;&lt; m[5] &lt;&lt;endl;

	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}

	//cout &lt;&lt; m[4] &lt;&lt; endl;

	if ( m.empty())
	{
		cout &lt;&lt; &quot;空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; m.size() &lt;&lt; endl;
	}
}

/*
map删除操作
clear();//删除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);//删除容器中key为keyElem的对组。
 map查找操作
find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();
count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
*/
void test02()
{
	map&lt;int, int&gt; m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	m[4] = 40;

	m.erase(1);
	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}


	map&lt;int,int&gt;::iterator pos = m.find(2);
	if (pos != m.end())
	{
		cout &lt;&lt; &quot;找到：key&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	int num  = m.count(3); //map的count 要么0 要么1 
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;

	// lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。

	map&lt;int,int&gt;::iterator ret = m.lower_bound(3);
	if (ret != m.end())
	{
		cout &lt;&lt; &quot;lower_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
	ret = m.upper_bound(3);
	if (ret != m.end())
	{
		cout &lt;&lt; &quot;upper_bound 中key&quot; &lt;&lt; ret-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	//equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。

	pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt; ret2 = m.equal_range(3);

	if (ret2.first != m.end())
	{
		cout &lt;&lt; &quot;找到了equal_range 中的lower_bound 的key &quot; &lt;&lt; ret2.first-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.first-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

	if (ret2.second != m.end())
	{
		cout &lt;&lt; &quot;找到了equal_range 中的upper_bound 的key &quot; &lt;&lt; ret2.second-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; ret2.second-&gt;second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}

}

//指定排序规则
class myCompare
{
public:
	bool operator()(int v1, int v2)
	{
		return v1 &gt; v2;
	}

};

void test03()
{
	//从大到小排序
	map&lt;int, int, myCompare&gt; m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	m[4] = 40;

	for (map&lt;int, int, myCompare&gt;::iterator it = m.begin(); it != m.end();it++)
	{
		cout &lt;&lt; &quot;key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}


}
</code></pre>
<h2 id="常用算法">常用算法</h2>
<p>算法主要是由头文件<algorithm> <functional> <numeric>组成</p>
<p><algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等...</p>
<p><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</p>
<p><functional> 定义了一些模板类,用以声明函数对象。</p>
<h3 id="遍历">遍历</h3>
<pre><code class="language-c">/*
    遍历算法 遍历容器元素
	@param beg 开始迭代器
	@param end 结束迭代器
	@param _callback  函数回调或者函数对象
	@return 函数对象
*/
for_each(iterator beg, iterator end, _callback);

/*
	transform算法 将指定容器区间元素搬运到另一容器中
	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存
	@param beg1 源容器开始迭代器
	@param end1 源容器结束迭代器
	@param beg2 目标容器开始迭代器
	@param _cakkback 回调函数或者函数对象
	@return 返回目标容器迭代器
*/
transform(iterator beg1, iterator end1, iterator beg2, _callbakc)

</code></pre>
<h3 id="查找">查找</h3>
<pre><code class="language-c">/*
	find算法 查找元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return 返回查找元素的位置
*/
find(iterator beg, iterator end, value)
/*
	find_if算法 条件查找
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return bool 查找返回true 否则false
*/
find_if(iterator beg, iterator end, _callback);

/*
	adjacent_find算法 查找相邻重复元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)
	@return 返回相邻元素的第一个位置的迭代器
*/
adjacent_find(iterator beg, iterator end, _callback);
/*
	binary_search算法 二分查找法
	注意: 在无序序列中不可用
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return bool 查找返回true 否则false
*/
bool binary_search(iterator beg, iterator end, value);
/*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  value回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count(iterator beg, iterator end, value);
/*
count_if算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*/
count_if(iterator beg, iterator end, _callback);

</code></pre>
<h3 id="排序">排序</h3>
<pre><code class="language-c">/*
	merge算法 容器元素合并，并存储到另一容器中
	注意:两个容器必须是有序的
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
*/
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	sort算法 容器元素排序
	@param beg 容器1开始迭代器
	@param end 容器1结束迭代器
	@param _callback 回调函数或者谓词(返回bool类型的函数对象)
*/
sort(iterator beg, iterator end, _callback)
/*
	random_shuffle算法 对指定范围内的元素随机调整次序
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
random_shuffle(iterator beg, iterator end)
/*
	reverse算法 反转指定范围的元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*/
reverse(iterator beg, iterator end)

</code></pre>
<h3 id="常用拷贝和替换算法">常用拷贝和替换算法</h3>
<pre><code class="language-c">/*
	copy算法 将容器内指定范围的元素拷贝到另一容器中
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param dest 目标起始迭代器
*/
copy(iterator beg, iterator end, iterator dest)
/*
	replace算法 将容器内指定范围的旧元素修改为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param oldvalue 旧元素
	@param oldvalue 新元素
*/
replace(iterator beg, iterator end, oldvalue, newvalue)
/*
	replace_if算法 将容器内指定范围满足条件的元素替换为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param callback函数回调或者谓词(返回Bool类型的函数对象)
	@param oldvalue 新元素
*/
replace_if(iterator beg, iterator end, _callback, newvalue)
/*
	swap算法 互换两个容器的元素
	@param c1容器1
	@param c2容器2
*/
swap(container c1, container c2)

</code></pre>
<h3 id="常用算数生成算法">常用算数生成算法</h3>
<pre><code class="language-c">/*
	accumulate算法 计算容器元素累计总和
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value累加值
*/
accumulate(iterator beg, iterator end, value)
/*
	fill算法 向容器中添加元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value t填充元素
*/
fill(iterator beg, iterator end, value)

</code></pre>
<h3 id="常用集合算法">常用集合算法</h3>
<pre><code class="language-c">/*
	set_intersection算法 求两个set集合的交集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_union算法 求两个set集合的并集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
/*
	set_difference算法 求两个set集合的差集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*/
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)

</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmweijh.github.io/post/za-ji/" class="post-title gt-a-link">
                    杂记
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">努力成就自我</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmweijh.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

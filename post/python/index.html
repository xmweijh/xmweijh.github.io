<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Python | 小虾米的记录</title>

<link rel="shortcut icon" href="https://xmweijh.github.io//favicon.ico?v=1620817935973">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmweijh.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            小虾米的记录
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1620817935973"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Python
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-04-04 ·
                    </time>
                    
                        <a href="https://xmweijh.github.io/tag/xHTgICqZ2/" class="post-tags">
                            # Python
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="基础知识">基础知识</h2>
<p>print括号中可以单引号或者双引号</p>
<p>多行打印时,使用三个引号</p>
<pre><code>print('''



''')
</code></pre>
<p>true类型只用True 和False 注意大小写</p>
<p>空值 None 表示无，与0 不同</p>
<p>input（输入）</p>
<p>当输入输出括号中字符串中还有引号，需要转义符\区别</p>
<pre><code>&gt;&gt;&gt; string = 'hello_shiyanlou'
&gt;&gt;&gt; string[0]  # 获取第一个字符
'h'
&gt;&gt;&gt; string[-2]  # 获取倒数第二个字符
'o'
</code></pre>
<p>注意负值代表倒数第几个（倒数不从0开始，毕竟 -0 = 0）</p>
<pre><code>print('你叫'+name+'，今年' + age + '岁了')
#等价于
print('你叫{}，今年{}岁了'.format(name,age))
#下面代码代表保留2位小数
print(&quot;{:.2f}&quot;.format(3.1415926))
</code></pre>
<p>#单行注释</p>
<p>逻辑运算符 and 	or 	not</p>
<p>条件判断</p>
<pre><code>if:
    ***
elif:
	***
else:
	***
</code></pre>
<p>后面加<strong>冒号</strong>  if下面的代码4个缩进</p>
<p>input 读取的为字符串类型</p>
<pre><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; if a&lt;1:
...     print(&quot;a&lt;1&quot;)
... else:
...     pass
...
&gt;&gt;&gt; #程序没有报错
</code></pre>
<p>pass会跳过这里的代码执行后面的代码</p>
<pre><code>for 元素 in 集合:
    do something 
</code></pre>
<p>range(x)函数 可以生成一个从0到x-1的整数序列</p>
<p><code>range()</code> 函数返回的并不是列表而是一种可迭代对象：</p>
<p>range(a,b)  a 到b-1，包头不包尾</p>
<pre><code>while condition:
   do something
</code></pre>
<p>所以如果是用空格，就一直用空格缩进，不要使用制表符。</p>
<p>建议遵守以下约定：</p>
<ul>
<li>使用 4 个空格来缩进</li>
<li>永远不要混用空格和制表符</li>
<li>在函数之间空一行</li>
<li>在类之间空两行</li>
<li>字典，列表，元组以及参数列表中，在 <code>,</code> 后添加一个空格。对于字典，<code>:</code> 后面也添加一个空格</li>
<li>在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：<code>a = f(1, 2) + g(3, 4)</code></li>
</ul>
<p>// 取整除 - 返回商的整数部分（<strong>向下取整</strong>）</p>
<p><code>divmod(num1, num2)</code> 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 <code>*</code> 运算符拆封这个元组，得到这两个值。</p>
<p>默认情况下，<code>print()</code> 除了打印你提供的字符串之外，还会打印一个换行符   <code>print()</code> 的另一个参数 <code>end</code> 来替换这个换行符</p>
<pre><code> print(b, end=' ') 
 print(&quot;-&quot; * 50) #打印50个-
  #列表的元素不必是同一类型
 &gt;&gt;&gt; a = [ 1, 342, 223, 'India', 'Fedora'] 
</code></pre>
<p>Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。 对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 <code>a[2:4]</code> 是 2。 返回a[2]和a[3]两个</p>
<p>切片操作还可以设置步长</p>
<pre><code>&gt;&gt;&gt; a[1::2]
[342, 'India']
</code></pre>
<p>意思是，从切片索引 1 到列表末尾，每隔两个元素取值。</p>
<p><code>len()</code> 我们可以获得列表的长度</p>
<p>如果你想要检查列表是否为空</p>
<pre><code>if list_name: # 列表不为空
    pass
else: # 列表为空
    pass
</code></pre>
<h3 id="列表">列表</h3>
<p><code>a.append(45)</code> 添加元素 <code>45</code> 到列表末尾。有些时候我们需要将数据插入到列表的任何位置，这时我们可以使用列表的 <code>insert()</code> 方法。   <code>count(s)</code> 会返回列表元素中 <code>s</code> 的数量。  如果你想要在列表中移除任意指定值，你需要使用 <code>remove()</code> 方法。  <code>a.reverse()</code> 反转整个列表。 将一个列表的所有元素添加到另一个列表的末尾呢，可以使用列表的 <code>extend()</code> 方法。  给列表排序，我们使用列表的 <code>sort()</code> 方法， 用 <code>del</code> 关键字删除指定位置的列表元素。</p>
<pre><code>&gt;&gt;&gt; a = [23, 45, 1, -3434, 43624356, 234]
&gt;&gt;&gt; a.append(45)
&gt;&gt;&gt;  a.insert(0, 1)
&gt;&gt;&gt; a.count(45)
</code></pre>
<h4 id="栈">栈</h4>
<p><code>pop()</code>。传入一个参数 i 即 <code>pop(i)</code> 会将第 i 个元素弹出。 栈使用<code>a.pop()</code> 将顶部元素弹出， <code>a.append(x)</code> 入栈</p>
<h4 id="队列">队列</h4>
<p><code>a.pop(0)</code> 出队 <code>a.append(x)</code> 入队</p>
<h4 id="列表推导式">列表推导式</h4>
<pre><code>squares = [x**2 for x in range(10)]
&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
#等价于
&gt;&gt;&gt; combs = []
&gt;&gt;&gt; for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
&gt;&gt;&gt; combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<h3 id="元组">元组</h3>
<p>元组是由数个逗号分割的值组成。</p>
<pre><code>&gt;&gt;&gt; a = 'Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus'
&gt;&gt;&gt; a
('Fedora', 'ShiYanLou', 'Kubuntu', 'Pardus')
&gt;&gt;&gt; a[1]
'ShiYanLou'
&gt;&gt;&gt; for x in a:
...     print(x, end=' ')
...
Fedora ShiYanLou Kubuntu Pardus
</code></pre>
<p>以对任何一个元组执行拆封操作并赋值给多个变量</p>
<pre><code>&gt;&gt;&gt; x, y = divmod(15,2)
&gt;&gt;&gt; x
7
&gt;&gt;&gt; y
1
</code></pre>
<p>元组是不可变类型，这意味着你<strong>不能在元组内删除或添加或编辑</strong>任何值。</p>
<p>要创建只含有一个元素的元组，在值后面跟一个<strong>逗号</strong>。</p>
<p>通过内建函数 <code>type()</code> 你可以知道任意变量的数据类型。</p>
<h3 id="集合">集合</h3>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p>
<p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典</p>
<pre><code>&gt;&gt;&gt; basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
&gt;&gt;&gt; print(basket)                      # 你可以看到重复的元素被去除
{'orange', 'banana', 'pear', 'apple'}
&gt;&gt;&gt; 'orange' in basket
True
&gt;&gt;&gt; 'crabgrass' in basket
False

&gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作
...
&gt;&gt;&gt; a = set('abracadabra')
&gt;&gt;&gt; b = set('alacazam')
&gt;&gt;&gt; a                                  # a 去重后的字母
{'a', 'r', 'b', 'c', 'd'}
&gt;&gt;&gt; a - b                              # a 有而 b 没有的字母
{'r', 'd', 'b'}
&gt;&gt;&gt; a | b                              # 存在于 a 或 b 的字母
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
&gt;&gt;&gt; a &amp; b                              # a 和 b 都有的字母
{'a', 'c'}
&gt;&gt;&gt; a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{'r', 'd', 'b', 'm', 'z', 'l'}
#添加或弹出元素
&gt;&gt;&gt; a = {'a','e','h','g'}
&gt;&gt;&gt; a.pop()  # pop 方法随机删除一个元素并打印
'h'
&gt;&gt;&gt; a.add('c')
&gt;&gt;&gt; a
{'c', 'e', 'g', 'a'}
</code></pre>
<h3 id="字典">字典</h3>
<p>字典是是无序的键值对（<code>key:value</code>）集合，同一个字典内的键必须是互不相同的。一对大括号 <code>{}</code> 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。</p>
<pre><code>&gt;&gt;&gt; data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
&gt;&gt;&gt; data['kart_']
'Debian'
&gt;&gt;&gt; data['parthan'] = 'Ubuntu'
&gt;&gt;&gt; data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
# 使用del关键字删除任意指定的键值对
&gt;&gt;&gt; del data['kushal']
&gt;&gt;&gt; data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
# 使用 in 关键字查询指定的键是否在字典中
&gt;&gt;&gt; 'ShiYanLou' in data
False
#必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作
#为键。dict() 可以从包含键值对的元组中创建字典。
&gt;&gt;&gt; dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
#遍历一个字典，使用字典的 items() 方法。
&gt;&gt;&gt; data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
&gt;&gt;&gt; for x, y in data.items():
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu
</code></pre>
<p>许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。我们可以使用 <code>dict.setdefault(key, default)</code> 更有效率的完成这个事情。</p>
<pre><code>&gt;&gt;&gt; data = {}
&gt;&gt;&gt; data.setdefault('names', []).append('Ruby')
&gt;&gt;&gt; data
{'names': ['Ruby']}
&gt;&gt;&gt; data.setdefault('names', []).append('Python')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python']}
&gt;&gt;&gt; data.setdefault('names', []).append('C')
&gt;&gt;&gt; data
{'names': ['Ruby', 'Python', 'C']}
</code></pre>
<p>试图索引一个不存在的键将会抛出一个 <em>keyError</em> 错误。我们可以使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p>
<p>如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code>。</p>
<pre><code>&gt;&gt;&gt; for i, j in enumerate(['a', 'b', 'c']):
...     print(i, j)
...
0 a
1 b
2 c
</code></pre>
<p>要同时遍历两个序列类型，你可以使用 <code>zip()</code> 函数。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = ['Pradeepto', 'Kushal']
&gt;&gt;&gt; b = ['OpenSUSE', 'Fedora']
&gt;&gt;&gt; for x, y in zip(a, b):
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora
</code></pre>
<h3 id="字符串">字符串</h3>
<p><code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写。</p>
<p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写版本。</p>
<p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本</p>
<p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字</p>
<p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p>
<pre><code>&gt;&gt;&gt; s = &quot;1234&quot;
&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字
True
&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;
&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写
False
&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;
&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式
True
&gt;&gt;&gt; s = &quot;CHINA&quot;
&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写
True
</code></pre>
<p><code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>），它返回一个包含所有分割后的字符串的列表。</p>
<p><code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p>
<p>最简单的一个是 <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符</p>
<p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1</p>
<p>格式化操作符（%）</p>
<pre><code>print(&quot;my name is %s.I am %d years old&quot; % ('Shixiaolou',4))
</code></pre>
<p>在这个例子中，<code>%s</code> 为第一个格式符，表示一个字符串；<code>%d</code> 为第二个格式符，表示一个整数。格式符为真实值预留位置，并控制显示的格式。常用的有：</p>
<blockquote>
<p>%s 字符串（用 str() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%r 字符串（用 repr() 函数进行字符串转换）</p>
</blockquote>
<blockquote>
<p>%d 十进制整数</p>
</blockquote>
<blockquote>
<p>%f 浮点数</p>
</blockquote>
<blockquote>
<p>%% 字符“%”</p>
</blockquote>
<h3 id="函数">函数</h3>
<p><code>def</code> 来定义一个函数</p>
<pre><code>def 函数名(参数):
    语句1
    语句2
</code></pre>
<p><code>global</code> 关键字，对函数中的a标志为全局变量 ， 让函数内部使用全局变量的 a。</p>
<p>函数的参数变量可以有默认值，也就是说如果我们对指定的参数变量没有给出任何值则会赋其默认值。</p>
<pre><code>&gt;&gt;&gt; def test(a , b=-99):
...     if a &gt; b:
...         return True
...     else:
...         return False
</code></pre>
<p>在函数的参数列表写出 <code>b = -99</code>。这表示如果调用者未给出 <code>b</code> 的值，那么 <code>b</code> 的值默认为 <code>-99</code>。</p>
<pre><code>&gt;&gt;&gt; test(12, 23)
False
&gt;&gt;&gt; test(12)
True
</code></pre>
<p>有两个非常重要的地方，第一个是具有默认值的参数后面不能再有普通参数，比如 <code>f(a,b=90,c)</code> 就是错误的。</p>
<p>第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。</p>
<pre><code>&gt;&gt;&gt; def f(a, data=[]):
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[1, 2]
&gt;&gt;&gt; print(f(3))
[1, 2, 3]
</code></pre>
<pre><code>&gt;&gt;&gt; def f(a, data=None):
...     if data is None:
...         data = []
...     data.append(a)
...     return data
...
&gt;&gt;&gt; print(f(1))
[1]
&gt;&gt;&gt; print(f(2))
[2]
</code></pre>
<p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<ul>
<li>使用一个或多个函数作为参数</li>
<li>返回另一个函数作为输出</li>
</ul>
<p>Python 里的任何函数都可以作为高阶函数</p>
<pre><code># 创建一个函数，将参数列表中每个元素都变成全大写
&gt;&gt;&gt; def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
&gt;&gt;&gt; def test(h, l):
...     return h(l)
...
&gt;&gt;&gt; l = ['python', 'Linux', 'Git']
# 运行高阶函数，返回预期的结果
&gt;&gt;&gt; test(high, l)
['PYTHON', 'LINUX', 'GIT']
</code></pre>
<p><code>map</code> 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。</p>
<h3 id="文件">文件</h3>
<p>使用 <code>open()</code> 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li>
<p><code>&quot;r&quot;</code>，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</p>
</li>
<li>
<p><code>&quot;w&quot;</code>，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</p>
</li>
<li>
<p><code>&quot;a&quot;</code>，以追加模式打开，写入到文件中的任何数据将自动添加到末尾</p>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，<code>open()</code> 函数将会以只读模式打开文件。</p>
<p><code>close()</code> 关闭文件</p>
<p><code>read()</code> 方法一次性读取整个文件。  <code>read(size)</code> 有一个可选的参数 <code>size</code>，用于指定字符串长度。如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。</p>
</li>
</ul>
<p><code>readline()</code> 能帮助你每次读取文件的一行。  使用 <code>readlines()</code> 方法读取所有行到一个列表中。</p>
<p><code>write()</code> 方法打开一个文件写入一些文本。</p>
<p>模块 <code>sys</code>。<code>sys.argv</code> 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 <code>cp</code> 命令替代：在 <code>cp</code> 后首先输入被拷贝的文件的文件名，然后输入新文件名。</p>
<p><code>with</code> 语句处理文件对象，它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写</p>
<p>在 Linux 下你可以使用 <code>lscpu</code> 命令来查看当前电脑的 CPU 相关信息 ， 实际上 <code>lscpu</code> 命令是读取 <code>/proc/cpuinfo</code> 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 <code>/proc/cpuinfo</code> 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 <code>lscpu</code> 命令了 :）</p>
<h3 id="异常">异常</h3>
<p>我们使用 <code>try...except</code> 块来处理任意异常。基本的语法像这样：</p>
<pre><code>try:
    statements to be inside try clause
    statement2
    statement3
    ...
except ExceptionName:
    statements to evaluated in case of ExceptionName happens
</code></pre>
<p>使用 <code>raise</code> 语句抛出一个异常。</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError(&quot;A value error happened.&quot;)
... except ValueError:
...     print(&quot;ValueError in our code.&quot;)
...
ValueError in our code.
</code></pre>
<p><code>try</code> 语句还有另一个可选的 <code>finally</code> 子句，目的在于定义在任何情况下都一定要执行的功能， 不管有没有发生异常，<code>finally</code> 子句 在程序离开 <code>try</code> 后都一定会被执行。当 <code>try</code> 语句中发生了未被 <code>except</code> 捕获的异常（或者它发生在 <code>except</code> 或 <code>else</code> 子句中），在 <code>finally</code> 子句执行完后它会被重新抛出。</p>
<p><code>with</code> 语句，它是 <code>try-finally</code> 块的简写，使用 <code>with</code> 语句能保证文件始终被关闭。</p>
<h3 id="类">类</h3>
<pre><code>class nameoftheclass(parent_class):
    statement1
    statement2
    statement3
</code></pre>
<p>在类的声明中你可以写任何 Python 语句，包括定义函数（在类中我们称为方法）。</p>
<p>类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。 <code>x = MyClass()</code></p>
<p>类定义了 <code>__init__()</code> 方法的话，类的实例化操作会自动为新创建的类实例调用 <code>__init__()</code> 方法。</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre>
<p>一个类可以继承自多个类，具有父类的所有变量和方法，语法如下：</p>
<pre><code>class MyClass(Parentclass1, Parentclass2,...):
    def __init__(self):
        Parentclass1.__init__(self)
        Parentclass2.__init__(self)
        ...
        ...
</code></pre>
<p>删除一个对象使用关键字 <code>del</code> 。</p>
<p>更精确的调整控制属性访问权限，你可以使用 <code>@property</code> 装饰器，<code>@property</code> 装饰器就是负责把一个方法变成属性调用的。</p>
<h3 id="模块">模块</h3>
<p>模块是包括 Python 定义和声明的文件。文件名就是模块名加上 <code>.py</code> 后缀。</p>
<p>从模块中导入指定的函数。这样做：</p>
<pre><code>&gt;&gt;&gt; from bars import simplebar, starbar
&gt;&gt;&gt; simplebar(20)
</code></pre>
<p>含有 <code>__init__.py</code> 文件的目录可以用来作为一个包，目录里的所有 <code>.py</code> 文件都是这个包的子模块。</p>
<p><a href="http://docs.python.org/3/library/os.html#module-os"><code>os</code></a> 模块提供了与操作系统相关的功能。<code>getuid()</code> 函数返回当前进程的有效用户 id。<code>getpid()</code> 函数返回当前进程的 id。<code>getppid()</code> 返回父进程的 id。<code>uname()</code> 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 <code>uname -a</code> 命令得到。<code>uname()</code> 返回的对象是一个元组，<code>（sysname, nodename, release, version, machine）</code>。getcwd() 函数返回当前工作目录。<code>chdir(path)</code> 则是更改当前目录到 path。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/">Requests</a> 是一个第三方 Python 模块， 第三方模块并不是默认的模块，意味着你需要安装它，我们使用 <code>pip3</code> 安装它。</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install python3-pip
$ sudo pip3 install requests
</code></pre>
<p>你可以使用 <code>get()</code> 方法获取任意一个网页。</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.get('https://github.com')
&gt;&gt;&gt; req.status_code
200
</code></pre>
<p><code>req</code> 的 <code>text</code> 属性存有服务器返回的 HTML 网页使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序。</p>
<pre><code>#!/usr/bin/env python3
import requests

def download(url):
    '''
    从指定的 URL 中下载文件并存储到当前目录
    url: 要下载页面内容的网址
    '''
    # 检查 URL 是否存在
    try:
        req = requests.get(url)
    except requests.exceptions.MissingSchema:
        print('Invalid URL &quot;{}&quot;'.format(url))
        return
    # 检查是否成功访问了该网站
    if req.status_code == 403:
        print('You do not have the authority to access this page.')
        return
    filename = url.split('/')[-1]
    with open(filename, 'w') as fobj:
        fobj.write(req.content.decode('utf-8'))
    print(&quot;Download over.&quot;)

if __name__ == '__main__':
    url = input('Enter a URL: ')
    download(url)
</code></pre>
<p><code>if __name__ == '__main__':</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 <code>if</code> 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，<code>if</code> 块内的语句并不会执行。</p>
<p>命令行传入的所有参数都可以使用 <code>sys.argv</code> 获取。如果希望对参数进行处理可以使用 <code>argparse</code> 模块</p>
<h4 id="collections-模块">collections  模块</h4>
<h5 id="counter">Counter</h5>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; import re
&gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt'
&gt;&gt;&gt; words = re.findall('\w+', open(path).read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)]
</code></pre>
<p>Counter 对象有一个叫做 <code>elements()</code> 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<p><code>most_common()</code> 方法返回最常见的元素及其计数，顺序为最常见到最少。</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<h5 id="defaultdict">defaultdict</h5>
<p><code>defaultdict</code> 是内建 <code>dict</code> 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同。  <code>defaultdict()</code> 第一个参数提供了 <code>default_factory</code> 属性的初始值，默认值为 <code>None</code>，<code>default_factory</code> 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数。  同样的功能使用 <code>defaultdict</code> 比使用 <code>dict.setdefault</code> 方法快。</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])])
</code></pre>
<h5 id="namedtuple">namedtuple</h5>
<p>命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息。</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])  # 定义命名元组
&gt;&gt;&gt; p = Point(10, y=20)  # 创建一个对象
&gt;&gt;&gt; p
Point(x=10, y=20)
&gt;&gt;&gt; p.x + p.y
30
&gt;&gt;&gt; p[0] + p[1]  # 像普通元组那样访问元素
30
&gt;&gt;&gt; x, y = p     # 元组拆封
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>
<h3 id="python排版">Python排版</h3>
<p>每层缩进使用4个空格。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>限制每行的最大长度为79个字符。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p>顶级函数和类定义上下使用两个空行分隔。</p>
<p>类内的方法定义使用一个空行分隔。</p>
<p><code>import</code>语句分组顺序如下：</p>
<ol>
<li>导入标准库模块</li>
<li>导入相关第三方库模块</li>
<li>导入当前应用程序/库模块</li>
</ol>
<p>避免在下列情况中使用多余的空格：</p>
<ul>
<li>
<p>与括号保持紧凑（小括号、中括号、大括号）：</p>
</li>
<li>
<p>与后面的逗号、分号或冒号保持紧凑</p>
</li>
<li>
<p>切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。</p>
</li>
<li>
<p>函数名与其后参数列表的左括号应该保持紧凑</p>
</li>
<li>
<p>与切片或索引的左括号保持紧凑</p>
</li>
<li>
<p>在赋值操作符（或其它）的两侧保持多余一个的空格</p>
</li>
<li>
<p>总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。</p>
</li>
<li>
<p>在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。</p>
</li>
<li>
<p>不要在关键值参数或默认值参数的等号两边加入空格。</p>
</li>
<li>
<p>【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的<code>-&gt;</code>左右各插入一个空格。</p>
</li>
<li>
<p>打消使用复合语句（多条语句在同一行）的念头。</p>
</li>
<li>
<p>有时候把 <code>if/for/while</code> 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。</p>
<p>块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以<code>#</code>起头，并且<code>#</code>后要跟一个空格（除非是注释内的缩进文本）。</p>
<p>有节制的使用行内注释。</p>
<p>一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以<code>#</code>打头，<code>#</code>后接一个空格。</p>
<p>无谓的行内注释如果状态明显，会转移注意力。</p>
<ul>
<li>为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。</li>
<li><a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a> 描述了良好的文档字符串的约定。注意，文档字符串的结尾<code>&quot;&quot;&quot;</code>应该放在单独的一行，例如：</li>
<li>对于单行的文档字符串，把结尾<code>&quot;&quot;&quot;</code>放在同一行。</li>
</ul>
</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>Python 迭代器（<em>Iterators</em>）对象在遵守迭代器协议时需要支持如下两种方法。</p>
<p><code>__iter__()</code>，返回迭代器对象自身。这用在 <code>for</code> 和 <code>in</code> 语句中。</p>
<p><code>__next__()</code>，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 <code>StopIteration</code> 异常。</p>
<pre><code>class Counter(object):
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        #返回下一个值直到当前值大于 high
        if self.current &gt; self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
            
   
&gt;&gt;&gt; c = Counter(5,10)
&gt;&gt;&gt; for i in c:
...   print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 <code>StopIteration</code>，它会持续抛出相同的异常。</p>
<p>Python 生成器（<em>Generators</em>），生成器是更简单的创建迭代器的方法，这通过在函数中使用 <code>yield</code> 关键字完成：</p>
<pre><code>&gt;&gt;&gt; def my_generator():
...     print(&quot;Inside my generator&quot;)
...     yield 'a'
...     yield 'b'
...     yield 'c'
...
&gt;&gt;&gt; my_generator()
&lt;generator object my_generator at 0x7fbcfa0a6aa0&gt;

&gt;&gt;&gt; for char in my_generator():
...     print(char)
...
Inside my generator
a
b
c

&gt;&gt;&gt; def counter_generator(low, high):
...     while low &lt;= high:
...        yield low
...        low += 1
... 
&gt;&gt;&gt; for i in counter_generator(5,10):
...     print(i, end=' ')
... 
5 6 7 8 9 10
</code></pre>
<p>我们会发现生成器的一个特点：它们是不可重复使用的。</p>
<p>生成器表达式（<em>Generator expressions</em>），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广。</p>
<pre><code>&gt;&gt;&gt; sum([x*x for x in range(1,10)])
</code></pre>
<p>这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
</code></pre>
<p>生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。</p>
<p>闭包（<em>Closures</em>）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和。</p>
<pre><code>&gt;&gt;&gt; def add_number(num):
...     def adder(number):
...         #adder 是一个闭包
...         return num + number
...     return adder
...
&gt;&gt;&gt; a_10 = add_number(10)
&gt;&gt;&gt; a_10(21)
31
&gt;&gt;&gt; a_10(34)
44
&gt;&gt;&gt; a_5 = add_number(5)
&gt;&gt;&gt; a_5(3)
8
</code></pre>
<p>装饰器（<em>Decorators</em>）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的。</p>
<pre><code>&gt;&gt;&gt; def my_decorator(func):
...     def wrapper(*args, **kwargs):
...         print(&quot;Before call&quot;)
...         result = func(*args, **kwargs)
...         print(&quot;After call&quot;)
...         return result
...     return wrapper
...
&gt;&gt;&gt; @my_decorator
... def add(a, b):
...     #我们的求和函数
...     return a + b
...
&gt;&gt;&gt; add(1, 3)
Before call
After call
4
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmweijh.github.io/post/git/" class="post-title gt-a-link">
                    Git
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">努力成就自我</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmweijh.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
